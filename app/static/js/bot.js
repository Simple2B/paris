/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/flowbite/dist/datepicker.js":
/*!**************************************************!*\
  !*** ./node_modules/flowbite/dist/datepicker.js ***!
  \**************************************************/
/***/ ((module) => {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 482:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_561__) {

/* harmony export */ __nested_webpack_require_561__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": function() { return /* binding */ DateRangePicker; }
/* harmony export */ });
/* harmony import */ var _lib_event_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_561__(698);
/* harmony import */ var _lib_date_format_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_561__(963);
/* harmony import */ var _Datepicker_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_561__(770);




// filter out the config options inapproprite to pass to Datepicker
function filterOptions(options) {
  const newOpts = Object.assign({}, options);

  delete newOpts.inputs;
  delete newOpts.allowOneSidedRange;
  delete newOpts.maxNumberOfDates; // to ensure each datepicker handles a single date

  return newOpts;
}

function setupDatepicker(rangepicker, changeDateListener, el, options) {
  (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_0__/* .registerListeners */ .cF)(rangepicker, [
    [el, 'changeDate', changeDateListener],
  ]);
  new _Datepicker_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(el, options, rangepicker);
}

function onChangeDate(rangepicker, ev) {
  // to prevent both datepickers trigger the other side's update each other
  if (rangepicker._updating) {
    return;
  }
  rangepicker._updating = true;

  const target = ev.target;
  if (target.datepicker === undefined) {
    return;
  }

  const datepickers = rangepicker.datepickers;
  const setDateOptions = {render: false};
  const changedSide = rangepicker.inputs.indexOf(target);
  const otherSide = changedSide === 0 ? 1 : 0;
  const changedDate = datepickers[changedSide].dates[0];
  const otherDate = datepickers[otherSide].dates[0];

  if (changedDate !== undefined && otherDate !== undefined) {
    // if the start of the range > the end, swap them
    if (changedSide === 0 && changedDate > otherDate) {
      datepickers[0].setDate(otherDate, setDateOptions);
      datepickers[1].setDate(changedDate, setDateOptions);
    } else if (changedSide === 1 && changedDate < otherDate) {
      datepickers[0].setDate(changedDate, setDateOptions);
      datepickers[1].setDate(otherDate, setDateOptions);
    }
  } else if (!rangepicker.allowOneSidedRange) {
    // to prevent the range from becoming one-sided, copy changed side's
    // selection (no matter if it's empty) to the other side
    if (changedDate !== undefined || otherDate !== undefined) {
      setDateOptions.clear = true;
      datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);
    }
  }
  datepickers[0].picker.update().render();
  datepickers[1].picker.update().render();
  delete rangepicker._updating;
}

/**
 * Class representing a date range picker
 */
class DateRangePicker  {
  /**
   * Create a date range picker
   * @param  {Element} element - element to bind a date range picker
   * @param  {Object} [options] - config options
   */
  constructor(element, options = {}) {
    const inputs = Array.isArray(options.inputs)
      ? options.inputs
      : Array.from(element.querySelectorAll('input'));
    if (inputs.length < 2) {
      return;
    }

    element.rangepicker = this;
    this.element = element;
    this.inputs = inputs.slice(0, 2);
    this.allowOneSidedRange = !!options.allowOneSidedRange;

    const changeDateListener = onChangeDate.bind(null, this);
    const cleanOptions = filterOptions(options);
    // in order for initial date setup to work right when pcicLvel > 0,
    // let Datepicker constructor add the instance to the rangepicker
    const datepickers = [];
    Object.defineProperty(this, 'datepickers', {
      get() {
        return datepickers;
      },
    });
    setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);
    setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);
    Object.freeze(datepickers);
    // normalize the range if inital dates are given
    if (datepickers[0].dates.length > 0) {
      onChangeDate(this, {target: this.inputs[0]});
    } else if (datepickers[1].dates.length > 0) {
      onChangeDate(this, {target: this.inputs[1]});
    }
  }

  /**
   * @type {Array} - selected date of the linked date pickers
   */
  get dates() {
    return this.datepickers.length === 2
      ? [
          this.datepickers[0].dates[0],
          this.datepickers[1].dates[0],
        ]
      : undefined;
  }

  /**
   * Set new values to the config options
   * @param {Object} options - config options to update
   */
  setOptions(options) {
    this.allowOneSidedRange = !!options.allowOneSidedRange;

    const cleanOptions = filterOptions(options);
    this.datepickers[0].setOptions(cleanOptions);
    this.datepickers[1].setOptions(cleanOptions);
  }

  /**
   * Destroy the DateRangePicker instance
   * @return {DateRangePicker} - the instance destroyed
   */
  destroy() {
    this.datepickers[0].destroy();
    this.datepickers[1].destroy();
    (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_0__/* .unregisterListeners */ .uV)(this);
    delete this.element.rangepicker;
  }

  /**
   * Get the start and end dates of the date range
   *
   * The method returns Date objects by default. If format string is passed,
   * it returns date strings formatted in given format.
   * The result array always contains 2 items (start date/end date) and
   * undefined is used for unselected side. (e.g. If none is selected,
   * the result will be [undefined, undefined]. If only the end date is set
   * when allowOneSidedRange config option is true, [undefined, endDate] will
   * be returned.)
   *
   * @param  {String} [format] - Format string to stringify the dates
   * @return {Array} - Start and end dates
   */
  getDates(format = undefined) {
    const callback = format
      ? date => (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_1__/* .formatDate */ .p6)(date, format, this.datepickers[0].config.locale)
      : date => new Date(date);

    return this.dates.map(date => date === undefined ? date : callback(date));
  }

  /**
   * Set the start and end dates of the date range
   *
   * The method calls datepicker.setDate() internally using each of the
   * arguments in start→end order.
   *
   * When a clear: true option object is passed instead of a date, the method
   * clears the date.
   *
   * If an invalid date, the same date as the current one or an option object
   * without clear: true is passed, the method considers that argument as an
   * "ineffective" argument because calling datepicker.setDate() with those
   * values makes no changes to the date selection.
   *
   * When the allowOneSidedRange config option is false, passing {clear: true}
   * to clear the range works only when it is done to the last effective
   * argument (in other words, passed to rangeEnd or to rangeStart along with
   * ineffective rangeEnd). This is because when the date range is changed,
   * it gets normalized based on the last change at the end of the changing
   * process.
   *
   * @param {Date|Number|String|Object} rangeStart - Start date of the range
   * or {clear: true} to clear the date
   * @param {Date|Number|String|Object} rangeEnd - End date of the range
   * or {clear: true} to clear the date
   */
  setDates(rangeStart, rangeEnd) {
    const [datepicker0, datepicker1] = this.datepickers;
    const origDates = this.dates;

    // If range normalization runs on every change, we can't set a new range
    // that starts after the end of the current range correctly because the
    // normalization process swaps start↔︎end right after setting the new start
    // date. To prevent this, the normalization process needs to run once after
    // both of the new dates are set.
    this._updating = true;
    datepicker0.setDate(rangeStart);
    datepicker1.setDate(rangeEnd);
    delete this._updating;

    if (datepicker1.dates[0] !== origDates[1]) {
      onChangeDate(this, {target: this.inputs[1]});
    } else if (datepicker0.dates[0] !== origDates[0]) {
      onChangeDate(this, {target: this.inputs[0]});
    }
  }
}


/***/ }),

/***/ 770:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_8693__) {


// EXPORTS
__nested_webpack_require_8693__.d(__nested_webpack_exports__, {
  "Z": function() { return /* binding */ Datepicker; }
});

// EXTERNAL MODULE: ./node_modules/flowbite-datepicker/js/lib/utils.js
var utils = __nested_webpack_require_8693__(105);
// EXTERNAL MODULE: ./node_modules/flowbite-datepicker/js/lib/date.js
var lib_date = __nested_webpack_require_8693__(560);
// EXTERNAL MODULE: ./node_modules/flowbite-datepicker/js/lib/date-format.js
var date_format = __nested_webpack_require_8693__(963);
// EXTERNAL MODULE: ./node_modules/flowbite-datepicker/js/lib/event.js
var lib_event = __nested_webpack_require_8693__(698);
;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/i18n/base-locales.js
// default locales
const locales = {
  en: {
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    today: "Today",
    clear: "Clear",
    titleFormat: "MM y"
  }
};

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/options/defaultOptions.js
// config options updatable by setOptions() and their default values
const defaultOptions = {
  autohide: false,
  beforeShowDay: null,
  beforeShowDecade: null,
  beforeShowMonth: null,
  beforeShowYear: null,
  calendarWeeks: false,
  clearBtn: false,
  dateDelimiter: ',',
  datesDisabled: [],
  daysOfWeekDisabled: [],
  daysOfWeekHighlighted: [],
  defaultViewDate: undefined, // placeholder, defaults to today() by the program
  disableTouchKeyboard: false,
  format: 'mm/dd/yyyy',
  language: 'en',
  maxDate: null,
  maxNumberOfDates: 1,
  maxView: 3,
  minDate: null,
  nextArrow: '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M12.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>',
  orientation: 'auto',
  pickLevel: 0,
  prevArrow: '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd"></path></svg>',
  showDaysOfWeek: true,
  showOnClick: true,
  showOnFocus: true,
  startView: 0,
  title: '',
  todayBtn: false,
  todayBtnMode: 0,
  todayHighlight: false,
  updateOnBlur: true,
  weekStart: 0,
};

/* harmony default export */ var options_defaultOptions = (defaultOptions);

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/lib/dom.js
const range = document.createRange();

function parseHTML(html) {
  return range.createContextualFragment(html);
}

// equivalent to jQuery's :visble
function isVisible(el) {
  return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
}

function hideElement(el) {
  if (el.style.display === 'none') {
    return;
  }
  // back up the existing display setting in data-style-display
  if (el.style.display) {
    el.dataset.styleDisplay = el.style.display;
  }
  el.style.display = 'none';
}

function showElement(el) {
  if (el.style.display !== 'none') {
    return;
  }
  if (el.dataset.styleDisplay) {
    // restore backed-up dispay property
    el.style.display = el.dataset.styleDisplay;
    delete el.dataset.styleDisplay;
  } else {
    el.style.display = '';
  }
}

function emptyChildNodes(el) {
  if (el.firstChild) {
    el.removeChild(el.firstChild);
    emptyChildNodes(el);
  }
}

function replaceChildNodes(el, newChildNodes) {
  emptyChildNodes(el);
  if (newChildNodes instanceof DocumentFragment) {
    el.appendChild(newChildNodes);
  } else if (typeof newChildNodes === 'string') {
    el.appendChild(parseHTML(newChildNodes));
  } else if (typeof newChildNodes.forEach === 'function') {
    newChildNodes.forEach((node) => {
      el.appendChild(node);
    });
  }
}

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/options/processOptions.js






const {
  language: defaultLang,
  format: defaultFormat,
  weekStart: defaultWeekStart,
} = options_defaultOptions;

// Reducer function to filter out invalid day-of-week from the input
function sanitizeDOW(dow, day) {
  return dow.length < 6 && day >= 0 && day < 7
    ? (0,utils/* pushUnique */.$C)(dow, day)
    : dow;
}

function calcEndOfWeek(startOfWeek) {
  return (startOfWeek + 6) % 7;
}

// validate input date. if invalid, fallback to the original value
function validateDate(value, format, locale, origValue) {
  const date = (0,date_format/* parseDate */.sG)(value, format, locale);
  return date !== undefined ? date : origValue;
}

// Validate viewId. if invalid, fallback to the original value
function validateViewId(value, origValue, max = 3) {
  const viewId = parseInt(value, 10);
  return viewId >= 0 && viewId <= max ? viewId : origValue;
}

// Create Datepicker configuration to set
function processOptions(options, datepicker) {
  const inOpts = Object.assign({}, options);
  const config = {};
  const locales = datepicker.constructor.locales;
  let {
    format,
    language,
    locale,
    maxDate,
    maxView,
    minDate,
    pickLevel,
    startView,
    weekStart,
  } = datepicker.config || {};

  if (inOpts.language) {
    let lang;
    if (inOpts.language !== language) {
      if (locales[inOpts.language]) {
        lang = inOpts.language;
      } else {
        // Check if langauge + region tag can fallback to the one without
        // region (e.g. fr-CA → fr)
        lang = inOpts.language.split('-')[0];
        if (locales[lang] === undefined) {
          lang = false;
        }
      }
    }
    delete inOpts.language;
    if (lang) {
      language = config.language = lang;

      // update locale as well when updating language
      const origLocale = locale || locales[defaultLang];
      // use default language's properties for the fallback
      locale = Object.assign({
        format: defaultFormat,
        weekStart: defaultWeekStart
      }, locales[defaultLang]);
      if (language !== defaultLang) {
        Object.assign(locale, locales[language]);
      }
      config.locale = locale;
      // if format and/or weekStart are the same as old locale's defaults,
      // update them to new locale's defaults
      if (format === origLocale.format) {
        format = config.format = locale.format;
      }
      if (weekStart === origLocale.weekStart) {
        weekStart = config.weekStart = locale.weekStart;
        config.weekEnd = calcEndOfWeek(locale.weekStart);
      }
    }
  }

  if (inOpts.format) {
    const hasToDisplay = typeof inOpts.format.toDisplay === 'function';
    const hasToValue = typeof inOpts.format.toValue === 'function';
    const validFormatString = date_format/* reFormatTokens.test */.CL.test(inOpts.format);
    if ((hasToDisplay && hasToValue) || validFormatString) {
      format = config.format = inOpts.format;
    }
    delete inOpts.format;
  }

  //*** dates ***//
  // while min and maxDate for "no limit" in the options are better to be null
  // (especially when updating), the ones in the config have to be undefined
  // because null is treated as 0 (= unix epoch) when comparing with time value
  let minDt = minDate;
  let maxDt = maxDate;
  if (inOpts.minDate !== undefined) {
    minDt = inOpts.minDate === null
      ? (0,lib_date/* dateValue */.by)(0, 0, 1)  // set 0000-01-01 to prevent negative values for year
      : validateDate(inOpts.minDate, format, locale, minDt);
    delete inOpts.minDate;
  }
  if (inOpts.maxDate !== undefined) {
    maxDt = inOpts.maxDate === null
      ? undefined
      : validateDate(inOpts.maxDate, format, locale, maxDt);
    delete inOpts.maxDate;
  }
  if (maxDt < minDt) {
    minDate = config.minDate = maxDt;
    maxDate = config.maxDate = minDt;
  } else {
    if (minDate !== minDt) {
      minDate = config.minDate = minDt;
    }
    if (maxDate !== maxDt) {
      maxDate = config.maxDate = maxDt;
    }
  }

  if (inOpts.datesDisabled) {
    config.datesDisabled = inOpts.datesDisabled.reduce((dates, dt) => {
      const date = (0,date_format/* parseDate */.sG)(dt, format, locale);
      return date !== undefined ? (0,utils/* pushUnique */.$C)(dates, date) : dates;
    }, []);
    delete inOpts.datesDisabled;
  }
  if (inOpts.defaultViewDate !== undefined) {
    const viewDate = (0,date_format/* parseDate */.sG)(inOpts.defaultViewDate, format, locale);
    if (viewDate !== undefined) {
      config.defaultViewDate = viewDate;
    }
    delete inOpts.defaultViewDate;
  }

  //*** days of week ***//
  if (inOpts.weekStart !== undefined) {
    const wkStart = Number(inOpts.weekStart) % 7;
    if (!isNaN(wkStart)) {
      weekStart = config.weekStart = wkStart;
      config.weekEnd = calcEndOfWeek(wkStart);
    }
    delete inOpts.weekStart;
  }
  if (inOpts.daysOfWeekDisabled) {
    config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekDisabled;
  }
  if (inOpts.daysOfWeekHighlighted) {
    config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekHighlighted;
  }

  //*** multi date ***//
  if (inOpts.maxNumberOfDates !== undefined) {
    const maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);
    if (maxNumberOfDates >= 0) {
      config.maxNumberOfDates = maxNumberOfDates;
      config.multidate = maxNumberOfDates !== 1;
    }
    delete inOpts.maxNumberOfDates;
  }
  if (inOpts.dateDelimiter) {
    config.dateDelimiter = String(inOpts.dateDelimiter);
    delete inOpts.dateDelimiter;
  }

  //*** pick level & view ***//
  let newPickLevel = pickLevel;
  if (inOpts.pickLevel !== undefined) {
    newPickLevel = validateViewId(inOpts.pickLevel, 2);
    delete inOpts.pickLevel;
  }
  if (newPickLevel !== pickLevel) {
    pickLevel = config.pickLevel = newPickLevel;
  }

  let newMaxView = maxView;
  if (inOpts.maxView !== undefined) {
    newMaxView = validateViewId(inOpts.maxView, maxView);
    delete inOpts.maxView;
  }
  // ensure max view >= pick level
  newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;
  if (newMaxView !== maxView) {
    maxView = config.maxView = newMaxView;
  }

  let newStartView = startView;
  if (inOpts.startView !== undefined) {
    newStartView = validateViewId(inOpts.startView, newStartView);
    delete inOpts.startView;
  }
  // ensure pick level <= start view <= max view
  if (newStartView < pickLevel) {
    newStartView = pickLevel;
  } else if (newStartView > maxView) {
    newStartView = maxView;
  }
  if (newStartView !== startView) {
    config.startView = newStartView;
  }

  //*** template ***//
  if (inOpts.prevArrow) {
    const prevArrow = parseHTML(inOpts.prevArrow);
    if (prevArrow.childNodes.length > 0) {
      config.prevArrow = prevArrow.childNodes;
    }
    delete inOpts.prevArrow;
  }
  if (inOpts.nextArrow) {
    const nextArrow = parseHTML(inOpts.nextArrow);
    if (nextArrow.childNodes.length > 0) {
      config.nextArrow = nextArrow.childNodes;
    }
    delete inOpts.nextArrow;
  }

  //*** misc ***//
  if (inOpts.disableTouchKeyboard !== undefined) {
    config.disableTouchKeyboard = 'ontouchstart' in document && !!inOpts.disableTouchKeyboard;
    delete inOpts.disableTouchKeyboard;
  }
  if (inOpts.orientation) {
    const orientation = inOpts.orientation.toLowerCase().split(/\s+/g);
    config.orientation = {
      x: orientation.find(x => (x === 'left' || x === 'right')) || 'auto',
      y: orientation.find(y => (y === 'top' || y === 'bottom')) || 'auto',
    };
    delete inOpts.orientation;
  }
  if (inOpts.todayBtnMode !== undefined) {
    switch(inOpts.todayBtnMode) {
      case 0:
      case 1:
        config.todayBtnMode = inOpts.todayBtnMode;
    }
    delete inOpts.todayBtnMode;
  }

  //*** copy the rest ***//
  Object.keys(inOpts).forEach((key) => {
    if (inOpts[key] !== undefined && (0,utils/* hasProperty */.l$)(options_defaultOptions, key)) {
      config[key] = inOpts[key];
    }
  });

  return config;
}

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/picker/templates/pickerTemplate.js


const pickerTemplate = (0,utils/* optimizeTemplateHTML */.zh)(`<div class="datepicker hidden">
  <div class="datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4">
    <div class="datepicker-header">
      <div class="datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold"></div>
      <div class="datepicker-controls flex justify-between mb-2">
        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn"></button>
        <button type="button" class="text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch"></button>
        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn"></button>
      </div>
    </div>
    <div class="datepicker-main p-1"></div>
    <div class="datepicker-footer">
      <div class="datepicker-controls flex space-x-2 mt-2">
        <button type="button" class="%buttonClass% today-btn text-white bg-blue-700 dark:bg-blue-600 hover:bg-blue-800 dark:hover:bg-blue-700 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>
        <button type="button" class="%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>
      </div>
    </div>
  </div>
</div>`);

/* harmony default export */ var templates_pickerTemplate = (pickerTemplate);

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/picker/templates/daysTemplate.js


const daysTemplate = (0,utils/* optimizeTemplateHTML */.zh)(`<div class="days">
  <div class="days-of-week grid grid-cols-7 mb-1">${(0,utils/* createTagRepeat */.em)('span', 7, {class: 'dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm'})}</div>
  <div class="datepicker-grid w-64 grid grid-cols-7">${(0,utils/* createTagRepeat */.em)('span', 42 , {class: 'block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400'})}</div>
</div>`);

/* harmony default export */ var templates_daysTemplate = (daysTemplate);

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/picker/templates/calendarWeeksTemplate.js


const calendarWeeksTemplate = (0,utils/* optimizeTemplateHTML */.zh)(`<div class="calendar-weeks">
  <div class="days-of-week flex"><span class="dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"></span></div>
  <div class="weeks">${(0,utils/* createTagRepeat */.em)('span', 6, {class: 'week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm'})}</div>
</div>`);

/* harmony default export */ var templates_calendarWeeksTemplate = (calendarWeeksTemplate);

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/picker/views/View.js



// Base class of the view classes
class View {
  constructor(picker, config) {
    Object.assign(this, config, {
      picker,
      element: parseHTML(`<div class="datepicker-view flex"></div>`).firstChild,
      selected: [],
    });
    this.init(this.picker.datepicker.config);
  }

  init(options) {
    if (options.pickLevel !== undefined) {
      this.isMinView = this.id === options.pickLevel;
    }
    this.setOptions(options);
    this.updateFocus();
    this.updateSelection();
  }

  // Execute beforeShow() callback and apply the result to the element
  // args:
  // - current - current value on the iteration on view rendering
  // - timeValue - time value of the date to pass to beforeShow()
  performBeforeHook(el, current, timeValue) {
    let result = this.beforeShow(new Date(timeValue));
    switch (typeof result) {
      case 'boolean':
        result = {enabled: result};
        break;
      case 'string':
        result = {classes: result};
    }

    if (result) {
      if (result.enabled === false) {
        el.classList.add('disabled');
        (0,utils/* pushUnique */.$C)(this.disabled, current);
      }
      if (result.classes) {
        const extraClasses = result.classes.split(/\s+/);
        el.classList.add(...extraClasses);
        if (extraClasses.includes('disabled')) {
          (0,utils/* pushUnique */.$C)(this.disabled, current);
        }
      }
      if (result.content) {
        replaceChildNodes(el, result.content);
      }
    }
  }
}

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/picker/views/DaysView.js








class DaysView extends View {
  constructor(picker) {
    super(picker, {
      id: 0,
      name: 'days',
      cellClass: 'day',
    });
  }

  init(options, onConstruction = true) {
    if (onConstruction) {
      const inner = parseHTML(templates_daysTemplate).firstChild;
      this.dow = inner.firstChild;
      this.grid = inner.lastChild;
      this.element.appendChild(inner);
    }
    super.init(options);
  }

  setOptions(options) {
    let updateDOW;

    if ((0,utils/* hasProperty */.l$)(options, 'minDate')) {
      this.minDate = options.minDate;
    }
    if ((0,utils/* hasProperty */.l$)(options, 'maxDate')) {
      this.maxDate = options.maxDate;
    }
    if (options.datesDisabled) {
      this.datesDisabled = options.datesDisabled;
    }
    if (options.daysOfWeekDisabled) {
      this.daysOfWeekDisabled = options.daysOfWeekDisabled;
      updateDOW = true;
    }
    if (options.daysOfWeekHighlighted) {
      this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;
    }
    if (options.todayHighlight !== undefined) {
      this.todayHighlight = options.todayHighlight;
    }
    if (options.weekStart !== undefined) {
      this.weekStart = options.weekStart;
      this.weekEnd = options.weekEnd;
      updateDOW = true;
    }
    if (options.locale) {
      const locale = this.locale = options.locale;
      this.dayNames = locale.daysMin;
      this.switchLabelFormat = locale.titleFormat;
      updateDOW = true;
    }
    if (options.beforeShowDay !== undefined) {
      this.beforeShow = typeof options.beforeShowDay === 'function'
        ? options.beforeShowDay
        : undefined;
    }

    if (options.calendarWeeks !== undefined) {
      if (options.calendarWeeks && !this.calendarWeeks) {
        const weeksElem = parseHTML(templates_calendarWeeksTemplate).firstChild;
        this.calendarWeeks = {
          element: weeksElem,
          dow: weeksElem.firstChild,
          weeks: weeksElem.lastChild,
        };
        this.element.insertBefore(weeksElem, this.element.firstChild);
      } else if (this.calendarWeeks && !options.calendarWeeks) {
        this.element.removeChild(this.calendarWeeks.element);
        this.calendarWeeks = null;
      }
    }
    if (options.showDaysOfWeek !== undefined) {
      if (options.showDaysOfWeek) {
        showElement(this.dow);
        if (this.calendarWeeks) {
          showElement(this.calendarWeeks.dow);
        }
      } else {
        hideElement(this.dow);
        if (this.calendarWeeks) {
          hideElement(this.calendarWeeks.dow);
        }
      }
    }

    // update days-of-week when locale, daysOfweekDisabled or weekStart is changed
    if (updateDOW) {
      Array.from(this.dow.children).forEach((el, index) => {
        const dow = (this.weekStart + index) % 7;
        el.textContent = this.dayNames[dow];
        el.className = this.daysOfWeekDisabled.includes(dow) ? 'dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed' : 'dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400';
      });
    }
  }

  // Apply update on the focused date to view's settings
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    const viewYear = viewDate.getFullYear();
    const viewMonth = viewDate.getMonth();
    const firstOfMonth = (0,lib_date/* dateValue */.by)(viewYear, viewMonth, 1);
    const start = (0,lib_date/* dayOfTheWeekOf */.fr)(firstOfMonth, this.weekStart, this.weekStart);

    this.first = firstOfMonth;
    this.last = (0,lib_date/* dateValue */.by)(viewYear, viewMonth + 1, 0);
    this.start = start;
    this.focused = this.picker.viewDate;
  }

  // Apply update on the selected dates to view's settings
  updateSelection() {
    const {dates, rangepicker} = this.picker.datepicker;
    this.selected = dates;
    if (rangepicker) {
      this.range = rangepicker.dates;
    }
  }

   // Update the entire view UI
  render() {
    // update today marker on ever render
    this.today = this.todayHighlight ? (0,lib_date/* today */.Lg)() : undefined;
    // refresh disabled dates on every render in order to clear the ones added
    // by beforeShow hook at previous render
    this.disabled = [...this.datesDisabled];

    const switchLabel = (0,date_format/* formatDate */.p6)(this.focused, this.switchLabelFormat, this.locale);
    this.picker.setViewSwitchLabel(switchLabel);
    this.picker.setPrevBtnDisabled(this.first <= this.minDate);
    this.picker.setNextBtnDisabled(this.last >= this.maxDate);

    if (this.calendarWeeks) {
      // start of the UTC week (Monday) of the 1st of the month
      const startOfWeek = (0,lib_date/* dayOfTheWeekOf */.fr)(this.first, 1, 1);
      Array.from(this.calendarWeeks.weeks.children).forEach((el, index) => {
        el.textContent = (0,lib_date/* getWeek */.Qk)((0,lib_date/* addWeeks */.jh)(startOfWeek, index));
      });
    }
    Array.from(this.grid.children).forEach((el, index) => {
      const classList = el.classList;
      const current = (0,lib_date/* addDays */.E4)(this.start, index);
      const date = new Date(current);
      const day = date.getDay();

      el.className = `datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ${this.cellClass}`;
      el.dataset.date = current;
      el.textContent = date.getDate();

      if (current < this.first) {
        classList.add('prev', 'text-gray-500', 'dark:text-white');
      } else if (current > this.last) {
        classList.add('next', 'text-gray-500', 'dark:text-white');
      }
      if (this.today === current) {
        classList.add('today', 'bg-gray-100', 'dark:bg-gray-600');
      }
      if (current < this.minDate || current > this.maxDate || this.disabled.includes(current)) {
        classList.add('disabled', 'cursor-not-allowed');
      }
      if (this.daysOfWeekDisabled.includes(day)) {
        classList.add('disabled', 'cursor-not-allowed');
        (0,utils/* pushUnique */.$C)(this.disabled, current);
      }
      if (this.daysOfWeekHighlighted.includes(day)) {
        classList.add('highlighted');
      }
      if (this.range) {
        const [rangeStart, rangeEnd] = this.range;
        if (current > rangeStart && current < rangeEnd) {
          classList.add('range', 'bg-gray-200', 'dark:bg-gray-600');
          classList.remove('rounded-lg', 'rounded-l-lg', 'rounded-r-lg')
        }
        if (current === rangeStart) {
          classList.add('range-start', 'bg-gray-100', 'dark:bg-gray-600', 'rounded-l-lg');
          classList.remove('rounded-lg', 'rounded-r-lg');
        }
        if (current === rangeEnd) {
          classList.add('range-end', 'bg-gray-100', 'dark:bg-gray-600', 'rounded-r-lg');
          classList.remove('rounded-lg', 'rounded-l-lg');
        }
      }
      if (this.selected.includes(current)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'text-gray-500', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600', 'dark:bg-gray-600', 'bg-gray-100', 'bg-gray-200');
      }
      if (current === this.focused) {
        classList.add('focused');
      }

      if (this.beforeShow) {
        this.performBeforeHook(el, current, current);
      }
    });
  }

  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const [rangeStart, rangeEnd] = this.range || [];
    this.grid
      .querySelectorAll('.range, .range-start, .range-end, .selected, .focused')
      .forEach((el) => {
        el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white', 'focused');
        el.classList.add('text-gray-900', 'rounded-lg', 'dark:text-white');
      });
    Array.from(this.grid.children).forEach((el) => {
      const current = Number(el.dataset.date);
      const classList = el.classList;
      classList.remove('bg-gray-200', 'dark:bg-gray-600', 'rounded-l-lg', 'rounded-r-lg')
      if (current > rangeStart && current < rangeEnd) {
        classList.add('range', 'bg-gray-200', 'dark:bg-gray-600');
        classList.remove('rounded-lg');
      }
      if (current === rangeStart) {
        classList.add('range-start', 'bg-gray-200', 'dark:bg-gray-600', 'rounded-l-lg');
        classList.remove('rounded-lg', 'rounded-r-lg');
      }
      if (current === rangeEnd) {
        classList.add('range-end', 'bg-gray-200', 'dark:bg-gray-600', 'rounded-r-lg');
        classList.remove('rounded-lg', 'rounded-l-lg');
      }
      if (this.selected.includes(current)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600', 'bg-gray-100', 'bg-gray-200', 'dark:bg-gray-600');
      }
      if (current === this.focused) {
        classList.add('focused');
      }
    });
  }

  // Update the view UI by applying the change of focused item
  refreshFocus() {
    const index = Math.round((this.focused - this.start) / 86400000);
    this.grid.querySelectorAll('.focused').forEach((el) => {
      el.classList.remove('focused');
    });
    this.grid.children[index].classList.add('focused');
  }
}

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/picker/views/MonthsView.js





function computeMonthRange(range, thisYear) {
  if (!range || !range[0] || !range[1]) {
    return;
  }

  const [[startY, startM], [endY, endM]] = range;
  if (startY > thisYear || endY < thisYear) {
    return;
  }
  return [
    startY === thisYear ? startM : -1,
    endY === thisYear ? endM : 12,
  ];
}

class MonthsView extends View {
  constructor(picker) {
    super(picker, {
      id: 1,
      name: 'months',
      cellClass: 'month',
    });
  }

  init(options, onConstruction = true) {
    if (onConstruction) {
      this.grid = this.element;
      this.element.classList.add('months', 'datepicker-grid', 'w-64', 'grid', 'grid-cols-4');
      this.grid.appendChild(parseHTML((0,utils/* createTagRepeat */.em)('span', 12, {'data-month': ix => ix})));
    }
    super.init(options);
  }

  setOptions(options) {
    if (options.locale) {
      this.monthNames = options.locale.monthsShort;
    }
    if ((0,utils/* hasProperty */.l$)(options, 'minDate')) {
      if (options.minDate === undefined) {
        this.minYear = this.minMonth = this.minDate = undefined;
      } else {
        const minDateObj = new Date(options.minDate);
        this.minYear = minDateObj.getFullYear();
        this.minMonth = minDateObj.getMonth();
        this.minDate = minDateObj.setDate(1);
      }
    }
    if ((0,utils/* hasProperty */.l$)(options, 'maxDate')) {
      if (options.maxDate === undefined) {
        this.maxYear = this.maxMonth = this.maxDate = undefined;
      } else {
        const maxDateObj = new Date(options.maxDate);
        this.maxYear = maxDateObj.getFullYear();
        this.maxMonth = maxDateObj.getMonth();
        this.maxDate = (0,lib_date/* dateValue */.by)(this.maxYear, this.maxMonth + 1, 0);
      }
    }
    if (options.beforeShowMonth !== undefined) {
      this.beforeShow = typeof options.beforeShowMonth === 'function'
        ? options.beforeShowMonth
        : undefined;
    }
  }

  // Update view's settings to reflect the viewDate set on the picker
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    this.year = viewDate.getFullYear();
    this.focused = viewDate.getMonth();
  }

  // Update view's settings to reflect the selected dates
  updateSelection() {
    const {dates, rangepicker} = this.picker.datepicker;
    this.selected = dates.reduce((selected, timeValue) => {
      const date = new Date(timeValue);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (selected[year] === undefined) {
        selected[year] = [month];
      } else {
        (0,utils/* pushUnique */.$C)(selected[year], month);
      }
      return selected;
    }, {});
    if (rangepicker && rangepicker.dates) {
      this.range = rangepicker.dates.map(timeValue => {
        const date = new Date(timeValue);
        return isNaN(date) ? undefined : [date.getFullYear(), date.getMonth()];
      });
    }
  }

  // Update the entire view UI
  render() {
    // refresh disabled months on every render in order to clear the ones added
    // by beforeShow hook at previous render
    this.disabled = [];

    this.picker.setViewSwitchLabel(this.year);
    this.picker.setPrevBtnDisabled(this.year <= this.minYear);
    this.picker.setNextBtnDisabled(this.year >= this.maxYear);

    const selected = this.selected[this.year] || [];
    const yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;
    const isMinYear = this.year === this.minYear;
    const isMaxYear = this.year === this.maxYear;
    const range = computeMonthRange(this.range, this.year);

    Array.from(this.grid.children).forEach((el, index) => {
      const classList = el.classList;
      const date = (0,lib_date/* dateValue */.by)(this.year, index, 1);

      el.className = `datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ${this.cellClass}`;
      if (this.isMinView) {
        el.dataset.date = date;
      }
      // reset text on every render to clear the custom content set
      // by beforeShow hook at previous render
      el.textContent = this.monthNames[index];

      if (
        yrOutOfRange
        || isMinYear && index < this.minMonth
        || isMaxYear && index > this.maxMonth
      ) {
        classList.add('disabled');
      }
      if (range) {
        const [rangeStart, rangeEnd] = range;
        if (index > rangeStart && index < rangeEnd) {
          classList.add('range');
        }
        if (index === rangeStart) {
          classList.add('range-start');
        }
        if (index === rangeEnd) {
          classList.add('range-end');
        }
      }
      if (selected.includes(index)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');
      }
      if (index === this.focused) {
        classList.add('focused');
      }

      if (this.beforeShow) {
        this.performBeforeHook(el, index, date);
      }
    });
  }

  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const selected = this.selected[this.year] || [];
    const [rangeStart, rangeEnd] = computeMonthRange(this.range, this.year) || [];
    this.grid
      .querySelectorAll('.range, .range-start, .range-end, .selected, .focused')
      .forEach((el) => {
        el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'dark:bg-blue-600', 'dark:text-white', 'text-white', 'focused');
        el.classList.add('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');
      });
    Array.from(this.grid.children).forEach((el, index) => {
      const classList = el.classList;
      if (index > rangeStart && index < rangeEnd) {
        classList.add('range');
      }
      if (index === rangeStart) {
        classList.add('range-start');
      }
      if (index === rangeEnd) {
        classList.add('range-end');
      }
      if (selected.includes(index)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');
      }
      if (index === this.focused) {
        classList.add('focused');
      }
    });
  }

  // Update the view UI by applying the change of focused item
  refreshFocus() {
    this.grid.querySelectorAll('.focused').forEach((el) => {
      el.classList.remove('focused');
    });
    this.grid.children[this.focused].classList.add('focused');
  }
}
;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/picker/views/YearsView.js





function toTitleCase(word) {
  return [...word].reduce((str, ch, ix) => str += ix ? ch : ch.toUpperCase(), '');
}

// Class representing the years and decades view elements
class YearsView extends View {
  constructor(picker, config) {
    super(picker, config);
  }

  init(options, onConstruction = true) {
    if (onConstruction) {
      this.navStep = this.step * 10;
      this.beforeShowOption = `beforeShow${toTitleCase(this.cellClass)}`;
      this.grid = this.element;
      this.element.classList.add(this.name, 'datepicker-grid', 'w-64', 'grid', 'grid-cols-4');
      this.grid.appendChild(parseHTML((0,utils/* createTagRepeat */.em)('span', 12)));
    }
    super.init(options);
  }

  setOptions(options) {
    if ((0,utils/* hasProperty */.l$)(options, 'minDate')) {
      if (options.minDate === undefined) {
        this.minYear = this.minDate = undefined;
      } else {
        this.minYear = (0,lib_date/* startOfYearPeriod */.ak)(options.minDate, this.step);
        this.minDate = (0,lib_date/* dateValue */.by)(this.minYear, 0, 1);
      }
    }
    if ((0,utils/* hasProperty */.l$)(options, 'maxDate')) {
      if (options.maxDate === undefined) {
        this.maxYear = this.maxDate = undefined;
      } else {
        this.maxYear = (0,lib_date/* startOfYearPeriod */.ak)(options.maxDate, this.step);
        this.maxDate = (0,lib_date/* dateValue */.by)(this.maxYear, 11, 31);
      }
    }
    if (options[this.beforeShowOption] !== undefined) {
      const beforeShow = options[this.beforeShowOption];
      this.beforeShow = typeof beforeShow === 'function' ? beforeShow : undefined;
    }
  }

  // Update view's settings to reflect the viewDate set on the picker
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    const first = (0,lib_date/* startOfYearPeriod */.ak)(viewDate, this.navStep);
    const last = first + 9 * this.step;

    this.first = first;
    this.last = last;
    this.start = first - this.step;
    this.focused = (0,lib_date/* startOfYearPeriod */.ak)(viewDate, this.step);
  }

  // Update view's settings to reflect the selected dates
  updateSelection() {
    const {dates, rangepicker} = this.picker.datepicker;
    this.selected = dates.reduce((years, timeValue) => {
      return (0,utils/* pushUnique */.$C)(years, (0,lib_date/* startOfYearPeriod */.ak)(timeValue, this.step));
    }, []);
    if (rangepicker && rangepicker.dates) {
      this.range = rangepicker.dates.map(timeValue => {
        if (timeValue !== undefined) {
          return (0,lib_date/* startOfYearPeriod */.ak)(timeValue, this.step);
        }
      });
    }
  }

  // Update the entire view UI
  render() {
    // refresh disabled years on every render in order to clear the ones added
    // by beforeShow hook at previous render
    this.disabled = [];

    this.picker.setViewSwitchLabel(`${this.first}-${this.last}`);
    this.picker.setPrevBtnDisabled(this.first <= this.minYear);
    this.picker.setNextBtnDisabled(this.last >= this.maxYear);

    Array.from(this.grid.children).forEach((el, index) => {
      const classList = el.classList;
      const current = this.start + (index * this.step);
      const date = (0,lib_date/* dateValue */.by)(current, 0, 1);

      el.className = `datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ${this.cellClass}`;
      if (this.isMinView) {
        el.dataset.date = date;
      }
      el.textContent = el.dataset.year = current;

      if (index === 0) {
        classList.add('prev');
      } else if (index === 11) {
        classList.add('next');
      }
      if (current < this.minYear || current > this.maxYear) {
        classList.add('disabled');
      }
      if (this.range) {
        const [rangeStart, rangeEnd] = this.range;
        if (current > rangeStart && current < rangeEnd) {
          classList.add('range');
        }
        if (current === rangeStart) {
          classList.add('range-start');
        }
        if (current === rangeEnd) {
          classList.add('range-end');
        }
      }
      if (this.selected.includes(current)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');
      }
      if (current === this.focused) {
        classList.add('focused');
      }

      if (this.beforeShow) {
        this.performBeforeHook(el, current, date);
      }
    });
  }

  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const [rangeStart, rangeEnd] = this.range || [];
    this.grid
      .querySelectorAll('.range, .range-start, .range-end, .selected, .focused')
      .forEach((el) => {
        el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white', 'focused');
      });
    Array.from(this.grid.children).forEach((el) => {
      const current = Number(el.textContent);
      const classList = el.classList;
      if (current > rangeStart && current < rangeEnd) {
        classList.add('range');
      }
      if (current === rangeStart) {
        classList.add('range-start');
      }
      if (current === rangeEnd) {
        classList.add('range-end');
      }
      if (this.selected.includes(current)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');
      }
      if (current === this.focused) {
        classList.add('focused');
      }
    });
  }

  // Update the view UI by applying the change of focused item
  refreshFocus() {
    const index = Math.round((this.focused - this.start) / this.step);
    this.grid.querySelectorAll('.focused').forEach((el) => {
      el.classList.remove('focused');
    });
    this.grid.children[index].classList.add('focused');
  }
}

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/events/functions.js



function triggerDatepickerEvent(datepicker, type) {
  const detail = {
    date: datepicker.getDate(),
    viewDate: new Date(datepicker.picker.viewDate),
    viewId: datepicker.picker.currentView.id,
    datepicker,
  };
  datepicker.element.dispatchEvent(new CustomEvent(type, {detail}));
}

// direction: -1 (to previous), 1 (to next)
function goToPrevOrNext(datepicker, direction) {
  const {minDate, maxDate} = datepicker.config;
  const {currentView, viewDate} = datepicker.picker;
  let newViewDate;
  switch (currentView.id) {
    case 0:
      newViewDate = (0,lib_date/* addMonths */.zI)(viewDate, direction);
      break;
    case 1:
      newViewDate = (0,lib_date/* addYears */.Bc)(viewDate, direction);
      break;
    default:
      newViewDate = (0,lib_date/* addYears */.Bc)(viewDate, direction * currentView.navStep);
  }
  newViewDate = (0,utils/* limitToRange */.jG)(newViewDate, minDate, maxDate);
  datepicker.picker.changeFocus(newViewDate).render();
}

function switchView(datepicker) {
  const viewId = datepicker.picker.currentView.id;
  if (viewId === datepicker.config.maxView) {
    return;
  }
  datepicker.picker.changeView(viewId + 1).render();
}

function unfocus(datepicker) {
  if (datepicker.config.updateOnBlur) {
    datepicker.update({autohide: true});
  } else {
    datepicker.refresh('input');
    datepicker.hide();
  }
}

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/events/pickerListeners.js




function goToSelectedMonthOrYear(datepicker, selection) {
  const picker = datepicker.picker;
  const viewDate = new Date(picker.viewDate);
  const viewId = picker.currentView.id;
  const newDate = viewId === 1
    ? (0,lib_date/* addMonths */.zI)(viewDate, selection - viewDate.getMonth())
    : (0,lib_date/* addYears */.Bc)(viewDate, selection - viewDate.getFullYear());

  picker.changeFocus(newDate).changeView(viewId - 1).render();
}

function onClickTodayBtn(datepicker) {
  const picker = datepicker.picker;
  const currentDate = (0,lib_date/* today */.Lg)();
  if (datepicker.config.todayBtnMode === 1) {
    if (datepicker.config.autohide) {
      datepicker.setDate(currentDate);
      return;
    }
    datepicker.setDate(currentDate, {render: false});
    picker.update();
  }
  if (picker.viewDate !== currentDate) {
    picker.changeFocus(currentDate);
  }
  picker.changeView(0).render();
}

function onClickClearBtn(datepicker) {
  datepicker.setDate({clear: true});
}

function onClickViewSwitch(datepicker) {
  switchView(datepicker);
}

function onClickPrevBtn(datepicker) {
  goToPrevOrNext(datepicker, -1);
}

function onClickNextBtn(datepicker) {
  goToPrevOrNext(datepicker, 1);
}

// For the picker's main block to delegete the events from `datepicker-cell`s
function onClickView(datepicker, ev) {
  const target = (0,lib_event/* findElementInEventPath */.He)(ev, '.datepicker-cell');
  if (!target || target.classList.contains('disabled')) {
    return;
  }

  const {id, isMinView} = datepicker.picker.currentView;
  if (isMinView) {
    datepicker.setDate(Number(target.dataset.date));
  } else if (id === 1) {
    goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));
  } else {
    goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));
  }
}

function onClickPicker(datepicker) {
  if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) {
    datepicker.inputField.focus();
  }
}

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/picker/Picker.js











function processPickerOptions(picker, options) {
  if (options.title !== undefined) {
    if (options.title) {
      picker.controls.title.textContent = options.title;
      showElement(picker.controls.title);
    } else {
      picker.controls.title.textContent = '';
      hideElement(picker.controls.title);
    }
  }
  if (options.prevArrow) {
    const prevBtn = picker.controls.prevBtn;
    emptyChildNodes(prevBtn);
    options.prevArrow.forEach((node) => {
      prevBtn.appendChild(node.cloneNode(true));
    });
  }
  if (options.nextArrow) {
    const nextBtn = picker.controls.nextBtn;
    emptyChildNodes(nextBtn);
    options.nextArrow.forEach((node) => {
      nextBtn.appendChild(node.cloneNode(true));
    });
  }
  if (options.locale) {
    picker.controls.todayBtn.textContent = options.locale.today;
    picker.controls.clearBtn.textContent = options.locale.clear;
  }
  if (options.todayBtn !== undefined) {
    if (options.todayBtn) {
      showElement(picker.controls.todayBtn);
    } else {
      hideElement(picker.controls.todayBtn);
    }
  }
  if ((0,utils/* hasProperty */.l$)(options, 'minDate') || (0,utils/* hasProperty */.l$)(options, 'maxDate')) {
    const {minDate, maxDate} = picker.datepicker.config;
    picker.controls.todayBtn.disabled = !(0,utils/* isInRange */.mh)((0,lib_date/* today */.Lg)(), minDate, maxDate);
  }
  if (options.clearBtn !== undefined) {
    if (options.clearBtn) {
      showElement(picker.controls.clearBtn);
    } else {
      hideElement(picker.controls.clearBtn);
    }
  }
}

// Compute view date to reset, which will be...
// - the last item of the selected dates or defaultViewDate if no selection
// - limitted to minDate or maxDate if it exceeds the range
function computeResetViewDate(datepicker) {
  const {dates, config} = datepicker;
  const viewDate = dates.length > 0 ? (0,utils/* lastItemOf */.Jm)(dates) : config.defaultViewDate;
  return (0,utils/* limitToRange */.jG)(viewDate, config.minDate, config.maxDate);
}

// Change current view's view date
function setViewDate(picker, newDate) {
  const oldViewDate = new Date(picker.viewDate);
  const newViewDate = new Date(newDate);
  const {id, year, first, last} = picker.currentView;
  const viewYear = newViewDate.getFullYear();

  picker.viewDate = newDate;
  if (viewYear !== oldViewDate.getFullYear()) {
    triggerDatepickerEvent(picker.datepicker, 'changeYear');
  }
  if (newViewDate.getMonth() !== oldViewDate.getMonth()) {
    triggerDatepickerEvent(picker.datepicker, 'changeMonth');
  }

  // return whether the new date is in different period on time from the one
  // displayed in the current view
  // when true, the view needs to be re-rendered on the next UI refresh.
  switch (id) {
    case 0:
      return newDate < first || newDate > last;
    case 1:
      return viewYear !== year;
    default:
      return viewYear < first || viewYear > last;
  }
}

function getTextDirection(el) {
  return window.getComputedStyle(el).direction;
}

// Class representing the picker UI
class Picker {
  constructor(datepicker) {
    this.datepicker = datepicker;

    const template = templates_pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);
    const element = this.element = parseHTML(template).firstChild;
    const [header, main, footer] = element.firstChild.children;
    const title = header.firstElementChild;
    const [prevBtn, viewSwitch, nextBtn] = header.lastElementChild.children;
    const [todayBtn, clearBtn] = footer.firstChild.children;
    const controls = {
      title,
      prevBtn,
      viewSwitch,
      nextBtn,
      todayBtn,
      clearBtn,
    };
    this.main = main;
    this.controls = controls;

    const elementClass = datepicker.inline ? 'inline' : 'dropdown';
    element.classList.add(`datepicker-${elementClass}`);
    elementClass === 'dropdown' ? element.classList.add('dropdown', 'absolute', 'top-0', 'left-0', 'z-50', 'pt-2') : null;

    processPickerOptions(this, datepicker.config);
    this.viewDate = computeResetViewDate(datepicker);

    // set up event listeners
    (0,lib_event/* registerListeners */.cF)(datepicker, [
      [element, 'click', onClickPicker.bind(null, datepicker), {capture: true}],
      [main, 'click', onClickView.bind(null, datepicker)],
      [controls.viewSwitch, 'click', onClickViewSwitch.bind(null, datepicker)],
      [controls.prevBtn, 'click', onClickPrevBtn.bind(null, datepicker)],
      [controls.nextBtn, 'click', onClickNextBtn.bind(null, datepicker)],
      [controls.todayBtn, 'click', onClickTodayBtn.bind(null, datepicker)],
      [controls.clearBtn, 'click', onClickClearBtn.bind(null, datepicker)],
    ]);

    // set up views
    this.views = [
      new DaysView(this),
      new MonthsView(this),
      new YearsView(this, {id: 2, name: 'years', cellClass: 'year', step: 1}),
      new YearsView(this, {id: 3, name: 'decades', cellClass: 'decade', step: 10}),
    ];
    this.currentView = this.views[datepicker.config.startView];

    this.currentView.render();
    this.main.appendChild(this.currentView.element);
    datepicker.config.container.appendChild(this.element);
  }

  setOptions(options) {
    processPickerOptions(this, options);
    this.views.forEach((view) => {
      view.init(options, false);
    });
    this.currentView.render();
  }

  detach() {
    this.datepicker.config.container.removeChild(this.element);
  }

  show() {
    if (this.active) {
      return;
    }
    this.element.classList.add('active', 'block');
    this.element.classList.remove('hidden');
    this.active = true;

    const datepicker = this.datepicker;
    if (!datepicker.inline) {
      // ensure picker's direction matches input's
      const inputDirection = getTextDirection(datepicker.inputField);
      if (inputDirection !== getTextDirection(datepicker.config.container)) {
        this.element.dir = inputDirection;
      } else if (this.element.dir) {
        this.element.removeAttribute('dir');
      }

      this.place();
      if (datepicker.config.disableTouchKeyboard) {
        datepicker.inputField.blur();
      }
    }
    triggerDatepickerEvent(datepicker, 'show');
  }

  hide() {
    if (!this.active) {
      return;
    }
    this.datepicker.exitEditMode();
    this.element.classList.remove('active', 'block');
    this.element.classList.add('active', 'block', 'hidden');
    this.active = false;
    triggerDatepickerEvent(this.datepicker, 'hide');
  }

  place() {
    const {classList, style} = this.element;
    const {config, inputField} = this.datepicker;
    const container = config.container;
    const {
      width: calendarWidth,
      height: calendarHeight,
    } = this.element.getBoundingClientRect();
    const {
      left: containerLeft,
      top: containerTop,
      width: containerWidth,
    } = container.getBoundingClientRect();
    const {
      left: inputLeft,
      top: inputTop,
      width: inputWidth,
      height: inputHeight
    } = inputField.getBoundingClientRect();
    let {x: orientX, y: orientY} = config.orientation;
    let scrollTop;
    let left;
    let top;

    if (container === document.body) {
      scrollTop = window.scrollY;
      left = inputLeft + window.scrollX;
      top = inputTop + scrollTop;
    } else {
      scrollTop = container.scrollTop;
      left = inputLeft - containerLeft;
      top = inputTop - containerTop + scrollTop;
    }

    if (orientX === 'auto') {
      if (left < 0) {
        // align to the left and move into visible area if input's left edge < window's
        orientX = 'left';
        left = 10;
      } else if (left + calendarWidth > containerWidth) {
        // align to the right if canlendar's right edge > container's
        orientX = 'right';
      } else {
        orientX = getTextDirection(inputField) === 'rtl' ? 'right' : 'left';
      }
    }
    if (orientX === 'right') {
      left -= calendarWidth - inputWidth;
    }

    if (orientY === 'auto') {
      orientY = top - calendarHeight < scrollTop ? 'bottom' : 'top';
    }
    if (orientY === 'top') {
      top -= calendarHeight;
    } else {
      top += inputHeight;
    }

    classList.remove(
      'datepicker-orient-top',
      'datepicker-orient-bottom',
      'datepicker-orient-right',
      'datepicker-orient-left'
    );
    classList.add(`datepicker-orient-${orientY}`, `datepicker-orient-${orientX}`);

    style.top = top ? `${top}px` : top;
    style.left = left ? `${left}px` : left;
  }

  setViewSwitchLabel(labelText) {
    this.controls.viewSwitch.textContent = labelText;
  }

  setPrevBtnDisabled(disabled) {
    this.controls.prevBtn.disabled = disabled;
  }

  setNextBtnDisabled(disabled) {
    this.controls.nextBtn.disabled = disabled;
  }

  changeView(viewId) {
    const oldView = this.currentView;
    const newView =  this.views[viewId];
    if (newView.id !== oldView.id) {
      this.currentView = newView;
      this._renderMethod = 'render';
      triggerDatepickerEvent(this.datepicker, 'changeView');
      this.main.replaceChild(newView.element, oldView.element);
    }
    return this;
  }

  // Change the focused date (view date)
  changeFocus(newViewDate) {
    this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refreshFocus';
    this.views.forEach((view) => {
      view.updateFocus();
    });
    return this;
  }

  // Apply the change of the selected dates
  update() {
    const newViewDate = computeResetViewDate(this.datepicker);
    this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refresh';
    this.views.forEach((view) => {
      view.updateFocus();
      view.updateSelection();
    });
    return this;
  }

  // Refresh the picker UI
  render(quickRender = true) {
    const renderMethod = (quickRender && this._renderMethod) || 'render';
    delete this._renderMethod;

    this.currentView[renderMethod]();
  }
}

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/events/inputFieldListeners.js




// Find the closest date that doesn't meet the condition for unavailable date
// Returns undefined if no available date is found
// addFn: function to calculate the next date
//   - args: time value, amount
// increase: amount to pass to addFn
// testFn: function to test the unavailablity of the date
//   - args: time value; retun: true if unavailable
function findNextAvailableOne(date, addFn, increase, testFn, min, max) {
  if (!(0,utils/* isInRange */.mh)(date, min, max)) {
    return;
  }
  if (testFn(date)) {
    const newDate = addFn(date, increase);
    return findNextAvailableOne(newDate, addFn, increase, testFn, min, max);
  }
  return date;
}

// direction: -1 (left/up), 1 (right/down)
// vertical: true for up/down, false for left/right
function moveByArrowKey(datepicker, ev, direction, vertical) {
  const picker = datepicker.picker;
  const currentView = picker.currentView;
  const step = currentView.step || 1;
  let viewDate = picker.viewDate;
  let addFn;
  let testFn;
  switch (currentView.id) {
    case 0:
      if (vertical) {
        viewDate = (0,lib_date/* addDays */.E4)(viewDate, direction * 7);
      } else if (ev.ctrlKey || ev.metaKey) {
        viewDate = (0,lib_date/* addYears */.Bc)(viewDate, direction);
      } else {
        viewDate = (0,lib_date/* addDays */.E4)(viewDate, direction);
      }
      addFn = lib_date/* addDays */.E4;
      testFn = (date) => currentView.disabled.includes(date);
      break;
    case 1:
      viewDate = (0,lib_date/* addMonths */.zI)(viewDate, vertical ? direction * 4 : direction);
      addFn = lib_date/* addMonths */.zI;
      testFn = (date) => {
        const dt = new Date(date);
        const {year, disabled} = currentView;
        return dt.getFullYear() === year && disabled.includes(dt.getMonth());
      };
      break;
    default:
      viewDate = (0,lib_date/* addYears */.Bc)(viewDate, direction * (vertical ? 4 : 1) * step);
      addFn = lib_date/* addYears */.Bc;
      testFn = date => currentView.disabled.includes((0,lib_date/* startOfYearPeriod */.ak)(date, step));
  }
  viewDate = findNextAvailableOne(
    viewDate,
    addFn,
    direction < 0 ? -step : step,
    testFn,
    currentView.minDate,
    currentView.maxDate
  );
  if (viewDate !== undefined) {
    picker.changeFocus(viewDate).render();
  }
}

function onKeydown(datepicker, ev) {
  if (ev.key === 'Tab') {
    unfocus(datepicker);
    return;
  }

  const picker = datepicker.picker;
  const {id, isMinView} = picker.currentView;
  if (!picker.active) {
    switch (ev.key) {
      case 'ArrowDown':
      case 'Escape':
        picker.show();
        break;
      case 'Enter':
        datepicker.update();
        break;
      default:
        return;
    }
  } else if (datepicker.editMode) {
    switch (ev.key) {
      case 'Escape':
        picker.hide();
        break;
      case 'Enter':
        datepicker.exitEditMode({update: true, autohide: datepicker.config.autohide});
        break;
      default:
        return;
    }
  } else {
    switch (ev.key) {
      case 'Escape':
        picker.hide();
        break;
      case 'ArrowLeft':
        if (ev.ctrlKey || ev.metaKey) {
          goToPrevOrNext(datepicker, -1);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, -1, false);
        }
        break;
      case 'ArrowRight':
        if (ev.ctrlKey || ev.metaKey) {
          goToPrevOrNext(datepicker, 1);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, 1, false);
        }
        break;
      case 'ArrowUp':
        if (ev.ctrlKey || ev.metaKey) {
          switchView(datepicker);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, -1, true);
        }
        break;
      case 'ArrowDown':
        if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
          datepicker.enterEditMode();
          return;
        }
        moveByArrowKey(datepicker, ev, 1, true);
        break;
      case 'Enter':
        if (isMinView) {
          datepicker.setDate(picker.viewDate);
        } else {
          picker.changeView(id - 1).render();
        }
        break;
      case 'Backspace':
      case 'Delete':
        datepicker.enterEditMode();
        return;
      default:
        if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {
          datepicker.enterEditMode();
        }
        return;
    }
  }
  ev.preventDefault();
  ev.stopPropagation();
}

function onFocus(datepicker) {
  if (datepicker.config.showOnFocus && !datepicker._showing) {
    datepicker.show();
  }
}

// for the prevention for entering edit mode while getting focus on click
function onMousedown(datepicker, ev) {
  const el = ev.target;
  if (datepicker.picker.active || datepicker.config.showOnClick) {
    el._active = el === document.activeElement;
    el._clicking = setTimeout(() => {
      delete el._active;
      delete el._clicking;
    }, 2000);
  }
}

function onClickInput(datepicker, ev) {
  const el = ev.target;
  if (!el._clicking) {
    return;
  }
  clearTimeout(el._clicking);
  delete el._clicking;

  if (el._active) {
    datepicker.enterEditMode();
  }
  delete el._active;

  if (datepicker.config.showOnClick) {
    datepicker.show();
  }
}

function onPaste(datepicker, ev) {
  if (ev.clipboardData.types.includes('text/plain')) {
    datepicker.enterEditMode();
  }
}

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/events/otherListeners.js



// for the `document` to delegate the events from outside the picker/input field
function onClickOutside(datepicker, ev) {
  const element = datepicker.element;
  if (element !== document.activeElement) {
    return;
  }
  const pickerElem = datepicker.picker.element;
  if ((0,lib_event/* findElementInEventPath */.He)(ev, el => el === element || el === pickerElem)) {
    return;
  }
  unfocus(datepicker);
}

;// CONCATENATED MODULE: ./node_modules/flowbite-datepicker/js/Datepicker.js












function stringifyDates(dates, config) {
  return dates
    .map(dt => (0,date_format/* formatDate */.p6)(dt, config.format, config.locale))
    .join(config.dateDelimiter);
}

// parse input dates and create an array of time values for selection
// returns undefined if there are no valid dates in inputDates
// when origDates (current selection) is passed, the function works to mix
// the input dates into the current selection
function processInputDates(datepicker, inputDates, clear = false) {
  const {config, dates: origDates, rangepicker} = datepicker;
  if (inputDates.length === 0) {
    // empty input is considered valid unless origiDates is passed
    return clear ? [] : undefined;
  }

  const rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];
  let newDates = inputDates.reduce((dates, dt) => {
    let date = (0,date_format/* parseDate */.sG)(dt, config.format, config.locale);
    if (date === undefined) {
      return dates;
    }
    if (config.pickLevel > 0) {
      // adjust to 1st of the month/Jan 1st of the year
      // or to the last day of the monh/Dec 31st of the year if the datepicker
      // is the range-end picker of a rangepicker
      const dt = new Date(date);
      if (config.pickLevel === 1) {
        date = rangeEnd
          ? dt.setMonth(dt.getMonth() + 1, 0)
          : dt.setDate(1);
      } else {
        date = rangeEnd
          ? dt.setFullYear(dt.getFullYear() + 1, 0, 0)
          : dt.setMonth(0, 1);
      }
    }
    if (
      (0,utils/* isInRange */.mh)(date, config.minDate, config.maxDate)
      && !dates.includes(date)
      && !config.datesDisabled.includes(date)
      && !config.daysOfWeekDisabled.includes(new Date(date).getDay())
    ) {
      dates.push(date);
    }
    return dates;
  }, []);
  if (newDates.length === 0) {
    return;
  }
  if (config.multidate && !clear) {
    // get the synmetric difference between origDates and newDates
    newDates = newDates.reduce((dates, date) => {
      if (!origDates.includes(date)) {
        dates.push(date);
      }
      return dates;
    }, origDates.filter(date => !newDates.includes(date)));
  }
  // do length check always because user can input multiple dates regardless of the mode
  return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates
    ? newDates.slice(config.maxNumberOfDates * -1)
    : newDates;
}

// refresh the UI elements
// modes: 1: input only, 2, picker only, 3 both
function refreshUI(datepicker, mode = 3, quickRender = true) {
  const {config, picker, inputField} = datepicker;
  if (mode & 2) {
    const newView = picker.active ? config.pickLevel : config.startView;
    picker.update().changeView(newView).render(quickRender);
  }
  if (mode & 1 && inputField) {
    inputField.value = stringifyDates(datepicker.dates, config);
  }
}

function setDate(datepicker, inputDates, options) {
  let {clear, render, autohide} = options;
  if (render === undefined) {
    render = true;
  }
  if (!render) {
    autohide = false;
  } else if (autohide === undefined) {
    autohide = datepicker.config.autohide;
  }

  const newDates = processInputDates(datepicker, inputDates, clear);
  if (!newDates) {
    return;
  }
  if (newDates.toString() !== datepicker.dates.toString()) {
    datepicker.dates = newDates;
    refreshUI(datepicker, render ? 3 : 1);
    triggerDatepickerEvent(datepicker, 'changeDate');
  } else {
    refreshUI(datepicker, 1);
  }
  if (autohide) {
    datepicker.hide();
  }
}

/**
 * Class representing a date picker
 */
class Datepicker {
  /**
   * Create a date picker
   * @param  {Element} element - element to bind a date picker
   * @param  {Object} [options] - config options
   * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the
   * date picker belongs to. Use this only when creating date picker as a part
   * of date range picker
   */
  constructor(element, options = {}, rangepicker = undefined) {
    element.datepicker = this;
    this.element = element;

    // set up config
    const config = this.config = Object.assign({
      buttonClass: (options.buttonClass && String(options.buttonClass)) || 'button',
      container: document.body,
      defaultViewDate: (0,lib_date/* today */.Lg)(),
      maxDate: undefined,
      minDate: undefined,
    }, processOptions(options_defaultOptions, this));
    this._options = options;
    Object.assign(config, processOptions(options, this));

    // configure by type
    const inline = this.inline = element.tagName !== 'INPUT';
    let inputField;
    let initialDates;

    if (inline) {
      config.container = element;
      initialDates = (0,utils/* stringToArray */.W7)(element.dataset.date, config.dateDelimiter);
      delete element.dataset.date;
    } else {
      const container = options.container ? document.querySelector(options.container) : null;
      if (container) {
        config.container = container;
      }
      inputField = this.inputField = element;
      inputField.classList.add('datepicker-input');
      initialDates = (0,utils/* stringToArray */.W7)(inputField.value, config.dateDelimiter);
    }
    if (rangepicker) {
      // check validiry
      const index = rangepicker.inputs.indexOf(inputField);
      const datepickers = rangepicker.datepickers;
      if (index < 0 || index > 1 || !Array.isArray(datepickers)) {
        throw Error('Invalid rangepicker object.');
      }
      // attach itaelf to the rangepicker here so that processInputDates() can
      // determine if this is the range-end picker of the rangepicker while
      // setting inital values when pickLevel > 0
      datepickers[index] = this;
      // add getter for rangepicker
      Object.defineProperty(this, 'rangepicker', {
        get() {
          return rangepicker;
        },
      });
    }

    // set initial dates
    this.dates = [];
    // process initial value
    const inputDateValues = processInputDates(this, initialDates);
    if (inputDateValues && inputDateValues.length > 0) {
      this.dates = inputDateValues;
    }
    if (inputField) {
      inputField.value = stringifyDates(this.dates, config);
    }

    const picker = this.picker = new Picker(this);

    if (inline) {
      this.show();
    } else {
      // set up event listeners in other modes
      const onMousedownDocument = onClickOutside.bind(null, this);
      const listeners = [
        [inputField, 'keydown', onKeydown.bind(null, this)],
        [inputField, 'focus', onFocus.bind(null, this)],
        [inputField, 'mousedown', onMousedown.bind(null, this)],
        [inputField, 'click', onClickInput.bind(null, this)],
        [inputField, 'paste', onPaste.bind(null, this)],
        [document, 'mousedown', onMousedownDocument],
        [document, 'touchstart', onMousedownDocument],
        [window, 'resize', picker.place.bind(picker)]
      ];
      (0,lib_event/* registerListeners */.cF)(this, listeners);
    }
  }

  /**
   * Format Date object or time value in given format and language
   * @param  {Date|Number} date - date or time value to format
   * @param  {String|Object} format - format string or object that contains
   * toDisplay() custom formatter, whose signature is
   * - args:
   *   - date: {Date} - Date instance of the date passed to the method
   *   - format: {Object} - the format object passed to the method
   *   - locale: {Object} - locale for the language specified by `lang`
   * - return:
   *     {String} formatted date
   * @param  {String} [lang=en] - language code for the locale to use
   * @return {String} formatted date
   */
  static formatDate(date, format, lang) {
    return (0,date_format/* formatDate */.p6)(date, format, lang && locales[lang] || locales.en);
  }

  /**
   * Parse date string
   * @param  {String|Date|Number} dateStr - date string, Date object or time
   * value to parse
   * @param  {String|Object} format - format string or object that contains
   * toValue() custom parser, whose signature is
   * - args:
   *   - dateStr: {String|Date|Number} - the dateStr passed to the method
   *   - format: {Object} - the format object passed to the method
   *   - locale: {Object} - locale for the language specified by `lang`
   * - return:
   *     {Date|Number} parsed date or its time value
   * @param  {String} [lang=en] - language code for the locale to use
   * @return {Number} time value of parsed date
   */
  static parseDate(dateStr, format, lang) {
    return (0,date_format/* parseDate */.sG)(dateStr, format, lang && locales[lang] || locales.en);
  }

  /**
   * @type {Object} - Installed locales in `[languageCode]: localeObject` format
   * en`:_English (US)_ is pre-installed.
   */
  static get locales() {
    return locales;
  }

  /**
   * @type {Boolean} - Whether the picker element is shown. `true` whne shown
   */
  get active() {
    return !!(this.picker && this.picker.active);
  }

  /**
   * @type {HTMLDivElement} - DOM object of picker element
   */
  get pickerElement() {
    return this.picker ? this.picker.element : undefined;
  }

  /**
   * Set new values to the config options
   * @param {Object} options - config options to update
   */
  setOptions(options) {
    const picker = this.picker;
    const newOptions = processOptions(options, this);
    Object.assign(this._options, options);
    Object.assign(this.config, newOptions);
    picker.setOptions(newOptions);

    refreshUI(this, 3);
  }

  /**
   * Show the picker element
   */
  show() {
    if (this.inputField) {
      if (this.inputField.disabled) {
        return;
      }
      if (this.inputField !== document.activeElement) {
        this._showing = true;
        this.inputField.focus();
        delete this._showing;
      }
    }
    this.picker.show();
  }

  /**
   * Hide the picker element
   * Not available on inline picker
   */
  hide() {
    if (this.inline) {
      return;
    }
    this.picker.hide();
    this.picker.update().changeView(this.config.startView).render();
  }

  /**
   * Destroy the Datepicker instance
   * @return {Detepicker} - the instance destroyed
   */
  destroy() {
    this.hide();
    (0,lib_event/* unregisterListeners */.uV)(this);
    this.picker.detach();
    if (!this.inline) {
      this.inputField.classList.remove('datepicker-input');
    }
    delete this.element.datepicker;
    return this;
  }

  /**
   * Get the selected date(s)
   *
   * The method returns a Date object of selected date by default, and returns
   * an array of selected dates in multidate mode. If format string is passed,
   * it returns date string(s) formatted in given format.
   *
   * @param  {String} [format] - Format string to stringify the date(s)
   * @return {Date|String|Date[]|String[]} - selected date(s), or if none is
   * selected, empty array in multidate mode and untitled in sigledate mode
   */
  getDate(format = undefined) {
    const callback = format
      ? date => (0,date_format/* formatDate */.p6)(date, format, this.config.locale)
      : date => new Date(date);

    if (this.config.multidate) {
      return this.dates.map(callback);
    }
    if (this.dates.length > 0) {
      return callback(this.dates[0]);
    }
  }

  /**
   * Set selected date(s)
   *
   * In multidate mode, you can pass multiple dates as a series of arguments
   * or an array. (Since each date is parsed individually, the type of the
   * dates doesn't have to be the same.)
   * The given dates are used to toggle the select status of each date. The
   * number of selected dates is kept from exceeding the length set to
   * maxNumberOfDates.
   *
   * With clear: true option, the method can be used to clear the selection
   * and to replace the selection instead of toggling in multidate mode.
   * If the option is passed with no date arguments or an empty dates array,
   * it works as "clear" (clear the selection then set nothing), and if the
   * option is passed with new dates to select, it works as "replace" (clear
   * the selection then set the given dates)
   *
   * When render: false option is used, the method omits re-rendering the
   * picker element. In this case, you need to call refresh() method later in
   * order for the picker element to reflect the changes. The input field is
   * refreshed always regardless of this option.
   *
   * When invalid (unparsable, repeated, disabled or out-of-range) dates are
   * passed, the method ignores them and applies only valid ones. In the case
   * that all the given dates are invalid, which is distinguished from passing
   * no dates, the method considers it as an error and leaves the selection
   * untouched.
   *
   * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date
   * objects, time values or mix of those for new selection
   * @param {Object} [options] - function options
   * - clear: {boolean} - Whether to clear the existing selection
   *     defualt: false
   * - render: {boolean} - Whether to re-render the picker element
   *     default: true
   * - autohide: {boolean} - Whether to hide the picker element after re-render
   *     Ignored when used with render: false
   *     default: config.autohide
   */
  setDate(...args) {
    const dates = [...args];
    const opts = {};
    const lastArg = (0,utils/* lastItemOf */.Jm)(args);
    if (
      typeof lastArg === 'object'
      && !Array.isArray(lastArg)
      && !(lastArg instanceof Date)
      && lastArg
    ) {
      Object.assign(opts, dates.pop());
    }

    const inputDates = Array.isArray(dates[0]) ? dates[0] : dates;
    setDate(this, inputDates, opts);
  }

  /**
   * Update the selected date(s) with input field's value
   * Not available on inline picker
   *
   * The input field will be refreshed with properly formatted date string.
   *
   * @param  {Object} [options] - function options
   * - autohide: {boolean} - whether to hide the picker element after refresh
   *     default: false
   */
  update(options = undefined) {
    if (this.inline) {
      return;
    }

    const opts = {clear: true, autohide: !!(options && options.autohide)};
    const inputDates = (0,utils/* stringToArray */.W7)(this.inputField.value, this.config.dateDelimiter);
    setDate(this, inputDates, opts);
  }

  /**
   * Refresh the picker element and the associated input field
   * @param {String} [target] - target item when refreshing one item only
   * 'picker' or 'input'
   * @param {Boolean} [forceRender] - whether to re-render the picker element
   * regardless of its state instead of optimized refresh
   */
  refresh(target = undefined, forceRender = false) {
    if (target && typeof target !== 'string') {
      forceRender = target;
      target = undefined;
    }

    let mode;
    if (target === 'picker') {
      mode = 2;
    } else if (target === 'input') {
      mode = 1;
    } else {
      mode = 3;
    }
    refreshUI(this, mode, !forceRender);
  }

  /**
   * Enter edit mode
   * Not available on inline picker or when the picker element is hidden
   */
  enterEditMode() {
    if (this.inline || !this.picker.active || this.editMode) {
      return;
    }
    this.editMode = true;
    this.inputField.classList.add('in-edit', 'border-blue-700');
  }

  /**
   * Exit from edit mode
   * Not available on inline picker
   * @param  {Object} [options] - function options
   * - update: {boolean} - whether to call update() after exiting
   *     If false, input field is revert to the existing selection
   *     default: false
   */
  exitEditMode(options = undefined) {
    if (this.inline || !this.editMode) {
      return;
    }
    const opts = Object.assign({update: false}, options);
    delete this.editMode;
    this.inputField.classList.remove('in-edit', 'border-blue-700');
    if (opts.update) {
      this.update(opts);
    }
  }
}


/***/ }),

/***/ 963:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_84376__) {

/* harmony export */ __nested_webpack_require_84376__.d(__nested_webpack_exports__, {
/* harmony export */   "CL": function() { return /* binding */ reFormatTokens; },
/* harmony export */   "p6": function() { return /* binding */ formatDate; },
/* harmony export */   "sG": function() { return /* binding */ parseDate; }
/* harmony export */ });
/* unused harmony export reNonDateParts */
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_84376__(560);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_84376__(105);



// pattern for format parts
const reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
// pattern for non date parts
const reNonDateParts = /[\s!-/:-@[-`{-~年月日]+/;
// cache for persed formats
let knownFormats = {};
// parse funtions for date parts
const parseFns = {
  y(date, year) {
    return new Date(date).setFullYear(parseInt(year, 10));
  },
  m(date, month, locale) {
    const newDate = new Date(date);
    let monthIndex = parseInt(month, 10) - 1;

    if (isNaN(monthIndex)) {
      if (!month) {
        return NaN;
      }

      const monthName = month.toLowerCase();
      const compareNames = name => name.toLowerCase().startsWith(monthName);
      // compare with both short and full names because some locales have periods
      // in the short names (not equal to the first X letters of the full names)
      monthIndex = locale.monthsShort.findIndex(compareNames);
      if (monthIndex < 0) {
        monthIndex = locale.months.findIndex(compareNames);
      }
      if (monthIndex < 0) {
        return NaN;
      }
    }

    newDate.setMonth(monthIndex);
    return newDate.getMonth() !== normalizeMonth(monthIndex)
      ? newDate.setDate(0)
      : newDate.getTime();
  },
  d(date, day) {
    return new Date(date).setDate(parseInt(day, 10));
  },
};
// format functions for date parts
const formatFns = {
  d(date) {
    return date.getDate();
  },
  dd(date) {
    return padZero(date.getDate(), 2);
  },
  D(date, locale) {
    return locale.daysShort[date.getDay()];
  },
  DD(date, locale) {
    return locale.days[date.getDay()];
  },
  m(date) {
    return date.getMonth() + 1;
  },
  mm(date) {
    return padZero(date.getMonth() + 1, 2);
  },
  M(date, locale) {
    return locale.monthsShort[date.getMonth()];
  },
  MM(date, locale) {
    return locale.months[date.getMonth()];
  },
  y(date) {
    return date.getFullYear();
  },
  yy(date) {
    return padZero(date.getFullYear(), 2).slice(-2);
  },
  yyyy(date) {
    return padZero(date.getFullYear(), 4);
  },
};

// get month index in normal range (0 - 11) from any number
function normalizeMonth(monthIndex) {
  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);
}

function padZero(num, length) {
  return num.toString().padStart(length, '0');
}

function parseFormatString(format) {
  if (typeof format !== 'string') {
    throw new Error("Invalid date format.");
  }
  if (format in knownFormats) {
    return knownFormats[format];
  }

  // sprit the format string into parts and seprators
  const separators = format.split(reFormatTokens);
  const parts = format.match(new RegExp(reFormatTokens, 'g'));
  if (separators.length === 0 || !parts) {
    throw new Error("Invalid date format.");
  }

  // collect format functions used in the format
  const partFormatters = parts.map(token => formatFns[token]);

  // collect parse function keys used in the format
  // iterate over parseFns' keys in order to keep the order of the keys.
  const partParserKeys = Object.keys(parseFns).reduce((keys, key) => {
    const token = parts.find(part => part[0] !== 'D' && part[0].toLowerCase() === key);
    if (token) {
      keys.push(key);
    }
    return keys;
  }, []);

  return knownFormats[format] = {
    parser(dateStr, locale) {
      const dateParts = dateStr.split(reNonDateParts).reduce((dtParts, part, index) => {
        if (part.length > 0 && parts[index]) {
          const token = parts[index][0];
          if (token === 'M') {
            dtParts.m = part;
          } else if (token !== 'D') {
            dtParts[token] = part;
          }
        }
        return dtParts;
      }, {});

      // iterate over partParserkeys so that the parsing is made in the oder
      // of year, month and day to prevent the day parser from correcting last
      // day of month wrongly
      return partParserKeys.reduce((origDate, key) => {
        const newDate = parseFns[key](origDate, dateParts[key], locale);
        // ingnore the part failed to parse
        return isNaN(newDate) ? origDate : newDate;
      }, (0,_date_js__WEBPACK_IMPORTED_MODULE_0__/* .today */ .Lg)());
    },
    formatter(date, locale) {
      let dateStr = partFormatters.reduce((str, fn, index) => {
        return str += `${separators[index]}${fn(date, locale)}`;
      }, '');
      // separators' length is always parts' length + 1,
      return dateStr += (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__/* .lastItemOf */ .Jm)(separators);
    },
  };
}

function parseDate(dateStr, format, locale) {
  if (dateStr instanceof Date || typeof dateStr === 'number') {
    const date = (0,_date_js__WEBPACK_IMPORTED_MODULE_0__/* .stripTime */ .xR)(dateStr);
    return isNaN(date) ? undefined : date;
  }
  if (!dateStr) {
    return undefined;
  }
  if (dateStr === 'today') {
    return (0,_date_js__WEBPACK_IMPORTED_MODULE_0__/* .today */ .Lg)();
  }

  if (format && format.toValue) {
    const date = format.toValue(dateStr, format, locale);
    return isNaN(date) ? undefined : (0,_date_js__WEBPACK_IMPORTED_MODULE_0__/* .stripTime */ .xR)(date);
  }

  return parseFormatString(format).parser(dateStr, locale);
}

function formatDate(date, format, locale) {
  if (isNaN(date) || (!date && date !== 0)) {
    return '';
  }

  const dateObj = typeof date === 'number' ? new Date(date) : date;

  if (format.toDisplay) {
    return format.toDisplay(dateObj, format, locale);
  }

  return parseFormatString(format).formatter(dateObj, locale);
}


/***/ }),

/***/ 560:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_90488__) {

/* harmony export */ __nested_webpack_require_90488__.d(__nested_webpack_exports__, {
/* harmony export */   "Bc": function() { return /* binding */ addYears; },
/* harmony export */   "E4": function() { return /* binding */ addDays; },
/* harmony export */   "Lg": function() { return /* binding */ today; },
/* harmony export */   "Qk": function() { return /* binding */ getWeek; },
/* harmony export */   "ak": function() { return /* binding */ startOfYearPeriod; },
/* harmony export */   "by": function() { return /* binding */ dateValue; },
/* harmony export */   "fr": function() { return /* binding */ dayOfTheWeekOf; },
/* harmony export */   "jh": function() { return /* binding */ addWeeks; },
/* harmony export */   "xR": function() { return /* binding */ stripTime; },
/* harmony export */   "zI": function() { return /* binding */ addMonths; }
/* harmony export */ });
function stripTime(timeValue) {
  return new Date(timeValue).setHours(0, 0, 0, 0);
}

function today() {
  return new Date().setHours(0, 0, 0, 0);
}

// Get the time value of the start of given date or year, month and day
function dateValue(...args) {
  switch (args.length) {
    case 0:
      return today();
    case 1:
      return stripTime(args[0]);
  }

  // use setFullYear() to keep 2-digit year from being mapped to 1900-1999
  const newDate = new Date(0);
  newDate.setFullYear(...args);
  return newDate.setHours(0, 0, 0, 0);
}

function addDays(date, amount) {
  const newDate = new Date(date);
  return newDate.setDate(newDate.getDate() + amount);
}

function addWeeks(date, amount) {
  return addDays(date, amount * 7);
}

function addMonths(date, amount) {
  // If the day of the date is not in the new month, the last day of the new
  // month will be returned. e.g. Jan 31 + 1 month → Feb 28 (not Mar 03)
  const newDate = new Date(date);
  const monthsToSet = newDate.getMonth() + amount;
  let expectedMonth = monthsToSet % 12;
  if (expectedMonth < 0) {
    expectedMonth += 12;
  }

  const time = newDate.setMonth(monthsToSet);
  return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;
}

function addYears(date, amount) {
  // If the date is Feb 29 and the new year is not a leap year, Feb 28 of the
  // new year will be returned.
  const newDate = new Date(date);
  const expectedMonth = newDate.getMonth();
  const time = newDate.setFullYear(newDate.getFullYear() + amount);
  return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;
}

// Calculate the distance bettwen 2 days of the week
function dayDiff(day, from) {
  return (day - from + 7) % 7;
}

// Get the date of the specified day of the week of given base date
function dayOfTheWeekOf(baseDate, dayOfWeek, weekStart = 0) {
  const baseDay = new Date(baseDate).getDay();
  return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));
}

// Get the ISO week of a date
function getWeek(date) {
  // start of ISO week is Monday
  const thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);
  // 1st week == the week where the 4th of January is in
  const firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);
  return Math.round((thuOfTheWeek - firstThu) / 604800000) + 1;
}

// Get the start year of the period of years that includes given date
// years: length of the year period
function startOfYearPeriod(date, years) {
  /* @see https://en.wikipedia.org/wiki/Year_zero#ISO_8601 */
  const year = new Date(date).getFullYear();
  return Math.floor(year / years) * years;
}


/***/ }),

/***/ 698:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_94098__) {

/* harmony export */ __nested_webpack_require_94098__.d(__nested_webpack_exports__, {
/* harmony export */   "He": function() { return /* binding */ findElementInEventPath; },
/* harmony export */   "cF": function() { return /* binding */ registerListeners; },
/* harmony export */   "uV": function() { return /* binding */ unregisterListeners; }
/* harmony export */ });
const listenerRegistry = new WeakMap();
const {addEventListener, removeEventListener} = EventTarget.prototype;

// Register event listeners to a key object
// listeners: array of listener definitions;
//   - each definition must be a flat array of event target and the arguments
//     used to call addEventListener() on the target
function registerListeners(keyObj, listeners) {
  let registered = listenerRegistry.get(keyObj);
  if (!registered) {
    registered = [];
    listenerRegistry.set(keyObj, registered);
  }
  listeners.forEach((listener) => {
    addEventListener.call(...listener);
    registered.push(listener);
  });
}

function unregisterListeners(keyObj) {
  let listeners = listenerRegistry.get(keyObj);
  if (!listeners) {
    return;
  }
  listeners.forEach((listener) => {
    removeEventListener.call(...listener);
  });
  listenerRegistry.delete(keyObj);
}

// Event.composedPath() polyfill for Edge
// based on https://gist.github.com/kleinfreund/e9787d73776c0e3750dcfcdc89f100ec
if (!Event.prototype.composedPath) {
  const getComposedPath = (node, path = []) => {
    path.push(node);

    let parent;
    if (node.parentNode) {
      parent = node.parentNode;
    } else if (node.host) { // ShadowRoot
      parent = node.host;
    } else if (node.defaultView) {  // Document
      parent = node.defaultView;
    }
    return parent ? getComposedPath(parent, path) : path;
  };

  Event.prototype.composedPath = function () {
    return getComposedPath(this.target);
  };
}

function findFromPath(path, criteria, currentTarget, index = 0) {
  const el = path[index];
  if (criteria(el)) {
    return el;
  } else if (el === currentTarget || !el.parentElement) {
    // stop when reaching currentTarget or <html>
    return;
  }
  return findFromPath(path, criteria, currentTarget, index + 1);
}

// Search for the actual target of a delegated event
function findElementInEventPath(ev, selector) {
  const criteria = typeof selector === 'function' ? selector : el => el.matches(selector);
  return findFromPath(ev.composedPath(), criteria, ev.currentTarget);
}


/***/ }),

/***/ 105:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_96649__) {

/* harmony export */ __nested_webpack_require_96649__.d(__nested_webpack_exports__, {
/* harmony export */   "$C": function() { return /* binding */ pushUnique; },
/* harmony export */   "Jm": function() { return /* binding */ lastItemOf; },
/* harmony export */   "W7": function() { return /* binding */ stringToArray; },
/* harmony export */   "em": function() { return /* binding */ createTagRepeat; },
/* harmony export */   "jG": function() { return /* binding */ limitToRange; },
/* harmony export */   "l$": function() { return /* binding */ hasProperty; },
/* harmony export */   "mh": function() { return /* binding */ isInRange; },
/* harmony export */   "zh": function() { return /* binding */ optimizeTemplateHTML; }
/* harmony export */ });
function hasProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function lastItemOf(arr) {
  return arr[arr.length - 1];
}

// push only the items not included in the array
function pushUnique(arr, ...items) {
  items.forEach((item) => {
    if (arr.includes(item)) {
      return;
    }
    arr.push(item);
  });
  return arr;
}

function stringToArray(str, separator) {
  // convert empty string to an empty array
  return str ? str.split(separator) : [];
}

function isInRange(testVal, min, max) {
  const minOK = min === undefined || testVal >= min;
  const maxOK = max === undefined || testVal <= max;
  return minOK && maxOK;
}

function limitToRange(val, min, max) {
  if (val < min) {
    return min;
  }
  if (val > max) {
    return max;
  }
  return val;
}

function createTagRepeat(tagName, repeat, attributes = {}, index = 0, html = '') {
  const openTagSrc = Object.keys(attributes).reduce((src, attr) => {
    let val = attributes[attr];
    if (typeof val === 'function') {
      val = val(index);
    }
    return `${src} ${attr}="${val}"`;
  }, tagName);
  html += `<${openTagSrc}></${tagName}>`;

  const next = index + 1;
  return next < repeat
    ? createTagRepeat(tagName, repeat, attributes, next, html)
    : html;
}

// Remove the spacing surrounding tags for HTML parser not to create text nodes
// before/after elements
function optimizeTemplateHTML(html) {
  return html.replace(/>\s+/g, '>').replace(/\s+</, '<');
}


/***/ }),

/***/ 947:
/***/ (function(__unused_webpack_module, exports) {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
var Events = /** @class */ (function () {
    function Events(eventType, eventFunctions) {
        if (eventFunctions === void 0) { eventFunctions = []; }
        this._eventType = eventType;
        this._eventFunctions = eventFunctions;
    }
    Events.prototype.init = function () {
        var _this = this;
        this._eventFunctions.forEach(function (eventFunction) {
            if (typeof window !== 'undefined') {
                window.addEventListener(_this._eventType, eventFunction);
            }
        });
    };
    return Events;
}());
exports["default"] = Events;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_99858__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_99858__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_99858__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_99858__.o(definition, key) && !__nested_webpack_require_99858__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_99858__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_99858__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
__nested_webpack_require_99858__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_99858__.d(__nested_webpack_exports__, {
/* harmony export */   "initDatepickers": function() { return /* binding */ initDatepickers; }
/* harmony export */ });
/* harmony import */ var flowbite_datepicker_Datepicker__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_99858__(770);
/* harmony import */ var flowbite_datepicker_DateRangePicker__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_99858__(482);
/* harmony import */ var _dom_events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_99858__(947);



var getDatepickerOptions = function getDatepickerOptions(datepickerEl) {
  var buttons = datepickerEl.hasAttribute('datepicker-buttons');
  var autohide = datepickerEl.hasAttribute('datepicker-autohide');
  var format = datepickerEl.hasAttribute('datepicker-format');
  var orientation = datepickerEl.hasAttribute('datepicker-orientation');
  var title = datepickerEl.hasAttribute('datepicker-title');
  var options = {};
  if (buttons) {
    options.todayBtn = true;
    options.clearBtn = true;
  }
  if (autohide) {
    options.autohide = true;
  }
  if (format) {
    options.format = datepickerEl.getAttribute('datepicker-format');
  }
  if (orientation) {
    options.orientation = datepickerEl.getAttribute('datepicker-orientation');
  }
  if (title) {
    options.title = datepickerEl.getAttribute('datepicker-title');
  }
  return options;
};
function initDatepickers() {
  document.querySelectorAll('[datepicker]').forEach(function (datepickerEl) {
    new flowbite_datepicker_Datepicker__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(datepickerEl, getDatepickerOptions(datepickerEl));
  });
  document.querySelectorAll('[inline-datepicker]').forEach(function (datepickerEl) {
    new flowbite_datepicker_Datepicker__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(datepickerEl, getDatepickerOptions(datepickerEl));
  });
  document.querySelectorAll('[date-rangepicker]').forEach(function (datepickerEl) {
    new flowbite_datepicker_DateRangePicker__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(datepickerEl, getDatepickerOptions(datepickerEl));
  });
}
var events = new _dom_events__WEBPACK_IMPORTED_MODULE_2__["default"]('DOMContentLoaded', [initDatepickers]);
events.init();
}();
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=datepicker.js.map

/***/ }),

/***/ "./node_modules/tw-elements/dist/js/tw-elements.es.min.js":
/*!****************************************************************!*\
  !*** ./node_modules/tw-elements/dist/js/tw-elements.es.min.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Alert": () => (/* binding */ Hl),
/* harmony export */   "Animate": () => (/* binding */ Jl),
/* harmony export */   "Button": () => (/* binding */ dl),
/* harmony export */   "Carousel": () => (/* binding */ Ut),
/* harmony export */   "Chart": () => (/* binding */ vc),
/* harmony export */   "Chip": () => (/* binding */ hi),
/* harmony export */   "ChipsInput": () => (/* binding */ K0),
/* harmony export */   "Collapse": () => (/* binding */ qt),
/* harmony export */   "Datatable": () => (/* binding */ wc),
/* harmony export */   "Datepicker": () => (/* binding */ F0),
/* harmony export */   "Dropdown": () => (/* binding */ It),
/* harmony export */   "Input": () => (/* binding */ W),
/* harmony export */   "Lightbox": () => (/* binding */ Ls),
/* harmony export */   "Modal": () => (/* binding */ Fl),
/* harmony export */   "Offcanvas": () => (/* binding */ no),
/* harmony export */   "PerfectScrollbar": () => (/* binding */ yc),
/* harmony export */   "Popconfirm": () => (/* binding */ kc),
/* harmony export */   "Popover": () => (/* binding */ Yl),
/* harmony export */   "Rating": () => (/* binding */ z0),
/* harmony export */   "Ripple": () => (/* binding */ Ue),
/* harmony export */   "ScrollSpy": () => (/* binding */ zl),
/* harmony export */   "Select": () => (/* binding */ $o),
/* harmony export */   "Sidenav": () => (/* binding */ pi),
/* harmony export */   "Stepper": () => (/* binding */ j0),
/* harmony export */   "Tab": () => (/* binding */ Ul),
/* harmony export */   "Timepicker": () => (/* binding */ Y0),
/* harmony export */   "Toast": () => (/* binding */ Xl),
/* harmony export */   "Tooltip": () => (/* binding */ Qe),
/* harmony export */   "initTE": () => (/* binding */ U0)
/* harmony export */ });
/*!
* Tailwind Elements 1.0.0-beta3
* 
* Tailwind Elements is an open-source UI kit of advanced components for TailwindCSS.
* Copyright © 2023 MDBootstrap.com
* 
* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
* 
*/
var Nc = Object.defineProperty;
var Rc = (s, t, e) => t in s ? Nc(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var At = (s, t, e) => (Rc(s, typeof t != "symbol" ? t + "" : t, e), e);
const Zs = (() => {
  const s = {};
  let t = 1;
  return {
    set(e, i, n) {
      typeof e[i] > "u" && (e[i] = {
        key: i,
        id: t
      }, t++), s[e[i].id] = n;
    },
    get(e, i) {
      if (!e || typeof e[i] > "u")
        return null;
      const n = e[i];
      return n.key === i ? s[n.id] : null;
    },
    delete(e, i) {
      if (typeof e[i] > "u")
        return;
      const n = e[i];
      n.key === i && (delete s[n.id], delete e[i]);
    }
  };
})(), I = {
  setData(s, t, e) {
    Zs.set(s, t, e);
  },
  getData(s, t) {
    return Zs.get(s, t);
  },
  removeData(s, t) {
    Zs.delete(s, t);
  }
}, Pc = 1e6, Bc = 1e3, Qn = "transitionend", Hc = (s) => s == null ? `${s}` : {}.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase(), bt = (s) => {
  do
    s += Math.floor(Math.random() * Pc);
  while (document.getElementById(s));
  return s;
}, Qa = (s) => {
  let t = s.getAttribute("data-te-target");
  if (!t || t === "#") {
    let e = s.getAttribute("href");
    if (!e || !e.includes("#") && !e.startsWith("."))
      return null;
    e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t = e && e !== "#" ? e.trim() : null;
  }
  return t;
}, fo = (s) => {
  const t = Qa(s);
  return t && document.querySelector(t) ? t : null;
}, Qt = (s) => {
  const t = Qa(s);
  return t ? document.querySelector(t) : null;
}, Wc = (s) => {
  if (!s)
    return 0;
  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(s);
  const i = Number.parseFloat(t), n = Number.parseFloat(e);
  return !i && !n ? 0 : (t = t.split(",")[0], e = e.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * Bc);
}, Ja = (s) => {
  s.dispatchEvent(new Event(Qn));
}, Ve = (s) => !s || typeof s != "object" ? !1 : (typeof s.jquery < "u" && (s = s[0]), typeof s.nodeType < "u"), Jt = (s) => Ve(s) ? s.jquery ? s[0] : s : typeof s == "string" && s.length > 0 ? document.querySelector(s) : null, L = (s, t, e) => {
  Object.keys(e).forEach((i) => {
    const n = e[i], o = t[i], r = o && Ve(o) ? "element" : Hc(o);
    if (!new RegExp(n).test(r))
      throw new Error(
        `${s.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${n}".`
      );
  });
}, Lt = (s) => {
  if (!s || s.getClientRects().length === 0)
    return !1;
  if (s.style && s.parentNode && s.parentNode.style) {
    const t = getComputedStyle(s), e = getComputedStyle(s.parentNode);
    return getComputedStyle(s).getPropertyValue("visibility") === "visible" || t.display !== "none" && e.display !== "none" && t.visibility !== "hidden";
  }
  return !1;
}, me = (s) => !s || s.nodeType !== Node.ELEMENT_NODE || s.classList.contains("disabled") ? !0 : typeof s.disabled < "u" ? s.disabled : s.hasAttribute("disabled") && s.getAttribute("disabled") !== "false", tl = (s) => {
  if (!document.documentElement.attachShadow)
    return null;
  if (typeof s.getRootNode == "function") {
    const t = s.getRootNode();
    return t instanceof ShadowRoot ? t : null;
  }
  return s instanceof ShadowRoot ? s : s.parentNode ? tl(s.parentNode) : null;
}, Ms = () => function() {
}, Ge = (s) => {
  s.offsetHeight;
}, el = () => {
  const { jQuery: s } = window;
  return s && !document.body.hasAttribute("data-te-no-jquery") ? s : null;
}, Qs = [], il = (s) => {
  document.readyState === "loading" ? (Qs.length || document.addEventListener("DOMContentLoaded", () => {
    Qs.forEach((t) => t());
  }), Qs.push(s)) : s();
}, F = () => document.documentElement.dir === "rtl", Vc = (s) => Array.from(s), D = (s) => document.createElement(s), fe = (s) => {
  typeof s == "function" && s();
}, sl = (s, t, e = !0) => {
  if (!e) {
    fe(s);
    return;
  }
  const i = 5, n = Wc(t) + i;
  let o = !1;
  const r = ({ target: a }) => {
    a === t && (o = !0, t.removeEventListener(Qn, r), fe(s));
  };
  t.addEventListener(Qn, r), setTimeout(() => {
    o || Ja(t);
  }, n);
}, nl = (s, t, e, i) => {
  let n = s.indexOf(t);
  if (n === -1)
    return s[!e && i ? s.length - 1 : 0];
  const o = s.length;
  return n += e ? 1 : -1, i && (n = (n + o) % o), s[Math.max(0, Math.min(n, o - 1))];
}, Fc = /[^.]*(?=\..*)\.|.*/, Yc = /\..*/, jc = /::\d+$/, Js = {};
let Yo = 1;
const Kc = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, zc = /^(mouseenter|mouseleave)/i, ol = /* @__PURE__ */ new Set([
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
]);
function rl(s, t) {
  return t && `${t}::${Yo++}` || s.uidEvent || Yo++;
}
function al(s) {
  const t = rl(s);
  return s.uidEvent = t, Js[t] = Js[t] || {}, Js[t];
}
function Uc(s, t) {
  return function e(i) {
    return i.delegateTarget = s, e.oneOff && h.off(s, i.type, t), t.apply(s, [i]);
  };
}
function Xc(s, t, e) {
  return function i(n) {
    const o = s.querySelectorAll(t);
    for (let { target: r } = n; r && r !== this; r = r.parentNode)
      for (let a = o.length; a--; "")
        if (o[a] === r)
          return n.delegateTarget = r, i.oneOff && h.off(s, n.type, e), e.apply(r, [n]);
    return null;
  };
}
function ll(s, t, e = null) {
  const i = Object.keys(s);
  for (let n = 0, o = i.length; n < o; n++) {
    const r = s[i[n]];
    if (r.originalHandler === t && r.delegationSelector === e)
      return r;
  }
  return null;
}
function cl(s, t, e) {
  const i = typeof t == "string", n = i ? e : t;
  let o = hl(s);
  return ol.has(o) || (o = s), [i, n, o];
}
function jo(s, t, e, i, n) {
  if (typeof t != "string" || !s)
    return;
  if (e || (e = i, i = null), zc.test(t)) {
    const m = (g) => function(v) {
      if (!v.relatedTarget || v.relatedTarget !== v.delegateTarget && !v.delegateTarget.contains(v.relatedTarget))
        return g.call(this, v);
    };
    i ? i = m(i) : e = m(e);
  }
  const [o, r, a] = cl(
    t,
    e,
    i
  ), l = al(s), p = l[a] || (l[a] = {}), u = ll(
    p,
    r,
    o ? e : null
  );
  if (u) {
    u.oneOff = u.oneOff && n;
    return;
  }
  const f = rl(
    r,
    t.replace(Fc, "")
  ), _ = o ? Xc(s, e, i) : Uc(s, e);
  _.delegationSelector = o ? e : null, _.originalHandler = r, _.oneOff = n, _.uidEvent = f, p[f] = _, s.addEventListener(a, _, o);
}
function Jn(s, t, e, i, n) {
  const o = ll(t[e], i, n);
  o && (s.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);
}
function Gc(s, t, e, i) {
  const n = t[e] || {};
  Object.keys(n).forEach((o) => {
    if (o.includes(i)) {
      const r = n[o];
      Jn(
        s,
        t,
        e,
        r.originalHandler,
        r.delegationSelector
      );
    }
  });
}
function hl(s) {
  return s = s.replace(Yc, ""), Kc[s] || s;
}
const h = {
  on(s, t, e, i) {
    jo(s, t, e, i, !1);
  },
  one(s, t, e, i) {
    jo(s, t, e, i, !0);
  },
  off(s, t, e, i) {
    if (typeof t != "string" || !s)
      return;
    const [n, o, r] = cl(
      t,
      e,
      i
    ), a = r !== t, l = al(s), p = t.startsWith(".");
    if (typeof o < "u") {
      if (!l || !l[r])
        return;
      Jn(
        s,
        l,
        r,
        o,
        n ? e : null
      );
      return;
    }
    p && Object.keys(l).forEach((f) => {
      Gc(
        s,
        l,
        f,
        t.slice(1)
      );
    });
    const u = l[r] || {};
    Object.keys(u).forEach((f) => {
      const _ = f.replace(jc, "");
      if (!a || t.includes(_)) {
        const m = u[f];
        Jn(
          s,
          l,
          r,
          m.originalHandler,
          m.delegationSelector
        );
      }
    });
  },
  trigger(s, t, e) {
    if (typeof t != "string" || !s)
      return null;
    const i = el(), n = hl(t), o = t !== n, r = ol.has(n);
    let a, l = !0, p = !0, u = !1, f = null;
    return o && i && (a = i.Event(t, e), i(s).trigger(a), l = !a.isPropagationStopped(), p = !a.isImmediatePropagationStopped(), u = a.isDefaultPrevented()), r ? (f = document.createEvent("HTMLEvents"), f.initEvent(n, l, !0)) : f = new CustomEvent(t, {
      bubbles: l,
      cancelable: !0
    }), typeof e < "u" && Object.keys(e).forEach((_) => {
      Object.defineProperty(f, _, {
        get() {
          return e[_];
        }
      });
    }), u && f.preventDefault(), p && s.dispatchEvent(f), f.defaultPrevented && typeof a < "u" && a.preventDefault(), f;
  }
}, oe = {
  on(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      h.on(s, n[o], e, i);
  },
  off(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      h.off(s, n[o], e, i);
  }
}, qc = "5.1.3";
class Et {
  constructor(t) {
    t = Jt(t), t && (this._element = t, I.setData(this._element, this.constructor.DATA_KEY, this));
  }
  dispose() {
    I.removeData(this._element, this.constructor.DATA_KEY), h.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {
      this[t] = null;
    });
  }
  _queueCallback(t, e, i = !0) {
    sl(t, e, i);
  }
  /** Static */
  static getInstance(t) {
    return I.getData(Jt(t), this.DATA_KEY);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static get VERSION() {
    return qc;
  }
  static get NAME() {
    throw new Error(
      'You have to implement the static method "NAME", for each component!'
    );
  }
  static get DATA_KEY() {
    return `te.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
}
const Zc = "button", Qc = "active";
class dl extends Et {
  // Getters
  static get NAME() {
    return Zc;
  }
  // Public
  toggle() {
    this._element.setAttribute(
      "aria-pressed",
      this._element.classList.toggle(Qc)
    );
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = dl.getOrCreateInstance(this);
      t === "toggle" && e[t]();
    });
  }
}
var Q = "top", ht = "bottom", dt = "right", J = "left", Ii = "auto", qe = [Q, ht, dt, J], ve = "start", Fe = "end", ul = "clippingParents", mo = "viewport", Ie = "popper", pl = "reference", to = /* @__PURE__ */ qe.reduce(function(s, t) {
  return s.concat([t + "-" + ve, t + "-" + Fe]);
}, []), go = /* @__PURE__ */ [].concat(qe, [Ii]).reduce(function(s, t) {
  return s.concat([t, t + "-" + ve, t + "-" + Fe]);
}, []), _l = "beforeRead", fl = "read", ml = "afterRead", gl = "beforeMain", bl = "main", vl = "afterMain", Tl = "beforeWrite", El = "write", Cl = "afterWrite", Ns = [_l, fl, ml, gl, bl, vl, Tl, El, Cl];
function Nt(s) {
  return s ? (s.nodeName || "").toLowerCase() : null;
}
function ut(s) {
  if (s == null)
    return window;
  if (s.toString() !== "[object Window]") {
    var t = s.ownerDocument;
    return t && t.defaultView || window;
  }
  return s;
}
function Te(s) {
  var t = ut(s).Element;
  return s instanceof t || s instanceof Element;
}
function ct(s) {
  var t = ut(s).HTMLElement;
  return s instanceof t || s instanceof HTMLElement;
}
function bo(s) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = ut(s).ShadowRoot;
  return s instanceof t || s instanceof ShadowRoot;
}
function Jc(s) {
  var t = s.state;
  Object.keys(t.elements).forEach(function(e) {
    var i = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];
    !ct(o) || !Nt(o) || (Object.assign(o.style, i), Object.keys(n).forEach(function(r) {
      var a = n[r];
      a === !1 ? o.removeAttribute(r) : o.setAttribute(r, a === !0 ? "" : a);
    }));
  });
}
function th(s) {
  var t = s.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(i) {
      var n = t.elements[i], o = t.attributes[i] || {}, r = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), a = r.reduce(function(l, p) {
        return l[p] = "", l;
      }, {});
      !ct(n) || !Nt(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {
        n.removeAttribute(l);
      }));
    });
  };
}
const vo = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: Jc,
  effect: th,
  requires: ["computeStyles"]
};
function vt(s) {
  return s.split("-")[0];
}
var ge = Math.max, Rs = Math.min, Ye = Math.round;
function eo() {
  var s = navigator.userAgentData;
  return s != null && s.brands && Array.isArray(s.brands) ? s.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function Al() {
  return !/^((?!chrome|android).)*safari/i.test(eo());
}
function je(s, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var i = s.getBoundingClientRect(), n = 1, o = 1;
  t && ct(s) && (n = s.offsetWidth > 0 && Ye(i.width) / s.offsetWidth || 1, o = s.offsetHeight > 0 && Ye(i.height) / s.offsetHeight || 1);
  var r = Te(s) ? ut(s) : window, a = r.visualViewport, l = !Al() && e, p = (i.left + (l && a ? a.offsetLeft : 0)) / n, u = (i.top + (l && a ? a.offsetTop : 0)) / o, f = i.width / n, _ = i.height / o;
  return {
    width: f,
    height: _,
    top: u,
    right: p + f,
    bottom: u + _,
    left: p,
    x: p,
    y: u
  };
}
function To(s) {
  var t = je(s), e = s.offsetWidth, i = s.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
    x: s.offsetLeft,
    y: s.offsetTop,
    width: e,
    height: i
  };
}
function yl(s, t) {
  var e = t.getRootNode && t.getRootNode();
  if (s.contains(t))
    return !0;
  if (e && bo(e)) {
    var i = t;
    do {
      if (i && s.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function Tt(s) {
  return ut(s).getComputedStyle(s);
}
function eh(s) {
  return ["table", "td", "th"].indexOf(Nt(s)) >= 0;
}
function te(s) {
  return ((Te(s) ? s.ownerDocument : (
    // $FlowFixMe[prop-missing]
    s.document
  )) || window.document).documentElement;
}
function Hs(s) {
  return Nt(s) === "html" ? s : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    s.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    s.parentNode || // DOM Element detected
    (bo(s) ? s.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    te(s)
  );
}
function Ko(s) {
  return !ct(s) || // https://github.com/popperjs/popper-core/issues/837
  Tt(s).position === "fixed" ? null : s.offsetParent;
}
function ih(s) {
  var t = /firefox/i.test(eo()), e = /Trident/i.test(eo());
  if (e && ct(s)) {
    var i = Tt(s);
    if (i.position === "fixed")
      return null;
  }
  var n = Hs(s);
  for (bo(n) && (n = n.host); ct(n) && ["html", "body"].indexOf(Nt(n)) < 0; ) {
    var o = Tt(n);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function Di(s) {
  for (var t = ut(s), e = Ko(s); e && eh(e) && Tt(e).position === "static"; )
    e = Ko(e);
  return e && (Nt(e) === "html" || Nt(e) === "body" && Tt(e).position === "static") ? t : e || ih(s) || t;
}
function Eo(s) {
  return ["top", "bottom"].indexOf(s) >= 0 ? "x" : "y";
}
function Ei(s, t, e) {
  return ge(s, Rs(t, e));
}
function sh(s, t, e) {
  var i = Ei(s, t, e);
  return i > e ? e : i;
}
function wl() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function xl(s) {
  return Object.assign({}, wl(), s);
}
function kl(s, t) {
  return t.reduce(function(e, i) {
    return e[i] = s, e;
  }, {});
}
var nh = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, xl(typeof t != "number" ? t : kl(t, qe));
};
function oh(s) {
  var t, e = s.state, i = s.name, n = s.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = vt(e.placement), l = Eo(a), p = [J, dt].indexOf(a) >= 0, u = p ? "height" : "width";
  if (!(!o || !r)) {
    var f = nh(n.padding, e), _ = To(o), m = l === "y" ? Q : J, g = l === "y" ? ht : dt, v = e.rects.reference[u] + e.rects.reference[l] - r[l] - e.rects.popper[u], b = r[l] - e.rects.reference[l], C = Di(o), y = C ? l === "y" ? C.clientHeight || 0 : C.clientWidth || 0 : 0, E = v / 2 - b / 2, T = f[m], A = y - _[u] - f[g], w = y / 2 - _[u] / 2 + E, S = Ei(T, w, A), k = l;
    e.modifiersData[i] = (t = {}, t[k] = S, t.centerOffset = S - w, t);
  }
}
function rh(s) {
  var t = s.state, e = s.options, i = e.element, n = i === void 0 ? "[data-popper-arrow]" : i;
  if (n != null && !(typeof n == "string" && (n = t.elements.popper.querySelector(n), !n))) {
    if ({}.NODE_ENV !== "production" && (ct(n) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !yl(t.elements.popper, n)) {
      ({}).NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = n;
  }
}
const Ol = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: oh,
  effect: rh,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Ke(s) {
  return s.split("-")[1];
}
var ah = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function lh(s, t) {
  var e = s.x, i = s.y, n = t.devicePixelRatio || 1;
  return {
    x: Ye(e * n) / n || 0,
    y: Ye(i * n) / n || 0
  };
}
function zo(s) {
  var t, e = s.popper, i = s.popperRect, n = s.placement, o = s.variation, r = s.offsets, a = s.position, l = s.gpuAcceleration, p = s.adaptive, u = s.roundOffsets, f = s.isFixed, _ = r.x, m = _ === void 0 ? 0 : _, g = r.y, v = g === void 0 ? 0 : g, b = typeof u == "function" ? u({
    x: m,
    y: v
  }) : {
    x: m,
    y: v
  };
  m = b.x, v = b.y;
  var C = r.hasOwnProperty("x"), y = r.hasOwnProperty("y"), E = J, T = Q, A = window;
  if (p) {
    var w = Di(e), S = "clientHeight", k = "clientWidth";
    if (w === ut(e) && (w = te(e), Tt(w).position !== "static" && a === "absolute" && (S = "scrollHeight", k = "scrollWidth")), w = w, n === Q || (n === J || n === dt) && o === Fe) {
      T = ht;
      var x = f && w === A && A.visualViewport ? A.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        w[S]
      );
      v -= x - i.height, v *= l ? 1 : -1;
    }
    if (n === J || (n === Q || n === ht) && o === Fe) {
      E = dt;
      var $ = f && w === A && A.visualViewport ? A.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        w[k]
      );
      m -= $ - i.width, m *= l ? 1 : -1;
    }
  }
  var O = Object.assign({
    position: a
  }, p && ah), M = u === !0 ? lh({
    x: m,
    y: v
  }, ut(e)) : {
    x: m,
    y: v
  };
  if (m = M.x, v = M.y, l) {
    var P;
    return Object.assign({}, O, (P = {}, P[T] = y ? "0" : "", P[E] = C ? "0" : "", P.transform = (A.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + v + "px)" : "translate3d(" + m + "px, " + v + "px, 0)", P));
  }
  return Object.assign({}, O, (t = {}, t[T] = y ? v + "px" : "", t[E] = C ? m + "px" : "", t.transform = "", t));
}
function ch(s) {
  var t = s.state, e = s.options, i = e.gpuAcceleration, n = i === void 0 ? !0 : i, o = e.adaptive, r = o === void 0 ? !0 : o, a = e.roundOffsets, l = a === void 0 ? !0 : a;
  if ({}.NODE_ENV !== "production") {
    var p = Tt(t.elements.popper).transitionProperty || "";
    r && ["transform", "top", "right", "bottom", "left"].some(function(f) {
      return p.indexOf(f) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var u = {
    placement: vt(t.placement),
    variation: Ke(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, zo(Object.assign({}, u, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: r,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, zo(Object.assign({}, u, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const Co = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: ch,
  data: {}
};
var ji = {
  passive: !0
};
function hh(s) {
  var t = s.state, e = s.instance, i = s.options, n = i.scroll, o = n === void 0 ? !0 : n, r = i.resize, a = r === void 0 ? !0 : r, l = ut(t.elements.popper), p = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && p.forEach(function(u) {
    u.addEventListener("scroll", e.update, ji);
  }), a && l.addEventListener("resize", e.update, ji), function() {
    o && p.forEach(function(u) {
      u.removeEventListener("scroll", e.update, ji);
    }), a && l.removeEventListener("resize", e.update, ji);
  };
}
const Ao = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: hh,
  data: {}
};
var dh = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function bs(s) {
  return s.replace(/left|right|bottom|top/g, function(t) {
    return dh[t];
  });
}
var uh = {
  start: "end",
  end: "start"
};
function Uo(s) {
  return s.replace(/start|end/g, function(t) {
    return uh[t];
  });
}
function yo(s) {
  var t = ut(s), e = t.pageXOffset, i = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: i
  };
}
function wo(s) {
  return je(te(s)).left + yo(s).scrollLeft;
}
function ph(s, t) {
  var e = ut(s), i = te(s), n = e.visualViewport, o = i.clientWidth, r = i.clientHeight, a = 0, l = 0;
  if (n) {
    o = n.width, r = n.height;
    var p = Al();
    (p || !p && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: o,
    height: r,
    x: a + wo(s),
    y: l
  };
}
function _h(s) {
  var t, e = te(s), i = yo(s), n = (t = s.ownerDocument) == null ? void 0 : t.body, o = ge(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = ge(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + wo(s), l = -i.scrollTop;
  return Tt(n || e).direction === "rtl" && (a += ge(e.clientWidth, n ? n.clientWidth : 0) - o), {
    width: o,
    height: r,
    x: a,
    y: l
  };
}
function xo(s) {
  var t = Tt(s), e = t.overflow, i = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + n + i);
}
function Sl(s) {
  return ["html", "body", "#document"].indexOf(Nt(s)) >= 0 ? s.ownerDocument.body : ct(s) && xo(s) ? s : Sl(Hs(s));
}
function Ci(s, t) {
  var e;
  t === void 0 && (t = []);
  var i = Sl(s), n = i === ((e = s.ownerDocument) == null ? void 0 : e.body), o = ut(i), r = n ? [o].concat(o.visualViewport || [], xo(i) ? i : []) : i, a = t.concat(r);
  return n ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Ci(Hs(r)))
  );
}
function io(s) {
  return Object.assign({}, s, {
    left: s.x,
    top: s.y,
    right: s.x + s.width,
    bottom: s.y + s.height
  });
}
function fh(s, t) {
  var e = je(s, !1, t === "fixed");
  return e.top = e.top + s.clientTop, e.left = e.left + s.clientLeft, e.bottom = e.top + s.clientHeight, e.right = e.left + s.clientWidth, e.width = s.clientWidth, e.height = s.clientHeight, e.x = e.left, e.y = e.top, e;
}
function Xo(s, t, e) {
  return t === mo ? io(ph(s, e)) : Te(t) ? fh(t, e) : io(_h(te(s)));
}
function mh(s) {
  var t = Ci(Hs(s)), e = ["absolute", "fixed"].indexOf(Tt(s).position) >= 0, i = e && ct(s) ? Di(s) : s;
  return Te(i) ? t.filter(function(n) {
    return Te(n) && yl(n, i) && Nt(n) !== "body";
  }) : [];
}
function gh(s, t, e, i) {
  var n = t === "clippingParents" ? mh(s) : [].concat(t), o = [].concat(n, [e]), r = o[0], a = o.reduce(function(l, p) {
    var u = Xo(s, p, i);
    return l.top = ge(u.top, l.top), l.right = Rs(u.right, l.right), l.bottom = Rs(u.bottom, l.bottom), l.left = ge(u.left, l.left), l;
  }, Xo(s, r, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function Il(s) {
  var t = s.reference, e = s.element, i = s.placement, n = i ? vt(i) : null, o = i ? Ke(i) : null, r = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;
  switch (n) {
    case Q:
      l = {
        x: r,
        y: t.y - e.height
      };
      break;
    case ht:
      l = {
        x: r,
        y: t.y + t.height
      };
      break;
    case dt:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case J:
      l = {
        x: t.x - e.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var p = n ? Eo(n) : null;
  if (p != null) {
    var u = p === "y" ? "height" : "width";
    switch (o) {
      case ve:
        l[p] = l[p] - (t[u] / 2 - e[u] / 2);
        break;
      case Fe:
        l[p] = l[p] + (t[u] / 2 - e[u] / 2);
        break;
    }
  }
  return l;
}
function ze(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = i === void 0 ? s.placement : i, o = e.strategy, r = o === void 0 ? s.strategy : o, a = e.boundary, l = a === void 0 ? ul : a, p = e.rootBoundary, u = p === void 0 ? mo : p, f = e.elementContext, _ = f === void 0 ? Ie : f, m = e.altBoundary, g = m === void 0 ? !1 : m, v = e.padding, b = v === void 0 ? 0 : v, C = xl(typeof b != "number" ? b : kl(b, qe)), y = _ === Ie ? pl : Ie, E = s.rects.popper, T = s.elements[g ? y : _], A = gh(Te(T) ? T : T.contextElement || te(s.elements.popper), l, u, r), w = je(s.elements.reference), S = Il({
    reference: w,
    element: E,
    strategy: "absolute",
    placement: n
  }), k = io(Object.assign({}, E, S)), x = _ === Ie ? k : w, $ = {
    top: A.top - x.top + C.top,
    bottom: x.bottom - A.bottom + C.bottom,
    left: A.left - x.left + C.left,
    right: x.right - A.right + C.right
  }, O = s.modifiersData.offset;
  if (_ === Ie && O) {
    var M = O[n];
    Object.keys($).forEach(function(P) {
      var tt = [dt, ht].indexOf(P) >= 0 ? 1 : -1, et = [Q, ht].indexOf(P) >= 0 ? "y" : "x";
      $[P] += M[et] * tt;
    });
  }
  return $;
}
function bh(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, p = l === void 0 ? go : l, u = Ke(i), f = u ? a ? to : to.filter(function(g) {
    return Ke(g) === u;
  }) : qe, _ = f.filter(function(g) {
    return p.indexOf(g) >= 0;
  });
  _.length === 0 && (_ = f, {}.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var m = _.reduce(function(g, v) {
    return g[v] = ze(s, {
      placement: v,
      boundary: n,
      rootBoundary: o,
      padding: r
    })[vt(v)], g;
  }, {});
  return Object.keys(m).sort(function(g, v) {
    return m[g] - m[v];
  });
}
function vh(s) {
  if (vt(s) === Ii)
    return [];
  var t = bs(s);
  return [Uo(s), t, Uo(t)];
}
function Th(s) {
  var t = s.state, e = s.options, i = s.name;
  if (!t.modifiersData[i]._skip) {
    for (var n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !0 : r, l = e.fallbackPlacements, p = e.padding, u = e.boundary, f = e.rootBoundary, _ = e.altBoundary, m = e.flipVariations, g = m === void 0 ? !0 : m, v = e.allowedAutoPlacements, b = t.options.placement, C = vt(b), y = C === b, E = l || (y || !g ? [bs(b)] : vh(b)), T = [b].concat(E).reduce(function(Ae, Ht) {
      return Ae.concat(vt(Ht) === Ii ? bh(t, {
        placement: Ht,
        boundary: u,
        rootBoundary: f,
        padding: p,
        flipVariations: g,
        allowedAutoPlacements: v
      }) : Ht);
    }, []), A = t.rects.reference, w = t.rects.popper, S = /* @__PURE__ */ new Map(), k = !0, x = T[0], $ = 0; $ < T.length; $++) {
      var O = T[$], M = vt(O), P = Ke(O) === ve, tt = [Q, ht].indexOf(M) >= 0, et = tt ? "width" : "height", U = ze(t, {
        placement: O,
        boundary: u,
        rootBoundary: f,
        altBoundary: _,
        padding: p
      }), mt = tt ? P ? dt : J : P ? ht : Q;
      A[et] > w[et] && (mt = bs(mt));
      var Hi = bs(mt), ie = [];
      if (o && ie.push(U[M] <= 0), a && ie.push(U[mt] <= 0, U[Hi] <= 0), ie.every(function(Ae) {
        return Ae;
      })) {
        x = O, k = !1;
        break;
      }
      S.set(O, ie);
    }
    if (k)
      for (var Wi = g ? 3 : 1, Us = function(Ht) {
        var ii = T.find(function(Fi) {
          var se = S.get(Fi);
          if (se)
            return se.slice(0, Ht).every(function(Xs) {
              return Xs;
            });
        });
        if (ii)
          return x = ii, "break";
      }, ei = Wi; ei > 0; ei--) {
        var Vi = Us(ei);
        if (Vi === "break")
          break;
      }
    t.placement !== x && (t.modifiersData[i]._skip = !0, t.placement = x, t.reset = !0);
  }
}
const Dl = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Th,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Go(s, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: s.top - t.height - e.y,
    right: s.right - t.width + e.x,
    bottom: s.bottom - t.height + e.y,
    left: s.left - t.width - e.x
  };
}
function qo(s) {
  return [Q, dt, ht, J].some(function(t) {
    return s[t] >= 0;
  });
}
function Eh(s) {
  var t = s.state, e = s.name, i = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = ze(t, {
    elementContext: "reference"
  }), a = ze(t, {
    altBoundary: !0
  }), l = Go(r, i), p = Go(a, n, o), u = qo(l), f = qo(p);
  t.modifiersData[e] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: p,
    isReferenceHidden: u,
    hasPopperEscaped: f
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": f
  });
}
const $l = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Eh
};
function Ch(s, t, e) {
  var i = vt(s), n = [J, Q].indexOf(i) >= 0 ? -1 : 1, o = typeof e == "function" ? e(Object.assign({}, t, {
    placement: s
  })) : e, r = o[0], a = o[1];
  return r = r || 0, a = (a || 0) * n, [J, dt].indexOf(i) >= 0 ? {
    x: a,
    y: r
  } : {
    x: r,
    y: a
  };
}
function Ah(s) {
  var t = s.state, e = s.options, i = s.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = go.reduce(function(u, f) {
    return u[f] = Ch(f, t.rects, o), u;
  }, {}), a = r[t.placement], l = a.x, p = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += p), t.modifiersData[i] = r;
}
const Ll = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Ah
};
function yh(s) {
  var t = s.state, e = s.name;
  t.modifiersData[e] = Il({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const ko = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: yh,
  data: {}
};
function wh(s) {
  return s === "x" ? "y" : "x";
}
function xh(s) {
  var t = s.state, e = s.options, i = s.name, n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !1 : r, l = e.boundary, p = e.rootBoundary, u = e.altBoundary, f = e.padding, _ = e.tether, m = _ === void 0 ? !0 : _, g = e.tetherOffset, v = g === void 0 ? 0 : g, b = ze(t, {
    boundary: l,
    rootBoundary: p,
    padding: f,
    altBoundary: u
  }), C = vt(t.placement), y = Ke(t.placement), E = !y, T = Eo(C), A = wh(T), w = t.modifiersData.popperOffsets, S = t.rects.reference, k = t.rects.popper, x = typeof v == "function" ? v(Object.assign({}, t.rects, {
    placement: t.placement
  })) : v, $ = typeof x == "number" ? {
    mainAxis: x,
    altAxis: x
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, x), O = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, M = {
    x: 0,
    y: 0
  };
  if (w) {
    if (o) {
      var P, tt = T === "y" ? Q : J, et = T === "y" ? ht : dt, U = T === "y" ? "height" : "width", mt = w[T], Hi = mt + b[tt], ie = mt - b[et], Wi = m ? -k[U] / 2 : 0, Us = y === ve ? S[U] : k[U], ei = y === ve ? -k[U] : -S[U], Vi = t.elements.arrow, Ae = m && Vi ? To(Vi) : {
        width: 0,
        height: 0
      }, Ht = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : wl(), ii = Ht[tt], Fi = Ht[et], se = Ei(0, S[U], Ae[U]), Xs = E ? S[U] / 2 - Wi - se - ii - $.mainAxis : Us - se - ii - $.mainAxis, Sc = E ? -S[U] / 2 + Wi + se + Fi + $.mainAxis : ei + se + Fi + $.mainAxis, Gs = t.elements.arrow && Di(t.elements.arrow), Ic = Gs ? T === "y" ? Gs.clientTop || 0 : Gs.clientLeft || 0 : 0, Mo = (P = O == null ? void 0 : O[T]) != null ? P : 0, Dc = mt + Xs - Mo - Ic, $c = mt + Sc - Mo, No = Ei(m ? Rs(Hi, Dc) : Hi, mt, m ? ge(ie, $c) : ie);
      w[T] = No, M[T] = No - mt;
    }
    if (a) {
      var Ro, Lc = T === "x" ? Q : J, Mc = T === "x" ? ht : dt, ne = w[A], Yi = A === "y" ? "height" : "width", Po = ne + b[Lc], Bo = ne - b[Mc], qs = [Q, J].indexOf(C) !== -1, Ho = (Ro = O == null ? void 0 : O[A]) != null ? Ro : 0, Wo = qs ? Po : ne - S[Yi] - k[Yi] - Ho + $.altAxis, Vo = qs ? ne + S[Yi] + k[Yi] - Ho - $.altAxis : Bo, Fo = m && qs ? sh(Wo, ne, Vo) : Ei(m ? Wo : Po, ne, m ? Vo : Bo);
      w[A] = Fo, M[A] = Fo - ne;
    }
    t.modifiersData[i] = M;
  }
}
const Ml = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: xh,
  requiresIfExists: ["offset"]
};
function kh(s) {
  return {
    scrollLeft: s.scrollLeft,
    scrollTop: s.scrollTop
  };
}
function Oh(s) {
  return s === ut(s) || !ct(s) ? yo(s) : kh(s);
}
function Sh(s) {
  var t = s.getBoundingClientRect(), e = Ye(t.width) / s.offsetWidth || 1, i = Ye(t.height) / s.offsetHeight || 1;
  return e !== 1 || i !== 1;
}
function Ih(s, t, e) {
  e === void 0 && (e = !1);
  var i = ct(t), n = ct(t) && Sh(t), o = te(t), r = je(s, n, e), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !e) && ((Nt(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  xo(o)) && (a = Oh(t)), ct(t) ? (l = je(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = wo(o))), {
    x: r.left + a.scrollLeft - l.x,
    y: r.top + a.scrollTop - l.y,
    width: r.width,
    height: r.height
  };
}
function Dh(s) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];
  s.forEach(function(o) {
    t.set(o.name, o);
  });
  function n(o) {
    e.add(o.name);
    var r = [].concat(o.requires || [], o.requiresIfExists || []);
    r.forEach(function(a) {
      if (!e.has(a)) {
        var l = t.get(a);
        l && n(l);
      }
    }), i.push(o);
  }
  return s.forEach(function(o) {
    e.has(o.name) || n(o);
  }), i;
}
function $h(s) {
  var t = Dh(s);
  return Ns.reduce(function(e, i) {
    return e.concat(t.filter(function(n) {
      return n.phase === i;
    }));
  }, []);
}
function Lh(s) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(s());
      });
    })), t;
  };
}
function Wt(s) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  return [].concat(e).reduce(function(n, o) {
    return n.replace(/%s/, o);
  }, s);
}
var re = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', Mh = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', Zo = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function Nh(s) {
  s.forEach(function(t) {
    [].concat(Object.keys(t), Zo).filter(function(e, i, n) {
      return n.indexOf(e) === i;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(Wt(re, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(Wt(re, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          Ns.indexOf(t.phase) < 0 && console.error(Wt(re, t.name, '"phase"', "either " + Ns.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(Wt(re, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(Wt(re, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(Wt(re, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(Wt(re, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + Zo.map(function(i) {
            return '"' + i + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(i) {
        s.find(function(n) {
          return n.name === i;
        }) == null && console.error(Wt(Mh, String(t.name), i, i));
      });
    });
  });
}
function Rh(s, t) {
  var e = /* @__PURE__ */ new Set();
  return s.filter(function(i) {
    var n = t(i);
    if (!e.has(n))
      return e.add(n), !0;
  });
}
function Ph(s) {
  var t = s.reduce(function(e, i) {
    var n = e[i.name];
    return e[i.name] = n ? Object.assign({}, n, i, {
      options: Object.assign({}, n.options, i.options),
      data: Object.assign({}, n.data, i.data)
    }) : i, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var Qo = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", Bh = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", Jo = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function tr() {
  for (var s = arguments.length, t = new Array(s), e = 0; e < s; e++)
    t[e] = arguments[e];
  return !t.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function Ws(s) {
  s === void 0 && (s = {});
  var t = s, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? Jo : n;
  return function(a, l, p) {
    p === void 0 && (p = o);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Jo, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, f = [], _ = !1, m = {
      state: u,
      setOptions: function(C) {
        var y = typeof C == "function" ? C(u.options) : C;
        v(), u.options = Object.assign({}, o, u.options, y), u.scrollParents = {
          reference: Te(a) ? Ci(a) : a.contextElement ? Ci(a.contextElement) : [],
          popper: Ci(l)
        };
        var E = $h(Ph([].concat(i, u.options.modifiers)));
        if (u.orderedModifiers = E.filter(function(O) {
          return O.enabled;
        }), {}.NODE_ENV !== "production") {
          var T = Rh([].concat(E, u.options.modifiers), function(O) {
            var M = O.name;
            return M;
          });
          if (Nh(T), vt(u.options.placement) === Ii) {
            var A = u.orderedModifiers.find(function(O) {
              var M = O.name;
              return M === "flip";
            });
            A || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var w = Tt(l), S = w.marginTop, k = w.marginRight, x = w.marginBottom, $ = w.marginLeft;
          [S, k, x, $].some(function(O) {
            return parseFloat(O);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return g(), m.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!_) {
          var C = u.elements, y = C.reference, E = C.popper;
          if (!tr(y, E)) {
            ({}).NODE_ENV !== "production" && console.error(Qo);
            return;
          }
          u.rects = {
            reference: Ih(y, Di(E), u.options.strategy === "fixed"),
            popper: To(E)
          }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(O) {
            return u.modifiersData[O.name] = Object.assign({}, O.data);
          });
          for (var T = 0, A = 0; A < u.orderedModifiers.length; A++) {
            if ({}.NODE_ENV !== "production" && (T += 1, T > 100)) {
              console.error(Bh);
              break;
            }
            if (u.reset === !0) {
              u.reset = !1, A = -1;
              continue;
            }
            var w = u.orderedModifiers[A], S = w.fn, k = w.options, x = k === void 0 ? {} : k, $ = w.name;
            typeof S == "function" && (u = S({
              state: u,
              options: x,
              name: $,
              instance: m
            }) || u);
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Lh(function() {
        return new Promise(function(b) {
          m.forceUpdate(), b(u);
        });
      }),
      destroy: function() {
        v(), _ = !0;
      }
    };
    if (!tr(a, l))
      return {}.NODE_ENV !== "production" && console.error(Qo), m;
    m.setOptions(p).then(function(b) {
      !_ && p.onFirstUpdate && p.onFirstUpdate(b);
    });
    function g() {
      u.orderedModifiers.forEach(function(b) {
        var C = b.name, y = b.options, E = y === void 0 ? {} : y, T = b.effect;
        if (typeof T == "function") {
          var A = T({
            state: u,
            name: C,
            instance: m,
            options: E
          }), w = function() {
          };
          f.push(A || w);
        }
      });
    }
    function v() {
      f.forEach(function(b) {
        return b();
      }), f = [];
    }
    return m;
  };
}
var Hh = /* @__PURE__ */ Ws(), Wh = [Ao, ko, Co, vo], Vh = /* @__PURE__ */ Ws({
  defaultModifiers: Wh
}), Fh = [Ao, ko, Co, vo, Ll, Dl, Ml, Ol, $l], Ee = /* @__PURE__ */ Ws({
  defaultModifiers: Fh
});
const Nl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  afterMain: vl,
  afterRead: ml,
  afterWrite: Cl,
  applyStyles: vo,
  arrow: Ol,
  auto: Ii,
  basePlacements: qe,
  beforeMain: gl,
  beforeRead: _l,
  beforeWrite: Tl,
  bottom: ht,
  clippingParents: ul,
  computeStyles: Co,
  createPopper: Ee,
  createPopperBase: Hh,
  createPopperLite: Vh,
  detectOverflow: ze,
  end: Fe,
  eventListeners: Ao,
  flip: Dl,
  hide: $l,
  left: J,
  main: bl,
  modifierPhases: Ns,
  offset: Ll,
  placements: go,
  popper: Ie,
  popperGenerator: Ws,
  popperOffsets: ko,
  preventOverflow: Ml,
  read: fl,
  reference: pl,
  right: dt,
  start: ve,
  top: Q,
  variationPlacements: to,
  viewport: mo,
  write: El
}, Symbol.toStringTag, { value: "Module" }));
function tn(s) {
  return s === "true" ? !0 : s === "false" ? !1 : s === Number(s).toString() ? Number(s) : s === "" || s === "null" ? null : s;
}
function en(s) {
  return s.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
const c = {
  setDataAttribute(s, t, e) {
    s.setAttribute(`data-te-${en(t)}`, e);
  },
  removeDataAttribute(s, t) {
    s.removeAttribute(`data-te-${en(t)}`);
  },
  getDataAttributes(s) {
    if (!s)
      return {};
    const t = {};
    return Object.keys(s.dataset).filter((e) => e.startsWith("te")).forEach((e) => {
      if (e.startsWith("teClass"))
        return;
      let i = e.replace(/^te/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = tn(s.dataset[e]);
    }), t;
  },
  getDataClassAttributes(s) {
    if (!s)
      return {};
    const t = {
      ...s.dataset
    };
    return Object.keys(t).filter((e) => e.startsWith("teClass")).forEach((e) => {
      let i = e.replace(/^teClass/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = tn(t[e]);
    }), t;
  },
  getDataAttribute(s, t) {
    return tn(
      s.getAttribute(`data-te-${en(t)}`)
    );
  },
  offset(s) {
    const t = s.getBoundingClientRect();
    return {
      top: t.top + document.body.scrollTop,
      left: t.left + document.body.scrollLeft
    };
  },
  position(s) {
    return {
      top: s.offsetTop,
      left: s.offsetLeft
    };
  },
  style(s, t) {
    Object.assign(s.style, t);
  },
  toggleClass(s, t) {
    s && sn(t).forEach((e) => {
      s.classList.contains(e) ? s.classList.remove(e) : s.classList.add(e);
    });
  },
  addClass(s, t) {
    sn(t).forEach(
      (e) => !s.classList.contains(e) && s.classList.add(e)
    );
  },
  addStyle(s, t) {
    Object.keys(t).forEach((e) => {
      s.style[e] = t[e];
    });
  },
  removeClass(s, t) {
    sn(t).forEach(
      (e) => s.classList.contains(e) && s.classList.remove(e)
    );
  },
  hasClass(s, t) {
    return s.classList.contains(t);
  },
  maxOffset(s) {
    const t = s.getBoundingClientRect();
    return {
      top: t.top + Math.max(
        document.body.scrollTop,
        document.documentElement.scrollTop,
        window.scrollY
      ),
      left: t.left + Math.max(
        document.body.scrollLeft,
        document.documentElement.scrollLeft,
        window.scrollX
      )
    };
  }
};
function sn(s) {
  return typeof s == "string" ? s.split(" ") : Array.isArray(s) ? s : !1;
}
const Yh = 3, d = {
  closest(s, t) {
    return s.closest(t);
  },
  matches(s, t) {
    return s.matches(t);
  },
  find(s, t = document.documentElement) {
    return [].concat(
      ...Element.prototype.querySelectorAll.call(t, s)
    );
  },
  findOne(s, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, s);
  },
  children(s, t) {
    return [].concat(...s.children).filter((i) => i.matches(t));
  },
  parents(s, t) {
    const e = [];
    let i = s.parentNode;
    for (; i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== Yh; )
      this.matches(i, t) && e.push(i), i = i.parentNode;
    return e;
  },
  prev(s, t) {
    let e = s.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  next(s, t) {
    let e = s.nextElementSibling;
    for (; e; ) {
      if (this.matches(e, t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  },
  focusableChildren(s) {
    const t = [
      "a",
      "button",
      "input",
      "textarea",
      "select",
      "details",
      "[tabindex]",
      '[contenteditable="true"]'
    ].map((e) => `${e}:not([tabindex^="-"])`).join(", ");
    return this.find(t, s).filter(
      (e) => !me(e) && Lt(e)
    );
  }
}, nn = "dropdown", jh = "te.dropdown", Ce = `.${jh}`, Oo = ".data-api", vs = "Escape", er = "Space", ir = "Tab", so = "ArrowUp", Ts = "ArrowDown", Kh = 2, zh = new RegExp(
  `${so}|${Ts}|${vs}`
), Uh = `hide${Ce}`, Xh = `hidden${Ce}`, Gh = `show${Ce}`, qh = `shown${Ce}`, Zh = `click${Ce}${Oo}`, sr = `keydown${Ce}${Oo}`, Qh = `keyup${Ce}${Oo}`, Vt = "show", Jh = "dropup", td = "dropend", ed = "dropstart", id = "[data-te-navbar-ref]", Ki = "[data-te-dropdown-toggle-ref]", on = "[data-te-dropdown-menu-ref]", sd = "[data-te-navbar-nav-ref]", nd = "[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)", od = F() ? "top-end" : "top-start", rd = F() ? "top-start" : "top-end", ad = F() ? "bottom-end" : "bottom-start", ld = F() ? "bottom-start" : "bottom-end", cd = F() ? "left-start" : "right-start", hd = F() ? "right-start" : "left-start", dd = [{ opacity: "0" }, { opacity: "1" }], ud = [{ opacity: "1" }, { opacity: "0" }], zi = {
  duration: 550,
  iterations: 1,
  easing: "ease",
  fill: "both"
}, pd = {
  offset: [0, 2],
  boundary: "clippingParents",
  reference: "toggle",
  display: "dynamic",
  popperConfig: null,
  autoClose: !0,
  dropdownAnimation: "on"
}, _d = {
  offset: "(array|string|function)",
  boundary: "(string|element)",
  reference: "(string|element|object)",
  display: "string",
  popperConfig: "(null|object|function)",
  autoClose: "(boolean|string)",
  dropdownAnimation: "string"
};
class It extends Et {
  constructor(t, e) {
    super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._fadeOutAnimate = null;
    const i = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    this._animationCanPlay = this._config.dropdownAnimation === "on" && !i, this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return pd;
  }
  static get DefaultType() {
    return _d;
  }
  static get NAME() {
    return nn;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (me(this._element) || this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    if (h.trigger(
      this._element,
      Gh,
      t
    ).defaultPrevented)
      return;
    const i = It.getParentFromElement(this._element);
    this._inNavbar ? c.setDataAttribute(this._menu, "popper", "none") : this._createPopper(i), "ontouchstart" in document.documentElement && !i.closest(sd) && [].concat(...document.body.children).forEach((n) => h.on(n, "mouseover", Ms)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.setAttribute(`data-te-dropdown-${Vt}`, ""), this._animationCanPlay && this._menu.animate(dd, zi), this._element.setAttribute(`data-te-dropdown-${Vt}`, ""), setTimeout(
      () => {
        h.trigger(this._element, qh, t);
      },
      this._animationCanPlay ? zi.duration : 0
    );
  }
  hide() {
    if (me(this._element) || !this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    this._completeHide(t);
  }
  dispose() {
    this._popper && this._popper.destroy(), super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
  }
  // Private
  _init() {
    this._didInit || (h.on(
      document,
      sr,
      Ki,
      It.dataApiKeydownHandler
    ), h.on(
      document,
      sr,
      on,
      It.dataApiKeydownHandler
    ), h.on(document, Zh, It.clearMenus), h.on(document, Qh, It.clearMenus), this._didInit = !0);
  }
  _completeHide(t) {
    this._fadeOutAnimate && this._fadeOutAnimate.playState === "running" || h.trigger(
      this._element,
      Uh,
      t
    ).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((i) => h.off(i, "mouseover", Ms)), this._animationCanPlay && (this._fadeOutAnimate = this._menu.animate(
      ud,
      zi
    )), setTimeout(
      () => {
        this._popper && this._popper.destroy(), this._menu.removeAttribute(`data-te-dropdown-${Vt}`), this._element.removeAttribute(`data-te-dropdown-${Vt}`), this._element.setAttribute("aria-expanded", "false"), c.removeDataAttribute(this._menu, "popper"), h.trigger(this._element, Xh, t);
      },
      this._animationCanPlay ? zi.duration : 0
    ));
  }
  _getConfig(t) {
    if (t = {
      ...this.constructor.Default,
      ...c.getDataAttributes(this._element),
      ...t
    }, L(nn, t, this.constructor.DefaultType), typeof t.reference == "object" && !Ve(t.reference) && typeof t.reference.getBoundingClientRect != "function")
      throw new TypeError(
        `${nn.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
      );
    return t;
  }
  _createPopper(t) {
    if (typeof Nl > "u")
      throw new TypeError(
        "Bootstrap's dropdowns require Popper (https://popper.js.org)"
      );
    let e = this._element;
    this._config.reference === "parent" ? e = t : Ve(this._config.reference) ? e = Jt(this._config.reference) : typeof this._config.reference == "object" && (e = this._config.reference);
    const i = this._getPopperConfig(), n = i.modifiers.find(
      (o) => o.name === "applyStyles" && o.enabled === !1
    );
    this._popper = Ee(
      e,
      this._menu,
      i
    ), n && c.setDataAttribute(this._menu, "popper", "static");
  }
  _isShown(t = this._element) {
    return t.dataset[`teDropdown${Vt.charAt(0).toUpperCase() + Vt.slice(1)}`] === "";
  }
  _getMenuElement() {
    return d.next(this._element, on)[0];
  }
  _getPlacement() {
    const t = this._element.parentNode;
    if (t.dataset.teDropdownPosition === td)
      return cd;
    if (t.dataset.teDropdownPosition === ed)
      return hd;
    const e = getComputedStyle(this._menu).getPropertyValue("--te-position").trim() === "end";
    return t.dataset.teDropdownPosition === Jh ? e ? rd : od : e ? ld : ad;
  }
  _detectNavbar() {
    return this._element.closest(id) !== null;
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _getPopperConfig() {
    const t = {
      placement: this._getPlacement(),
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }
      ]
    };
    return this._config.display === "static" && (t.modifiers = [
      {
        name: "applyStyles",
        enabled: !1
      }
    ]), {
      ...t,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig
    };
  }
  _selectMenuItem({ key: t, target: e }) {
    const i = d.find(
      nd,
      this._menu
    ).filter(Lt);
    i.length && nl(
      i,
      e,
      t === Ts,
      !i.includes(e)
    ).focus();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = It.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static clearMenus(t) {
    if (t && (t.button === Kh || t.type === "keyup" && t.key !== ir))
      return;
    const e = d.find(Ki);
    for (let i = 0, n = e.length; i < n; i++) {
      const o = It.getInstance(e[i]);
      if (!o || o._config.autoClose === !1 || !o._isShown())
        continue;
      const r = {
        relatedTarget: o._element
      };
      if (t) {
        const a = t.composedPath(), l = a.includes(o._menu);
        if (a.includes(o._element) || o._config.autoClose === "inside" && !l || o._config.autoClose === "outside" && l || o._menu.contains(t.target) && (t.type === "keyup" && t.key === ir || /input|select|option|textarea|form/i.test(t.target.tagName)))
          continue;
        t.type === "click" && (r.clickEvent = t);
      }
      o._completeHide(r);
    }
  }
  static getParentFromElement(t) {
    return Qt(t) || t.parentNode;
  }
  static dataApiKeydownHandler(t) {
    if (/input|textarea/i.test(t.target.tagName) ? t.key === er || t.key !== vs && (t.key !== Ts && t.key !== so || t.target.closest(on)) : !zh.test(t.key))
      return;
    const e = this.dataset[`teDropdown${Vt.charAt(0).toUpperCase() + Vt.slice(1)}`] === "";
    if (!e && t.key === vs || (t.preventDefault(), t.stopPropagation(), me(this)))
      return;
    const i = this.matches(Ki) ? this : d.prev(this, Ki)[0], n = It.getOrCreateInstance(i);
    if (t.key === vs) {
      n.hide();
      return;
    }
    if (t.key === so || t.key === Ts) {
      e || n.show(), n._selectMenuItem(t);
      return;
    }
    (!e || t.key === er) && It.clearMenus();
  }
}
const rn = "collapse", Rl = "te.collapse", Vs = `.${Rl}`, nr = {
  toggle: !0,
  parent: null
}, fd = {
  toggle: "boolean",
  parent: "(null|element)"
}, md = `show${Vs}`, gd = `shown${Vs}`, bd = `hide${Vs}`, vd = `hidden${Vs}`, an = "data-te-collapse-show", or = "data-te-collapse-collapsed", Ui = "data-te-collapse-collapsing", Td = "data-te-collapse-horizontal", Le = "data-te-collapse-item", rr = `:scope [${Le}] [${Le}]`, Ed = "width", Cd = "height", Ad = "[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]", ar = "[data-te-collapse-init]", yd = {
  visible: "!visible",
  hidden: "hidden",
  baseTransition: "overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsing: "h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsingHorizontal: "w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none"
}, wd = {
  visible: "string",
  hidden: "string",
  baseTransition: "string",
  collapsing: "string",
  collapsingHorizontal: "string"
};
class qt extends Et {
  constructor(t, e, i) {
    super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._triggerArray = [];
    const n = d.find(ar);
    for (let o = 0, r = n.length; o < r; o++) {
      const a = n[o], l = fo(a), p = d.find(l).filter(
        (u) => u === this._element
      );
      l !== null && p.length && (this._selector = l, this._triggerArray.push(a));
    }
    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
  }
  // Getters
  static get Default() {
    return nr;
  }
  static get NAME() {
    return rn;
  }
  // Public
  toggle() {
    this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (this._isTransitioning || this._isShown())
      return;
    let t = [], e;
    if (this._config.parent) {
      const u = d.find(
        rr,
        this._config.parent
      );
      t = d.find(
        Ad,
        this._config.parent
      ).filter((f) => !u.includes(f));
    }
    const i = d.findOne(this._selector);
    if (t.length) {
      const u = t.find((f) => i !== f);
      if (e = u ? qt.getInstance(u) : null, e && e._isTransitioning)
        return;
    }
    if (h.trigger(this._element, md).defaultPrevented)
      return;
    t.forEach((u) => {
      i !== u && qt.getOrCreateInstance(u, { toggle: !1 }).hide(), e || I.setData(u, Rl, null);
    });
    const o = this._getDimension(), r = o === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    c.removeClass(this._element, this._classes.visible), c.removeClass(this._element, this._classes.hidden), c.addClass(this._element, r), this._element.removeAttribute(Le), this._element.setAttribute(Ui, ""), this._element.style[o] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
    const a = () => {
      this._isTransitioning = !1, c.removeClass(this._element, this._classes.hidden), c.removeClass(this._element, r), c.addClass(this._element, this._classes.visible), this._element.removeAttribute(Ui), this._element.setAttribute(Le, ""), this._element.setAttribute(an, ""), this._element.style[o] = "", h.trigger(this._element, gd);
    }, p = `scroll${o[0].toUpperCase() + o.slice(1)}`;
    this._queueCallback(a, this._element, !0), this._element.style[o] = `${this._element[p]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown() || h.trigger(this._element, bd).defaultPrevented)
      return;
    const e = this._getDimension(), i = e === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Ge(this._element), c.addClass(this._element, i), c.removeClass(this._element, this._classes.visible), c.removeClass(this._element, this._classes.hidden), this._element.setAttribute(Ui, ""), this._element.removeAttribute(Le), this._element.removeAttribute(an);
    const n = this._triggerArray.length;
    for (let r = 0; r < n; r++) {
      const a = this._triggerArray[r], l = Qt(a);
      l && !this._isShown(l) && this._addAriaAndCollapsedClass([a], !1);
    }
    this._isTransitioning = !0;
    const o = () => {
      this._isTransitioning = !1, c.removeClass(this._element, i), c.addClass(this._element, this._classes.visible), c.addClass(this._element, this._classes.hidden), this._element.removeAttribute(Ui), this._element.setAttribute(Le, ""), h.trigger(this._element, vd);
    };
    this._element.style[e] = "", this._queueCallback(o, this._element, !0);
  }
  _isShown(t = this._element) {
    return t.hasAttribute(an);
  }
  // Private
  _getConfig(t) {
    return t = {
      ...nr,
      ...c.getDataAttributes(this._element),
      ...t
    }, t.toggle = !!t.toggle, t.parent = Jt(t.parent), L(rn, t, fd), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...yd,
      ...e,
      ...t
    }, L(rn, t, wd), t;
  }
  _getDimension() {
    return this._element.hasAttribute(Td) ? Ed : Cd;
  }
  _initializeChildren() {
    if (!this._config.parent)
      return;
    const t = d.find(
      rr,
      this._config.parent
    );
    d.find(ar, this._config.parent).filter((e) => !t.includes(e)).forEach((e) => {
      const i = Qt(e);
      i && this._addAriaAndCollapsedClass([e], this._isShown(i));
    });
  }
  _addAriaAndCollapsedClass(t, e) {
    t.length && t.forEach((i) => {
      e ? i.removeAttribute(or) : i.setAttribute(`${or}`, ""), i.setAttribute("aria-expanded", e);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = {};
      typeof t == "string" && /show|hide/.test(t) && (e.toggle = !1);
      const i = qt.getOrCreateInstance(this, e);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t]();
      }
    });
  }
}
const lr = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", cr = ".sticky-top";
class ki {
  constructor() {
    this._element = document.body;
  }
  getWidth() {
    const t = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - t);
  }
  hide() {
    const t = this.getWidth();
    this._disableOverFlow(), this._setElementAttributes(
      this._element,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      lr,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      cr,
      "marginRight",
      (e) => e - t
    );
  }
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
  }
  _setElementAttributes(t, e, i) {
    const n = this.getWidth(), o = (r) => {
      if (r !== this._element && window.innerWidth > r.clientWidth + n)
        return;
      this._saveInitialAttribute(r, e);
      const a = window.getComputedStyle(r)[e];
      r.style[e] = `${i(
        Number.parseFloat(a)
      )}px`;
    };
    this._applyManipulationCallback(t, o);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(lr, "paddingRight"), this._resetElementAttributes(cr, "marginRight");
  }
  _saveInitialAttribute(t, e) {
    const i = t.style[e];
    i && c.setDataAttribute(t, e, i);
  }
  _resetElementAttributes(t, e) {
    const i = (n) => {
      const o = c.getDataAttribute(n, e);
      typeof o > "u" ? n.style.removeProperty(e) : (c.removeDataAttribute(n, e), n.style[e] = o);
    };
    this._applyManipulationCallback(t, i);
  }
  _applyManipulationCallback(t, e) {
    Ve(t) ? e(t) : d.find(t, this._element).forEach(e);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
}
const xd = {
  isVisible: !0,
  // if false, we use the backdrop helper without adding any element to the dom
  isAnimated: !1,
  rootElement: "body",
  // give the choice to place backdrop under different elements
  clickCallback: null,
  backdropClasses: null
}, kd = {
  isVisible: "boolean",
  isAnimated: "boolean",
  rootElement: "(element|string)",
  clickCallback: "(function|null)",
  backdropClasses: "(array|null)"
}, Pl = "backdrop", hr = `mousedown.te.${Pl}`;
class So {
  constructor(t) {
    this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
  }
  show(t) {
    if (!this._config.isVisible) {
      fe(t);
      return;
    }
    this._append(), this._config.isAnimated && Ge(this._getElement());
    const e = this._config.backdropClasses || [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      "fixed",
      "top-0",
      "left-0",
      "z-[1040]",
      "bg-black",
      "w-screen",
      "h-screen"
    ];
    c.removeClass(this._getElement(), "opacity-0"), c.addClass(this._getElement(), e), this._element.setAttribute("data-te-backdrop-show", ""), this._emulateAnimation(() => {
      fe(t);
    });
  }
  hide(t) {
    if (!this._config.isVisible) {
      fe(t);
      return;
    }
    this._element.removeAttribute("data-te-backdrop-show"), this._getElement().classList.add("opacity-0"), this._getElement().classList.remove("opacity-50"), this._emulateAnimation(() => {
      this.dispose(), fe(t);
    });
  }
  // Private
  _getElement() {
    if (!this._element) {
      const t = document.createElement("div");
      t.className = this._config.className, this._config.isAnimated && t.classList.add("opacity-50"), this._element = t;
    }
    return this._element;
  }
  _getConfig(t) {
    return t = {
      ...xd,
      ...typeof t == "object" ? t : {}
    }, t.rootElement = Jt(t.rootElement), L(Pl, t, kd), t;
  }
  _append() {
    this._isAppended || (this._config.rootElement.append(this._getElement()), h.on(this._getElement(), hr, () => {
      fe(this._config.clickCallback);
    }), this._isAppended = !0);
  }
  dispose() {
    this._isAppended && (h.off(this._element, hr), this._element.remove(), this._isAppended = !1);
  }
  _emulateAnimation(t) {
    sl(
      t,
      this._getElement(),
      this._config.isAnimated
    );
  }
}
class $i {
  constructor(t, e = {}, i) {
    this._element = t, this._toggler = i, this._event = e.event || "blur", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {
      this._condition(n) && !n.shiftKey && n.target === this._lastElement ? (n.preventDefault(), this._firstElement.focus()) : this._condition(n) && n.shiftKey && n.target === this._firstElement && (n.preventDefault(), this._lastElement.focus());
    };
  }
  trap() {
    this._setElements(), this._init(), this._setFocusTrap();
  }
  disable() {
    this._focusableElements.forEach((t) => {
      t.removeEventListener(this._event, this.handler);
    }), this._toggler && this._toggler.focus();
  }
  update() {
    this._setElements(), this._setFocusTrap();
  }
  _init() {
    const t = (e) => {
      !this._firstElement || e.key !== "Tab" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener("keydown", t));
    };
    window.addEventListener("keydown", t);
  }
  _filterVisible(t) {
    return t.filter((e) => {
      if (!Lt(e))
        return !1;
      const i = d.parents(e, "*");
      for (let n = 0; n < i.length; n++) {
        const o = window.getComputedStyle(i[n]);
        if (o && (o.display === "none" || o.visibility === "hidden"))
          return !1;
      }
      return !0;
    });
  }
  _setElements() {
    this._focusableElements = d.focusableChildren(this._element), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];
  }
  _setFocusTrap() {
    this._focusableElements.forEach((t, e) => {
      e === this._focusableElements.length - 1 || e === 0 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);
    });
  }
}
const dr = "offcanvas", Od = "te.offcanvas", Ze = `.${Od}`, Sd = ".data-api", Id = `load${Ze}${Sd}`, Dd = "Escape", ur = {
  backdrop: !0,
  keyboard: !0,
  scroll: !1
}, $d = {
  backdrop: "boolean",
  keyboard: "boolean",
  scroll: "boolean"
}, pr = "show", Ld = "[data-te-offcanvas-init][data-te-offcanvas-show]", Md = `show${Ze}`, Nd = `shown${Ze}`, Rd = `hide${Ze}`, Pd = `hidden${Ze}`, Bd = `keydown.dismiss${Ze}`;
class no extends Et {
  constructor(t, e) {
    super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return dr;
  }
  static get Default() {
    return ur;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    if (this._isShown || h.trigger(this._element, Md, {
      relatedTarget: t
    }).defaultPrevented)
      return;
    this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || new ki().hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`data-te-offcanvas-${pr}`, "");
    const i = () => {
      this._config.scroll || this._focustrap.trap(), h.trigger(this._element, Nd, { relatedTarget: t });
    };
    this._queueCallback(i, this._element, !0);
  }
  hide() {
    if (!this._isShown || h.trigger(this._element, Rd).defaultPrevented)
      return;
    this._focustrap.disable(), this._element.blur(), this._isShown = !1, this._element.removeAttribute(`data-te-offcanvas-${pr}`), this._backdrop.hide();
    const e = () => {
      this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new ki().reset(), h.trigger(this._element, Pd);
    };
    this._queueCallback(e, this._element, !0);
  }
  dispose() {
    this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (h.on(
      window,
      Id,
      () => d.find(Ld).forEach(
        (t) => no.getOrCreateInstance(t).show()
      )
    ), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...ur,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, L(dr, t, $d), t;
  }
  _initializeBackDrop() {
    return new So({
      isVisible: this._config.backdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      clickCallback: () => this.hide()
    });
  }
  _initializeFocusTrap() {
    return new $i(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _addEventListeners() {
    h.on(this._element, Bd, (t) => {
      this._config.keyboard && t.key === Dd && this.hide();
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = no.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const ln = "alert", Hd = "te.alert", Bl = `.${Hd}`, Wd = `close${Bl}`, Vd = `closed${Bl}`, si = "data-te-alert-show", Fd = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, _r = {
  animation: !0,
  autohide: !0,
  delay: 1e3
}, Yd = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, jd = {
  fadeIn: "string",
  fadeOut: "string"
};
class Hl extends Et {
  constructor(t, e, i) {
    super(t), this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i);
  }
  // Getters
  static get DefaultType() {
    return Fd;
  }
  static get Default() {
    return _r;
  }
  static get NAME() {
    return ln;
  }
  // Public
  close() {
    if (h.trigger(this._element, Wd).defaultPrevented)
      return;
    let e = 0;
    this._config.animation && (e = 300, c.addClass(this._element, this._classes.fadeOut)), this._element.removeAttribute(si), setTimeout(() => {
      this._queueCallback(
        () => this._destroyElement(),
        this._element,
        this._config.animation
      );
    }, e);
  }
  show() {
    if (this._element) {
      if (this._config.autohide && this._setupAutohide(), !this._element.hasAttribute(si) && (c.removeClass(this._element, "hidden"), c.addClass(this._element, "block"), Lt(this._element))) {
        const t = (e) => {
          c.removeClass(this._element, "hidden"), c.addClass(this._element, "block"), h.off(e.target, "animationend", t);
        };
        this._element.setAttribute(si, ""), h.on(this._element, "animationend", t);
      }
      this._config.animation && (c.removeClass(this._element, this._classes.fadeOut), c.addClass(this._element, this._classes.fadeIn));
    }
  }
  hide() {
    if (this._element && this._element.hasAttribute(si)) {
      this._element.removeAttribute(si);
      const t = (e) => {
        c.addClass(this._element, "hidden"), c.removeClass(this._element, "block"), this._timeout !== null && (clearTimeout(this._timeout), this._timeout = null), h.off(e.target, "animationend", t);
      };
      h.on(this._element, "animationend", t), c.removeClass(this._element, this._classes.fadeIn), c.addClass(this._element, this._classes.fadeOut);
    }
  }
  // Private
  _getConfig(t) {
    return t = {
      ..._r,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, L(ln, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Yd,
      ...e,
      ...t
    }, L(ln, t, jd), t;
  }
  _setupAutohide() {
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _destroyElement() {
    this._element.remove(), h.trigger(this._element, Vd), this.dispose();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Hl.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const cn = "carousel", Kd = "te.carousel", pt = `.${Kd}`, Wl = ".data-api", zd = "ArrowLeft", Ud = "ArrowRight", Xd = 500, Gd = 40, fr = {
  interval: 5e3,
  keyboard: !0,
  ride: !1,
  pause: "hover",
  wrap: !0,
  touch: !0
}, qd = {
  interval: "(number|boolean)",
  keyboard: "boolean",
  ride: "(boolean|string)",
  pause: "(string|boolean)",
  wrap: "boolean",
  touch: "boolean"
}, Zd = {
  pointer: "touch-pan-y",
  block: "!block",
  visible: "data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]",
  invisible: "data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-[600ms] data-[te-carousel-fade]:delay-600",
  slideRight: "translate-x-full",
  slideLeft: "-translate-x-full"
}, Qd = {
  pointer: "string",
  block: "string",
  visible: "string",
  invisible: "string",
  slideRight: "string",
  slideLeft: "string"
}, ae = "next", le = "prev", pe = "left", ui = "right", Jd = {
  [zd]: ui,
  [Ud]: pe
}, tu = `slide${pt}`, hn = `slid${pt}`, eu = `keydown${pt}`, iu = `mouseenter${pt}`, su = `mouseleave${pt}`, nu = `touchstart${pt}`, ou = `touchmove${pt}`, ru = `touchend${pt}`, au = `pointerdown${pt}`, lu = `pointerup${pt}`, cu = `dragstart${pt}`, hu = `load${pt}${Wl}`, du = `click${pt}${Wl}`, mr = "data-te-carousel-init", ce = "data-te-carousel-active", uu = "data-te-carousel-item-end", dn = "data-te-carousel-item-start", pu = "data-te-carousel-item-next", _u = "data-te-carousel-item-prev", fu = "data-te-carousel-pointer-event", mu = "[data-te-carousel-init]", Vl = "[data-te-carousel-active]", Io = "[data-te-carousel-item]", ye = `${Vl}${Io}`, gu = `${Io} img`, bu = "[data-te-carousel-item-next], [data-te-carousel-item-prev]", vu = "[data-te-carousel-indicators]", Tu = "[data-te-target]", Eu = "[data-te-slide], [data-te-slide-to]", Cu = "touch", Au = "pen";
class Ut extends Et {
  constructor(t, e, i) {
    super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._indicatorsElement = d.findOne(
      vu,
      this._element
    ), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = !!window.PointerEvent, this._setActiveElementClass(), this._addEventListeners(), this._didInit = !1, this._init(), this._config.ride === "carousel" && this.cycle();
  }
  // Getters
  static get Default() {
    return fr;
  }
  static get NAME() {
    return cn;
  }
  // Public
  next() {
    this._slide(ae);
  }
  nextWhenVisible() {
    !document.hidden && Lt(this._element) && this.next();
  }
  prev() {
    this._slide(le);
  }
  pause(t) {
    t || (this._isPaused = !0), d.findOne(bu, this._element) && (Ja(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;
  }
  cycle(t) {
    t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval(
      (document.visibilityState ? this.nextWhenVisible : this.next).bind(
        this
      ),
      this._config.interval
    ));
  }
  to(t) {
    this._activeElement = d.findOne(
      ye,
      this._element
    );
    const e = this._getItemIndex(this._activeElement);
    if (t > this._items.length - 1 || t < 0)
      return;
    if (this._isSliding) {
      h.one(this._element, hn, () => this.to(t));
      return;
    }
    if (e === t) {
      this.pause(), this.cycle();
      return;
    }
    const i = t > e ? ae : le;
    this._slide(i, this._items[t]);
  }
  // Private
  _init() {
    this._didInit || (h.on(
      document,
      du,
      Eu,
      Ut.dataApiClickHandler
    ), h.on(window, hu, () => {
      const t = d.find(mu);
      for (let e = 0, i = t.length; e < i; e++)
        Ut.carouselInterface(
          t[e],
          Ut.getInstance(t[e])
        );
    }), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...fr,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, L(cn, t, qd), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Zd,
      ...e,
      ...t
    }, L(cn, t, Qd), t;
  }
  _enableCycle() {
    if (this._config.ride) {
      if (this._isSliding) {
        h.one(this._element, hn, () => this.cycle());
        return;
      }
      this.cycle();
    }
  }
  _applyInitialClasses() {
    const t = d.findOne(
      ye,
      this._element
    );
    t.classList.add(
      this._classes.block,
      ...this._classes.visible.split(" ")
    ), this._setActiveIndicatorElement(t);
  }
  _handleSwipe() {
    const t = Math.abs(this.touchDeltaX);
    if (t <= Gd)
      return;
    const e = t / this.touchDeltaX;
    this.touchDeltaX = 0, e && this._slide(e > 0 ? ui : pe);
  }
  _setActiveElementClass() {
    this._activeElement = d.findOne(
      ye,
      this._element
    ), c.addClass(this._activeElement, "hidden");
  }
  _addEventListeners() {
    this._config.keyboard && h.on(
      this._element,
      eu,
      (t) => this._keydown(t)
    ), this._config.pause === "hover" && (h.on(
      this._element,
      iu,
      (t) => this.pause(t)
    ), h.on(
      this._element,
      su,
      (t) => this._enableCycle(t)
    )), this._config.touch && this._touchSupported && this._addTouchEventListeners(), this._applyInitialClasses();
  }
  _addTouchEventListeners() {
    const t = (o) => this._pointerEvent && (o.pointerType === Au || o.pointerType === Cu), e = (o) => {
      t(o) ? this.touchStartX = o.clientX : this._pointerEvent || (this.touchStartX = o.touches[0].clientX);
    }, i = (o) => {
      this.touchDeltaX = o.touches && o.touches.length > 1 ? 0 : o.touches[0].clientX - this.touchStartX;
    }, n = (o) => {
      t(o) && (this.touchDeltaX = o.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(
        (r) => this._enableCycle(r),
        Xd + this._config.interval
      ));
    };
    d.find(gu, this._element).forEach(
      (o) => {
        h.on(
          o,
          cu,
          (r) => r.preventDefault()
        );
      }
    ), this._pointerEvent ? (h.on(
      this._element,
      au,
      (o) => e(o)
    ), h.on(this._element, lu, (o) => n(o)), this._element.classList.add(this._classes.pointer), this._element.setAttribute(`${fu}`, "")) : (h.on(this._element, nu, (o) => e(o)), h.on(this._element, ou, (o) => i(o)), h.on(this._element, ru, (o) => n(o)));
  }
  _keydown(t) {
    if (/input|textarea/i.test(t.target.tagName))
      return;
    const e = Jd[t.key];
    e && (t.preventDefault(), this._slide(e));
  }
  _getItemIndex(t) {
    return this._items = t && t.parentNode ? d.find(Io, t.parentNode) : [], this._items.indexOf(t);
  }
  _getItemByOrder(t, e) {
    const i = t === ae;
    return nl(
      this._items,
      e,
      i,
      this._config.wrap
    );
  }
  _triggerSlideEvent(t, e) {
    const i = this._getItemIndex(t), n = this._getItemIndex(
      d.findOne(ye, this._element)
    );
    return h.trigger(this._element, tu, {
      relatedTarget: t,
      direction: e,
      from: n,
      to: i
    });
  }
  _setActiveIndicatorElement(t) {
    if (this._indicatorsElement) {
      const e = d.findOne(
        Vl,
        this._indicatorsElement
      );
      e.removeAttribute(ce), e.removeAttribute("aria-current"), e.classList.remove("!opacity-100");
      const i = d.find(
        Tu,
        this._indicatorsElement
      );
      for (let n = 0; n < i.length; n++)
        if (Number.parseInt(
          i[n].getAttribute("data-te-slide-to"),
          10
        ) === this._getItemIndex(t)) {
          i[n].setAttribute(`${ce}`, ""), i[n].setAttribute("aria-current", "true"), i[n].classList.add("!opacity-100");
          break;
        }
    }
  }
  _updateInterval() {
    const t = this._activeElement || d.findOne(ye, this._element);
    if (!t)
      return;
    const e = Number.parseInt(
      t.getAttribute("data-te-interval"),
      10
    );
    e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;
  }
  _slide(t, e) {
    const i = this._directionToOrder(t), n = d.findOne(
      ye,
      this._element
    ), o = this._getItemIndex(n), r = e || this._getItemByOrder(i, n), a = this._getItemIndex(r), l = !!this._interval, p = i === ae, u = p ? dn : uu, f = p ? pu : _u, _ = this._orderToDirection(i), m = u === dn ? this._classes.slideLeft : this._classes.slideRight, g = u !== dn ? this._classes.slideLeft : this._classes.slideRight;
    if (r && r.hasAttribute(ce)) {
      this._isSliding = !1;
      return;
    }
    if (this._isSliding || this._triggerSlideEvent(r, _).defaultPrevented || !n || !r)
      return;
    this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(r), this._activeElement = r;
    const b = () => {
      h.trigger(this._element, hn, {
        relatedTarget: r,
        direction: _,
        from: o,
        to: a
      });
    };
    if (this._element.hasAttribute(mr)) {
      r.setAttribute(`${f}`, ""), r.classList.add(this._classes.block, g), Ge(r), n.setAttribute(`${u}`, ""), n.classList.add(
        m,
        ...this._classes.invisible.split(" ")
      ), n.classList.remove(...this._classes.visible.split(" ")), r.setAttribute(`${u}`, ""), r.classList.add(...this._classes.visible.split(" ")), r.classList.remove(
        this._classes.slideRight,
        this._classes.slideLeft
      );
      const C = () => {
        r.removeAttribute(u), r.removeAttribute(f), r.setAttribute(`${ce}`, ""), n.removeAttribute(ce), n.classList.remove(
          m,
          ...this._classes.invisible.split(" "),
          this._classes.block
        ), n.removeAttribute(f), n.removeAttribute(u), this._isSliding = !1, setTimeout(b, 0);
      };
      this._queueCallback(C, n, !0);
    } else
      n.removeAttribute(ce), n.classList.remove(this._classes.block), r.setAttribute(`${ce}`, ""), r.classList.add(this._classes.block), this._isSliding = !1, b();
    l && this.cycle();
  }
  _directionToOrder(t) {
    return [ui, pe].includes(t) ? F() ? t === pe ? le : ae : t === pe ? ae : le : t;
  }
  _orderToDirection(t) {
    return [ae, le].includes(t) ? F() ? t === le ? pe : ui : t === le ? ui : pe : t;
  }
  // Static
  static carouselInterface(t, e) {
    const i = Ut.getOrCreateInstance(t, e);
    let { _config: n } = i;
    typeof e == "object" && (n = {
      ...n,
      ...e
    });
    const o = typeof e == "string" ? e : e.slide;
    if (typeof e == "number") {
      i.to(e);
      return;
    }
    if (typeof o == "string") {
      if (typeof i[o] > "u")
        throw new TypeError(`No method named "${o}"`);
      i[o]();
    } else
      n.interval && n.ride === !0 && i.pause();
  }
  static jQueryInterface(t) {
    return this.each(function() {
      Ut.carouselInterface(this, t);
    });
  }
  static dataApiClickHandler(t) {
    const e = Qt(this);
    if (!e || !e.hasAttribute(mr))
      return;
    const i = {
      ...c.getDataAttributes(e),
      ...c.getDataAttributes(this)
    }, n = this.getAttribute("data-te-slide-to");
    n && (i.interval = !1), Ut.carouselInterface(e, i), n && Ut.getInstance(e).to(n), t.preventDefault();
  }
}
const un = "modal", yu = "te.modal", Ct = `.${yu}`, gr = "Escape", br = {
  backdrop: !0,
  keyboard: !0,
  focus: !0
}, wu = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  focus: "boolean"
}, xu = {
  show: "transform-none",
  static: "scale-[1.02]",
  staticProperties: "transition-scale duration-300 ease-in-out"
}, ku = {
  show: "string",
  static: "string",
  staticProperties: "string"
}, Ou = `hide${Ct}`, Su = `hidePrevented${Ct}`, Iu = `hidden${Ct}`, Du = `show${Ct}`, $u = `shown${Ct}`, vr = `resize${Ct}`, Tr = `click.dismiss${Ct}`, Er = `keydown.dismiss${Ct}`, Lu = `mouseup.dismiss${Ct}`, Cr = `mousedown.dismiss${Ct}`, Ar = "data-te-modal-open", yr = "data-te-open", ni = "[data-te-modal-dialog-ref]", Mu = "[data-te-modal-body-ref]";
class Fl extends Et {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._dialog = d.findOne(ni, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new ki();
  }
  // Getters
  static get Default() {
    return br;
  }
  static get NAME() {
    return un;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    this._isShown || this._isTransitioning || h.trigger(this._element, Du, {
      relatedTarget: t
    }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.setAttribute(Ar, "true"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), h.on(this._dialog, Cr, () => {
      h.one(this._element, Lu, (i) => {
        i.target === this._element && (this._ignoreBackdropClick = !0);
      });
    }), this._showElement(t), this._showBackdrop());
  }
  hide() {
    if (!this._isShown || this._isTransitioning || h.trigger(this._element, Ou).defaultPrevented)
      return;
    this._isShown = !1;
    const e = this._isAnimated();
    e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.disable(), d.findOne(ni, this._element).classList.remove(this._classes.show), h.off(this._element, Tr), h.off(this._dialog, Cr), this._queueCallback(() => this._hideModal(), this._element, e), this._element.removeAttribute(yr);
  }
  dispose() {
    [window, this._dialog].forEach(
      (t) => h.off(t, Ct)
    ), this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _initializeBackDrop() {
    return new So({
      isVisible: !!this._config.backdrop,
      // 'static' option will be translated to true, and booleans will keep their value
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new $i(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _getConfig(t) {
    return t = {
      ...br,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, L(un, t, wu), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...xu,
      ...e,
      ...t
    }, L(un, t, ku), t;
  }
  _showElement(t) {
    const e = this._isAnimated(), i = d.findOne(Mu, this._dialog);
    (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = "block", this._element.classList.remove("hidden"), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`${yr}`, "true"), this._element.scrollTop = 0;
    const n = d.findOne(ni, this._element);
    n.classList.add(this._classes.show), n.classList.remove("opacity-0"), n.classList.add("opacity-100"), i && (i.scrollTop = 0), e && Ge(this._element);
    const o = () => {
      this._config.focus && this._focustrap.trap(), this._isTransitioning = !1, h.trigger(this._element, $u, {
        relatedTarget: t
      });
    };
    this._queueCallback(o, this._dialog, e);
  }
  _setEscapeEvent() {
    this._isShown ? h.on(document, Er, (t) => {
      this._config.keyboard && t.key === gr ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === gr && this._triggerBackdropTransition();
    }) : h.off(this._element, Er);
  }
  _setResizeEvent() {
    this._isShown ? h.on(window, vr, () => this._adjustDialog()) : h.off(window, vr);
  }
  _hideModal() {
    const t = d.findOne(ni, this._element);
    t.classList.remove(this._classes.show), t.classList.remove("opacity-100"), t.classList.add("opacity-0"), setTimeout(() => {
      this._element.style.display = "none";
    }, 300), this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
      document.body.removeAttribute(Ar), this._resetAdjustments(), this._scrollBar.reset(), h.trigger(this._element, Iu);
    });
  }
  _showBackdrop(t) {
    h.on(this._element, Tr, (e) => {
      if (this._ignoreBackdropClick) {
        this._ignoreBackdropClick = !1;
        return;
      }
      e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === "static" && this._triggerBackdropTransition());
    }), this._backdrop.show(t);
  }
  _isAnimated() {
    return !!d.findOne(ni, this._element);
  }
  _triggerBackdropTransition() {
    if (h.trigger(this._element, Su).defaultPrevented)
      return;
    const { classList: e, scrollHeight: i, style: n } = this._element, o = i > document.documentElement.clientHeight;
    !o && n.overflowY === "hidden" || e.contains(this._classes.static) || (o || (n.overflowY = "hidden"), e.add(...this._classes.static.split(" ")), e.add(...this._classes.staticProperties.split(" ")), this._queueCallback(() => {
      e.remove(this._classes.static), setTimeout(() => {
        e.remove(...this._classes.staticProperties.split(" "));
      }, 300), o || this._queueCallback(() => {
        n.overflowY = "";
      }, this._dialog);
    }, this._dialog), this._element.focus());
  }
  // ----------------------------------------------------------------------
  // the following methods are used to handle overflowing modals
  // ----------------------------------------------------------------------
  _adjustDialog() {
    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), i = e > 0;
    (!i && t && !F() || i && !t && F()) && (this._element.style.paddingLeft = `${e}px`), (i && !t && !F() || !i && t && F()) && (this._element.style.paddingRight = `${e}px`);
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const i = Fl.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
}
const Nu = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Ru = /^aria-[\w-]*$/i, Pu = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Bu = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Hu = (s, t) => {
  const e = s.nodeName.toLowerCase();
  if (t.includes(e))
    return Nu.has(e) ? !!(Pu.test(s.nodeValue) || Bu.test(s.nodeValue)) : !0;
  const i = t.filter(
    (n) => n instanceof RegExp
  );
  for (let n = 0, o = i.length; n < o; n++)
    if (i[n].test(e))
      return !0;
  return !1;
}, Wu = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Ru],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
function wr(s, t, e) {
  if (!s.length)
    return s;
  if (e && typeof e == "function")
    return e(s);
  const n = new window.DOMParser().parseFromString(s, "text/html"), o = [].concat(...n.body.querySelectorAll("*"));
  for (let r = 0, a = o.length; r < a; r++) {
    const l = o[r], p = l.nodeName.toLowerCase();
    if (!Object.keys(t).includes(p)) {
      l.remove();
      continue;
    }
    const u = [].concat(...l.attributes), f = [].concat(
      t["*"] || [],
      t[p] || []
    );
    u.forEach((_) => {
      Hu(_, f) || l.removeAttribute(_.nodeName);
    });
  }
  return n.body.innerHTML;
}
const xr = "tooltip", Vu = "te.tooltip", yt = `.${Vu}`, Fu = "te-tooltip", Yu = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), ju = {
  animation: "boolean",
  template: "string",
  title: "(string|element|function)",
  trigger: "string",
  delay: "(number|object)",
  html: "boolean",
  selector: "(string|boolean)",
  placement: "(string|function)",
  offset: "(array|string|function)",
  container: "(string|element|boolean)",
  fallbackPlacements: "array",
  boundary: "(string|element)",
  customClass: "(string|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  allowList: "object",
  popperConfig: "(null|object|function)"
}, Ku = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: F() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: F() ? "right" : "left"
}, zu = {
  animation: !0,
  template: '<div class="opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal" role="tooltip"><div data-te-tooltip-inner-ref class="tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded"></div></div>',
  trigger: "hover focus",
  title: "",
  delay: 0,
  html: !1,
  selector: !1,
  placement: "top",
  offset: [0, 0],
  container: !1,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  boundary: "clippingParents",
  customClass: "",
  sanitize: !0,
  sanitizeFn: null,
  allowList: Wu,
  popperConfig: { hide: !0 }
}, Uu = {
  HIDE: `hide${yt}`,
  HIDDEN: `hidden${yt}`,
  SHOW: `show${yt}`,
  SHOWN: `shown${yt}`,
  INSERTED: `inserted${yt}`,
  CLICK: `click${yt}`,
  FOCUSIN: `focusin${yt}`,
  FOCUSOUT: `focusout${yt}`,
  MOUSEENTER: `mouseenter${yt}`,
  MOUSELEAVE: `mouseleave${yt}`
}, Xu = "fade", Gu = "modal", pn = "show", oi = "show", _n = "out", kr = ".tooltip-inner", Or = `.${Gu}`, Sr = "hide.te.modal", ri = "hover", fn = "focus", qu = "click", Zu = "manual";
class Qe extends Et {
  constructor(t, e) {
    if (typeof Nl > "u")
      throw new TypeError(
        "Bootstrap's tooltips require Popper (https://popper.js.org)"
      );
    super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();
  }
  // Getters
  static get Default() {
    return zu;
  }
  static get NAME() {
    return xr;
  }
  static get Event() {
    return Uu;
  }
  static get DefaultType() {
    return ju;
  }
  // Public
  enable() {
    this._isEnabled = !0;
  }
  disable() {
    this._isEnabled = !1;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle(t) {
    if (this._isEnabled)
      if (t) {
        const e = this._initializeOnDelegatedTarget(t);
        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);
      } else {
        if (this.getTipElement().classList.contains(pn)) {
          this._leave(null, this);
          return;
        }
        this._enter(null, this);
      }
  }
  dispose() {
    clearTimeout(this._timeout), h.off(
      this._element.closest(Or),
      Sr,
      this._hideModalHandler
    ), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();
  }
  show() {
    if (this._element.style.display === "none")
      throw new Error("Please use show on visible elements");
    if (!(this.isWithContent() && this._isEnabled))
      return;
    const t = h.trigger(
      this._element,
      this.constructor.Event.SHOW
    ), e = tl(this._element), i = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);
    if (t.defaultPrevented || !i)
      return;
    this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(kr).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);
    const n = this.getTipElement(), o = bt(this.constructor.NAME);
    n.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this._config.animation && setTimeout(() => {
      this.tip.classList.add("opacity-100"), this.tip.classList.remove("opacity-0");
    }, 100);
    const r = typeof this._config.placement == "function" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(r);
    this._addAttachmentClass(a);
    const { container: l } = this._config;
    if (I.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), h.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Ee(
      this._element,
      n,
      this._getPopperConfig(a)
    ), n.getAttribute("id").includes("tooltip"))
      switch (r) {
        case "bottom":
          n.classList.add("py-[0.4rem]");
          break;
        case "left":
          n.classList.add("px-[0.4rem]");
          break;
        case "right":
          n.classList.add("px-[0.4rem]");
          break;
        default:
          n.classList.add("py-[0.4rem]");
          break;
      }
    const u = this._resolvePossibleFunction(this._config.customClass);
    u && n.classList.add(...u.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((m) => {
      h.on(m, "mouseover", Ms);
    });
    const f = () => {
      const m = this._hoverState;
      this._hoverState = null, h.trigger(this._element, this.constructor.Event.SHOWN), m === _n && this._leave(null, this);
    }, _ = this.tip.classList.contains("transition-opacity");
    this._queueCallback(f, this.tip, _);
  }
  hide() {
    if (!this._popper)
      return;
    const t = this.getTipElement(), e = () => {
      this._isWithActiveTrigger() || (this._hoverState !== oi && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), h.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());
    };
    if (h.trigger(
      this._element,
      this.constructor.Event.HIDE
    ).defaultPrevented)
      return;
    t.classList.add("opacity-0"), t.classList.remove("opacity-100"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((o) => h.off(o, "mouseover", Ms)), this._activeTrigger[qu] = !1, this._activeTrigger[fn] = !1, this._activeTrigger[ri] = !1;
    const n = this.tip.classList.contains("opacity-0");
    this._queueCallback(e, this.tip, n), this._hoverState = "";
  }
  update() {
    this._popper !== null && this._popper.update();
  }
  // Protected
  isWithContent() {
    return !!this.getTitle();
  }
  getTipElement() {
    if (this.tip)
      return this.tip;
    const t = document.createElement("div");
    t.innerHTML = this._config.template;
    const e = t.children[0];
    return this.setContent(e), e.classList.remove(Xu, pn), this.tip = e, this.tip;
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), kr);
  }
  _sanitizeAndSetContent(t, e, i) {
    const n = d.findOne(i, t);
    if (!e && n) {
      n.remove();
      return;
    }
    this.setElementContent(n, e);
  }
  setElementContent(t, e) {
    if (t !== null) {
      if (Ve(e)) {
        e = Jt(e), this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent;
        return;
      }
      this._config.html ? (this._config.sanitize && (e = wr(
        e,
        this._config.allowList,
        this._config.sanitizeFn
      )), t.innerHTML = e) : t.textContent = e;
    }
  }
  getTitle() {
    const t = this._element.getAttribute("data-te-original-title") || this._config.title;
    return this._resolvePossibleFunction(t);
  }
  updateAttachment(t) {
    return t === "right" ? "end" : t === "left" ? "start" : t;
  }
  // Private
  _initializeOnDelegatedTarget(t, e) {
    return e || this.constructor.getOrCreateInstance(
      t.delegateTarget,
      this._getDelegateConfig()
    );
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _resolvePossibleFunction(t) {
    return typeof t == "function" ? t.call(this._element) : t;
  }
  _getPopperConfig(t) {
    const e = {
      placement: t,
      modifiers: [
        {
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        },
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        },
        {
          name: "onChange",
          enabled: !0,
          phase: "afterWrite",
          fn: (i) => this._handlePopperPlacementChange(i)
        }
      ],
      onFirstUpdate: (i) => {
        i.options.placement !== i.placement && this._handlePopperPlacementChange(i);
      }
    };
    return {
      ...e,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig
    };
  }
  _addAttachmentClass(t) {
    this.getTipElement().classList.add(
      `${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`
    );
  }
  _getAttachment(t) {
    return Ku[t.toUpperCase()];
  }
  _setListeners() {
    this._config.trigger.split(" ").forEach((e) => {
      if (e === "click")
        h.on(
          this._element,
          this.constructor.Event.CLICK,
          this._config.selector,
          (i) => this.toggle(i)
        );
      else if (e !== Zu) {
        const i = e === ri ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === ri ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
        h.on(
          this._element,
          i,
          this._config.selector,
          (o) => this._enter(o)
        ), h.on(
          this._element,
          n,
          this._config.selector,
          (o) => this._leave(o)
        );
      }
    }), this._hideModalHandler = () => {
      this._element && this.hide();
    }, h.on(
      this._element.closest(Or),
      Sr,
      this._hideModalHandler
    ), this._config.selector ? this._config = {
      ...this._config,
      trigger: "manual",
      selector: ""
    } : this._fixTitle();
  }
  _fixTitle() {
    const t = this._element.getAttribute("title"), e = typeof this._element.getAttribute(
      "data-te-original-title"
    );
    (t || e !== "string") && (this._element.setAttribute("data-te-original-title", t || ""), t && !this._element.getAttribute("aria-label") && !this._element.textContent && this._element.setAttribute("aria-label", t), this._element.setAttribute("title", ""));
  }
  _enter(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusin" ? fn : ri] = !0), e.getTipElement().classList.contains(pn) || e._hoverState === oi) {
      e._hoverState = oi;
      return;
    }
    if (clearTimeout(e._timeout), e._hoverState = oi, !e._config.delay || !e._config.delay.show) {
      e.show();
      return;
    }
    e._timeout = setTimeout(() => {
      e._hoverState === oi && e.show();
    }, e._config.delay.show);
  }
  _leave(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusout" ? fn : ri] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {
      if (clearTimeout(e._timeout), e._hoverState = _n, !e._config.delay || !e._config.delay.hide) {
        e.hide();
        return;
      }
      e._timeout = setTimeout(() => {
        e._hoverState === _n && e.hide();
      }, e._config.delay.hide);
    }
  }
  _isWithActiveTrigger() {
    for (const t in this._activeTrigger)
      if (this._activeTrigger[t])
        return !0;
    return !1;
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return Object.keys(e).forEach((i) => {
      Yu.has(i) && delete e[i];
    }), t = {
      ...this.constructor.Default,
      ...e,
      ...typeof t == "object" && t ? t : {}
    }, t.container = t.container === !1 ? document.body : Jt(t.container), typeof t.delay == "number" && (t.delay = {
      show: t.delay,
      hide: t.delay
    }), typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), L(xr, t, this.constructor.DefaultType), t.sanitize && (t.template = wr(
      t.template,
      t.allowList,
      t.sanitizeFn
    )), t;
  }
  _getDelegateConfig() {
    const t = {};
    for (const e in this._config)
      this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);
    return t;
  }
  _cleanTipClass() {
    const t = this.getTipElement(), e = new RegExp(
      `(^|\\s)${this._getBasicClassPrefix()}\\S+`,
      "g"
    ), i = t.getAttribute("class").match(e);
    i !== null && i.length > 0 && i.map((n) => n.trim()).forEach((n) => t.classList.remove(n));
  }
  _getBasicClassPrefix() {
    return Fu;
  }
  _handlePopperPlacementChange(t) {
    const { state: e } = t;
    e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));
  }
  _disposePopper() {
    this._popper && (this._popper.destroy(), this._popper = null);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Qe.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const Qu = "popover", Ju = "te.popover", wt = `.${Ju}`, tp = "te-popover", ep = {
  ...Qe.Default,
  placement: "right",
  offset: [0, 8],
  trigger: "click",
  content: "",
  template: '<div class="opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden" role="tooltip"><h3 class="popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500"></h3><div class="popover-body p-4 text-[#212529] dark:text-white"></div></div>'
}, ip = {
  ...Qe.DefaultType,
  content: "(string|element|function)"
}, sp = {
  HIDE: `hide${wt}`,
  HIDDEN: `hidden${wt}`,
  SHOW: `show${wt}`,
  SHOWN: `shown${wt}`,
  INSERTED: `inserted${wt}`,
  CLICK: `click${wt}`,
  FOCUSIN: `focusin${wt}`,
  FOCUSOUT: `focusout${wt}`,
  MOUSEENTER: `mouseenter${wt}`,
  MOUSELEAVE: `mouseleave${wt}`
}, np = ".popover-header", op = ".popover-body";
class Yl extends Qe {
  // Getters
  static get Default() {
    return ep;
  }
  static get NAME() {
    return Qu;
  }
  static get Event() {
    return sp;
  }
  static get DefaultType() {
    return ip;
  }
  // Overrides
  isWithContent() {
    return this.getTitle() || this._getContent();
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), np), this._sanitizeAndSetContent(t, this._getContent(), op);
  }
  // Private
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  _getBasicClassPrefix() {
    return tp;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Yl.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const mn = "scrollspy", rp = "te.scrollspy", Do = `.${rp}`, Ir = {
  offset: 10,
  method: "auto",
  target: ""
}, ap = {
  offset: "number",
  method: "string",
  target: "(string|element)"
}, lp = {
  active: "!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400"
}, cp = {
  active: "string"
}, hp = `activate${Do}`, dp = `scroll${Do}`, gn = "data-te-nav-link-active", jl = "[data-te-dropdown-item-ref]", up = "[data-te-nav-list-ref]", oo = "[data-te-nav-link-ref]", pp = "[data-te-nav-item-ref]", Kl = "[data-te-list-group-item-ref]", bn = `${oo}, ${Kl}, ${jl}`, _p = "[data-te-dropdown-ref]", fp = "[data-te-dropdown-toggle-ref]", mp = "maxOffset", Dr = "position";
class zl extends Et {
  constructor(t, e, i) {
    super(t), this._scrollElement = this._element.tagName === "BODY" ? window : this._element, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, h.on(this._scrollElement, dp, () => this._process()), this.refresh(), this._process();
  }
  // Getters
  static get Default() {
    return Ir;
  }
  static get NAME() {
    return mn;
  }
  // Public
  refresh() {
    const t = this._scrollElement === this._scrollElement.window ? mp : Dr, e = this._config.method === "auto" ? t : this._config.method, i = e === Dr ? this._getScrollTop() : 0;
    this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), d.find(
      bn,
      this._config.target
    ).map((o) => {
      const r = fo(o), a = r ? d.findOne(r) : null;
      if (a) {
        const l = a.getBoundingClientRect();
        if (l.width || l.height)
          return [
            c[e](a).top + i,
            r
          ];
      }
      return null;
    }).filter((o) => o).sort((o, r) => o[0] - r[0]).forEach((o) => {
      this._offsets.push(o[0]), this._targets.push(o[1]);
    });
  }
  dispose() {
    h.off(this._scrollElement, Do), super.dispose();
  }
  // Private
  _getConfig(t) {
    return t = {
      ...Ir,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, t.target = Jt(t.target) || document.documentElement, L(mn, t, ap), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...lp,
      ...e,
      ...t
    }, L(mn, t, cp), t;
  }
  _getScrollTop() {
    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
  }
  _getScrollHeight() {
    return this._scrollElement.scrollHeight || Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight
    );
  }
  _getOffsetHeight() {
    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
  }
  _process() {
    const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), i = this._config.offset + e - this._getOffsetHeight();
    if (this._scrollHeight !== e && this.refresh(), t >= i) {
      const n = this._targets[this._targets.length - 1];
      this._activeTarget !== n && this._activate(n);
      return;
    }
    if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {
      this._activeTarget = null, this._clear();
      return;
    }
    for (let n = this._offsets.length; n--; )
      this._activeTarget !== this._targets[n] && t >= this._offsets[n] && (typeof this._offsets[n + 1] > "u" || t < this._offsets[n + 1]) && this._activate(this._targets[n]);
  }
  _activate(t) {
    this._activeTarget = t, this._clear();
    const e = bn.split(",").map(
      (n) => `${n}[data-te-target="${t}"],${n}[href="${t}"]`
    ), i = d.findOne(e.join(","), this._config.target);
    i.classList.add(...this._classes.active.split(" ")), i.setAttribute(gn, ""), i.getAttribute(jl) ? d.findOne(
      fp,
      i.closest(_p)
    ).classList.add(...this._classes.active.split(" ")) : d.parents(i, up).forEach(
      (n) => {
        d.prev(
          n,
          `${oo}, ${Kl}`
        ).forEach((o) => {
          o.classList.add(...this._classes.active.split(" ")), o.setAttribute(gn, "");
        }), d.prev(n, pp).forEach(
          (o) => {
            d.children(o, oo).forEach(
              (r) => r.classList.add(...this._classes.active.split(" "))
            );
          }
        );
      }
    ), h.trigger(this._scrollElement, hp, {
      relatedTarget: t
    });
  }
  _clear() {
    d.find(bn, this._config.target).filter(
      (t) => t.classList.contains(...this._classes.active.split(" "))
    ).forEach((t) => {
      t.classList.remove(...this._classes.active.split(" ")), t.removeAttribute(gn);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = zl.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const $r = "tab", gp = "te.tab", Fs = `.${gp}`, bp = `hide${Fs}`, vp = `hidden${Fs}`, Tp = `show${Fs}`, Ep = `shown${Fs}`, Cp = "data-te-dropdown-menu-ref", De = "data-te-tab-active", Es = "data-te-nav-active", Ap = "[data-te-dropdown-ref]", yp = "[data-te-nav-ref]", Lr = `[${De}]`, wp = `[${Es}]`, Mr = ":scope > li > .active", xp = "[data-te-dropdown-toggle-ref]", kp = ":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]", Op = {
  show: "opacity-100",
  hide: "opacity-0"
}, Sp = {
  show: "string",
  hide: "string"
};
class Ul extends Et {
  constructor(t, e) {
    super(t), this._classes = this._getClasses(e);
  }
  // Getters
  static get NAME() {
    return $r;
  }
  // Public
  show() {
    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(Es) === "")
      return;
    let t;
    const e = Qt(this._element), i = this._element.closest(yp), n = d.findOne(
      wp,
      i
    );
    if (i) {
      const l = i.nodeName === "UL" || i.nodeName === "OL" ? Mr : Lr;
      t = d.find(l, i), t = t[t.length - 1];
    }
    const o = t ? h.trigger(t, bp, {
      relatedTarget: this._element
    }) : null;
    if (h.trigger(this._element, Tp, {
      relatedTarget: t
    }).defaultPrevented || o !== null && o.defaultPrevented)
      return;
    this._activate(
      this._element,
      i,
      null,
      n,
      this._element
    );
    const a = () => {
      h.trigger(t, vp, {
        relatedTarget: this._element
      }), h.trigger(this._element, Ep, {
        relatedTarget: t
      });
    };
    e ? this._activate(
      e,
      e.parentNode,
      a,
      n,
      this._element
    ) : a();
  }
  // Private
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Op,
      ...e,
      ...t
    }, L($r, t, Sp), t;
  }
  _activate(t, e, i, n, o) {
    const a = (e && (e.nodeName === "UL" || e.nodeName === "OL") ? d.find(Mr, e) : d.children(e, Lr))[0], l = i && a && a.hasAttribute(De), p = () => this._transitionComplete(
      t,
      a,
      i,
      n,
      o
    );
    a && l ? (c.removeClass(a, this._classes.show), c.addClass(a, this._classes.hide), this._queueCallback(p, t, !0)) : p();
  }
  _transitionComplete(t, e, i, n, o) {
    if (e && n) {
      e.removeAttribute(De), n.removeAttribute(Es);
      const a = d.findOne(
        kp,
        e.parentNode
      );
      a && a.removeAttribute(De), e.getAttribute("role") === "tab" && e.setAttribute("aria-selected", !1);
    }
    t.setAttribute(De, ""), o.setAttribute(Es, ""), t.getAttribute("role") === "tab" && t.setAttribute("aria-selected", !0), Ge(t), t.classList.contains(this._classes.hide) && (c.removeClass(t, this._classes.hide), c.addClass(t, this._classes.show));
    let r = t.parentNode;
    if (r && r.nodeName === "LI" && (r = r.parentNode), r && r.hasAttribute(Cp)) {
      const a = t.closest(Ap);
      a && d.find(xp, a).forEach(
        (l) => l.setAttribute(De, "")
      ), t.setAttribute("aria-expanded", !0);
    }
    i && i();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Ul.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const vn = "toast", Ip = "te.toast", ee = `.${Ip}`, Dp = `mouseover${ee}`, $p = `mouseout${ee}`, Lp = `focusin${ee}`, Mp = `focusout${ee}`, Np = `hide${ee}`, Rp = `hidden${ee}`, Pp = `show${ee}`, Bp = `shown${ee}`, Nr = "data-te-toast-hide", Tn = "data-te-toast-show", Xi = "data-te-toast-showing", Hp = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, Rr = {
  animation: !0,
  autohide: !0,
  delay: 5e3
}, Wp = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, Vp = {
  fadeIn: "string",
  fadeOut: "string"
};
class Xl extends Et {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();
  }
  // Getters
  static get DefaultType() {
    return Hp;
  }
  static get Default() {
    return Rr;
  }
  static get NAME() {
    return vn;
  }
  // Public
  show() {
    if (h.trigger(this._element, Pp).defaultPrevented)
      return;
    this._clearTimeout(), this._config.animation && (c.removeClass(this._element, this._classes.fadeOut), c.addClass(this._element, this._classes.fadeIn));
    const e = () => {
      this._element.removeAttribute(Xi), h.trigger(this._element, Bp), this._maybeScheduleHide();
    };
    this._element.removeAttribute(Nr), Ge(this._element), this._element.setAttribute(Tn, ""), this._element.setAttribute(Xi, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  hide() {
    if (!this._element || this._element.dataset.teToastShow === void 0 || h.trigger(this._element, Np).defaultPrevented)
      return;
    const e = () => {
      let i = 0;
      this._config.animation && (i = 300, c.removeClass(this._element, this._classes.fadeIn), c.addClass(this._element, this._classes.fadeOut)), setTimeout(() => {
        this._element.setAttribute(Nr, ""), this._element.removeAttribute(Xi), this._element.removeAttribute(Tn), h.trigger(this._element, Rp);
      }, i);
    };
    this._element.setAttribute(Xi, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout(), this._element.dataset.teToastShow !== void 0 && this._element.removeAttribute(Tn), super.dispose();
  }
  // Private
  _getConfig(t) {
    return t = {
      ...Rr,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, L(vn, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Wp,
      ...e,
      ...t
    }, L(vn, t, Vp), t;
  }
  _maybeScheduleHide() {
    this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay)));
  }
  _onInteraction(t, e) {
    switch (t.type) {
      case "mouseover":
      case "mouseout":
        this._hasMouseInteraction = e;
        break;
      case "focusin":
      case "focusout":
        this._hasKeyboardInteraction = e;
        break;
    }
    if (e) {
      this._clearTimeout();
      return;
    }
    const i = t.relatedTarget;
    this._element === i || this._element.contains(i) || this._maybeScheduleHide();
  }
  _setListeners() {
    h.on(
      this._element,
      Dp,
      (t) => this._onInteraction(t, !0)
    ), h.on(
      this._element,
      $p,
      (t) => this._onInteraction(t, !1)
    ), h.on(
      this._element,
      Lp,
      (t) => this._onInteraction(t, !0)
    ), h.on(
      this._element,
      Mp,
      (t) => this._onInteraction(t, !1)
    );
  }
  _clearTimeout() {
    clearTimeout(this._timeout), this._timeout = null;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Xl.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
(() => {
  var s = { 454: (i, n, o) => {
    o.d(n, { Z: () => l });
    var r = o(645), a = o.n(r)()(function(p) {
      return p[1];
    });
    a.push([i.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
    const l = a;
  }, 645: (i) => {
    i.exports = function(n) {
      var o = [];
      return o.toString = function() {
        return this.map(function(r) {
          var a = n(r);
          return r[2] ? "@media ".concat(r[2], " {").concat(a, "}") : a;
        }).join("");
      }, o.i = function(r, a, l) {
        typeof r == "string" && (r = [[null, r, ""]]);
        var p = {};
        if (l)
          for (var u = 0; u < this.length; u++) {
            var f = this[u][0];
            f != null && (p[f] = !0);
          }
        for (var _ = 0; _ < r.length; _++) {
          var m = [].concat(r[_]);
          l && p[m[0]] || (a && (m[2] ? m[2] = "".concat(a, " and ").concat(m[2]) : m[2] = a), o.push(m));
        }
      }, o;
    };
  }, 810: () => {
    (function() {
      if (typeof window < "u")
        try {
          var i = new window.CustomEvent("test", { cancelable: !0 });
          if (i.preventDefault(), i.defaultPrevented !== !0)
            throw new Error("Could not prevent default");
        } catch {
          var n = function(r, a) {
            var l, p;
            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent("CustomEvent")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), p = l.preventDefault, l.preventDefault = function() {
              p.call(this);
              try {
                Object.defineProperty(this, "defaultPrevented", { get: function() {
                  return !0;
                } });
              } catch {
                this.defaultPrevented = !0;
              }
            }, l;
          };
          n.prototype = window.Event.prototype, window.CustomEvent = n;
        }
    })();
  }, 379: (i, n, o) => {
    var r, a = function() {
      var E = {};
      return function(T) {
        if (E[T] === void 0) {
          var A = document.querySelector(T);
          if (window.HTMLIFrameElement && A instanceof window.HTMLIFrameElement)
            try {
              A = A.contentDocument.head;
            } catch {
              A = null;
            }
          E[T] = A;
        }
        return E[T];
      };
    }(), l = [];
    function p(E) {
      for (var T = -1, A = 0; A < l.length; A++)
        if (l[A].identifier === E) {
          T = A;
          break;
        }
      return T;
    }
    function u(E, T) {
      for (var A = {}, w = [], S = 0; S < E.length; S++) {
        var k = E[S], x = T.base ? k[0] + T.base : k[0], $ = A[x] || 0, O = "".concat(x, " ").concat($);
        A[x] = $ + 1;
        var M = p(O), P = { css: k[1], media: k[2], sourceMap: k[3] };
        M !== -1 ? (l[M].references++, l[M].updater(P)) : l.push({ identifier: O, updater: y(P, T), references: 1 }), w.push(O);
      }
      return w;
    }
    function f(E) {
      var T = document.createElement("style"), A = E.attributes || {};
      if (A.nonce === void 0) {
        var w = o.nc;
        w && (A.nonce = w);
      }
      if (Object.keys(A).forEach(function(k) {
        T.setAttribute(k, A[k]);
      }), typeof E.insert == "function")
        E.insert(T);
      else {
        var S = a(E.insert || "head");
        if (!S)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        S.appendChild(T);
      }
      return T;
    }
    var _, m = (_ = [], function(E, T) {
      return _[E] = T, _.filter(Boolean).join(`
`);
    });
    function g(E, T, A, w) {
      var S = A ? "" : w.media ? "@media ".concat(w.media, " {").concat(w.css, "}") : w.css;
      if (E.styleSheet)
        E.styleSheet.cssText = m(T, S);
      else {
        var k = document.createTextNode(S), x = E.childNodes;
        x[T] && E.removeChild(x[T]), x.length ? E.insertBefore(k, x[T]) : E.appendChild(k);
      }
    }
    function v(E, T, A) {
      var w = A.css, S = A.media, k = A.sourceMap;
      if (S ? E.setAttribute("media", S) : E.removeAttribute("media"), k && typeof btoa < "u" && (w += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(k)))), " */")), E.styleSheet)
        E.styleSheet.cssText = w;
      else {
        for (; E.firstChild; )
          E.removeChild(E.firstChild);
        E.appendChild(document.createTextNode(w));
      }
    }
    var b = null, C = 0;
    function y(E, T) {
      var A, w, S;
      if (T.singleton) {
        var k = C++;
        A = b || (b = f(T)), w = g.bind(null, A, k, !1), S = g.bind(null, A, k, !0);
      } else
        A = f(T), w = v.bind(null, A, T), S = function() {
          (function(x) {
            if (x.parentNode === null)
              return !1;
            x.parentNode.removeChild(x);
          })(A);
        };
      return w(E), function(x) {
        if (x) {
          if (x.css === E.css && x.media === E.media && x.sourceMap === E.sourceMap)
            return;
          w(E = x);
        } else
          S();
      };
    }
    i.exports = function(E, T) {
      (T = T || {}).singleton || typeof T.singleton == "boolean" || (T.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));
      var A = u(E = E || [], T);
      return function(w) {
        if (w = w || [], Object.prototype.toString.call(w) === "[object Array]") {
          for (var S = 0; S < A.length; S++) {
            var k = p(A[S]);
            l[k].references--;
          }
          for (var x = u(w, T), $ = 0; $ < A.length; $++) {
            var O = p(A[$]);
            l[O].references === 0 && (l[O].updater(), l.splice(O, 1));
          }
          A = x;
        }
      };
    };
  } }, t = {};
  function e(i) {
    var n = t[i];
    if (n !== void 0)
      return n.exports;
    var o = t[i] = { id: i, exports: {} };
    return s[i](o, o.exports, e), o.exports;
  }
  e.n = (i) => {
    var n = i && i.__esModule ? () => i.default : () => i;
    return e.d(n, { a: n }), n;
  }, e.d = (i, n) => {
    for (var o in n)
      e.o(n, o) && !e.o(i, o) && Object.defineProperty(i, o, { enumerable: !0, get: n[o] });
  }, e.o = (i, n) => Object.prototype.hasOwnProperty.call(i, n), (() => {
    var i = e(379), n = e.n(i), o = e(454);
    function r(l) {
      if (!l.hasAttribute("autocompleted")) {
        l.setAttribute("autocompleted", "");
        var p = new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !0, detail: null });
        l.dispatchEvent(p) || (l.value = "");
      }
    }
    function a(l) {
      l.hasAttribute("autocompleted") && (l.removeAttribute("autocompleted"), l.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !1, detail: null })));
    }
    n()(o.Z, { insert: "head", singleton: !1 }), o.Z.locals, e(810), document.addEventListener("animationstart", function(l) {
      l.animationName === "onautofillstart" ? r(l.target) : a(l.target);
    }, !0), document.addEventListener("input", function(l) {
      l.inputType !== "insertReplacementText" && "data" in l ? a(l.target) : r(l.target);
    }, !0);
  })();
})();
const En = "input", Gi = "te.input", Gl = "data-te-input-wrapper-init", ql = "data-te-input-notch-ref", Zl = "data-te-input-notch-leading-ref", Ql = "data-te-input-notch-middle-ref", Fp = "data-te-input-notch-trailing-ref", Yp = "data-te-input-helper-ref", jp = "data-te-input-placeholder-active", Ft = "data-te-input-state-active", Pr = "data-te-input-focused", Br = "data-te-input-form-counter", he = `[${Gl}] input`, de = `[${Gl}] textarea`, we = `[${ql}]`, Hr = `[${Zl}]`, Wr = `[${Ql}]`, Kp = `[${Yp}]`, zp = {
  inputFormWhite: !1
}, Up = {
  inputFormWhite: "(boolean)"
}, Xp = {
  notch: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
  notchLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0",
  notchLeadingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchLeadingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent",
  notchMiddleNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchMiddleWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0",
  notchTrailingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchTrailingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  counter: "text-right leading-[1.6]"
}, Gp = {
  notch: "string",
  notchLeading: "string",
  notchLeadingNormal: "string",
  notchLeadingWhite: "string",
  notchMiddle: "string",
  notchMiddleNormal: "string",
  notchMiddleWhite: "string",
  notchTrailing: "string",
  notchTrailingNormal: "string",
  notchTrailingWhite: "string",
  counter: "string"
};
class W {
  constructor(t, e, i) {
    this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(i), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (I.setData(t, Gi, this), this.init());
  }
  // Getters
  static get NAME() {
    return En;
  }
  get input() {
    return d.findOne("input", this._element) || d.findOne("textarea", this._element);
  }
  // Public
  init() {
    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = !0);
  }
  update() {
    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();
  }
  forceActive() {
    this.input.setAttribute(Ft, ""), d.findOne(we, this.input.parentNode).setAttribute(
      Ft,
      ""
    );
  }
  forceInactive() {
    this.input.removeAttribute(Ft), d.findOne(
      we,
      this.input.parentNode
    ).removeAttribute(Ft);
  }
  dispose() {
    this._removeBorder(), I.removeData(this._element, Gi), this._element = null;
  }
  // Private
  _getConfig(t, e) {
    return t = {
      ...zp,
      ...c.getDataAttributes(e),
      ...typeof t == "object" ? t : {}
    }, L(En, t, Up), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Xp,
      ...e,
      ...t
    }, L(En, t, Gp), t;
  }
  _getLabelData() {
    this._label = d.findOne("label", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());
  }
  _getHelper() {
    this._helper = d.findOne(Kp, this._element);
  }
  _getCounter() {
    this._counter = c.getDataAttribute(
      this.input,
      "inputShowcounter"
    ), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());
  }
  _getEvents() {
    h.on(
      document,
      "focus",
      he,
      W.activate(new W())
    ), h.on(
      document,
      "input",
      he,
      W.activate(new W())
    ), h.on(
      document,
      "blur",
      he,
      W.deactivate(new W())
    ), h.on(
      document,
      "focus",
      de,
      W.activate(new W())
    ), h.on(
      document,
      "input",
      de,
      W.activate(new W())
    ), h.on(
      document,
      "blur",
      de,
      W.deactivate(new W())
    ), h.on(window, "shown.te.modal", (t) => {
      d.find(he, t.target).forEach(
        (e) => {
          const i = W.getInstance(e.parentNode);
          i && i.update();
        }
      ), d.find(de, t.target).forEach(
        (e) => {
          const i = W.getInstance(e.parentNode);
          i && i.update();
        }
      );
    }), h.on(window, "shown.te.dropdown", (t) => {
      const e = t.target.parentNode.querySelector(
        "[data-te-dropdown-menu-ref]"
      );
      e && (d.find(he, e).forEach(
        (i) => {
          const n = W.getInstance(i.parentNode);
          n && n.update();
        }
      ), d.find(de, e).forEach(
        (i) => {
          const n = W.getInstance(i.parentNode);
          n && n.update();
        }
      ));
    }), h.on(window, "shown.te.tab", (t) => {
      let e;
      t.target.href ? e = t.target.href.split("#")[1] : e = c.getDataAttribute(t.target, "target").split(
        "#"
      )[1];
      const i = d.findOne(`#${e}`);
      d.find(he, i).forEach((n) => {
        const o = W.getInstance(n.parentNode);
        o && o.update();
      }), d.find(de, i).forEach(
        (n) => {
          const o = W.getInstance(n.parentNode);
          o && o.update();
        }
      );
    }), h.on(window, "reset", (t) => {
      d.find(he, t.target).forEach(
        (e) => {
          const i = W.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      ), d.find(de, t.target).forEach(
        (e) => {
          const i = W.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      );
    }), h.on(window, "onautocomplete", (t) => {
      const e = W.getInstance(t.target.parentNode);
      !e || !t.cancelable || e.forceActive();
    });
  }
  _showCounter() {
    if (d.find(
      `[${Br}]`,
      this._element
    ).length > 0)
      return;
    this._counterElement = document.createElement("div"), c.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(Br, "");
    const e = this.input.value.length;
    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();
  }
  _bindCounter() {
    h.on(this.input, "input", () => {
      const t = this.input.value.length;
      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;
    });
  }
  _toggleDefaultDatePlaceholder(t = this.input) {
    if (!(t.getAttribute("type") === "date"))
      return;
    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;
  }
  _showPlaceholder() {
    this.input.setAttribute(jp, "");
  }
  _getNotchData() {
    this._notchMiddle = d.findOne(
      Wr,
      this._element
    ), this._notchLeading = d.findOne(
      Hr,
      this._element
    );
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _getLabelPositionInInputGroup() {
    if (this._labelMarginLeft = 0, !this._element.hasAttribute("data-te-input-group-ref"))
      return;
    const t = this.input, e = d.prev(
      t,
      "[data-te-input-group-text-ref]"
    )[0];
    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;
  }
  _applyDivs() {
    const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, i = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = d.find(we, this._element), o = D("div");
    c.addClass(o, this._classes.notch), o.setAttribute(ql, ""), this._notchLeading = D("div"), c.addClass(
      this._notchLeading,
      `${this._classes.notchLeading} ${t}`
    ), this._notchLeading.setAttribute(Zl, ""), this._notchMiddle = D("div"), c.addClass(
      this._notchMiddle,
      `${this._classes.notchMiddle} ${e}`
    ), this._notchMiddle.setAttribute(Ql, ""), this._notchTrailing = D("div"), c.addClass(
      this._notchTrailing,
      `${this._classes.notchTrailing} ${i}`
    ), this._notchTrailing.setAttribute(Fp, ""), !(n.length >= 1) && (o.append(this._notchLeading), o.append(this._notchMiddle), o.append(this._notchTrailing), this._element.append(o));
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
  }
  _removeBorder() {
    const t = d.findOne(we, this._element);
    t && t.remove();
  }
  _activate(t) {
    il(() => {
      this._getElements(t);
      const e = t ? t.target : this.input, i = d.findOne(
        we,
        this._element
      );
      t && t.type === "focus" && i.setAttribute(Pr, ""), e.value !== "" && (e.setAttribute(Ft, ""), i.setAttribute(Ft, "")), this._toggleDefaultDatePlaceholder(e);
    });
  }
  _getElements(t) {
    if (t && (this._element = t.target.parentNode, this._label = d.findOne("label", this._element)), t && this._label) {
      const e = this._labelWidth;
      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = d.findOne(
        Wr,
        t.target.parentNode
      ), this._notchLeading = d.findOne(
        Hr,
        t.target.parentNode
      ), this._applyNotch());
    }
  }
  _deactivate(t) {
    const e = t ? t.target : this.input, i = d.findOne(
      we,
      e.parentNode
    );
    i.removeAttribute(Pr), e.value === "" && (e.removeAttribute(Ft), i.removeAttribute(Ft)), this._toggleDefaultDatePlaceholder(e);
  }
  static activate(t) {
    return function(e) {
      t._activate(e);
    };
  }
  static deactivate(t) {
    return function(e) {
      t._deactivate(e);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, Gi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new W(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, Gi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Vr = "animation", Cn = "te.animation", qp = {
  animation: "string",
  animationStart: "string",
  animationShowOnLoad: "boolean",
  onStart: "(null|function)",
  onEnd: "(null|function)",
  onHide: "(null|function)",
  onShow: "(null|function)",
  animationOnScroll: "(string)",
  animationWindowHeight: "number",
  animationOffset: "(number|string)",
  animationDelay: "(number|string)",
  animationReverse: "boolean",
  animationInterval: "(number|string)",
  animationRepeat: "(number|boolean)",
  animationReset: "boolean"
}, Zp = {
  animation: "fade",
  animationStart: "onClick",
  animationShowOnLoad: !0,
  onStart: null,
  onEnd: null,
  onHide: null,
  onShow: null,
  animationOnScroll: "once",
  animationWindowHeight: 0,
  animationOffset: 0,
  animationDelay: 0,
  animationReverse: !1,
  animationInterval: 0,
  animationRepeat: !1,
  animationReset: !1
};
class Jl {
  constructor(t, e) {
    this._element = t, this._animateElement = this._getAnimateElement(), this._isFirstScroll = !0, this._repeatAnimateOnScroll = !0, this._options = this._getConfig(e), this._element && (I.setData(t, Cn, this), this._init());
  }
  // Getters
  static get NAME() {
    return Vr;
  }
  // Public
  init() {
    this._init();
  }
  startAnimation() {
    this._startAnimation();
  }
  stopAnimation() {
    this._clearAnimationClass();
  }
  changeAnimationType(t) {
    this._options.animation = t;
  }
  dispose() {
    h.off(this._element, "mousedown"), h.off(this._animateElement, "animationend"), h.off(window, "scroll"), h.off(this._element, "mouseover"), I.removeData(this._element, Cn), this._element = null, this._animateElement = null, this._isFirstScroll = null, this._repeatAnimateOnScroll = null, this._options = null;
  }
  // Private
  _init() {
    switch (this._options.animationStart) {
      case "onHover":
        this._bindHoverEvents();
        break;
      case "onLoad":
        this._startAnimation();
        break;
      case "onScroll":
        this._bindScrollEvents();
        break;
      case "onClick":
        this._bindClickEvents();
        break;
    }
    this._bindTriggerOnEndCallback(), this._options.animationReset && this._bindResetAnimationAfterFinish();
  }
  _getAnimateElement() {
    const t = c.getDataAttribute(
      this._element,
      "animation-target"
    );
    return t ? d.find(t)[0] : this._element;
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._animateElement);
    return t = {
      ...Zp,
      ...e,
      ...t
    }, L(Vr, t, qp), t;
  }
  _animateOnScroll() {
    const t = c.offset(this._animateElement).top, e = this._animateElement.offsetHeight, i = window.innerHeight, n = t + this._options.animationOffset <= i && t + this._options.animationOffset + e >= 0, o = this._animateElement.style.visibility === "visible";
    switch (!0) {
      case (n && this._isFirstScroll):
        this._isFirstScroll = !1, this._startAnimation();
        break;
      case (!n && this._isFirstScroll):
        this._isFirstScroll = !1, this._hideAnimateElement();
        break;
      case (n && !o && this._repeatAnimateOnScroll):
        this._options.animationOnScroll !== "repeat" && (this._repeatAnimateOnScroll = !1), this._callback(this._options.onShow), this._showAnimateElement(), this._startAnimation();
        break;
      case (!n && o && this._repeatAnimateOnScroll):
        this._hideAnimateElement(), this._clearAnimationClass(), this._callback(this._options.onHide);
        break;
    }
  }
  _addAnimatedClass() {
    c.addClass(
      this._animateElement,
      `animate-${this._options.animation}`
    );
  }
  _clearAnimationClass() {
    this._animateElement.classList.remove(`animate-${this._options.animation}`);
  }
  _startAnimation() {
    this._callback(this._options.onStart), this._addAnimatedClass(), this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(), this._options.animationReverse && this._setAnimationReverse(), this._options.animationDelay && this._setAnimationDelay(), this._options.animationDuration && this._setAnimationDuration(), this._options.animationInterval && this._setAnimationInterval();
  }
  _setAnimationReverse() {
    c.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : "2",
      animationDirection: "alternate"
    });
  }
  _setAnimationDuration() {
    c.style(this._animateElement, {
      animationDuration: `${this._options.animationDuration}ms`
    });
  }
  _setAnimationDelay() {
    c.style(this._animateElement, {
      animationDelay: `${this._options.animationDelay}ms`
    });
  }
  _setAnimationRepeat() {
    c.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : this._options.animationRepeat
    });
  }
  _setAnimationInterval() {
    h.on(this._animateElement, "click", () => {
      this._clearAnimationClass(), setTimeout(() => {
        this._addAnimatedClass();
      }, this._options.animationInterval);
    });
  }
  _hideAnimateElement() {
    c.style(this._animateElement, { visibility: "hidden" });
  }
  _showAnimateElement() {
    c.style(this._animateElement, { visibility: "visible" });
  }
  _bindResetAnimationAfterFinish() {
    h.on(this._animateElement, "animationend", () => {
      this._clearAnimationClass();
    });
  }
  _bindTriggerOnEndCallback() {
    h.on(this._animateElement, "animationend", () => {
      this._callback(this._options.onEnd);
    });
  }
  _bindScrollEvents() {
    this._options.animationShowOnLoad || this._animateOnScroll(), h.on(window, "scroll", () => {
      this._animateOnScroll();
    });
  }
  _bindClickEvents() {
    h.on(this._element, "mousedown", () => {
      this._startAnimation();
    });
  }
  _bindHoverEvents() {
    h.one(this._element, "mouseover", () => {
      this._startAnimation();
    }), h.one(this._animateElement, "animationend", () => {
      setTimeout(() => {
        this._bindHoverEvents();
      }, 100);
    });
  }
  _callback(t) {
    t instanceof Function && t();
  }
  // Static
  static autoInit(t) {
    t._init();
  }
  static jQueryInterface(t) {
    new Jl(this[0], t).init();
  }
  static getInstance(t) {
    return I.getData(t, Cn);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const An = "ripple", qi = "te.ripple", Qp = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%", Jp = ["[data-te-ripple-init]"], Zi = [0, 0, 0], t_ = [
  { name: "primary", gradientColor: "#3B71CA" },
  { name: "secondary", gradientColor: "#9FA6B2" },
  { name: "success", gradientColor: "#14A44D" },
  { name: "danger", gradientColor: "#DC4C64" },
  { name: "warning", gradientColor: "#E4A11B" },
  { name: "info", gradientColor: "#54B4D3" },
  { name: "light", gradientColor: "#fbfbfb" },
  { name: "dark", gradientColor: "#262626" }
], Fr = 0.5, e_ = {
  rippleCentered: !1,
  rippleColor: "",
  rippleColorDark: "",
  rippleDuration: "500ms",
  rippleRadius: 0,
  rippleUnbound: !1
}, i_ = {
  rippleCentered: "boolean",
  rippleColor: "string",
  rippleColorDark: "string",
  rippleDuration: "string",
  rippleRadius: "number",
  rippleUnbound: "boolean"
}, s_ = {
  ripple: "relative overflow-hidden inline-block align-bottom",
  rippleWave: "rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]",
  unbound: "overflow-visible"
}, n_ = {
  ripple: "string",
  rippleWave: "string",
  unbound: "string"
};
class Ue {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && (I.setData(t, qi, this), c.addClass(this._element, this._classes.ripple)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._initialClasses = null, this.init();
  }
  // Getters
  static get NAME() {
    return An;
  }
  // Public
  init() {
    this._addClickEvent(this._element);
  }
  dispose() {
    I.removeData(this._element, qi), h.off(this._element, "click", this._clickHandler), this._element = null, this._options = null;
  }
  // Private
  _autoInit(t) {
    Jp.forEach((e) => {
      d.closest(t.target, e) && (this._element = d.closest(t.target, e));
    }), this._element.style.minWidth || (c.style(this._element, {
      "min-width": getComputedStyle(this._element).width
    }), this._isMinWidthSet = !0), this._options = this._getConfig(), this._classes = this._getClasses(), this._initialClasses = [...this._element.classList], c.addClass(this._element, this._classes.ripple), this._createRipple(t);
  }
  _addClickEvent(t) {
    h.on(t, "mousedown", this._clickHandler);
  }
  _createRipple(t) {
    this._element.className.indexOf(this._classes.ripple) < 0 && c.addClass(this._element, this._classes.ripple);
    const { layerX: e, layerY: i } = t, n = t.offsetX || e, o = t.offsetY || i, r = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), p = {
      offsetX: this._options.rippleCentered ? r / 2 : n,
      offsetY: this._options.rippleCentered ? a / 2 : o,
      height: r,
      width: a
    }, u = this._getDiameter(p), f = this._options.rippleRadius || u / 2, _ = {
      delay: l * Fr,
      duration: l - l * Fr
    }, m = {
      left: this._options.rippleCentered ? `${a / 2 - f}px` : `${n - f}px`,
      top: this._options.rippleCentered ? `${r / 2 - f}px` : `${o - f}px`,
      height: `${this._options.rippleRadius * 2 || u}px`,
      width: `${this._options.rippleRadius * 2 || u}px`,
      transitionDelay: `0s, ${_.delay}ms`,
      transitionDuration: `${l}ms, ${_.duration}ms`
    }, g = D("div");
    this._createHTMLRipple({
      wrapper: this._element,
      ripple: g,
      styles: m
    }), this._removeHTMLRipple({ ripple: g, duration: l });
  }
  _createHTMLRipple({ wrapper: t, ripple: e, styles: i }) {
    Object.keys(i).forEach(
      (n) => e.style[n] = i[n]
    ), c.addClass(e, this._classes.rippleWave), e.setAttribute("data-te-ripple-ref", ""), this._addColor(e, t), this._toggleUnbound(t), this._appendRipple(e, t);
  }
  _removeHTMLRipple({ ripple: t, duration: e }) {
    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), t && setTimeout(() => {
      t.classList.add("!opacity-0");
    }, 10), this._rippleTimer = setTimeout(() => {
      if (t && (t.remove(), this._element)) {
        d.find("[data-te-ripple-ref]", this._element).forEach(
          (n) => {
            n.remove();
          }
        ), this._isMinWidthSet && (c.style(this._element, { "min-width": "" }), this._isMinWidthSet = !1);
        const i = this._initialClasses ? this._addedNewRippleClasses(
          this._classes.ripple,
          this._initialClasses
        ) : this._classes.ripple.split(" ");
        c.removeClass(this._element, i);
      }
    }, e);
  }
  _addedNewRippleClasses(t, e) {
    return t.split(" ").filter(
      (i) => e.findIndex((n) => i === n) === -1
    );
  }
  _durationToMsNumber(t) {
    return Number(t.replace("ms", "").replace("s", "000"));
  }
  _getConfig(t = {}) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...e_,
      ...e,
      ...t
    }, L(An, t, i_), t;
  }
  _getClasses(t = {}) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...s_,
      ...e,
      ...t
    }, L(An, t, n_), t;
  }
  _getDiameter({ offsetX: t, offsetY: e, height: i, width: n }) {
    const o = e <= i / 2, r = t <= n / 2, a = (_, m) => Math.sqrt(_ ** 2 + m ** 2), l = e === i / 2 && t === n / 2, p = {
      first: o === !0 && r === !1,
      second: o === !0 && r === !0,
      third: o === !1 && r === !0,
      fourth: o === !1 && r === !1
    }, u = {
      topLeft: a(t, e),
      topRight: a(n - t, e),
      bottomLeft: a(t, i - e),
      bottomRight: a(n - t, i - e)
    };
    let f = 0;
    return l || p.fourth ? f = u.topLeft : p.third ? f = u.topRight : p.second ? f = u.bottomRight : p.first && (f = u.bottomLeft), f * 2;
  }
  _appendRipple(t, e) {
    e.appendChild(t), setTimeout(() => {
      c.addClass(t, "opacity-0 scale-100");
    }, 50);
  }
  _toggleUnbound(t) {
    this._options.rippleUnbound === !0 ? c.addClass(t, this._classes.unbound) : c.removeClass(t, this._classes.unbound);
  }
  _addColor(t) {
    let e = this._options.rippleColor || "rgb(0,0,0)";
    (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (e = this._options.rippleColorDark || this._options.rippleColor);
    const i = t_.find(
      (r) => r.name === e.toLowerCase()
    ), n = i ? this._colorToRGB(i.gradientColor).join(",") : this._colorToRGB(e).join(","), o = Qp.split("{{color}}").join(`${n}`);
    t.style.backgroundImage = `radial-gradient(circle, ${o})`;
  }
  _colorToRGB(t) {
    function e(o) {
      return o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [
        parseInt(o.substr(1, 2), 16),
        parseInt(o.substr(3, 2), 16),
        parseInt(o.substr(5, 2), 16)
      ];
    }
    function i(o) {
      const r = document.body.appendChild(
        document.createElement("fictum")
      ), a = "rgb(1, 2, 3)";
      return r.style.color = a, r.style.color !== a || (r.style.color = o, r.style.color === a || r.style.color === "") ? Zi : (o = getComputedStyle(r).color, document.body.removeChild(r), o);
    }
    function n(o) {
      return o = o.match(/[.\d]+/g).map((r) => +Number(r)), o.length = 3, o;
    }
    return t.toLowerCase() === "transparent" ? Zi : t[0] === "#" ? e(t) : (t.indexOf("rgb") === -1 && (t = i(t)), t.indexOf("rgb") === 0 ? n(t) : Zi);
  }
  // Static
  static autoInitial(t) {
    return function(e) {
      t._autoInit(e);
    };
  }
  static jQueryInterface(t) {
    return this.each(function() {
      return I.getData(this, qi) ? null : new Ue(this, t);
    });
  }
  static getInstance(t) {
    return I.getData(t, qi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
function Z(s) {
  return s.getDate();
}
function Cs(s) {
  return s.getDay();
}
function Y(s) {
  return s.getMonth();
}
function B(s) {
  return s.getFullYear();
}
function o_(s, t, e) {
  const i = e.startDay, n = i > 0 ? 7 - i : 0, r = new Date(s, t).getDay() + n;
  return r >= 7 ? r - 7 : r;
}
function ro(s) {
  return r_(s).getDate();
}
function r_(s) {
  return Mt(s.getFullYear(), s.getMonth() + 1, 0);
}
function Re() {
  return /* @__PURE__ */ new Date();
}
function it(s, t) {
  return nt(s, t * 12);
}
function nt(s, t) {
  const e = Mt(
    s.getFullYear(),
    s.getMonth() + t,
    s.getDate()
  ), i = Z(s), n = Z(e);
  return i !== n && e.setDate(0), e;
}
function xe(s, t) {
  return Mt(s.getFullYear(), s.getMonth(), s.getDate() + t);
}
function Mt(s, t, e) {
  const i = new Date(s, t, e);
  return s >= 0 && s < 100 && i.setFullYear(i.getFullYear() - 1900), i;
}
function Yr(s) {
  const t = s.split("-"), e = t[0], i = t[1], n = t[2];
  return Mt(e, i, n);
}
function a_(s) {
  return !Number.isNaN(s.getTime());
}
function Me(s, t) {
  return B(s) - B(t) || Y(s) - Y(t) || Z(s) - Z(t);
}
function _e(s, t) {
  return s.setHours(0, 0, 0, 0), t.setHours(0, 0, 0, 0), s.getTime() === t.getTime();
}
function As(s, t) {
  const i = B(s) - c_();
  return l_(i, t);
}
function l_(s, t) {
  return (s % t + t) % t;
}
function c_(s, t, e) {
  let i = 0;
  return e ? i = B(e) - s + 1 : t && (i = B(t)), i;
}
function Ps(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date();
  r.setHours(0, 0, 0, 0);
  const a = t && Me(s, t) <= -1, l = e && Me(s, e) >= 1, p = n && Me(s, r) <= -1, u = o && Me(s, r) >= 1, f = i && i(s) === !1;
  return a || l || f || p || u;
}
function tc(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date(), a = i && B(i), l = i && Y(i), p = e && B(e), u = e && Y(e), f = B(r), _ = Y(r), m = l && a && (t > a || t === a && s > l), g = u && p && (t < p || t === p && s < u), v = n && (t < f || t === f && s < _), b = o && (t > f || t === f && s > _);
  return m || g || v || b;
}
function ao(s, t, e, i, n) {
  const o = t && B(t), r = e && B(e), a = B(/* @__PURE__ */ new Date()), l = r && s > r, p = o && s < o, u = i && s < a, f = n && s > a;
  return l || p || u || f;
}
function h_(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && o && Me(o, l) < 0 || s) && (o = l), o && Ai(
    t,
    o,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function d_(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && n && Me(n, l) < 0 || s) && (n = l), n && Ai(
    t,
    n,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function Ai(s, t, e, i, n, o, r, a) {
  return e === "days" ? B(s) === B(t) && Y(s) === Y(t) : e === "months" ? B(s) === B(t) : e === "years" ? B(t) >= a && B(t) <= r : !1;
}
const u_ = "data-te-datepicker-modal-container-ref", p_ = "data-te-datepicker-dropdown-container-ref", __ = "data-te-dropdown-backdrop-ref", f_ = "data-te-datepicker-date-text-ref", jr = "data-te-datepicker-view-ref", m_ = "data-te-datepicker-previous-button-ref", g_ = "data-te-datepicker-next-button-ref", b_ = "data-te-datepicker-ok-button-ref", v_ = "data-te-datepicker-cancel-button-ref", T_ = "data-te-datepicker-clear-button-ref", E_ = "data-te-datepicker-view-change-button-ref";
function C_(s, t, e, i, n, o, r, a, l, p) {
  const u = Y(s), f = B(s), _ = Z(s), m = Cs(s), g = D("div"), v = `
        ${Kr(
    s,
    u,
    f,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    p
  )}
    `, b = `
      ${y_(_, m, u, n, p)}
      ${Kr(
    s,
    u,
    f,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    p
  )}
    `;
  return n.inline ? (c.addClass(g, p.datepickerDropdownContainer), g.setAttribute(p_, l), g.innerHTML = v) : (c.addClass(g, p.modalContainer), g.setAttribute(u_, l), g.innerHTML = b), g;
}
function A_(s) {
  const t = D("div");
  return c.addClass(t, s), t.setAttribute(__, ""), t;
}
function y_(s, t, e, i, n) {
  return `
      <div class="${n.datepickerHeader}">
        <div class="${n.datepickerTitle}">
          <span class="${n.datepickerTitleText}">${i.title}</span>
        </div>
        <div class="${n.datepickerDate}">
          <span class="${n.datepickerDateText}" ${f_} >${i.weekdaysShort[t]}, ${i.monthsShort[e]} ${s}</span>
        </div>
      </div>
    `;
}
function Kr(s, t, e, i, n, o, r, a, l, p, u) {
  let f;
  return r.inline ? f = `
    <div class="${u.datepickerMain}">
      ${Ur(t, e, r, u)}
      <div class="${u.datepickerView}" ${jr} tabindex="0">
        ${zr(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    p,
    u
  )}
      </div>
    </div>
  ` : f = `
    <div class="${u.datepickerMain}">
      ${Ur(t, e, r, u)}
      <div class="${u.datepickerView}" ${jr} tabindex="0">
        ${zr(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    p,
    u
  )}
      </div>
      ${w_(r, u)}
    </div>
  `, f;
}
function zr(s, t, e, i, n, o, r, a, l, p) {
  let u;
  return o.view === "days" ? u = ys(s, e, o, p) : o.view === "months" ? u = ws(
    t,
    i,
    n,
    o,
    r,
    p
  ) : u = xs(
    s,
    i,
    o,
    a,
    l,
    p
  ), u;
}
function Ur(s, t, e, i) {
  return `
    <div class="${i.datepickerDateControls}">
      <button class="${i.datepickerViewChangeButton}" aria-label="${e.switchToMultiYearViewLabel}" ${E_}>
        ${e.monthsFull[s]} ${t} ${Dt(
    e,
    i
  )}
      </button>
      <div class="${i.datepickerArrowControls}">
        <button class="${i.datepickerPreviousButton}" aria-label="${e.prevMonthLabel}" ${m_}>${e.changeMonthIconTemplate}</button>
        <button class="${i.datepickerNextButton}" aria-label="${e.nextMonthLabel}" ${g_}>${e.changeMonthIconTemplate}</button>
      </div>
    </div>
    `;
}
function Dt(s, t) {
  return `
  <span class="${t.datepickerViewChangeIcon}">
  ${s.viewChangeIconTemplate}
  </span>
  `;
}
function w_(s, t) {
  const e = `<button class="${t.datepickerFooterBtn}" aria-label="${s.okBtnLabel}" ${b_}>${s.okBtnText}</button>`, i = `<button class="${t.datepickerFooterBtn}" aria-label="${s.cancelBtnLabel}" ${v_}>${s.cancelBtnText}</button>`, n = `<button class="${t.datepickerFooterBtn} ${t.datepickerClearBtn}" aria-label="${s.clearBtnLabel}" ${T_}>${s.clearBtnText}</button>`;
  return `
        <div class="${t.datepickerFooter}">
          
        ${s.removeClearBtn ? "" : n}
        ${s.removeCancelBtn ? "" : i}
        ${s.removeOkBtn ? "" : e}
        </div>
      `;
}
function ys(s, t, e, i) {
  const n = x_(s, t, e), r = `
      <tr>
        ${e.weekdaysNarrow.map((l, p) => `<th class="${i.datepickerDayHeading}" scope="col" aria-label="${e.weekdaysFull[p]}">${l}</th>`).join("")}
      </tr>
    `, a = n.map((l) => `
        <tr>
          ${l.map((p) => `
              <td
              class="${i.datepickerCell} ${i.datepickerCellSmall}"
              data-te-date="${B(p.date)}-${Y(
    p.date
  )}-${Z(p.date)}"
              aria-label="${p.date}"
              aria-selected="${p.isSelected}"
              ${p.isSelected ? "data-te-datepicker-cell-selected" : ""}
              ${!p.currentMonth || p.disabled ? "data-te-datepicker-cell-disabled" : ""}
              ${p.isToday ? "data-te-datepicker-cell-current" : ""}
              >
                <div
                  class="${i.datepickerCellContent} ${i.datepickerCellContentSmall}"
                  style="${p.currentMonth ? "display: block" : "display: none"}"
                  >
                  ${p.dayNumber}
                  </div>
              </td>
            `).join("")}
        </tr>
      `).join("");
  return `
      <table class="${i.datepickerTable}">
        <thead>
          ${r}
        </thead>
        <tbody>
         ${a}
        </tbody>
      </table>
    `;
}
function x_(s, t, e) {
  const i = [], n = Y(s), o = Y(nt(s, -1)), r = Y(nt(s, 1)), a = B(s), l = o_(a, n, e), p = ro(s), u = ro(nt(s, -1)), f = 7;
  let _ = 1, m = !1;
  for (let g = 1; g < f; g++) {
    const v = [];
    if (g === 1) {
      const b = u - l + 1;
      for (let y = b; y <= u; y++) {
        const E = Mt(a, o, y);
        v.push({
          date: E,
          currentMonth: m,
          isSelected: t && _e(E, t),
          isToday: _e(E, Re()),
          dayNumber: Z(E)
        });
      }
      m = !0;
      const C = f - v.length;
      for (let y = 0; y < C; y++) {
        const E = Mt(a, n, _);
        v.push({
          date: E,
          currentMonth: m,
          isSelected: t && _e(E, t),
          isToday: _e(E, Re()),
          dayNumber: Z(E),
          disabled: Ps(
            E,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), _++;
      }
    } else
      for (let b = 1; b < 8; b++) {
        _ > p && (_ = 1, m = !1);
        const C = Mt(
          a,
          m ? n : r,
          _
        );
        v.push({
          date: C,
          currentMonth: m,
          isSelected: t && _e(C, t),
          isToday: _e(C, Re()),
          dayNumber: Z(C),
          disabled: Ps(
            C,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), _++;
      }
    i.push(v);
  }
  return i;
}
function ws(s, t, e, i, n, o) {
  const r = k_(i, n), a = Y(Re()), l = B(Re()), p = `
      ${r.map((u) => `
          <tr>
            ${u.map((f) => {
    const _ = i.monthsShort.indexOf(f);
    return `
                <td class="${o.datepickerCell} ${o.datepickerCellLarge}"
                ${tc(
      _,
      s,
      i.min,
      i.max,
      i.disablePast,
      i.disableFuture
    ) ? "data-te-datepicker-cell-disabled" : ""}
                
                data-te-month="${_}" data-te-year="${s}" aria-label="${f}, ${s}"
                ${_ === e && s === t ? "data-te-datepicker-cell-selected" : ""}
                ${_ === a && s === l ? "data-te-datepicker-cell-current" : ""}" data-te-month="${_}" data-te-year="${s}" aria-label="${f}, ${s}">
                  <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${f}</div>
                </td>
              `;
  }).join("")}
          </tr>
        `).join("")}
    `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
         ${p}
        </tbody>
      </table>
    `;
}
function k_(s, t) {
  const e = [];
  let i = [];
  for (let n = 0; n < s.monthsShort.length; n++)
    if (i.push(s.monthsShort[n]), i.length === t) {
      const o = i;
      e.push(o), i = [];
    }
  return e;
}
function xs(s, t, e, i, n, o) {
  const r = O_(s, i, n), a = B(Re()), l = `
    ${r.map((p) => `
        <tr>
          ${p.map((u) => `
              <td class="${o.datepickerCell} ${o.datepickerCellLarge}"  aria-label="${u}" data-te-year="${u}"
              ${ao(
    u,
    e.min,
    e.max,
    e.disablePast,
    e.disableFuture
  ) ? "data-te-datepicker-cell-disabled" : ""}
              ${u === t ? "data-te-datepicker-cell-selected" : ""}
              ${u === a ? "data-te-datepicker-cell-current" : ""}
              >
                <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${u}</div>
              </td>
            `).join("")}
        </tr>
      `).join("")}
  `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
        ${l}
        </tbody>
      </table>
    `;
}
function O_(s, t, e) {
  const i = [], n = B(s), o = As(s, t), r = n - o;
  let a = [];
  for (let l = 0; l < t; l++)
    if (a.push(r + l), a.length === e) {
      const p = a;
      i.push(p), a = [];
    }
  return i;
}
function S_(s, t) {
  return `
    <button id="${s}" type="button" class="${t}" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
      <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z" clip-rule="evenodd" />
      </svg>  
    </button>
  `;
}
const Pe = 37, rt = 38, Be = 39, z = 40, He = 36, We = 35, yn = 33, wn = 34, lt = 13, ks = 32, Li = 27, Oi = 9, I_ = 8, D_ = 46, gt = 24, Qi = 4, Ji = 4, xn = "datepicker", Os = "te.datepicker", Ys = `.${Os}`, $_ = ".data-api", L_ = `close${Ys}`, M_ = `open${Ys}`, N_ = `dateChange${Ys}`, ts = `click${Ys}${$_}`, ec = "data-te-datepicker-modal-container-ref", ic = "data-te-datepicker-dropdown-container-ref", es = "[data-te-datepicker-toggle-ref]", R_ = `[${ec}]`, P_ = `[${ic}]`, B_ = "[data-te-datepicker-view-change-button-ref]", H_ = "[data-te-datepicker-previous-button-ref]", W_ = "[data-te-datepicker-next-button-ref]", V_ = "[data-te-datepicker-ok-button-ref]", F_ = "[data-te-datepicker-cancel-button-ref]", Y_ = "[data-te-datepicker-clear-button-ref]", j_ = "[data-te-datepicker-view-ref]", K_ = "[data-te-datepicker-toggle-button-ref]", z_ = "[data-te-datepicker-date-text-ref]", U_ = "[data-te-dropdown-backdrop-ref]", X_ = "animate-[fade-in_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", G_ = "animate-[fade-out_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", q_ = "animate-[fade-in_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", Z_ = "animate-[fade-out_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", Q_ = "flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700", J_ = "w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]", tf = "relative h-full", ef = "xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800", sf = "h-8 flex flex-col justify-end", nf = "text-[10px] font-normal uppercase tracking-[1.7px] text-white", of = "xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end", rf = "text-[34px] font-normal text-white", af = "outline-none px-3", lf = "px-3 pt-2.5 pb-0 flex justify-between text-black/[64]", cf = "flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", hf = "mt-2.5", df = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto", uf = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto", pf = "h-14 flex absolute w-full bottom-0 justify-end items-center px-3", _f = "outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", ff = "mr-auto", mf = "w-10 h-10 text-center text-[12px] font-normal dark:text-white", gf = "text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group", bf = "w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8", vf = "w-[76px] h-[42px]", Tf = "mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:text-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10 dark:group-[[data-te-datepicker-cell-disabled]]:text-neutral-500", Ef = "w-9 h-9 leading-9 rounded-[50%] text-[13px]", Cf = "w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]", Af = "mx-auto w-[304px]", yf = "flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200", wf = "inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white", xf = "w-[328px] h-[380px] bg-white rounded-lg shadow-[0px_2px_15px_-3px_rgba(0,0,0,.07),_0px_10px_20px_-2px_rgba(0,0,0,.04)] z-[1066] dark:bg-zinc-700", kf = {
  title: "Select date",
  container: "body",
  disablePast: !1,
  disableFuture: !1,
  monthsFull: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  monthsShort: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  weekdaysFull: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  weekdaysNarrow: ["S", "M", "T", "W", "T", "F", "S"],
  okBtnText: "Ok",
  clearBtnText: "Clear",
  cancelBtnText: "Cancel",
  okBtnLabel: "Confirm selection",
  clearBtnLabel: "Clear selection",
  cancelBtnLabel: "Cancel selection",
  nextMonthLabel: "Next month",
  prevMonthLabel: "Previous month",
  nextYearLabel: "Next year",
  prevYearLabel: "Previous year",
  changeMonthIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
  </svg>
  `,
  nextMultiYearLabel: "Next 24 years",
  prevMultiYearLabel: "Previous 24 years",
  switchToMultiYearViewLabel: "Choose year and month",
  switchToMonthViewLabel: "Choose date",
  switchToDayViewLabel: "Choose date",
  startDate: null,
  startDay: 0,
  format: "dd/mm/yyyy",
  view: "days",
  viewChangeIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="0" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
  </svg>
  `,
  min: null,
  max: null,
  filter: null,
  inline: !1,
  toggleButton: !0,
  disableToggleButton: !1,
  disableInput: !1,
  animations: !0,
  confirmDateOnSelect: !1,
  removeOkBtn: !1,
  removeCancelBtn: !1,
  removeClearBtn: !1
}, Of = {
  title: "string",
  container: "string",
  disablePast: "boolean",
  disableFuture: "boolean",
  monthsFull: "array",
  monthsShort: "array",
  weekdaysFull: "array",
  weekdaysShort: "array",
  weekdaysNarrow: "array",
  okBtnText: "string",
  clearBtnText: "string",
  cancelBtnText: "string",
  okBtnLabel: "string",
  clearBtnLabel: "string",
  cancelBtnLabel: "string",
  nextMonthLabel: "string",
  prevMonthLabel: "string",
  nextYearLabel: "string",
  prevYearLabel: "string",
  nextMultiYearLabel: "string",
  prevMultiYearLabel: "string",
  changeMonthIconTemplate: "string",
  switchToMultiYearViewLabel: "string",
  switchToMonthViewLabel: "string",
  switchToDayViewLabel: "string",
  startDate: "(null|string|date)",
  startDay: "number",
  format: "string",
  view: "string",
  viewChangeIconTemplate: "string",
  min: "(null|string|date)",
  max: "(null|string|date)",
  filter: "(null|function)",
  inline: "boolean",
  toggleButton: "boolean",
  disableToggleButton: "boolean",
  disableInput: "boolean",
  animations: "boolean",
  confirmDateOnSelect: "boolean",
  removeOkBtn: "boolean",
  removeCancelBtn: "boolean",
  removeClearBtn: "boolean"
}, Sf = {
  fadeIn: X_,
  fadeOut: G_,
  fadeInShort: q_,
  fadeOutShort: Z_,
  modalContainer: Q_,
  datepickerBackdrop: J_,
  datepickerMain: tf,
  datepickerHeader: ef,
  datepickerTitle: sf,
  datepickerTitleText: nf,
  datepickerDate: of,
  datepickerDateText: rf,
  datepickerView: af,
  datepickerDateControls: lf,
  datepickerViewChangeButton: cf,
  datepickerViewChangeIcon: wf,
  datepickerArrowControls: hf,
  datepickerPreviousButton: df,
  datepickerNextButton: uf,
  datepickerFooter: pf,
  datepickerFooterBtn: _f,
  datepickerClearBtn: ff,
  datepickerDayHeading: mf,
  datepickerCell: gf,
  datepickerCellSmall: bf,
  datepickerCellLarge: vf,
  datepickerCellContent: Tf,
  datepickerCellContentSmall: Ef,
  datepickerCellContentLarge: Cf,
  datepickerTable: Af,
  datepickerToggleButton: yf,
  datepickerDropdownContainer: xf
}, If = {
  fadeIn: "string",
  fadeOut: "string",
  fadeInShort: "string",
  fadeOutShort: "string",
  modalContainer: "string",
  datepickerBackdrop: "string",
  datepickerMain: "string",
  datepickerHeader: "string",
  datepickerTitle: "string",
  datepickerTitleText: "string",
  datepickerDate: "string",
  datepickerDateText: "string",
  datepickerView: "string",
  datepickerDateControls: "string",
  datepickerViewChangeButton: "string",
  datepickerArrowControls: "string",
  datepickerPreviousButton: "string",
  datepickerNextButton: "string",
  datepickerFooter: "string",
  datepickerFooterBtn: "string",
  datepickerClearBtn: "string",
  datepickerDayHeading: "string",
  datepickerCell: "string",
  datepickerCellSmall: "string",
  datepickerCellLarge: "string",
  datepickerCellContent: "string",
  datepickerCellContentSmall: "string",
  datepickerCellContentLarge: "string",
  datepickerTable: "string",
  datepickerToggleButton: "string",
  datepickerDropdownContainer: "string"
};
class F0 {
  constructor(t, e, i) {
    this._element = t, this._input = d.findOne("input", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = bt("datepicker-toggle-"), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this._scrollBar = new ki(), this._element && I.setData(t, Os, this), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = "true"), this._options.disableInput && (this._input.disabled = "true");
  }
  // Getters
  static get NAME() {
    return xn;
  }
  get container() {
    return d.findOne(
      `[${ec}='${this._toggleButtonId}']`
    ) || d.findOne(
      `[${ic}='${this._toggleButtonId}']`
    );
  }
  get options() {
    return this._options;
  }
  get activeCell() {
    let t;
    return this._view === "days" && (t = this._getActiveDayCell()), this._view === "months" && (t = this._getActiveMonthCell()), this._view === "years" && (t = this._getActiveYearCell()), t;
  }
  get activeDay() {
    return Z(this._activeDate);
  }
  get activeMonth() {
    return Y(this._activeDate);
  }
  get activeYear() {
    return B(this._activeDate);
  }
  get firstYearInView() {
    return this.activeYear - As(this._activeDate, gt);
  }
  get lastYearInView() {
    return this.firstYearInView + gt - 1;
  }
  get viewChangeButton() {
    return d.findOne(B_, this.container);
  }
  get previousButton() {
    return d.findOne(H_, this.container);
  }
  get nextButton() {
    return d.findOne(W_, this.container);
  }
  get okButton() {
    return d.findOne(V_, this.container);
  }
  get cancelButton() {
    return d.findOne(F_, this.container);
  }
  get clearButton() {
    return d.findOne(Y_, this.container);
  }
  get datesContainer() {
    return d.findOne(j_, this.container);
  }
  get toggleButton() {
    return d.findOne(K_, this._element);
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    if (t = {
      ...kf,
      ...e,
      ...t
    }, L(xn, t, Of), t.max && typeof t.max == "string" && (t.max = new Date(t.max)), t.min && typeof t.min == "string" && (t.min = new Date(t.min)), t.startDay && t.startDay !== 0) {
      const i = this._getNewDaysOrderArray(t);
      t.weekdaysNarrow = i;
    }
    return t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Sf,
      ...e,
      ...t
    }, L(xn, t, If), t;
  }
  _getContainer() {
    return d.findOne(this._options.container);
  }
  _getNewDaysOrderArray(t) {
    const e = t.startDay, i = t.weekdaysNarrow;
    return i.slice(e).concat(i.slice(0, e));
  }
  _init() {
    !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = "none")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown();
  }
  _appendToggleButton() {
    const t = S_(
      this._toggleButtonId,
      this._classes.datepickerToggleButton
    );
    this._element.insertAdjacentHTML("beforeend", t);
  }
  open() {
    if (this._input.readOnly || this._input.disabled)
      return;
    const t = h.trigger(this._element, M_);
    if (this._isOpen || t.defaultPrevented)
      return;
    this._setInitialDate();
    const e = A_(this._classes.datepickerBackdrop), i = C_(
      this._activeDate,
      this._selectedDate,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Ji,
      gt,
      Qi,
      this._toggleButtonId,
      this._classes
    );
    this._options.inline ? this._openDropdown(i) : (this._openModal(e, i), this._scrollBar.hide()), this._animations && (c.addClass(this.container, this._classes.fadeIn), c.addClass(e, this._classes.fadeInShort)), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(() => {
      this._listenToOutsideClick();
    }, 0);
  }
  _openDropdown(t) {
    this._popper = Ee(this._input, t, {
      placement: "bottom-start"
    }), this._getContainer().appendChild(t);
  }
  _openModal(t, e) {
    const i = this._getContainer();
    i.appendChild(t), i.appendChild(e);
  }
  _setFocusTrap(t) {
    this._focusTrap = new $i(t, {
      event: "keydown",
      condition: (e) => e.key === "Tab"
    }), this._focusTrap.trap();
  }
  _listenToUserInput() {
    h.on(this._input, "input", (t) => {
      this._handleUserInput(t.target.value);
    });
  }
  _listenToToggleClick() {
    h.on(
      this._element,
      ts,
      es,
      (t) => {
        t.preventDefault(), this.open();
      }
    );
  }
  _listenToToggleKeydown() {
    h.on(
      this._element,
      "keydown",
      es,
      (t) => {
        t.keyCode === lt && !this._isOpen && this.open();
      }
    );
  }
  _listenToDateSelection() {
    h.on(this.datesContainer, "click", (t) => {
      this._handleDateSelection(t);
    });
  }
  _handleDateSelection(t) {
    const e = t.target.nodeName === "DIV" ? t.target.parentNode.dataset : t.target.dataset, i = t.target.nodeName === "DIV" ? t.target.parentNode : t.target;
    if (e.teDate && this._pickDay(e.teDate, i), e.teMonth && e.teYear) {
      const n = parseInt(e.teMonth, 10), o = parseInt(e.teYear, 10);
      this._pickMonth(n, o);
    }
    if (e.teYear && !e.teMonth) {
      const n = parseInt(e.teYear, 10);
      this._pickYear(n);
    }
    this._options.inline || this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _updateHeaderDate(t, e, i) {
    const n = d.findOne(
      z_,
      this.container
    ), o = Y(t), r = Z(t), a = Cs(t);
    n.innerHTML = `${i[a]}, ${e[o]} ${r}`;
  }
  _addControlsListeners() {
    h.on(this.nextButton, "click", () => {
      this._view === "days" ? this.nextMonth() : this._view === "years" ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState();
    }), h.on(this.previousButton, "click", () => {
      this._view === "days" ? this.previousMonth() : this._view === "years" ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState();
    }), h.on(this.viewChangeButton, "click", () => {
      this._view === "days" ? this._changeView("years") : (this._view === "years" || this._view === "months") && this._changeView("days");
    }), this._options.inline || this._listenToFooterButtonsClick();
  }
  _listenToFooterButtonsClick() {
    h.on(this.okButton, "click", () => this.handleOk()), h.on(this.cancelButton, "click", () => this.handleCancel()), h.on(this.clearButton, "click", () => this.handleClear());
  }
  _listenToOutsideClick() {
    h.on(document, ts, (t) => {
      const e = t.target === this.container, i = this.container && this.container.contains(t.target);
      !e && !i && this.close();
    });
  }
  _listenToEscapeClick() {
    h.on(document, "keydown", (t) => {
      t.keyCode === Li && this._isOpen && this.close();
    });
  }
  _listenToKeyboardNavigation() {
    h.on(this.datesContainer, "keydown", (t) => {
      this._handleKeydown(t);
    });
  }
  _listenToDatesContainerFocus() {
    h.on(this.datesContainer, "focus", () => {
      this._focusActiveCell(this.activeCell);
    });
  }
  _listenToDatesContainerBlur() {
    h.on(this.datesContainer, "blur", () => {
      this._removeCurrentFocusStyles();
    });
  }
  _handleKeydown(t) {
    this._view === "days" && this._handleDaysViewKeydown(t), this._view === "months" && this._handleMonthsViewKeydown(t), this._view === "years" && this._handleYearsViewKeydown(t);
  }
  _handleDaysViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Pe:
        this._activeDate = xe(this._activeDate, F() ? 1 : -1);
        break;
      case Be:
        this._activeDate = xe(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = xe(this._activeDate, -7);
        break;
      case z:
        this._activeDate = xe(this._activeDate, 7);
        break;
      case He:
        this._activeDate = xe(
          this._activeDate,
          1 - Z(this._activeDate)
        );
        break;
      case We:
        this._activeDate = xe(
          this._activeDate,
          ro(this._activeDate) - Z(this._activeDate)
        );
        break;
      case yn:
        this._activeDate = nt(this._activeDate, -1);
        break;
      case wn:
        this._activeDate = nt(this._activeDate, 1);
        break;
      case lt:
      case ks:
        this._selectDate(this._activeDate), this._handleDateSelection(t), t.preventDefault();
        return;
      default:
        return;
    }
    Ai(
      e,
      this._activeDate,
      this._view,
      gt,
      this._options.min,
      this._options.max
    ) || this._changeView("days"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _asyncFocusDatesContainer() {
    setTimeout(() => {
      this.datesContainer.focus();
    }, 0);
  }
  _focusActiveCell(t) {
    t && t.setAttribute("data-te-datepicker-cell-focused", "");
  }
  _removeHighlightFromCell(t) {
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  _getActiveDayCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = Yr(i.dataset.teDate);
      return _e(n, this._activeDate);
    });
  }
  _handleMonthsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Pe:
        this._activeDate = nt(this._activeDate, F() ? 1 : -1);
        break;
      case Be:
        this._activeDate = nt(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = nt(this._activeDate, -4);
        break;
      case z:
        this._activeDate = nt(this._activeDate, 4);
        break;
      case He:
        this._activeDate = nt(this._activeDate, -this.activeMonth);
        break;
      case We:
        this._activeDate = nt(this._activeDate, 11 - this.activeMonth);
        break;
      case yn:
        this._activeDate = it(this._activeDate, -1);
        break;
      case wn:
        this._activeDate = it(this._activeDate, 1);
        break;
      case lt:
      case ks:
        this._selectMonth(this.activeMonth);
        return;
      default:
        return;
    }
    Ai(
      e,
      this._activeDate,
      this._view,
      gt,
      this._options.min,
      this._options.max
    ) || this._changeView("months"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveMonthCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = parseInt(i.dataset.teYear, 10), o = parseInt(i.dataset.teMonth, 10);
      return n === this.activeYear && o === this.activeMonth;
    });
  }
  _handleYearsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell, n = 4, o = 24;
    switch (t.keyCode) {
      case Pe:
        this._activeDate = it(this._activeDate, F() ? 1 : -1);
        break;
      case Be:
        this._activeDate = it(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = it(this._activeDate, -n);
        break;
      case z:
        this._activeDate = it(this._activeDate, n);
        break;
      case He:
        this._activeDate = it(
          this._activeDate,
          -As(this._activeDate, o)
        );
        break;
      case We:
        this._activeDate = it(
          this._activeDate,
          o - As(this._activeDate, o) - 1
        );
        break;
      case yn:
        this._activeDate = it(this._activeDate, -o);
        break;
      case wn:
        this._activeDate = it(this._activeDate, o);
        break;
      case lt:
      case ks:
        this._selectYear(this.activeYear);
        return;
      default:
        return;
    }
    Ai(
      e,
      this._activeDate,
      this._view,
      gt,
      this._options.min,
      this._options.max
    ) || this._changeView("years"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveYearCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => parseInt(i.dataset.teYear, 10) === this.activeYear);
  }
  _setInitialDate() {
    this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = /* @__PURE__ */ new Date();
  }
  close() {
    const t = h.trigger(this._element, L_);
    !this._isOpen || t.defaultPrevented || (this._removeDatepickerListeners(), this._animations && c.addClass(this.container, this._classes.fadeOut), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, this.toggleButton ? this.toggleButton.focus() : this._input.focus());
  }
  _closeDropdown() {
    const t = d.findOne(P_), e = this._getContainer();
    window.matchMedia("(prefers-reduced-motion: reduce)").matches && (t && e.removeChild(t), this._popper && this._popper.destroy()), t.addEventListener("animationend", () => {
      t && e.removeChild(t), this._popper && this._popper.destroy();
    }), this._removeFocusTrap();
  }
  _closeModal() {
    const t = d.findOne(U_), e = d.findOne(R_);
    !e || !t || (this._animations ? (c.addClass(t, this._classes.fadeOutShort), t.addEventListener("animationend", () => {
      this._removePicker(t, e), this._scrollBar.reset();
    })) : (this._removePicker(t, e), this._scrollBar.reset()));
  }
  _removePicker(t, e) {
    const i = this._getContainer();
    i.removeChild(t), i.removeChild(e);
  }
  _removeFocusTrap() {
    this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null);
  }
  _removeDatepickerListeners() {
    h.off(this.nextButton, "click"), h.off(this.previousButton, "click"), h.off(this.viewChangeButton, "click"), h.off(this.okButton, "click"), h.off(this.cancelButton, "click"), h.off(this.clearButton, "click"), h.off(this.datesContainer, "click"), h.off(this.datesContainer, "keydown"), h.off(this.datesContainer, "focus"), h.off(this.datesContainer, "blur"), h.off(document, ts);
  }
  dispose() {
    this._isOpen && this.close(), this._removeInputAndToggleListeners();
    const t = d.findOne(
      `#${this._toggleButtonId}`
    );
    t && this._element.removeChild(t), I.removeData(this._element, Os), this._element = null, this._input = null, this._options = null, this._activeDate = null, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = null, this._popper = null, this._focusTrap = null;
  }
  _removeInputAndToggleListeners() {
    h.off(this._input, "input"), h.off(
      this._element,
      ts,
      es
    ), h.off(this._element, "keydown", es);
  }
  handleOk() {
    this._confirmSelection(this._headerDate), this.close();
  }
  _selectDate(t, e = this.activeCell) {
    const { min: i, max: n, filter: o, disablePast: r, disableFuture: a } = this._options;
    Ps(t, i, n, o, r, a) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = B(t), this._selectedMonth = Y(t), this._headerDate = t, (this._options.inline || this.options.confirmDateOnSelect) && (this._confirmSelection(t), this.close()));
  }
  _selectYear(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView("months");
  }
  _selectMonth(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView("days");
  }
  _removeSelectedStyles(t) {
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _addSelectedStyles(t) {
    t && t.setAttribute("data-te-datepicker-cell-selected", "");
  }
  _confirmSelection(t) {
    if (t) {
      const e = this.formatDate(t);
      this._input.value = e, h.trigger(this._element, N_, { date: t }), h.trigger(this._input, "input");
    }
  }
  handleCancel() {
    this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close();
  }
  handleClear() {
    this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = "", this._setInitialDate(), this._changeView("days"), this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _removeCurrentSelectionStyles() {
    const t = d.findOne(
      "[data-te-datepicker-cell-selected]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _removeCurrentFocusStyles() {
    const t = d.findOne(
      "[data-te-datepicker-cell-focused]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  formatDate(t) {
    const e = Z(t), i = this._addLeadingZero(Z(t)), n = this._options.weekdaysShort[Cs(t)], o = this._options.weekdaysFull[Cs(t)], r = Y(t) + 1, a = this._addLeadingZero(Y(t) + 1), l = this._options.monthsShort[Y(t)], p = this._options.monthsFull[Y(t)], u = B(t).toString().length === 2 ? B(t) : B(t).toString().slice(2, 4), f = B(t), _ = this._options.format.split(
      /(d{1,4}|m{1,4}|y{4}|yy|!.)/g
    );
    let m = "";
    return _.forEach((g) => {
      switch (g) {
        case "dddd":
          g = g.replace(g, o);
          break;
        case "ddd":
          g = g.replace(g, n);
          break;
        case "dd":
          g = g.replace(g, i);
          break;
        case "d":
          g = g.replace(g, e);
          break;
        case "mmmm":
          g = g.replace(g, p);
          break;
        case "mmm":
          g = g.replace(g, l);
          break;
        case "mm":
          g = g.replace(g, a);
          break;
        case "m":
          g = g.replace(g, r);
          break;
        case "yyyy":
          g = g.replace(g, f);
          break;
        case "yy":
          g = g.replace(g, u);
          break;
      }
      m += g;
    }), m;
  }
  _addLeadingZero(t) {
    return parseInt(t, 10) < 10 ? `0${t}` : t;
  }
  _pickDay(t, e) {
    const i = Yr(t), { min: n, max: o, filter: r, disablePast: a, disableFuture: l } = this._options;
    Ps(i, n, o, r, a, l) || (this._activeDate = i, this._selectDate(i, e));
  }
  _pickYear(t) {
    const { min: e, max: i, disablePast: n, disableFuture: o } = this._options;
    if (ao(t, e, i, n, o))
      return;
    const r = Mt(t, this.activeMonth, this.activeDay);
    this._activeDate = r, this._selectedDate = r, this._selectYear(t);
  }
  _pickMonth(t, e) {
    const { min: i, max: n, disablePast: o, disableFuture: r } = this._options;
    if (tc(t, e, i, n, o, r) || ao(e, i, n, o, r))
      return;
    const a = Mt(e, t, this.activeDay);
    this._activeDate = a, this._selectMonth(t);
  }
  nextMonth() {
    const t = nt(this._activeDate, 1), e = ys(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this._activeDate = t, this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousMonth() {
    const t = nt(this._activeDate, -1);
    this._activeDate = t;
    const e = ys(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  nextYear() {
    const t = it(this._activeDate, 1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    );
    const e = ws(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Ji,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  previousYear() {
    const t = it(this._activeDate, -1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    );
    const e = ws(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Ji,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  nextYears() {
    const t = it(this._activeDate, 24);
    this._activeDate = t;
    const e = xs(
      t,
      this._selectedYear,
      this._options,
      gt,
      Qi,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousYears() {
    const t = it(this._activeDate, -24);
    this._activeDate = t;
    const e = xs(
      t,
      this._selectedYear,
      this._options,
      gt,
      Qi,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  _asyncChangeView(t) {
    setTimeout(() => {
      this._changeView(t);
    }, 0);
  }
  _changeView(t) {
    this._view = t, this.datesContainer.blur(), t === "days" && (this.datesContainer.innerHTML = ys(
      this._activeDate,
      this._headerDate,
      this._options,
      this._classes
    )), t === "months" && (this.datesContainer.innerHTML = ws(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Ji,
      this._classes
    )), t === "years" && (this.datesContainer.innerHTML = xs(
      this._activeDate,
      this._selectedYear,
      this._options,
      gt,
      Qi,
      this._classes
    )), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState();
  }
  _updateViewControlsAndAttributes(t) {
    t === "days" && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMultiYearViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMonthLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextMonthLabel)), t === "months" && (this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToDayViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevYearLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextYearLabel)), t === "years" && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMonthViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMultiYearLabel
    ), this.nextButton.setAttribute(
      "aria-label",
      this._options.nextMultiYearLabel
    ));
  }
  _updateControlsDisabledState() {
    h_(
      this._options.disableFuture,
      this._activeDate,
      this._view,
      gt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.nextButton.disabled = !0 : this.nextButton.disabled = !1, d_(
      this._options.disablePast,
      this._activeDate,
      this._view,
      gt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.previousButton.disabled = !0 : this.previousButton.disabled = !1;
  }
  _handleUserInput(t) {
    const e = this._getDelimeters(this._options.format), i = this._parseDate(t, this._options.format, e);
    a_(i) ? (this._activeDate = i, this._selectedDate = i, this._selectedYear = B(i), this._selectedMonth = Y(i), this._headerDate = i) : (this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null);
  }
  _getDelimeters(t) {
    return t.match(/[^(dmy)]{1,}/g);
  }
  _parseDate(t, e, i) {
    let n;
    i[0] !== i[1] ? n = i[0] + i[1] : n = i[0];
    const o = new RegExp(`[${n}]`), r = t.split(o), a = e.split(o), l = e.indexOf("mmm") !== -1, p = [];
    for (let v = 0; v < a.length; v++)
      a[v].indexOf("yy") !== -1 && (p[0] = { value: r[v], format: a[v] }), a[v].indexOf("m") !== -1 && (p[1] = { value: r[v], format: a[v] }), a[v].indexOf("d") !== -1 && a[v].length <= 2 && (p[2] = { value: r[v], format: a[v] });
    let u;
    e.indexOf("mmmm") !== -1 ? u = this._options.monthsFull : u = this._options.monthsShort;
    const f = Number(p[0].value), _ = l ? this.getMonthNumberByMonthName(p[1].value, u) : Number(p[1].value) - 1, m = Number(p[2].value);
    return Mt(f, _, m);
  }
  getMonthNumberByMonthName(t, e) {
    return e.findIndex((i) => i === t);
  }
  static getInstance(t) {
    return I.getData(t, Os);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Df = ({
  format24: s,
  okLabel: t,
  cancelLabel: e,
  headID: i,
  footerID: n,
  bodyID: o,
  pickerID: r,
  clearLabel: a,
  inline: l,
  showClearBtn: p,
  amLabel: u,
  pmLabel: f
}, _) => {
  const m = `<div id='${r}' class='${_.timepickerWrapper}' data-te-timepicker-wrapper>
      <div class="${_.timepickerContainer}">
        <div class="${_.timepickerElements}">
        <div id='${i}' class='${_.timepickerHead}' style='padding-right:${s ? 50 : 10}px'>
        <div class='${_.timepickerHeadContent}'>
            <div class="${_.timepickerCurrentWrapper}">
              <span class="${_.timepickerCurrentButtonWrapper}">
                <button type='button' class='${_.timepickerCurrentButton}' tabindex="0" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>
              </span>
              <button type='button' class='${_.timepickerDot}' disabled>:</button>
            <span class="${_.timepickerCurrentButtonWrapper}">
              <button type='button' class='${_.timepickerCurrentButton}' tabindex="0" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>
            </span>
            </div>
            ${s ? "" : `<div class="${_.timepickerModeWrapper}">
                  <button type='button' class="${_.timepickerModeAm}" tabindex="0" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${u}</button>
                  <button class="${_.timepickerModePm}" tabindex="0" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${f}</button>
                </div>`}
        </div>
      </div>
      ${l ? "" : `<div id='${o}' class='${_.timepickerClockWrapper}' data-te-timepicker-clock-wrapper>
            <div class='${_.timepickerClock}' data-te-timepicker-clock>
              <span class='${_.timepickerMiddleDot}' data-te-timepicker-middle-dot></span>
              <div class='${_.timepickerHandPointer}' data-te-timepicker-hand-pointer>
                <div class='${_.timepickerPointerCircle}' data-te-timepicker-circle></div>
              </div>
              ${s ? '<div class="' + _.timepickerClockInner + '" data-te-timepicker-clock-inner></div>' : ""}
            </div>
          </div>`}
    </div>
    <div id='${n}' class='${_.timepickerFooterWrapper}'>
      <div class="${_.timepickerFooter}">
        ${p ? `<button type='button' class='${_.timepickerFooterButton}' data-te-timepicker-clear tabindex="0" data-te-ripple-init>${a}</button>` : ""}
        <button type='button' class='${_.timepickerFooterButton}' data-te-timepicker-cancel tabindex="0" data-te-ripple-init>${e}</button>
        <button type='button' class='${_.timepickerFooterButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
      </div>
    </div>
  </div>
</div>`, g = `<div id='${r}' class='${_.timepickerInlineWrapper}' data-te-timepicker-wrapper>
        <div class="${_.timepickerInlineContainer}">
          <div class="${_.timepickerInlineElements}">
          <div id='${i}' class='${_.timepickerInlineHead}'
          style='padding-right:10px'>
          <div class='${_.timepickerInlineHeadContent}'>
              <div class="${_.timepickerCurrentWrapper}">
                <span class="${_.timepickerInlineHourWrapper}" data-te-timepicker-inline-hour-icons>
                  <span class="${_.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>
                    <span class="${_.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                      </svg>   
                    </span>
                  </span>
                  <button type='button' class='${_.timepickerInlineCurrentButton}' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                  <span class="${_.timepickerInlineIconDown}" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>
                    <span class="${_.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                      </svg>  
                    </span>
                  </span>
                </span>
                <button type='button' class='${_.timepickerInlineDot}' data-te-timepicker-current-inline disabled>:</button>
              <span class="${_.timepickerCurrentMinuteWrapper}">
                <span class="${_.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>
                  <span class="${_.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                    </svg>
                  </span>
                </span>
                <button type='button' class='${_.timepickerInlineCurrentButton}' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                <span class="${_.timepickerInlineIconDown}" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>
                  <span class="${_.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                    </svg> 
                  </span>
                </span>
              </span>
              </div>
              ${s ? "" : `<div class="${_.timepickerInlineModeWrapper}">
                      <button type='button' class="${_.timepickerInlineModeAm}" data-te-timepicker-am data-te-timepicker-hour-mode tabindex="0" data-te-ripple-init>${u}</button>
                      <button class="${_.timepickerInlineModePm}" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex="0" data-te-ripple-init>${f}</button>
                      <button type='button' class='${_.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
                    </div>`}
              ${s ? `<button class='${_.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>` : ""}
          </div>
        </div>
      </div>
    </div>
</div>`;
  return l ? g : m;
}, $f = (s, t, e) => {
  const { iconSVG: i } = s;
  return `
  <button id="${t}" tabindex="0" type="button" class="${e.timepickerToggleButton}" data-te-toggle="timepicker" data-te-timepicker-toggle-button data-te-timepicker-icon>
    ${i}
  </button>
`;
}, js = "data-te-timepicker-disabled", is = "data-te-timepicker-active", be = (s) => {
  if (s === "")
    return;
  let t, e, i, n;
  return sc(s) ? (t = s.getHours(), n = t, e = s.getMinutes(), t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM"), e = e < 10 ? `0${e}` : e) : ([t, e, i] = R(s, !1), n = t, t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM")), {
    hours: t,
    minutes: e,
    amOrPm: i
  };
}, sc = (s) => s && Object.prototype.toString.call(s) === "[object Date]" && !Number.isNaN(s), Xr = (s) => {
  if (s === "")
    return;
  let t, e;
  return sc(s) ? (t = s.getHours(), e = s.getMinutes()) : [t, e] = R(s, !1), e = Number(e) < 10 ? `0${Number(e)}` : e, {
    hours: t,
    minutes: e
  };
}, Lf = (s, t, e) => h.on(document, s, t, ({ target: i }) => {
  if (i.hasAttribute(is))
    return;
  document.querySelectorAll(t).forEach((o) => {
    o.hasAttribute(is) && (c.removeClass(o, e.opacity), o.removeAttribute(is));
  }), c.addClass(i, e.opacity), i.setAttribute(is, "");
}), Gr = ({ clientX: s, clientY: t, touches: e }, i, n = !1) => {
  const { left: o, top: r } = i.getBoundingClientRect();
  let a = {};
  return !n || !e ? a = {
    x: s - o,
    y: t - r
  } : n && Object.keys(e).length > 0 && (a = {
    x: e[0].clientX - o,
    y: e[0].clientY - r
  }), a;
}, ss = () => navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  navigator.userAgent
), R = (s, t = !0) => t ? s.value.replace(/:/gi, " ").split(" ") : s.replace(/:/gi, " ").split(" "), nc = (s, t) => {
  const [e, i, n] = R(s, !1), [o, r, a] = R(t, !1);
  return n === "PM" && a === "AM" || n === a && e > o || i > r;
}, oc = () => {
  const s = /* @__PURE__ */ new Date(), t = s.getHours(), e = s.getMinutes();
  return `${t}:${e < 10 ? `0${e}` : e}`;
}, Xt = (s, t, e) => {
  if (!t)
    return s;
  let i = oc();
  return e && (i = `${be(i).hours}:${be(i).minutes} ${be(i).amOrPm}`), (s !== "" && nc(i, s) || s === "") && (s = i), s;
}, Gt = (s, t, e) => {
  if (!t)
    return s;
  let i = oc();
  return e && (i = `${be(i).hours}:${be(i).minutes} ${be(i).amOrPm}`), (s !== "" && !nc(i, s) || s === "") && (s = i), s;
}, Mf = ({ format12: s, maxTime: t, minTime: e, disablePast: i, disableFuture: n }, o, r) => {
  const a = R(o)[1];
  e = Xt(e, i, s), t = Gt(t, n, s);
  const [l, p, u] = R(t, !1), [f, _, m] = R(e, !1);
  if (u !== void 0 || m !== void 0)
    return [r, a];
  if (!(l !== "" && f === "" && Number(r) > Number(l)) && !(l === "" && f !== "" && p === void 0 && _ !== "" && Number(r) < Number(f)))
    return [r, a];
}, qr = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, (n.textContent === "00" || Number(n.textContent === "12" && i ? "0" : n.textContent) > t) && (c.addClass(n, e.tipsDisabled), n.setAttribute(js, ""));
  });
}, Zr = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, n.textContent !== "00" && Number(n.textContent === "12" && i ? "0" : n.textContent) < Number(t) && (c.addClass(n, e.tipsDisabled), n.setAttribute(js, ""));
  });
}, rc = (s, t, e, i) => {
  if (t === "12" || t === "24")
    return;
  const n = e ? 12 : 24;
  return i === "max" ? (Number(s) === n ? 0 : Number(s)) > Number(t) : (Number(s) === n ? 0 : Number(s)) < Number(t);
}, Nf = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (rc(i, e, o, "max") || Number(r.textContent) > t && Number(i) === Number(e)) && (c.addClass(r, n.tipsDisabled), r.setAttribute(js, ""));
  });
}, Rf = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (rc(i, e, o, "min") || Number(r.textContent) < t && Number(i) === Number(e)) && (c.addClass(r, n.tipsDisabled), r.setAttribute(js, ""));
  });
}, Pf = (s) => s.startsWith("0") ? Number(s.slice(1)) : Number(s), yi = "timepicker", N = `data-te-${yi}`, Qr = "[data-te-toggle]", Ss = `te.${yi}`, Rt = `.${Ss}`, Pt = ".data-api", Jr = `click${Rt}${Pt}`, ns = `keydown${Rt}${Pt}`, ta = `mousedown${Rt}${Pt}`, ea = `mouseup${Rt}${Pt}`, ia = `mousemove${Rt}${Pt}`, sa = `mouseleave${Rt}${Pt}`, na = `mouseover${Rt}${Pt}`, oa = `touchmove${Rt}${Pt}`, ra = `touchend${Rt}${Pt}`, aa = `touchstart${Rt}${Pt}`, Bf = `[${N}-am]`, Hf = `[${N}-pm]`, Wf = `[${N}-format24]`, os = `[${N}-current]`, rs = `[${N}-hour-mode]`, Vf = `[${N}-toggle-button]`, kn = `${N}-cancel`, la = `${N}-clear`, On = `${N}-submit`, Ff = `${N}-icon`, Sn = `${N}-icon-up`, In = `${N}-icon-down`, Yf = `${N}-icon-inline-hour`, jf = `${N}-icon-inline-minute`, ca = `${N}-inline-hour-icons`, Kf = `${N}-current-inline`, zf = "readonly", ha = `${N}-invalid-feedback`, Dn = `${N}-is-invalid`, Yt = `${N}-disabled`, H = `${N}-active`, Uf = `${N}-input`, ue = `${N}-clock`, ai = `${N}-clock-inner`, $n = `${N}-wrapper`, da = `${N}-clock-wrapper`, as = `${N}-hour`, Ln = `${N}-minute`, ls = `${N}-tips-element`, K = `${N}-tips-hours`, X = `${N}-tips-minutes`, at = `${N}-tips-inner`, cs = `${N}-tips-inner-element`, ua = `${N}-middle-dot`, Mn = `${N}-hand-pointer`, Nn = `${N}-circle`, pa = `${N}-modal`, Xf = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>`, Gf = {
  appendValidationInfo: !0,
  bodyID: "",
  cancelLabel: "Cancel",
  clearLabel: "Clear",
  closeModalOnBackdropClick: !0,
  closeModalOnMinutesClick: !1,
  container: "body",
  defaultTime: "",
  disabled: !1,
  disablePast: !1,
  disableFuture: !1,
  enableValidation: !0,
  focusInputAfterApprove: !1,
  footerID: "",
  format12: !0,
  format24: !1,
  headID: "",
  increment: !1,
  inline: !1,
  invalidLabel: "Invalid Time Format",
  maxTime: "",
  minTime: "",
  modalID: "",
  okLabel: "Ok",
  overflowHidden: !0,
  pickerID: "",
  readOnly: !1,
  showClearBtn: !0,
  switchHoursToMinutesOnClick: !0,
  iconSVG: Xf,
  withIcon: !0,
  pmLabel: "PM",
  amLabel: "AM",
  animations: !0
}, qf = {
  appendValidationInfo: "boolean",
  bodyID: "string",
  cancelLabel: "string",
  clearLabel: "string",
  closeModalOnBackdropClick: "boolean",
  closeModalOnMinutesClick: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  enableValidation: "boolean",
  footerID: "string",
  format12: "boolean",
  format24: "boolean",
  headID: "string",
  increment: "boolean",
  inline: "boolean",
  invalidLabel: "string",
  modalID: "string",
  okLabel: "string",
  overflowHidden: "boolean",
  pickerID: "string",
  readOnly: "boolean",
  showClearBtn: "boolean",
  switchHoursToMinutesOnClick: "boolean",
  defaultTime: "(string|date|number)",
  iconSVG: "string",
  withIcon: "boolean",
  pmLabel: "string",
  amLabel: "string",
  animations: "boolean"
}, Zf = {
  tips: "absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent",
  tipsActive: "text-white bg-[#3b71ca] font-normal",
  tipsDisabled: "text-[#b3afaf] pointer-events-none bg-transparent",
  transform: "transition-[transform,height] ease-in-out duration-[400ms]",
  modal: "z-[1065]",
  clockAnimation: "animate-[show-up-clock_350ms_linear]",
  opacity: "!opacity-100",
  timepickerWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed",
  timepickerContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg",
  timepickerElements: "flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center",
  timepickerHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly",
  timepickerCurrentWrapper: "[direction:ltr] rtl:[direction:rtl]",
  timepickerCurrentButtonWrapper: "relative h-full",
  timepickerCurrentButton: "text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none ",
  timepickerDot: "font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal",
  timepickerModeWrapper: "flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerModeAm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerModePm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerClockWrapper: "min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500",
  timepickerClock: "relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50",
  timepickerMiddleDot: "top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute",
  timepickerHandPointer: "bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute",
  timepickerPointerCircle: "-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute",
  timepickerClockInner: "absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]",
  timepickerFooterWrapper: "rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500",
  timepickerFooter: "w-full flex justify-between",
  timepickerFooterButton: "text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none",
  timepickerInlineWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg",
  timepickerInlineContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]",
  timepickerInlineElements: "flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerInlineHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg",
  timepickerInlineHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center",
  timepickerInlineHourWrapper: "relative h-full !opacity-100",
  timepickerCurrentMinuteWrapper: "relative h-full",
  timepickerInlineIconUp: "absolute fill-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineIconSvg: "h-4 w-4",
  timepickerInlineCurrentButton: "font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]",
  timepickerInlineIconDown: "absolute fill-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineDot: "font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]",
  timepickerInlineModeWrapper: "flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerInlineModeAm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6",
  timepickerInlineModePm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer",
  timepickerInlineSubmitButton: "hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0",
  timepickerToggleButton: "h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-1.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca] dark:text-white",
  invalidFeedback: "block absolute text-sm text-red-500 dark:text-red-300"
}, Qf = {
  tips: "string",
  tipsActive: "string",
  tipsDisabled: "string",
  transform: "string",
  modal: "string",
  clockAnimation: "string",
  opacity: "string",
  timepickerWrapper: "string",
  timepickerContainer: "string",
  timepickerElements: "string",
  timepickerHead: "string",
  timepickerHeadContent: "string",
  timepickerCurrentWrapper: "string",
  timepickerCurrentButtonWrapper: "string",
  timepickerCurrentButton: "string",
  timepickerDot: "string",
  timepickerModeWrapper: "string",
  timepickerModeAm: "string",
  timepickerModePm: "string",
  timepickerClockWrapper: "string",
  timepickerClock: "string",
  timepickerMiddleDot: "string",
  timepickerHandPointer: "string",
  timepickerPointerCircle: "string",
  timepickerClockInner: "string",
  timepickerFooterWrapper: "string",
  timepickerFooterButton: "string",
  timepickerInlineWrapper: "string",
  timepickerInlineContainer: "string",
  timepickerInlineElements: "string",
  timepickerInlineHead: "string",
  timepickerInlineHeadContent: "string",
  timepickerInlineHourWrapper: "string",
  timepickerCurrentMinuteWrapper: "string",
  timepickerInlineIconUp: "string",
  timepickerInlineIconSvg: "string",
  timepickerInlineCurrentButton: "string",
  timepickerInlineIconDown: "string",
  timepickerInlineDot: "string",
  timepickerInlineModeWrapper: "string",
  timepickerInlineModeAm: "string",
  timepickerInlineModePm: "string",
  timepickerInlineSubmitButton: "string",
  timepickerToggleButton: "string",
  invalidFeedback: "string"
};
class Y0 {
  constructor(t, e = {}, i) {
    At(this, "_toggleAmPm", (t) => {
      t === "PM" ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : t === "AM" && (this._isPmEnabled = !1, this._isAmEnabled = !0);
    });
    At(this, "_toggleBackgroundColorCircle", (t) => {
      if (this._modal.querySelector(`${t}[${H}]`) !== null) {
        c.addStyle(this._circle, {
          backgroundColor: "#1976d2"
        });
        return;
      }
      c.addStyle(this._circle, {
        backgroundColor: "transparent"
      });
    });
    At(this, "_toggleClassActive", (t, { textContent: e }, i) => {
      const n = [...t].find(
        (o) => Number(o) === Number(e)
      );
      return i.forEach((o) => {
        if (!o.hasAttribute(Yt)) {
          if (o.textContent === n) {
            c.addClass(o, this._classes.tipsActive), o.setAttribute(H, "");
            return;
          }
          c.removeClass(o, this._classes.tipsActive), o.removeAttribute(H);
        }
      });
    });
    At(this, "_makeMinutesDegrees", (t, e) => {
      const { increment: i } = this._options;
      return t < 0 ? (e = Math.round(360 + t / 6) % 60, t = 360 + Math.round(t / 6) * 6) : (e = Math.round(t / 6) % 60, t = Math.round(t / 6) * 6), i && (t = Math.round(t / 30) * 30, e = Math.round(t / 6) * 6 / 6, e === 60 && (e = "00")), t >= 360 && (t = 0), {
        degrees: t,
        minute: e,
        addDegrees: i ? 30 : 6
      };
    });
    At(this, "_makeHourDegrees", (t, e, i) => {
      if (t)
        return this._hasTargetInnerClass(t) ? e < 0 ? (i = Math.round(360 + e / 30) % 24, e = 360 + e) : (i = Math.round(e / 30) + 12, i === 12 && (i = "00")) : e < 0 ? (i = Math.round(360 + e / 30) % 12, e = 360 + e) : (i = Math.round(e / 30) % 12, (i === 0 || i > 12) && (i = 12)), e >= 360 && (e = 0), {
          degrees: e,
          hour: i,
          addDegrees: 30
        };
    });
    At(this, "_makeInnerHoursDegrees", (t, e) => (t < 0 ? (e = Math.round(360 + t / 30) % 24, t = 360 + t) : (e = Math.round(t / 30) + 12, e === 12 && (e = "00")), {
      degrees: t,
      hour: e,
      addDegrees: 30
    }));
    At(this, "_getAppendClock", (t = [], e = `[${ue}]`, i) => {
      let { minTime: n, maxTime: o } = this._options;
      const { inline: r, format12: a, disablePast: l, disableFuture: p } = this._options;
      n = Xt(n, l, a), o = Gt(o, p, a);
      const [u, f, _] = R(
        o,
        !1
      ), [m, g, v] = R(
        n,
        !1
      );
      !r && a && this._isInvalidTimeFormat && !this._AM.hasAttribute(H) && (c.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, ""));
      const b = d.findOne(e), C = 360 / t.length;
      function y(w) {
        return w * (Math.PI / 180);
      }
      if (b === null)
        return;
      const E = (b.offsetWidth - 32) / 2, T = (b.offsetHeight - 32) / 2, A = E - 4;
      setTimeout(() => {
        let w;
        a && (w = d.findOne(
          `${rs}[${H}]`
        ).textContent), this._handleDisablingTipsMinTime(
          w,
          v,
          g,
          m
        ), this._handleDisablingTipsMaxTime(
          w,
          _,
          f,
          u
        );
      }, 0), [...t].forEach((w, S) => {
        const k = y(S * C), x = D("span"), $ = D("span");
        $.innerHTML = w, c.addClass(x, this._classes.tips), x.setAttribute(i, "");
        const O = x.offsetWidth, M = x.offsetHeight;
        return c.addStyle(x, {
          left: `${E + Math.sin(k) * A - O}px`,
          bottom: `${T + Math.cos(k) * A - M}px`
        }), t.includes("05") && x.setAttribute(X, ""), t.includes("13") ? $.setAttribute(cs, "") : $.setAttribute(ls, ""), x.appendChild($), b.appendChild(x);
      });
    });
    this._element = t, this._element && I.setData(t, Ss, this), this._document = document, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._currentTime = null, this._toggleButtonId = bt("timepicker-toggle-"), this.hoursArray = [
      "12",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "10",
      "11"
    ], this.innerHours = [
      "00",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "20",
      "21",
      "22",
      "23"
    ], this.minutesArray = [
      "00",
      "05",
      "10",
      "15",
      "20",
      "25",
      "30",
      "35",
      "40",
      "45",
      "50",
      "55"
    ], this.input = d.findOne("input", this._element), this.dataWithIcon = t.dataset.withIcon, this.dataToggle = t.dataset.toggle, this.customIcon = d.findOne(
      Vf,
      this._element
    ), this._checkToggleButton(), this.inputFormatShow = d.findOne(
      Wf,
      this._element
    ), this.inputFormat = this.inputFormatShow === null ? "" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = d.findOne(
      Qr,
      this._element
    ), this.toggleElement = Object.values(
      t.querySelector(Qr).dataset
    )[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._inputValue = this._options.defaultTime !== "" ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = Xr(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = be(this._inputValue)), this._options.readOnly && this.input.setAttribute(zf, !0), this.inputFormat === "true" && this.inputFormat !== "" && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = Xr(this._inputValue)), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = { degrees: null }, this._scrollBar = new ki();
  }
  // Getters
  static get NAME() {
    return yi;
  }
  // Public
  init() {
    const { format12: t, format24: e, enableValidation: i } = this._options;
    let n, o, r;
    if (this.input.setAttribute(Uf, ""), this._currentTime !== void 0) {
      const { hours: a, minutes: l, amOrPm: p } = this._currentTime;
      n = Number(a) < 10 ? 0 : "", o = `${n}${Number(a)}:${l}`, r = p, t ? this.input.value = `${o} ${r}` : e && (this.input.value = `${o}`);
    } else
      n = "", o = "", r = "", this.input.value = "";
    this.input.value.length > 0 && this.input.value !== "" && (this.input.setAttribute(H, ""), h.trigger(this.input, "input")), !(this._options === null && this._element === null) && (i && this._getValidate("keydown change blur focus"), this._handleOpen(), this._listenToToggleKeydown());
  }
  dispose() {
    this._removeModal(), this._element !== null && I.removeData(this._element, Ss), setTimeout(() => {
      this._element = null, this._options = null, this.input = null, this._focusTrap = null;
    }, 350), h.off(
      this._document,
      "click",
      `[data-te-toggle='${this.toggleElement}']`
    ), h.off(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`
    );
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  // private
  _checkToggleButton() {
    this.customIcon === null && (this.dataWithIcon !== void 0 && (this._options.withIcon = null, this.dataWithIcon === "true" && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options));
  }
  _appendToggleButton() {
    const t = $f(
      this._options,
      this._toggleButtonId,
      this._classes
    );
    this.input.insertAdjacentHTML("afterend", t);
  }
  _getDomElements() {
    this._hour = d.findOne(`[${as}]`), this._minutes = d.findOne(`[${Ln}]`), this._AM = d.findOne(Bf), this._PM = d.findOne(Hf), this._wrapper = d.findOne(`[${$n}]`), this._modal = d.findOne(`[${pa}]`), this._hand = d.findOne(`[${Mn}]`), this._circle = d.findOne(`[${Nn}]`), this._clock = d.findOne(`[${ue}]`), this._clockInner = d.findOne(
      `[${ai}]`
    );
  }
  _handlerMaxMinHoursOptions(t, e, i, n, o, r) {
    if (!e && !i)
      return !0;
    const { format24: a, format12: l, disablePast: p, disableFuture: u } = this._options, { _isAmEnabled: f, _isPmEnabled: _ } = this, m = r.keyCode, g = r.target.hasAttribute(ai) || r.target.hasAttribute(at) || r.target.hasAttribute(cs);
    i = Xt(i, p, l), e = Gt(e, u, l), typeof e != "number" && (e = R(e, !1)[0]);
    const v = e !== "" ? e * 30 : "", b = i !== "" ? i * 30 : "";
    t < 0 && (t = 360 + t), t = t === 360 ? 0 : t;
    const C = () => {
      const S = document.querySelectorAll(
        `[${ls}]`
      ), k = document.querySelectorAll(
        `[${cs}]`
      ), x = Pf(this._hour.innerText);
      let $, O, M;
      return m === rt ? O = 1 : m === z && (O = -1), x === 12 && m === rt ? M = 1 : x === 0 && m === rt ? M = 13 : x === 0 && m === z ? M = 23 : x === 13 && m === z ? M = 0 : x === 1 && m === z ? M = 12 : M = x + O, S.forEach((P) => {
        Number(P.textContent) === M && ($ = P);
      }), k.forEach((P) => {
        Number(P.textContent) === M && ($ = P);
      }), !$.parentElement.hasAttribute(Yt);
    }, y = () => {
      const S = i !== "" && i > 12 ? (i - 12) * 30 : "", k = e !== "" && e > 12 ? (e - 12) * 30 : "";
      if (!(S && t < S || k && t > k || e && e < 12))
        return !0;
    };
    if (a && r.type !== "keydown" && g)
      return y();
    if (r.type === "keydown")
      return C();
    const E = !o || o === "PM" && _ || i !== "" && o === "AM" && f, T = !n || n === "PM" && _ || e !== "" && n === "AM" && f, A = () => {
      const S = b === 360 && l ? 0 : b;
      if (i) {
        if (o === "PM" && f || E && t < S)
          return;
      } else
        return !0;
      return !0;
    }, w = () => {
      const S = v === 360 && l ? 0 : v;
      if (e) {
        if (n === "AM" && _ || T && t > S)
          return;
      } else
        return !0;
      return !0;
    };
    return A() && w();
  }
  _handleKeyboard() {
    h.on(this._document, ns, "", (t) => {
      let e, i, n;
      const {
        increment: o,
        maxTime: r,
        minTime: a,
        format12: l,
        disablePast: p,
        disableFuture: u
      } = this._options;
      let f = R(a, !1)[0], _ = R(r, !1)[0];
      const m = R(a, !1)[2], g = R(r, !1)[2];
      f = Xt(f, p, l), _ = Gt(_, u, l), typeof _ != "number" && (_ = R(_, !1)[0]);
      const v = d.findOne(`[${X}]`) === null, b = d.findOne(`[${at}]`) !== null, C = Number(this._hand.style.transform.replace(/[^\d-]/g, "")), y = d.find(
        `[${X}]`,
        this._modal
      ), E = d.find(
        `[${K}]`,
        this._modal
      ), T = d.find(
        `[${at}]`,
        this._modal
      );
      let A = this._makeHourDegrees(t.target, C, e).hour;
      const { degrees: w, addDegrees: S } = this._makeHourDegrees(
        t.target,
        C,
        e
      );
      let { minute: k, degrees: x } = this._makeMinutesDegrees(C, i);
      const $ = this._makeMinutesDegrees(
        C,
        i
      ).addDegrees;
      let { hour: O } = this._makeInnerHoursDegrees(
        C,
        n
      );
      if (t.keyCode === Li) {
        const M = d.findOne(
          `[${kn}]`,
          this._modal
        );
        h.trigger(M, "click");
      } else if (v) {
        if (b && (t.keyCode === Be && (this._isInner = !1, c.addStyle(this._hand, {
          height: "calc(40% + 1px)"
        }), this._hour.textContent = this._setHourOrMinute(
          A > 12 ? 1 : A
        ), this._toggleClassActive(this.hoursArray, this._hour, E), this._toggleClassActive(this.innerHours, this._hour, T)), t.keyCode === Pe && (this._isInner = !0, c.addStyle(this._hand, {
          height: "21.5%"
        }), this._hour.textContent = this._setHourOrMinute(
          O >= 24 || O === "00" ? 0 : O
        ), this._toggleClassActive(this.innerHours, this._hour, T), this._toggleClassActive(
          this.hoursArray,
          this._hour - 1,
          E
        ))), t.keyCode === rt) {
          if (!this._handlerMaxMinHoursOptions(
            w + 30,
            _,
            f,
            g,
            m,
            t
          ))
            return;
          c.addStyle(this._hand, {
            transform: `rotateZ(${w + S}deg)`
          }), this._isInner ? (O += 1, O === 24 ? O = 0 : (O === 25 || O === "001") && (O = 13), this._hour.textContent = this._setHourOrMinute(O), this._toggleClassActive(this.innerHours, this._hour, T)) : (A += 1, this._hour.textContent = this._setHourOrMinute(
            A > 12 ? 1 : A
          ), this._toggleClassActive(this.hoursArray, this._hour, E));
        }
        if (t.keyCode === z) {
          if (!this._handlerMaxMinHoursOptions(
            w - 30,
            _,
            f,
            g,
            m,
            t
          ))
            return;
          c.addStyle(this._hand, {
            transform: `rotateZ(${w - S}deg)`
          }), this._isInner ? (O -= 1, O === 12 ? O = 0 : O === -1 && (O = 23), this._hour.textContent = this._setHourOrMinute(O), this._toggleClassActive(this.innerHours, this._hour, T)) : (A -= 1, this._hour.textContent = this._setHourOrMinute(
            A === 0 ? 12 : A
          ), this._toggleClassActive(this.hoursArray, this._hour, E));
        }
      } else
        t.keyCode === rt && (x += $, c.addStyle(this._hand, {
          transform: `rotateZ(${x}deg)`
        }), k += 1, o && (k += 4, k === "0014" && (k = 5)), this._minutes.textContent = this._setHourOrMinute(
          k > 59 ? 0 : k
        ), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          y
        ), this._toggleBackgroundColorCircle(
          `[${X}]`
        )), t.keyCode === z && (x -= $, c.addStyle(this._hand, {
          transform: `rotateZ(${x}deg)`
        }), o ? k -= 5 : k -= 1, k === -1 ? k = 59 : k === -5 && (k = 55), this._minutes.textContent = this._setHourOrMinute(k), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          y
        ), this._toggleBackgroundColorCircle(
          `[${X}]`
        ));
    });
  }
  _setActiveClassToTipsOnOpen(t, ...e) {
    if (!this._isInvalidTimeFormat)
      if (this._options.format24) {
        const i = d.find(
          `[${K}]`,
          this._modal
        ), n = d.find(
          `[${at}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t), this._addActiveClassToTip(n, t);
      } else {
        [...e].filter((n) => (n === "PM" ? (c.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, "")) : n === "AM" ? (c.addClass(this._AM, this._classes.opacity), this._AM.setAttribute(H, "")) : (c.removeClass(this._AM, this._classes.opacity), c.removeClass(this._PM, this._classes.opacity), this._AM.removeAttribute(H), this._PM.removeAttribute(H)), n));
        const i = d.find(
          `[${K}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t);
      }
  }
  _setTipsAndTimesDependOnInputValue(t, e) {
    const { inline: i, format12: n } = this._options;
    if (this._isInvalidTimeFormat)
      this._hour.textContent = "12", this._minutes.textContent = "00", i || c.addStyle(this._hand, {
        transform: "rotateZ(0deg)"
      }), n && (c.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, ""));
    else {
      const o = t > 12 ? t * 30 - 360 : t * 30;
      this._hour.textContent = t, this._minutes.textContent = e, i || (c.addStyle(this._hand, {
        transform: `rotateZ(${o}deg)`
      }), c.addStyle(this._circle, {
        backgroundColor: "#1976d2"
      }), (Number(t) > 12 || t === "00") && c.addStyle(this._hand, {
        height: "21.5%"
      }));
    }
  }
  _listenToToggleKeydown() {
    h.on(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`,
      (t) => {
        t.keyCode === lt && (t.preventDefault(), h.trigger(this.elementToggle, "click"));
      }
    );
  }
  _handleOpen() {
    const t = this._getContainer();
    oe.on(
      this._element,
      "click",
      `[data-te-toggle='${this.toggleElement}']`,
      (e) => {
        if (this._options === null)
          return;
        const i = c.getDataAttribute(this.input, "toggle") !== null ? 200 : 0;
        setTimeout(() => {
          c.addStyle(this.elementToggle, {
            pointerEvents: "none"
          }), this.elementToggle.blur();
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const { modalID: o, inline: r, format12: a } = this._options, [l, p, u] = n, f = D("div");
          if ((Number(l) > 12 || l === "00") && (this._isInner = !0), this.input.blur(), e.target.blur(), f.innerHTML = Df(this._options, this._classes), c.addClass(f, this._classes.modal), f.setAttribute(pa, ""), f.setAttribute("role", "dialog"), f.setAttribute("tabIndex", "-1"), f.setAttribute("id", o), r ? (this._popper = Ee(this.input, f, {
            placement: "bottom-start"
          }), t.appendChild(f)) : (t.appendChild(f), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : c.addClass(this._wrapper, this._classes.opacity), this._setActiveClassToTipsOnOpen(l, p, u), this._appendTimes(), this._setActiveClassToTipsOnOpen(l, p, u), this._setTipsAndTimesDependOnInputValue(l, p), this.input.value === "") {
            const _ = d.find(
              `[${K}]`,
              this._modal
            );
            a && (c.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, "")), this._hour.textContent = "12", this._minutes.textContent = "00", this._addActiveClassToTip(
              _,
              Number(this._hour.textContent)
            );
          }
          if (this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), r)
            this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks();
          else {
            this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard();
            const _ = document.querySelector(
              `${os}[${H}]`
            );
            c.addClass(_, this._classes.opacity), c.addStyle(this._hour, {
              pointerEvents: "none"
            }), c.addStyle(this._minutes, {
              pointerEvents: ""
            });
          }
          this._focusTrap = new $i(this._wrapper, {
            event: "keydown",
            condition: ({ key: _ }) => _ === "Tab"
          }), this._focusTrap.trap();
        }, i);
      }
    );
  }
  _handleInlineClicks() {
    let t, e;
    const i = (_) => {
      let m = _;
      return m > 59 ? m = 0 : m < 0 && (m = 59), m;
    }, n = (_) => {
      let m = _;
      return this._options.format24 ? (m > 24 ? m = 1 : m < 0 && (m = 23), m > 23 && (m = 0)) : (m > 12 ? m = 1 : m < 1 && (m = 12), m > 12 && (m = 1)), m;
    }, o = (_) => {
      const m = n(_);
      this._hour.textContent = this._setHourOrMinute(m);
    }, r = (_) => {
      const m = i(_);
      this._minutes.textContent = this._setHourOrMinute(m);
    }, a = () => {
      t += 1, o(t);
    }, l = () => {
      e += 1, r(e);
    }, p = () => {
      t -= 1, o(t);
    }, u = () => {
      e -= 1, r(e);
    }, f = (_) => {
      clearInterval(this._interval), this._interval = setInterval(_, 100);
    };
    oe.on(
      this._modal,
      "click mousedown mouseup touchstart touchend contextmenu",
      `[${Sn}], [${In}]`,
      (_) => {
        t = Number(this._hour.textContent), e = Number(this._minutes.textContent);
        const { target: m, type: g } = _, v = g === "mousedown" || g === "touchstart";
        m.closest(`[${Sn}]`) ? m.closest(`[${Sn}]`).parentNode.hasAttribute(ca) ? v ? f(a) : g === "mouseup" || g === "touchend" || g === "contextmenu" ? clearInterval(this._interval) : a() : v ? f(l) : g === "mouseup" || g === "touchend" || g === "contextmenu" ? clearInterval(this._interval) : l() : m.closest(`[${In}]`) && (m.closest(`[${In}]`).parentNode.hasAttribute(ca) ? v ? f(p) : g === "mouseup" || g === "touchend" ? clearInterval(this._interval) : p() : v ? f(u) : g === "mouseup" || g === "touchend" ? clearInterval(this._interval) : u());
      }
    ), h.on(window, ns, (_) => {
      const m = _.code, g = document.activeElement.hasAttribute(as), v = document.activeElement.hasAttribute(
        Ln
      ), b = document.activeElement === document.body;
      switch (t = Number(this._hour.textContent), e = Number(this._minutes.textContent), m) {
        case "ArrowUp":
          _.preventDefault(), b || g ? (this._hour.focus(), a()) : v && l();
          break;
        case "ArrowDown":
          _.preventDefault(), b || g ? (this._hour.focus(), p()) : v && u();
          break;
      }
    });
  }
  _handleClose() {
    h.on(
      this._modal,
      "click",
      `[${$n}], [${kn}], [${la}]`,
      ({ target: t }) => {
        const { closeModalOnBackdropClick: e } = this._options, i = () => {
          var n;
          c.addStyle(this.elementToggle, {
            pointerEvents: "auto"
          }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), (n = this._focusTrap) == null || n.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus();
        };
        if (t.hasAttribute(la)) {
          this._toggleAmPm("PM"), this.input.value = "", this.input.removeAttribute(H);
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const [o, r, a] = n;
          this._setTipsAndTimesDependOnInputValue("12", "00"), this._setActiveClassToTipsOnOpen(o, r, a), this._hour.click();
        } else
          (t.hasAttribute(kn) || t.hasAttribute(On) || t.hasAttribute($n) && e) && i();
      }
    );
  }
  showValueInput() {
    return this.input.value;
  }
  _handleOkButton() {
    oe.on(
      this._modal,
      "click",
      `[${On}]`,
      () => {
        let { maxTime: t, minTime: e } = this._options;
        const {
          format12: i,
          format24: n,
          readOnly: o,
          focusInputAfterApprove: r,
          disablePast: a,
          disableFuture: l
        } = this._options, p = this._document.querySelector(
          `${rs}[${H}]`
        ), u = `${this._hour.textContent}:${this._minutes.textContent}`, f = Number(this._hour.textContent), _ = f === 12 && i ? 0 : f, m = Number(this._minutes.textContent);
        e = Xt(e, a, i), t = Gt(t, l, i);
        let [g, v, b] = R(
          t,
          !1
        ), [C, y, E] = R(
          e,
          !1
        );
        C = C === "12" && i ? "00" : C, g = g === "12" && i ? "00" : g;
        const T = _ < Number(C), A = _ > Number(g);
        let w = !0;
        p && (w = b === p.textContent);
        let S = !0;
        p && (S = E === p.textContent);
        const k = m > v && _ === Number(g), x = m < y && _ === Number(C);
        if (this.input.setAttribute(H, ""), c.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), t !== "") {
          if (w && (A || k))
            return;
          if (b === "AM" && p.textContent === "PM")
            return;
        }
        e !== "" && (S && (T || x) || E === "PM" && p.textContent === "AM") || Mf(
          this._options,
          this.input,
          this._hour.textContent
        ) !== void 0 && (this._isInvalidTimeFormat && this.input.removeAttribute(Dn), !o && r && this.input.focus(), c.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), n ? this.input.value = u : p === null ? this.input.value = `${u} PM` : this.input.value = `${u} ${p.textContent}`, this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), h.trigger(this.input, "input.te.timepicker"), h.trigger(this.input, "input"));
      }
    );
  }
  _handleHoverInlineBtn() {
    oe.on(
      this._modal,
      "mouseover mouseleave",
      `[${Kf}]`,
      ({ type: t, target: e }) => {
        const i = d.find(
          `[${Yf}]`,
          this._modal
        ), n = d.find(
          `[${jf}]`,
          this._modal
        ), o = (l, p) => l.forEach((u) => {
          if (p) {
            c.addClass(u, this._classes.opacity), u.setAttribute(H, "");
            return;
          }
          c.removeClass(u, this._classes.opacity), u.removeAttribute(H);
        }), a = e.hasAttribute(as) ? i : n;
        o(a, t === "mouseover");
      }
    );
  }
  _handleDocumentClickInline() {
    h.on(document, Jr, ({ target: t }) => {
      if (this._modal && !this._modal.contains(t) && !t.hasAttribute(Ff)) {
        if (clearInterval(this._interval), c.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), this._removeModal(), !this._animations)
          return;
        this._toggleBackdropAnimation(!0);
      }
    });
  }
  _handleSwitchHourMinute() {
    Lf(
      "click",
      os,
      this._classes
    ), h.on(
      this._modal,
      "click",
      os,
      () => {
        const { format24: t } = this._options, e = d.find(
          os,
          this._modal
        ), i = d.find(
          `[${X}]`,
          this._modal
        ), n = d.find(
          `[${K}]`,
          this._modal
        ), o = d.find(
          `[${at}]`,
          this._modal
        ), r = Number(this._hour.textContent), a = Number(this._minutes.textContent), l = (p, u) => {
          n.forEach((_) => _.remove()), i.forEach((_) => _.remove()), c.addClass(this._hand, this._classes.transform), setTimeout(() => {
            c.removeClass(this._hand, this._classes.transform);
          }, 401), this._getAppendClock(p, `[${ue}]`, u);
          const f = () => {
            const _ = d.find(
              `[${K}]`,
              this._modal
            ), m = d.find(
              `[${X}]`,
              this._modal
            );
            this._addActiveClassToTip(_, r), this._addActiveClassToTip(m, a);
          };
          if (!t)
            setTimeout(() => {
              f();
            }, 401);
          else {
            const _ = d.find(
              `[${at}]`,
              this._modal
            );
            setTimeout(() => {
              this._addActiveClassToTip(_, r), f();
            }, 401);
          }
        };
        e.forEach((p) => {
          p.hasAttribute(H) && (p.hasAttribute(Ln) ? (c.addClass(this._hand, this._classes.transform), c.addStyle(this._hand, {
            transform: `rotateZ(${this._minutes.textContent * 6}deg)`,
            height: "calc(40% + 1px)"
          }), t && o.length > 0 && o.forEach((u) => u.remove()), l(
            this.minutesArray,
            X
          ), this._hour.style.pointerEvents = "", this._minutes.style.pointerEvents = "none") : p.hasAttribute(as) && (c.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30}deg)`
          }), Number(this._hour.textContent) > 12 ? (c.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,
            height: "21.5%"
          }), Number(this._hour.textContent) > 12 && c.addStyle(this._hand, {
            height: "21.5%"
          })) : c.addStyle(this._hand, {
            height: "calc(40% + 1px)"
          }), t && this._getAppendClock(
            this.innerHours,
            `[${ai}]`,
            at
          ), o.length > 0 && o.forEach((u) => u.remove()), l(
            this.hoursArray,
            K
          ), c.addStyle(this._hour, {
            pointerEvents: "none"
          }), c.addStyle(this._minutes, {
            pointerEvents: ""
          })));
        });
      }
    );
  }
  _handleDisablingTipsMaxTime(t, e, i, n) {
    if (!this._options.maxTime && !this._options.disableFuture)
      return;
    const o = d.find(
      `[${K}]`
    ), r = d.find(
      `[${at}]`
    ), a = d.find(
      `[${X}]`
    );
    if (!e || e === t) {
      qr(
        r,
        n,
        this._classes,
        this._options.format12
      ), qr(
        o,
        n,
        this._classes,
        this._options.format12
      ), Nf(
        a,
        i,
        n,
        this._hour.textContent,
        this._classes,
        this._options.format12
      );
      return;
    }
    e === "AM" && t === "PM" && (o.forEach((l) => {
      c.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, "");
    }), a.forEach((l) => {
      c.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, "");
    }));
  }
  _handleDisablingTipsMinTime(t, e, i, n) {
    if (!this._options.minTime && !this._options.disablePast)
      return;
    const o = d.find(
      `[${K}]`
    ), r = d.find(
      `[${at}]`
    ), a = d.find(
      `[${X}]`
    );
    !e || e === t ? (Zr(
      o,
      n,
      this._classes,
      this._options.format12
    ), Zr(
      r,
      n,
      this._classes,
      this._options.format12
    ), Rf(
      a,
      i,
      n,
      this._hour.textContent,
      this._classes,
      this._options.format12
    )) : e === "PM" && t === "AM" && (o.forEach((l) => {
      c.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, "");
    }), a.forEach((l) => {
      c.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, "");
    }));
  }
  _handleSwitchTimeMode() {
    h.on(
      document,
      "click",
      rs,
      ({ target: t }) => {
        let { maxTime: e, minTime: i } = this._options;
        const { disablePast: n, disableFuture: o, format12: r } = this._options;
        i = Xt(i, n, r), e = Gt(e, o, r);
        const [a, l, p] = R(
          e,
          !1
        ), [u, f, _] = R(
          i,
          !1
        ), m = d.find(
          `[${K}]`
        ), g = d.find(
          `[${X}]`
        );
        (() => {
          m.forEach((b) => {
            c.removeClass(b, this._classes.tipsDisabled), b.removeAttribute(Yt);
          }), g.forEach((b) => {
            c.removeClass(b, this._classes.tipsDisabled), b.removeAttribute(Yt);
          });
        })(), this._handleDisablingTipsMinTime(
          t.textContent,
          _,
          f,
          u
        ), this._handleDisablingTipsMaxTime(
          t.textContent,
          p,
          l,
          a
        ), this._toggleAmPm(t.textContent), t.hasAttribute(H) || (d.find(
          rs
        ).forEach((C) => {
          C.hasAttribute(H) && (c.removeClass(C, this._classes.opacity), C.removeAttribute(H));
        }), c.addClass(t, this._classes.opacity), t.setAttribute(H, ""));
      }
    );
  }
  _handleClockClick() {
    let { maxTime: t, minTime: e } = this._options;
    const { disablePast: i, disableFuture: n, format12: o } = this._options;
    e = Xt(e, i, o), t = Gt(t, n, o);
    const r = R(t, !1)[2], a = R(e, !1)[2], l = R(t, !1)[0], p = R(e, !1)[0], u = d.findOne(
      `[${da}]`
    );
    oe.on(
      document,
      `${ta} ${ea} ${ia} ${sa} ${na} ${aa} ${oa} ${ra}`,
      "",
      (f) => {
        ss() || f.preventDefault();
        const { type: _, target: m } = f, { closeModalOnMinutesClick: g, switchHoursToMinutesOnClick: v } = this._options, b = d.findOne(
          `[${X}]`,
          this._modal
        ) !== null, C = d.findOne(
          `[${K}]`,
          this._modal
        ) !== null, y = d.findOne(
          `[${at}]`,
          this._modal
        ) !== null, E = d.find(
          `[${X}]`,
          this._modal
        ), T = Gr(f, u), A = u.offsetWidth / 2;
        let w = Math.atan2(T.y - A, T.x - A);
        if (ss()) {
          const $ = Gr(f, u, !0);
          w = Math.atan2($.y - A, $.x - A);
        }
        let S = null, k = null, x = null;
        if (_ === "mousedown" || _ === "mousemove" || _ === "touchmove" || _ === "touchstart")
          (_ === "mousedown" || _ === "touchstart" || _ === "touchmove") && (this._hasTargetInnerClass(m) || m.hasAttribute(da) || m.hasAttribute(ue) || m.hasAttribute(X) || m.hasAttribute(K) || m.hasAttribute(Nn) || m.hasAttribute(Mn) || m.hasAttribute(ua) || m.hasAttribute(ls)) && (this._isMouseMove = !0, ss() && f.touches && (S = f.touches[0].clientX, k = f.touches[0].clientY, x = document.elementFromPoint(S, k)));
        else if (_ === "mouseup" || _ === "touchend") {
          if (this._isMouseMove = !1, this._hasTargetInnerClass(m) || m.hasAttribute(ue) || m.hasAttribute(K) || m.hasAttribute(Nn) || m.hasAttribute(Mn) || m.hasAttribute(ua) || m.hasAttribute(ls)) {
            if ((C || y) && v) {
              const $ = Number(this._hour.textContent) > l || Number(this._hour.textContent) < p;
              if (this._options.format24 && l !== "" && p !== "" && $)
                return;
              if (this._options.format24 && p !== "" && Number(this._hour.textContent) < p)
                return;
            }
            h.trigger(this._minutes, "click");
          }
          if (b && g) {
            const $ = d.findOne(
              `[${On}]`,
              this._modal
            );
            h.trigger($, "click");
          }
        }
        if (b) {
          let $;
          const O = Math.trunc(w * 180 / Math.PI) + 90, { degrees: M, minute: P } = this._makeMinutesDegrees(O, $);
          if (this._handlerMaxMinMinutesOptions(M, P) === void 0)
            return;
          const { degrees: tt, minute: et } = this._handlerMaxMinMinutesOptions(M, P);
          if (this._isMouseMove) {
            if (c.addStyle(this._hand, {
              transform: `rotateZ(${tt}deg)`
            }), et === void 0)
              return;
            const U = () => et >= 10 || et === "00" ? et : `0${et}`;
            this._minutes.textContent = U(), this._toggleClassActive(
              this.minutesArray,
              this._minutes,
              E
            ), this._toggleBackgroundColorCircle(
              `[${X}]`
            ), this._objWithDataOnChange.degreesMinutes = tt, this._objWithDataOnChange.minutes = et;
          }
        }
        if (C || y) {
          let $, O = Math.trunc(w * 180 / Math.PI) + 90;
          if (O = Math.round(O / 30) * 30, c.addStyle(this._circle, {
            backgroundColor: "#1976d2"
          }), this._makeHourDegrees(m, O, $) === void 0)
            return;
          const M = () => {
            if (ss() && O && x) {
              const { degrees: P, hour: tt } = this._makeHourDegrees(x, O, $);
              return this._handleMoveHand(
                x,
                tt,
                P
              );
            } else {
              const { degrees: P, hour: tt } = this._makeHourDegrees(m, O, $);
              return this._handleMoveHand(m, tt, P);
            }
          };
          this._objWithDataOnChange.degreesHours = O, this._handlerMaxMinHoursOptions(
            O,
            l,
            p,
            r,
            a,
            f
          ) && M();
        }
        f.stopPropagation();
      }
    );
  }
  _hasTargetInnerClass(t) {
    return t.hasAttribute(ai) || t.hasAttribute(at) || t.hasAttribute(cs);
  }
  _handleMoveHand(t, e, i) {
    const n = d.find(
      `[${K}]`,
      this._modal
    ), o = d.find(
      `[${at}]`,
      this._modal
    );
    this._isMouseMove && (this._hasTargetInnerClass(t) ? c.addStyle(this._hand, {
      height: "21.5%"
    }) : c.addStyle(this._hand, {
      height: "calc(40% + 1px)"
    }), c.addStyle(this._hand, {
      transform: `rotateZ(${i}deg)`
    }), this._hour.textContent = e >= 10 || e === "00" ? e : `0${e}`, this._toggleClassActive(this.hoursArray, this._hour, n), this._toggleClassActive(this.innerHours, this._hour, o), this._objWithDataOnChange.hour = e >= 10 || e === "00" ? e : `0${e}`);
  }
  _handlerMaxMinMinutesOptions(t, e) {
    let { maxTime: i, minTime: n } = this._options;
    const { format12: o, increment: r, disablePast: a, disableFuture: l } = this._options;
    n = Xt(n, a, o), i = Gt(i, l, o);
    const p = R(i, !1)[1], u = R(n, !1)[1], f = R(i, !1)[0], _ = R(n, !1)[0], m = _ === "12" && o ? "0" : _, g = f === "12" && o ? "0" : f, v = R(i, !1)[2], b = R(n, !1)[2], C = p !== "" ? p * 6 : "", y = u !== "" ? u * 6 : "", E = Number(this._hour.textContent), T = E === 12 && o ? 0 : E;
    if (!v && !b) {
      if (i !== "" && n !== "") {
        if (Number(g) === T && t > C || Number(m) === T && t < y)
          return t;
      } else if (n !== "" && T <= Number(m)) {
        if (t <= y - 6)
          return t;
      } else if (i !== "" && T >= Number(g) && t >= C + 6)
        return t;
    } else {
      if (n !== "") {
        if (b === "PM" && this._isAmEnabled)
          return;
        if (b === "PM" && this._isPmEnabled) {
          if (T < Number(m))
            return;
          if (T <= Number(m) && t <= y - 6)
            return t;
        } else if (b === "AM" && this._isAmEnabled) {
          if (T < Number(m))
            return;
          if (T <= Number(m) && t <= y - 6)
            return t;
        }
      }
      if (i !== "") {
        if (v === "AM" && this._isPmEnabled)
          return;
        if (v === "PM" && this._isPmEnabled) {
          if (T >= Number(g) && t >= C + 6)
            return t;
        } else if (v === "AM" && this._isAmEnabled && T >= Number(g) && t >= C + 6)
          return t;
      }
    }
    return r && (t = Math.round(t / 30) * 30), t < 0 ? t = 360 + t : t >= 360 && (t = 0), {
      degrees: t,
      minute: e
    };
  }
  _removeModal() {
    this._animations ? setTimeout(() => {
      this._removeModalElements(), this._scrollBar.reset();
    }, 300) : (this._removeModalElements(), this._scrollBar.reset()), oe.off(
      this._document,
      `${Jr} ${ns} ${ta} ${ea} ${ia} ${sa} ${na} ${aa} ${oa} ${ra}`
    ), h.off(window, ns);
  }
  _removeModalElements() {
    this._modal && this._modal.remove();
  }
  _toggleBackdropAnimation(t = !1) {
    t ? this._wrapper.classList.add("animate-[fade-out_350ms_ease-in-out]") : (this._wrapper.classList.add("animate-[fade-in_350ms_ease-in-out]"), this._options.inline || c.addClass(this._clock, this._classes.clockAnimation)), setTimeout(() => {
      this._wrapper.classList.remove(
        "animate-[fade-out_350ms_ease-in-out]",
        "animate-[fade-in_350ms_ease-in-out]"
      );
    }, 351);
  }
  _addActiveClassToTip(t, e) {
    t.forEach((i) => {
      Number(i.textContent) === Number(e) && (c.addClass(i, this._classes.tipsActive), i.setAttribute(H, ""));
    });
  }
  _setHourOrMinute(t) {
    return t < 10 ? `0${t}` : t;
  }
  _appendTimes() {
    const { format24: t } = this._options;
    if (t) {
      this._getAppendClock(
        this.hoursArray,
        `[${ue}]`,
        K
      ), this._getAppendClock(
        this.innerHours,
        `[${ai}]`,
        at
      );
      return;
    }
    this._getAppendClock(
      this.hoursArray,
      `[${ue}]`,
      K
    );
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...Gf,
      ...e,
      ...t
    }, L(yi, t, qf), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Zf,
      ...e,
      ...t
    }, L(yi, t, Qf), t;
  }
  _getContainer() {
    return d.findOne(this._options.container);
  }
  _getValidate(t) {
    const { invalidLabel: e, format24: i, format12: n, appendValidationInfo: o } = this._options;
    let r;
    o && (r = D("div"), r.setAttribute(ha, ""), c.addClass(r, this._classes.invalidFeedback), r.innerHTML = e), oe.on(this.input, t, ({ target: a }) => {
      if (this._options === null || this.input.value === "")
        return;
      const l = /^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/, p = /^([01]\d|2[0-3])(:[0-5]\d)$/, u = l.test(a.value);
      if (p.test(a.value) !== !0 && i || u !== !0 && n) {
        o && (this.input.setAttribute(Dn, ""), this.input.parentNode.insertBefore(
          r,
          this.input.nextSibling
        )), c.addStyle(a, { marginBottom: 0 }), c.addStyle(r, { bottom: "-23px" }), this._isInvalidTimeFormat = !0;
        return;
      }
      this.input.removeAttribute(Dn), this._isInvalidTimeFormat = !1;
      const _ = d.findOne(
        `[${ha}]`
      );
      _ !== null && _.remove();
    });
  }
  // Static
  static getInstance(t) {
    return I.getData(t, Ss);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Jf = {
  threshold: 10,
  direction: "all"
};
class tm {
  constructor(t, e) {
    this._element = t, this._startPosition = null, this._options = {
      ...Jf,
      ...e
    };
  }
  handleTouchStart(t) {
    this._startPosition = this._getCoordinates(t);
  }
  handleTouchMove(t) {
    if (!this._startPosition)
      return;
    const e = this._getCoordinates(t), i = {
      x: e.x - this._startPosition.x,
      y: e.y - this._startPosition.y
    }, n = this._getDirection(i);
    if (this._options.direction === "all") {
      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
        return;
      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;
      h.trigger(this._element, `swipe${r}`), h.trigger(this._element, "swipe", { direction: r }), this._startPosition = null;
      return;
    }
    const o = this._options.direction === "left" || this._options === "right" ? "x" : "y";
    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (h.trigger(this._element, `swipe${n[o].direction}`), this._startPosition = null);
  }
  handleTouchEnd() {
    this._startPosition = null;
  }
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection(t) {
    return {
      x: {
        direction: t.x < 0 ? "left" : "right",
        value: Math.abs(t.x)
      },
      y: {
        direction: t.y < 0 ? "up" : "down",
        value: Math.abs(t.y)
      }
    };
  }
}
class em {
  constructor(t, e = "swipe", i = {}) {
    this._element = t, this._event = e, this.swipe = new tm(t, i), this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this);
  }
  dispose() {
    this._element.removeEventListener("touchstart", this._touchStartHandler), this._element.removeEventListener("touchmove", this._touchMoveHandler), window.removeEventListener("touchend", this._touchEndHandler);
  }
  init() {
    this._element.addEventListener(
      "touchstart",
      (t) => this._handleTouchStart(t)
    ), this._element.addEventListener(
      "touchmove",
      (t) => this._handleTouchMove(t)
    ), window.addEventListener("touchend", (t) => this._handleTouchEnd(t));
  }
  _handleTouchStart(t) {
    this[this._event].handleTouchStart(t);
  }
  _handleTouchMove(t) {
    this[this._event].handleTouchMove(t);
  }
  _handleTouchEnd(t) {
    this[this._event].handleTouchEnd(t);
  }
}
const _a = "sidenav", hs = "te.sidenav", im = "data-te-sidenav-rotate-icon-ref", Rn = "[data-te-sidenav-toggle-ref]", sm = "[data-te-collapse-init]", nm = '[data-te-sidenav-slim="true"]', om = '[data-te-sidenav-slim="false"]', rm = "[data-te-sidenav-menu-ref]", ke = "[data-te-sidenav-collapse-ref]", li = "[data-te-sidenav-link-ref]", am = F() ? 100 : -100, lm = F() ? -100 : 100, cm = {
  sidenavAccordion: "(boolean)",
  sidenavBackdrop: "(boolean)",
  sidenavBackdropClass: "(null|string)",
  sidenavCloseOnEsc: "(boolean)",
  sidenavColor: "(string)",
  sidenavContent: "(null|string)",
  sidenavExpandable: "(boolean)",
  sidenavExpandOnHover: "(boolean)",
  sidenavFocusTrap: "(boolean)",
  sidenavHidden: "(boolean)",
  sidenavMode: "(string)",
  sidenavModeBreakpointOver: "(null|string|number)",
  sidenavModeBreakpointSide: "(null|string|number)",
  sidenavModeBreakpointPush: "(null|string|number)",
  sidenavBreakpointSm: "(number)",
  sidenavBreakpointMd: "(number)",
  sidenavBreakpointLg: "(number)",
  sidenavBreakpointXl: "(number)",
  sidenavBreakpoint2xl: "(number)",
  sidenavScrollContainer: "(null|string)",
  sidenavSlim: "(boolean)",
  sidenavSlimCollapsed: "(boolean)",
  sidenavSlimWidth: "(number)",
  sidenavPosition: "(string)",
  sidenavRight: "(boolean)",
  sidenavTransitionDuration: "(number)",
  sidenavWidth: "(number)"
}, hm = {
  sidenavAccordion: !1,
  sidenavBackdrop: !0,
  sidenavBackdropClass: null,
  sidenavCloseOnEsc: !0,
  sidenavColor: "primary",
  sidenavContent: null,
  sidenavExpandable: !0,
  sidenavExpandOnHover: !1,
  sidenavFocusTrap: !0,
  sidenavHidden: !0,
  sidenavMode: "over",
  sidenavModeBreakpointOver: null,
  sidenavModeBreakpointSide: null,
  sidenavModeBreakpointPush: null,
  sidenavBreakpointSm: 640,
  sidenavBreakpointMd: 768,
  sidenavBreakpointLg: 1024,
  sidenavBreakpointXl: 1280,
  sidenavBreakpoint2xl: 1536,
  sidenavScrollContainer: null,
  sidenavSlim: !1,
  sidenavSlimCollapsed: !1,
  sidenavSlimWidth: 77,
  sidenavPosition: "fixed",
  sidenavRight: !1,
  sidenavTransitionDuration: 300,
  sidenavWidth: 240
};
class pi {
  constructor(t, e = {}) {
    At(this, "_addBackdropOnInit", () => {
      this._options.sidenavHidden || (this._backdrop.show(), h.off(this._element, "transitionend", this._addBackdropOnInit));
    });
    this._element = t, this._options = e, this._ID = bt(""), this._content = null, this._initialContentStyle = null, this._slimCollapsed = !1, this._activeNode = null, this._tempSlim = !1, this._backdrop = this._initializeBackDrop(), this._focusTrap = null, this._perfectScrollbar = null, this._touch = null, this._setModeFromBreakpoints(), this.escHandler = (i) => {
      i.keyCode === Li && this.toggler && Lt(this.toggler) && (this._update(!1), h.off(window, "keydown", this.escHandler));
    }, this.hashHandler = () => {
      this._setActiveElements();
    }, t && (I.setData(t, hs, this), this._setup()), this.options.sidenavBackdrop && !this.options.sidenavHidden && this.options.sidenavMode === "over" && h.on(this._element, "transitionend", this._addBackdropOnInit), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return _a;
  }
  get container() {
    if (this.options.sidenavPosition === "fixed")
      return d.findOne("body");
    const t = (e) => !e.parentNode || e.parentNode === document ? e : e.parentNode.style.position === "relative" || e.parentNode.classList.contains("relative") ? e.parentNode : t(e.parentNode);
    return t(this._element);
  }
  get isVisible() {
    let t = 0, e = window.innerWidth;
    if (this.options.sidenavPosition !== "fixed") {
      const n = this.container.getBoundingClientRect();
      t = n.x, e = n.x + n.width;
    }
    const { x: i } = this._element.getBoundingClientRect();
    return this.options.sidenavRight ? Math.abs(i - e) > 10 : Math.abs(i - t) < 10;
  }
  get links() {
    return d.find(li, this._element);
  }
  get navigation() {
    return d.find(rm, this._element);
  }
  get options() {
    const t = {
      ...hm,
      ...c.getDataAttributes(this._element),
      ...this._options
    };
    return L(_a, t, cm), t;
  }
  get sidenavStyle() {
    return {
      width: `${this.width}px`,
      height: this.options.sidenavPosition === "fixed" ? "100vh" : "100%",
      position: this.options.sidenavPosition,
      transition: `all ${this.transitionDuration} linear`
    };
  }
  get toggler() {
    return d.find(Rn).find(
      (e) => {
        const i = c.getDataAttribute(e, "target");
        return d.findOne(i) === this._element;
      }
    );
  }
  get transitionDuration() {
    return `${this.options.sidenavTransitionDuration / 1e3}s`;
  }
  get translation() {
    return this.options.sidenavRight ? lm : am;
  }
  get width() {
    return this._slimCollapsed ? this.options.sidenavSlimWidth : this.options.sidenavWidth;
  }
  get isBackdropVisible() {
    return !!this._backdrop._element;
  }
  // Public
  changeMode(t) {
    this._setMode(t);
  }
  dispose() {
    h.off(window, "keydown", this.escHandler), this.options.sidenavBackdrop && this._backdrop.dispose(), h.off(window, "hashchange", this.hashHandler), this._touch.dispose(), I.removeData(this._element, hs), this._element = null;
  }
  hide() {
    this._emitEvents(!1), this._update(!1), this._options.sidenavBackdrop && this.isBackdropVisible && this._backdrop.hide();
  }
  show() {
    this._emitEvents(!0), this._update(!0), this._options.sidenavBackdrop && this._options.sidenavMode === "over" && this._backdrop.show();
  }
  toggle() {
    this._emitEvents(!this.isVisible), this._update(!this.isVisible);
  }
  toggleSlim() {
    this._setSlim(!this._slimCollapsed);
  }
  update(t) {
    this._options = t, this._setup();
  }
  getBreakpoint(t) {
    return this._transformBreakpointValuesToObject()[t];
  }
  // Private
  _init() {
    this._didInit || (h.on(
      document,
      "click",
      Rn,
      pi.toggleSidenav()
    ), this._didInit = !0);
  }
  _transformBreakpointValuesToObject() {
    return {
      sm: this.options.sidenavBreakpointSm,
      md: this.options.sidenavBreakpointMd,
      lg: this.options.sidenavBreakpointLg,
      xl: this.options.sidenavBreakpointXl,
      "2xl": this.options.sidenavBreakpoint2xl
    };
  }
  _setModeFromBreakpoints() {
    const t = window.innerWidth, e = this._transformBreakpointValuesToObject();
    if (t === void 0 || !e)
      return;
    const i = typeof this.options.sidenavModeBreakpointOver == "number" ? t - this.options.sidenavModeBreakpointOver : t - e[this.options.sidenavModeBreakpointOver], n = typeof this.options.sidenavModeBreakpointSide == "number" ? t - this.options.sidenavModeBreakpointSide : t - e[this.options.sidenavModeBreakpointSide], o = typeof this.options.sidenavModeBreakpointPush == "number" ? t - this.options.sidenavModeBreakpointPush : t - e[this.options.sidenavModeBreakpointPush], r = (l, p) => l - p < 0 ? -1 : p - l < 0 ? 1 : 0, a = [i, n, o].filter((l) => l != null && l >= 0).sort(r)[0];
    i > 0 && i === a ? (this._options.sidenavMode = "over", this._options.sidenavHidden = !0) : n > 0 && n === a ? this._options.sidenavMode = "side" : o > 0 && o === a && (this._options.sidenavMode = "push");
  }
  _collapseItems() {
    this.navigation.forEach((t) => {
      d.find(ke, t).forEach((i) => {
        qt.getInstance(i).hide();
      });
    });
  }
  _getOffsetValue(t, { index: e, property: i, offsets: n }) {
    const o = this._getPxValue(
      this._initialContentStyle[e][n[i].property]
    ), r = t ? n[i].value : 0;
    return o + r;
  }
  _getProperty(...t) {
    return t.map((e, i) => i === 0 ? e : e[0].toUpperCase().concat(e.slice(1))).join("");
  }
  _getPxValue(t) {
    return t ? parseFloat(t) : 0;
  }
  _handleSwipe(t, e) {
    e && this._slimCollapsed && this.options.sidenavSlim && this.options.sidenavExpandable ? this.toggleSlim() : e || (this._slimCollapsed || !this.options.sidenavSlim || !this.options.sidenavExpandable ? this.toggler && Lt(this.toggler) && this.toggle() : this.toggleSlim());
  }
  _isActive(t, e) {
    return e ? e === t : t.attributes.href ? new URL(t, window.location.href).href === window.location.href : !1;
  }
  _isAllToBeCollapsed() {
    return d.find(
      sm,
      this._element
    ).filter(
      (i) => i.getAttribute("aria-expanded") === "true"
    ).length === 0;
  }
  _isAllCollapsed() {
    return d.find(ke, this._element).filter(
      (t) => Lt(t)
    ).length === 0;
  }
  _initializeBackDrop() {
    if (!this.options.sidenavBackdrop)
      return;
    const t = this.options.sidenavBackdropClass ? this.options.sidenavBackdropClass.split(" ") : this.options.sidenavPosition ? [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      this.options.sidenavPosition,
      "top-0",
      "left-0",
      "z-50",
      "bg-black/10",
      "dark:bg-black-60",
      "w-full",
      "h-full",
      this._element.id
    ] : null;
    return new So({
      isVisible: this.options.sidenavBackdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      backdropClasses: t,
      clickCallback: () => this.hide()
    });
  }
  _updateBackdrop(t) {
    if (this.options.sidenavMode === "over") {
      t ? this._backdrop.show() : this.isBackdropVisible && this._backdrop.hide();
      return;
    }
    this.isBackdropVisible && this._backdrop.hide();
  }
  _setup() {
    this._setupTouch(), this.options.sidenavFocusTrap && this._setupFocusTrap(), this._setupCollapse(), this.options.sidenavSlim && this._setupSlim(), this._setupInitialStyling(), this._setupScrolling(), this.options.sidenavContent && this._setupContent(), this._setupActiveState(), this._setupRippleEffect(), this.options.sidenavHidden || this._updateOffsets(!0, !0), this.options.sidenavMode === "over" && this._setTabindex(!0);
  }
  _setupActiveState() {
    this._setActiveElements(), this.links.forEach((t) => {
      h.on(t, "click", () => this._setActiveElements(t)), h.on(t, "keydown", (e) => {
        e.keyCode === lt && this._setActiveElements(t);
      });
    }), h.on(window, "hashchange", this.hashHandler);
  }
  _setupCollapse() {
    this.navigation.forEach((t, e) => {
      d.find(ke, t).forEach(
        (n, o) => this._setupCollapseList({ list: n, index: o, menu: t, menuIndex: e })
      );
    });
  }
  _generateCollpaseID(t, e) {
    return `sidenav-collapse-${this._ID}-${e}-${t}`;
  }
  _setupCollapseList({ list: t, index: e, menu: i, menuIndex: n }) {
    const o = this._generateCollpaseID(e, n);
    t.setAttribute("id", o), t.setAttribute("data-te-collapse-item", "");
    const [r] = d.prev(t, li);
    c.setDataAttribute(r, "collapse-init", ""), r.setAttribute("href", `#${o}`), r.setAttribute("role", "button");
    const a = qt.getInstance(t) || new qt(t, {
      toggle: !1,
      parent: this.options.sidenavAccordion ? i : t
    });
    (t.dataset.teSidenavStateShow === "" || t.dataset.teCollapseShow === "") && this._rotateArrow(r, !1), h.on(r, "click", (l) => {
      this._toggleCategory(l, a, t), this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), h.on(
      t,
      "show.te.collapse",
      () => this._rotateArrow(r, !1)
    ), h.on(
      t,
      "hide.te.collapse",
      () => this._rotateArrow(r, !0)
    ), h.on(t, "shown.te.collapse", () => {
      this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), h.on(t, "hidden.te.collapse", () => {
      this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    });
  }
  _setupContent() {
    this._content = d.find(this.options.sidenavContent), this._content.forEach((t) => {
      const e = [
        "!p",
        "!m",
        "!px",
        "!pl",
        "!pr",
        "!mx",
        "!ml",
        "!mr",
        "!-p",
        "!-m",
        "!-px",
        "!-pl",
        "!-pr",
        "!-mx",
        "!-ml",
        "!-mr"
      ];
      [...t.classList].filter(
        (n) => e.findIndex((o) => n.includes(o)) >= 0
      ).forEach((n) => t.classList.remove(n));
    }), this._initialContentStyle = this._content.map((t) => {
      const { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r } = window.getComputedStyle(t);
      return { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r };
    });
  }
  _setupFocusTrap() {
    this._focusTrap = new $i(
      this._element,
      {
        event: "keydown",
        condition: (t) => t.keyCode === Oi,
        onlyVisible: !0
      },
      this.toggler
    );
  }
  _setupInitialStyling() {
    this._setColor(), c.style(this._element, this.sidenavStyle);
  }
  _setupScrolling() {
    let t = this._element;
    if (this.options.sidenavScrollContainer) {
      t = d.findOne(
        this.options.sidenavScrollContainer,
        this._element
      );
      const i = Vc(t.parentNode.children).filter(
        (n) => n !== t
      ).reduce((n, o) => n + o.clientHeight, 0);
      c.style(t, {
        maxHeight: `calc(100% - ${i}px)`,
        position: "relative"
      });
    }
    this._perfectScrollbar = new yc(t, {
      suppressScrollX: !0,
      handlers: ["click-rail", "drag-thumb", "wheel", "touch"]
    });
  }
  _setupSlim() {
    this._slimCollapsed = this.options.sidenavSlimCollapsed, this._toggleSlimDisplay(this._slimCollapsed), this.options.sidenavExpandOnHover && (this._element.addEventListener("mouseenter", () => {
      this._slimCollapsed && this._setSlim(!1);
    }), this._element.addEventListener("mouseleave", () => {
      this._slimCollapsed || this._setSlim(!0);
    }));
  }
  _setupRippleEffect() {
    this.links.forEach((t) => {
      let e = Ue.getInstance(t), i = this.options.sidenavColor;
      if (e && e._options.sidenavColor !== this.options.sidenavColor)
        e.dispose();
      else if (e)
        return;
      (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (i = "white"), e = new Ue(t, { rippleColor: i });
    });
  }
  _setupTouch() {
    this._touch = new em(this._element, "swipe", { threshold: 20 }), this._touch.init(), h.on(
      this._element,
      "swipeleft",
      (t) => this._handleSwipe(t, this.options.sidenavRight)
    ), h.on(
      this._element,
      "swiperight",
      (t) => this._handleSwipe(t, !this.options.sidenavRight)
    );
  }
  _setActive(t, e) {
    t.setAttribute("data-te-sidebar-state-active", ""), this._activeNode && t.removeAttribute("data-te-sidebar-state-active"), this._activeNode = t;
    const [i] = d.parents(
      this._activeNode,
      ke
    );
    if (!i) {
      this._setActiveCategory();
      return;
    }
    const [n] = d.prev(i, li);
    this._setActiveCategory(n), !e && !this._slimCollapsed && qt.getInstance(i).show();
  }
  _setActiveCategory(t) {
    this.navigation.forEach((e) => {
      d.find(ke, e).forEach((n) => {
        const [o] = d.prev(n, li);
        o !== t ? o.removeAttribute("data-te-sidenav-state-active") : o.setAttribute("data-te-sidenav-state-active", "");
      });
    });
  }
  _setActiveElements(t) {
    this.navigation.forEach((e) => {
      d.find(li, e).filter((n) => d.next(n, ke).length === 0).forEach((n) => {
        this._isActive(n, t) && n !== this._activeNode && this._setActive(n, t);
      });
    }), t && this._updateFocus(this.isVisible);
  }
  _setColor() {
    const t = [
      "primary",
      "secondary",
      "success",
      "info",
      "warning",
      "danger",
      "light",
      "dark"
    ], { sidenavColor: e } = this.options, i = t.includes(e) ? e : "primary";
    t.forEach((n) => {
      this._element.classList.remove(`sidenav-${n}`);
    }), c.addClass(this._element, `sidenav-${i}`);
  }
  _setContentOffsets(t, e, i) {
    this._content.forEach((n, o) => {
      const r = this._getOffsetValue(t, {
        index: o,
        property: "padding",
        offsets: e
      }), a = this._getOffsetValue(t, {
        index: o,
        property: "margin",
        offsets: e
      }), l = {};
      if (i || (l.transition = `all ${this.transitionDuration} linear`), l[e.padding.property] = `${r}px`, l[e.margin.property] = `${a}px`, c.style(n, l), !!t) {
        if (i) {
          c.style(n, {
            transition: this._initialContentStyle[o].transition
          });
          return;
        }
        h.on(n, "transitionend", () => {
          c.style(n, {
            transition: this._initialContentStyle[o].transition
          });
        });
      }
    });
  }
  _setMode(t) {
    this.options.sidenavMode !== t && (this._options.sidenavMode = t, this._update(this.isVisible));
  }
  _setSlim(t) {
    const e = t ? ["collapse", "collapsed"] : ["expand", "expanded"];
    this._triggerEvents(...e), t && this._collapseItems(), this._slimCollapsed = t, this._toggleSlimDisplay(t), c.style(this._element, { width: `${this.width}px` }), this._updateOffsets(this.isVisible);
  }
  _setTabindex(t) {
    this.links.forEach((e) => {
      e.tabIndex = t ? 0 : -1;
    });
  }
  _emitEvents(t) {
    const e = t ? ["show", "shown"] : ["hide", "hidden"];
    this._triggerEvents(...e);
  }
  _rotateArrow(t, e) {
    const [i] = d.children(t, `[${im}]`);
    i && (e ? c.removeClass(i, "rotate-180") : c.addClass(i, "rotate-180"));
  }
  _toggleCategory(t, e) {
    t.preventDefault(), e.toggle(), this._slimCollapsed && this.options.sidenavExpandable && (this._tempSlim = !0, this._setSlim(!1));
  }
  _toggleSlimDisplay(t) {
    const e = d.find(
      nm,
      this._element
    ), i = d.find(
      om,
      this._element
    ), n = () => {
      e.forEach((o) => {
        c.style(o, {
          display: this._slimCollapsed ? "unset" : "none"
        });
      }), i.forEach((o) => {
        c.style(o, {
          display: this._slimCollapsed ? "none" : "unset"
        });
      });
    };
    t ? setTimeout(
      () => n(),
      this.options.sidenavTransitionDuration
    ) : n();
  }
  async _triggerEvents(t, e) {
    h.trigger(this._element, `${t}.te.sidenav`), e && await setTimeout(() => {
      h.trigger(this._element, `${e}.te.sidenav`);
    }, this.options.sidenavTransitionDuration + 5);
  }
  _isiPhone() {
    return /iPhone|iPod/i.test(navigator.userAgent);
  }
  _update(t) {
    t && this._isiPhone() && c.addClass(this._element, "ps--scrolling-y"), this.toggler && this._updateTogglerAria(t), this._updateDisplay(t), this.options.sidenavBackdrop && this._updateBackdrop(t), this._updateOffsets(t), t && this.options.sidenavCloseOnEsc && this.options.sidenavMode !== "side" && h.on(window, "keydown", this.escHandler), this.options.sidenavFocusTrap && this._updateFocus(t);
  }
  _updateDisplay(t) {
    const e = t ? 0 : this.translation;
    c.style(this._element, {
      transform: `translateX(${e}%)`
    });
  }
  _updateFocus(t) {
    if (this._setTabindex(t), this.options.sidenavMode === "over" && this.options.sidenavFocusTrap) {
      if (t) {
        this._focusTrap.trap();
        return;
      }
      this._focusTrap.disable();
    }
    this._focusTrap.disable();
  }
  _updateOffsets(t, e = !1) {
    const [i, n] = this.options.sidenavRight ? ["right", "left"] : ["left", "right"], o = {
      property: this._getProperty("padding", i),
      value: this.options.sidenavMode === "over" ? 0 : this.width
    }, r = {
      property: this._getProperty("margin", n),
      value: this.options.sidenavMode === "push" ? -1 * this.width : 0
    };
    h.trigger(this._element, "update.te.sidenav", {
      margin: r,
      padding: o
    }), this._content && (this._content.className = "", this._setContentOffsets(t, { padding: o, margin: r }, e));
  }
  _updateTogglerAria(t) {
    this.toggler.setAttribute("aria-expanded", t);
  }
  // Static
  static toggleSidenav() {
    return function(t) {
      const e = d.closest(t.target, Rn), i = c.getDataAttributes(e).target;
      d.find(i).forEach((n) => {
        (pi.getInstance(n) || new pi(n)).toggle();
      });
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, hs);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new pi(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, hs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const lo = "stepper", Is = "te.stepper", Ks = `.${Is}`, Mi = `data-te-${lo}`, _i = "horizontal", xt = "vertical", dm = {
  stepperType: "string",
  stepperLinear: "boolean",
  stepperNoEditable: "boolean",
  stepperActive: "string",
  stepperCompleted: "string",
  stepperInvalid: "string",
  stepperDisabled: "string",
  stepperVerticalBreakpoint: "number",
  stepperMobileBreakpoint: "number",
  stepperMobileBarBreakpoint: "number"
}, um = {
  stepperType: _i,
  stepperLinear: !1,
  stepperNoEditable: !1,
  stepperActive: "",
  stepperCompleted: "",
  stepperInvalid: "",
  stepperDisabled: "",
  stepperVerticalBreakpoint: 0,
  stepperMobileBreakpoint: 0,
  stepperMobileBarBreakpoint: 4
}, fa = `mousedown${Ks}`, ma = `keydown${Ks}`, pm = `keyup${Ks}`, ga = `resize${Ks}`, jt = `[${Mi}-step-ref]`, G = `[${Mi}-head-ref]`, ba = `[${Mi}-head-text-ref]`, ds = `[${Mi}-head-icon-ref]`, st = `[${Mi}-content-ref]`;
class j0 {
  constructor(t, e) {
    this._element = t, this._options = this._getConfig(e), this._elementHeight = 0, this._steps = d.find(`${jt}`, this._element), this._currentView = "", this._activeStepIndex = 0, this._verticalStepperStyles = [], this._element && (I.setData(t, Is, this), this._init());
  }
  // Getters
  static get NAME() {
    return lo;
  }
  get activeStep() {
    return this._steps[this._activeStepIndex];
  }
  get activeStepIndex() {
    return this._activeStepIndex;
  }
  // Public
  dispose() {
    this._steps.forEach((t) => {
      h.off(t, fa), h.off(t, ma);
    }), h.off(window, ga), I.removeData(this._element, Is), this._element = null;
  }
  changeStep(t) {
    this._toggleStep(t);
  }
  nextStep() {
    this._toggleStep(this._activeStepIndex + 1);
  }
  previousStep() {
    this._toggleStep(this._activeStepIndex - 1);
  }
  // Private
  _init() {
    const t = d.find(`${jt}`, this._element)[this._activeStepIndex].setAttribute("data-te", "active-step"), e = d.find(
      `${ba}`,
      this._element
    ), i = d.find(
      `${ds}`,
      this._element
    );
    switch (t ? (this._activeStepIndex = this._steps.indexOf(t), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    ), e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700")) : (e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    )), this._bindMouseDown(), this._bindKeysNavigation(), this._options.stepperType) {
      case xt:
        this._toggleVertical();
        break;
      default:
        this._toggleHorizontal();
        break;
    }
    (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(), this._bindResize();
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...um,
      ...e,
      ...t
    }, L(lo, t, dm), t;
  }
  _bindMouseDown() {
    this._steps.forEach((t) => {
      const e = d.findOne(`${G}`, t);
      h.on(e, fa, (i) => {
        const n = d.parents(i.target, `${jt}`)[0], o = this._steps.indexOf(n);
        i.preventDefault(), this._toggleStep(o);
      });
    });
  }
  _bindResize() {
    h.on(window, ga, () => {
      this._currentView === xt && this._setSingleStepHeight(this.activeStep), this._currentView === _i && this._setHeight(this.activeStep), (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView();
    });
  }
  _toggleStepperView() {
    const t = this._options.stepperVerticalBreakpoint < window.innerWidth, e = this._options.stepperVerticalBreakpoint > window.innerWidth, i = this._options.stepperMobileBreakpoint > window.innerWidth;
    t && this._currentView !== _i && this._toggleHorizontal(), e && !i && this._currentView !== xt && (this._steps.forEach((n) => {
      const o = d.findOne(`${st}`, n);
      this._resetStepperHeight(), this._showElement(o);
    }), this._toggleVertical());
  }
  _toggleStep(t) {
    this._activeStepIndex !== t && (this._options.stepperNoEditable && this._toggleDisabled(), this._showElement(
      d.findOne(`${st}`, this._steps[t])
    ), this._toggleActive(t), t > this._activeStepIndex && this._toggleCompleted(this._activeStepIndex), this._currentView === _i ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t), this._setSingleStepHeight(this._steps[t])), this._toggleStepTabIndex(
      d.findOne(`${G}`, this.activeStep),
      d.findOne(`${G}`, this._steps[t])
    ), this._activeStepIndex = t, this._steps[this._activeStepIndex].setAttribute("data-te", "active-step"), this._steps.forEach((e, i) => {
      e[this._activeStepIndex] !== i && e.removeAttribute("data-te");
    }));
  }
  _resetStepperHeight() {
    this._element.style.height = "";
  }
  _setStepsHeight() {
    this._steps.forEach((t) => {
      const e = d.findOne(`${st}`, t), i = window.getComputedStyle(e);
      this._verticalStepperStyles.push({
        paddingTop: parseFloat(i.paddingTop),
        paddingBottom: parseFloat(i.paddingBottom)
      });
      const n = e.scrollHeight;
      e.style.height = `${n}px`;
    });
  }
  _setSingleStepHeight(t) {
    const e = d.findOne(`${st}`, t), i = this.activeStep === t, n = this._steps.indexOf(t);
    let o;
    i ? (e.style.height = "", o = e.scrollHeight) : o = e.scrollHeight + this._verticalStepperStyles[n].paddingTop + this._verticalStepperStyles[n].paddingBottom, e.style.height = `${o}px`;
  }
  _toggleVertical() {
    this._currentView = xt, this._setStepsHeight(), this._hideInactiveSteps();
  }
  _toggleHorizontal() {
    this._currentView = _i, this._setHeight(this.activeStep), this._hideInactiveSteps();
  }
  _toggleStepperClass() {
    d.findOne(
      "[data-te-stepper-type]",
      this._element
    ) !== null && this._steps.forEach((e) => {
      d.findOne(`${st}`, e).classList.remove("!my-0"), d.findOne(`${st}`, e).classList.remove("!py-0"), d.findOne(`${st}`, e).classList.remove("!h-0");
    });
  }
  _toggleStepClass(t, e, i) {
    i && this._steps[t].classList[e](i);
  }
  _bindKeysNavigation() {
    this._toggleStepTabIndex(
      !1,
      d.findOne(`${G}`, this.activeStep)
    ), this._steps.forEach((t) => {
      const e = d.findOne(`${G}`, t);
      h.on(e, ma, (i) => {
        const n = d.parents(
          i.currentTarget,
          `${jt}`
        )[0], o = d.next(n, `${jt}`)[0], r = d.prev(n, `${jt}`)[0], a = d.findOne(
          `${G}`,
          n
        ), l = d.findOne(
          `${G}`,
          this.activeStep
        );
        let p = null, u = null;
        if (o && (p = d.findOne(`${G}`, o)), r && (u = d.findOne(`${G}`, r)), i.keyCode === Pe && this._currentView !== xt && (u ? (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus()) : p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === Be && this._currentView !== xt && (p ? (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus()) : u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === z && this._currentView === xt && (i.preventDefault(), p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === rt && this._currentView === xt && (i.preventDefault(), u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === He) {
          const f = d.findOne(
            `${G}`,
            this._steps[0]
          );
          this._toggleStepTabIndex(a, f), this._toggleOutlineStyles(a, f), f.focus();
        }
        if (i.keyCode === We) {
          const f = this._steps[this._steps.length - 1], _ = d.findOne(`${G}`, f);
          this._toggleStepTabIndex(a, _), this._toggleOutlineStyles(a, _), _.focus();
        }
        (i.keyCode === lt || i.keyCode === ks) && (i.preventDefault(), this.changeStep(this._steps.indexOf(n))), i.keyCode === Oi && (this._toggleStepTabIndex(a, l), this._toggleOutlineStyles(a, !1), l.focus());
      }), h.on(e, pm, (i) => {
        const n = d.parents(
          i.currentTarget,
          `${jt}`
        )[0], o = d.findOne(
          `${G}`,
          n
        ), r = d.findOne(
          `${G}`,
          this.activeStep
        );
        i.keyCode === Oi && (this._toggleStepTabIndex(o, r), this._toggleOutlineStyles(!1, r), r.focus());
      });
    });
  }
  _toggleStepTabIndex(t, e) {
    t && t.setAttribute("tabIndex", -1), e && e.setAttribute("tabIndex", 0);
  }
  _toggleOutlineStyles(t, e) {
    t && (t.style.outline = ""), e && (e.style.outline = "revert");
  }
  _toggleDisabled() {
    const t = d.find(`${G}`, this._element), e = d.find(
      `${ds}`,
      this._element
    );
    t[this._activeStepIndex].classList.add("color-[#858585]"), t[this._activeStepIndex].classList.add("cursor-default"), e[this._activeStepIndex].classList.add("!bg-[#858585]"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperDisabled
    );
  }
  _toggleActive(t) {
    const e = d.find(
      `${ba}`,
      this._element
    ), i = d.find(
      `${ds}`,
      this._element
    );
    e[t].classList.add("font-medium"), i[t].classList.add("!bg-primary-100"), i[t].classList.add("!text-primary-700"), i[t].classList.remove("!bg-success-100"), i[t].classList.remove("!text-success-700"), e[this._activeStepIndex].classList.remove("font-medium"), i[this._activeStepIndex].classList.remove("!bg-primary-100"), i[this._activeStepIndex].classList.remove(
      "!text-primary-700"
    ), this._toggleStepClass(t, "add", this._options.stepperActive), this._toggleStepClass(
      this._activeStepIndex,
      "remove",
      this._options.stepperActive
    );
  }
  _toggleCompleted(t) {
    const e = d.find(
      `${ds}`,
      this._element
    );
    e[t].classList.add("!bg-success-100"), e[t].classList.add("!text-success-700"), e[t].classList.remove("!bg-danger-100"), e[t].classList.remove("!text-danger-700"), this._toggleStepClass(t, "add", this._options.stepperCompleted), this._toggleStepClass(t, "remove", this._options.stepperInvalid);
  }
  _hideInactiveSteps() {
    this._steps.forEach((t) => {
      t.getAttribute("data-te") || this._hideElement(d.findOne(`${st}`, t));
    });
  }
  _setHeight(t) {
    const e = d.findOne(`${st}`, t), i = getComputedStyle(e), n = d.findOne(`${G}`, t), o = getComputedStyle(n), r = e.offsetHeight + parseFloat(i.marginTop) + parseFloat(i.marginBottom), a = n.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);
    this._element.style.height = `${a + r}px`;
  }
  _hideElement(t) {
    !d.parents(
      t,
      `${jt}`
    )[0].getAttribute("data-te") && this._currentView !== xt || (t.classList.add("!my-0"), t.classList.add("!py-0"), t.classList.add("!h-0"));
  }
  _showElement(t) {
    this._currentView === xt ? (t.classList.remove("!my-0"), t.classList.remove("!py-0"), t.classList.remove("!h-0")) : t.style.display = "block";
  }
  _animateHorizontalStep(t) {
    const e = t > this._activeStepIndex, i = d.findOne(
      `${st}`,
      this._steps[t]
    ), n = d.findOne(
      `${st}`,
      this.activeStep
    );
    let o, r;
    this._steps.forEach((u, f) => {
      const _ = d.findOne(`${st}`, u);
      f !== t && f !== this._activeStepIndex && this._hideElement(_);
    });
    const a = "translate-x-[150%]", l = "-translate-x-[150%]", p = "translate-0";
    e ? (r = l, o = p, i.classList.remove("translate-x-[150%]"), i.classList.remove("-translate-x-[150%]")) : (r = a, o = p, i.classList.remove("-translate-x-[150%]"), i.classList.remove("translate-x-[150%]")), n.classList.add(r), i.classList.add(o), this._setHeight(this._steps[t]);
  }
  _animateVerticalStep(t) {
    const e = d.findOne(
      `${st}`,
      this._steps[t]
    ), i = d.findOne(
      `${st}`,
      this.activeStep
    );
    this._hideElement(i), this._showElement(e);
  }
  static getInstance(t) {
    return I.getData(t, Is);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const va = "data-te-input-state-active", us = "data-te-input-selected", Ta = "data-te-input-multiple-active", Ea = "[data-te-form-check-input]";
class Ca {
  constructor(t, e, i, n, o, r, a, l, p, u, f) {
    this.id = t, this.nativeOption = e, this.multiple = i, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = p, this.groupId = u, this.icon = f, this.node = null, this.active = !1;
  }
  select() {
    this.multiple ? this._selectMultiple() : this._selectSingle();
  }
  _selectSingle() {
    this.selected || (this.node.setAttribute(us, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0));
  }
  _selectMultiple() {
    if (!this.selected) {
      const t = d.findOne(
        Ea,
        this.node
      );
      t.checked = !0, this.node.setAttribute(us, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0);
    }
  }
  deselect() {
    this.multiple ? this._deselectMultiple() : this._deselectSingle();
  }
  _deselectSingle() {
    this.selected && (this.node.removeAttribute(us), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1));
  }
  _deselectMultiple() {
    if (this.selected) {
      const t = d.findOne(
        Ea,
        this.node
      );
      t.checked = !1, this.node.removeAttribute(us), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1);
    }
  }
  setNode(t) {
    this.node = t;
  }
  setActiveStyles() {
    if (!this.active) {
      if (this.multiple) {
        this.node.setAttribute(Ta, "");
        return;
      }
      this.active = !0, this.node.setAttribute(va, "");
    }
  }
  removeActiveStyles() {
    this.active && (this.active = !1, this.node.removeAttribute(va)), this.multiple && this.node.removeAttribute(Ta);
  }
}
class _m {
  constructor(t = !1) {
    this._multiple = t, this._selections = [];
  }
  select(t) {
    this._multiple ? this._selections.push(t) : this._selections = [t];
  }
  deselect(t) {
    if (this._multiple) {
      const e = this._selections.findIndex(
        (i) => t === i
      );
      this._selections.splice(e, 1);
    } else
      this._selections = [];
  }
  clear() {
    this._selections = [];
  }
  get selection() {
    return this._selections[0];
  }
  get selections() {
    return this._selections;
  }
  get label() {
    return this._selections[0] && this.selection.label;
  }
  get labels() {
    return this._selections.map((t) => t.label).join(", ");
  }
  get value() {
    return this.selections[0] && this.selection.value;
  }
  get values() {
    return this._selections.map((t) => t.value);
  }
}
function co(s) {
  return s.filter((t) => !t.disabled).every((t) => t.selected);
}
const fm = "data-te-select-form-outline-ref", mm = "data-te-select-wrapper-ref", gm = "data-te-select-input-ref", bm = "data-te-select-clear-btn-ref", vm = "data-te-select-dropdown-container-ref", Tm = "data-te-select-dropdown-ref", Em = "data-te-select-options-wrapper-ref", Cm = "data-te-select-options-list-ref", Am = "data-te-select-input-filter-ref", ac = "data-te-select-option-ref", ym = "data-te-select-option-all-ref", wm = "data-te-select-option-text-ref", xm = "data-te-form-check-input", km = "data-te-select-option-group-ref", Om = "data-te-select-option-group-label-ref", lc = "data-te-select-selected", Sm = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
</svg>
`, Im = (s) => {
  s.code === "Tab" || s.code === "Esc" || s.preventDefault();
};
function ps(s, t, e, i, n) {
  t.selectSize === "default" && c.addClass(s, e), t.selectSize === "sm" && c.addClass(s, i), t.selectSize === "lg" && c.addClass(s, n);
}
function Dm(s, t, e, i) {
  const n = document.createElement("div");
  n.setAttribute("id", s), n.setAttribute(mm, "");
  const o = D("div");
  o.setAttribute(fm, ""), c.addClass(o, i.formOutline);
  const r = D("input"), a = t.selectFilter ? "combobox" : "listbox", l = t.multiple ? "true" : "false", p = t.disabled ? "true" : "false";
  r.setAttribute(gm, ""), c.addClass(r, i.selectInput), ps(
    r,
    t,
    i.selectInputSizeDefault,
    i.selectInputSizeSm,
    i.selectInputSizeLg
  ), t.selectFormWhite && c.addClass(r, i.selectInputWhite), r.setAttribute("type", "text"), r.setAttribute("role", a), r.setAttribute("aria-multiselectable", l), r.setAttribute("aria-disabled", p), r.setAttribute("aria-haspopup", "true"), r.setAttribute("aria-expanded", !1), t.tabIndex && r.setAttribute("tabIndex", t.tabIndex), t.disabled && r.setAttribute("disabled", ""), t.selectPlaceholder !== "" && r.setAttribute("placeholder", t.selectPlaceholder), t.selectValidation ? (c.addStyle(r, {
    "pointer-events": "none",
    "caret-color": "transparent"
  }), c.addStyle(o, { cursor: "pointer" })) : r.setAttribute("readonly", "true"), t.selectValidation && (r.setAttribute("required", "true"), r.setAttribute("aria-required", "true"), r.addEventListener("keydown", Im));
  const u = D("div");
  c.addClass(u, i.selectValidationValid);
  const f = document.createTextNode(
    `${t.selectValidFeedback}`
  );
  u.appendChild(f);
  const _ = D("div");
  c.addClass(_, i.selectValidationInvalid);
  const m = document.createTextNode(
    `${t.selectInvalidFeedback}`
  );
  _.appendChild(m);
  const g = D("span");
  g.setAttribute(bm, ""), c.addClass(g, i.selectClearBtn), ps(
    g,
    t,
    i.selectClearBtnDefault,
    i.selectClearBtnSm,
    i.selectClearBtnLg
  ), t.selectFormWhite && c.addClass(g, i.selectClearBtnWhite);
  const v = document.createTextNode("✕");
  g.appendChild(v), g.setAttribute("tabindex", "0");
  const b = D("span");
  return c.addClass(b, i.selectArrow), ps(
    b,
    t,
    i.selectArrowDefault,
    i.selectArrowSm,
    i.selectArrowLg
  ), t.selectFormWhite && c.addClass(b, i.selectArrowWhite), b.innerHTML = Sm, o.appendChild(r), e && (c.addClass(e, i.selectLabel), ps(
    e,
    t,
    i.selectLabelSizeDefault,
    i.selectLabelSizeSm,
    i.selectLabelSizeLg
  ), t.selectFormWhite && c.addClass(e, i.selectLabelWhite), o.appendChild(e)), t.selectValidation && (o.appendChild(u), o.appendChild(_)), t.selectClearButton && o.appendChild(g), o.appendChild(b), n.appendChild(o), n;
}
function Aa(s, t, e, i, n, o, r, a) {
  const l = document.createElement("div");
  l.setAttribute(vm, ""), c.addClass(l, a.selectDropdownContainer), l.setAttribute("id", `${s}`), l.style.width = `${e}px`;
  const p = document.createElement("div");
  p.setAttribute("tabindex", 0), p.setAttribute(Tm, ""), c.addClass(p, a.dropdown);
  const u = D("div");
  u.setAttribute(Em, ""), c.addClass(u, a.optionsWrapper), c.addClass(u, a.optionsWrapperScrollbar), u.style.maxHeight = `${i}px`;
  const f = cc(
    o,
    n,
    t,
    a
  );
  return u.appendChild(f), t.selectFilter && p.appendChild(
    $m(t.selectSearchPlaceholder, a)
  ), p.appendChild(u), r && p.appendChild(r), l.appendChild(p), l;
}
function cc(s, t, e, i) {
  const n = D("div");
  n.setAttribute(Cm, ""), c.addClass(n, i.optionsList);
  let o;
  return e.multiple ? o = Mm(
    s,
    t,
    e,
    i
  ) : o = Lm(s, e, i), o.forEach((r) => {
    n.appendChild(r);
  }), n;
}
function $m(s, t) {
  const e = D("div");
  c.addClass(e, t.inputGroup);
  const i = D("input");
  return i.setAttribute(Am, ""), c.addClass(i, t.selectFilterInput), i.placeholder = s, i.setAttribute("role", "searchbox"), i.setAttribute("type", "text"), e.appendChild(i), e;
}
function Lm(s, t, e) {
  return hc(s, t, e);
}
function Mm(s, t, e, i) {
  let n = null;
  e.selectAll && (n = Nm(
    t,
    s,
    e,
    i
  ));
  const o = hc(s, e, i);
  return n ? [n, ...o] : o;
}
function hc(s, t, e) {
  const i = [];
  return s.forEach((n) => {
    if (Object.prototype.hasOwnProperty.call(
      n,
      "options"
    )) {
      const r = Hm(n, t, e);
      i.push(r);
    } else
      i.push(dc(n, t, e));
  }), i;
}
function Nm(s, t, e, i) {
  const n = co(t), o = D("div");
  return o.setAttribute(ac, ""), c.addClass(o, i.selectOption), o.setAttribute(ym, ""), c.addStyle(o, {
    height: `${e.selectOptionHeight}px`
  }), o.setAttribute("role", "option"), o.setAttribute("aria-selected", n), n && o.setAttribute(lc, ""), o.appendChild(uc(s, e, i)), s.setNode(o), o;
}
function dc(s, t, e) {
  if (s.node)
    return s.node;
  const i = D("div");
  return i.setAttribute(ac, ""), c.addClass(i, e.selectOption), c.addStyle(i, {
    height: `${t.selectOptionHeight}px`
  }), c.setDataAttribute(i, "id", s.id), i.setAttribute("role", "option"), i.setAttribute("aria-selected", s.selected), i.setAttribute("aria-disabled", s.disabled), s.selected && i.setAttribute(lc, ""), s.disabled && i.setAttribute("data-te-select-option-disabled", !0), s.hidden && c.addClass(i, "hidden"), i.appendChild(uc(s, t, e)), s.icon && i.appendChild(Bm(s, e)), s.setNode(i), i;
}
function uc(s, t, e) {
  const i = D("span");
  i.setAttribute(wm, ""), c.addClass(i, e.selectOptionText);
  const n = document.createTextNode(s.label);
  return t.multiple && i.appendChild(Pm(s, e)), i.appendChild(n), (s.secondaryText || typeof s.secondaryText == "number") && i.appendChild(
    Rm(s.secondaryText, e)
  ), i;
}
function Rm(s, t) {
  const e = D("span");
  c.addClass(e, t.selectOptionSecondaryText);
  const i = document.createTextNode(s);
  return e.appendChild(i), e;
}
function Pm(s, t) {
  const e = D("input");
  e.setAttribute("type", "checkbox"), c.addClass(e, t.formCheckInput), e.setAttribute(xm, "");
  const i = D("label");
  return s.selected && e.setAttribute("checked", !0), s.disabled && e.setAttribute("disabled", !0), e.appendChild(i), e;
}
function Bm(s, t) {
  const e = D("span"), i = D("img");
  return c.addClass(i, t.selectOptionIcon), i.src = s.icon, e.appendChild(i), e;
}
function Hm(s, t, e) {
  const i = D("div");
  i.setAttribute(km, ""), c.addClass(i, e.selectOptionGroup), i.setAttribute("role", "group"), i.setAttribute("id", s.id), s.hidden && c.addClass(i, "hidden");
  const n = D("label");
  return n.setAttribute(Om, ""), c.addClass(n, e.selectOptionGroupLabel), c.addStyle(n, { height: `${t.selectOptionHeight}px` }), n.setAttribute("for", s.id), n.textContent = s.label, i.appendChild(n), s.options.forEach((o) => {
    i.appendChild(dc(o, t, e));
  }), i;
}
function Wm(s, t) {
  const e = D("div");
  return e.innerHTML = s, c.addClass(e, t.selectLabel), c.addClass(e, t.selectFakeValue), e;
}
const Pn = "select", fi = "te.select", Ni = `.${fi}`, Vm = `close${Ni}`, Fm = `open${Ni}`, ya = `optionSelect${Ni}`, wa = `optionDeselect${Ni}`, Ym = `valueChange${Ni}`, jm = "change", xa = "data-te-select-init", pc = "data-te-select-no-results-ref", ka = "data-te-select-open", q = "data-te-input-state-active", Kt = "data-te-input-focused", Bn = "data-te-input-disabled", Km = "data-te-select-option-group-label-ref", zm = "data-te-select-option-all-ref", ci = "data-te-select-selected", Um = "[data-te-select-label-ref]", Oa = "[data-te-select-input-ref]", Xm = "[data-te-select-input-filter-ref]", Gm = "[data-te-select-dropdown-ref]", qm = "[data-te-select-options-wrapper-ref]", Sa = "[data-te-select-options-list-ref]", Zm = "[data-te-select-option-ref]", Qm = "[data-te-select-clear-btn-ref]", Jm = "[data-te-select-custom-content-ref]", tg = `[${pc}]`, Ia = "[data-te-select-form-outline-ref]", eg = "[data-te-select-toggle]", Hn = "[data-te-input-notch-ref]", ig = 200, sg = {
  selectAutoSelect: !1,
  selectContainer: "body",
  selectClearButton: !1,
  disabled: !1,
  selectDisplayedLabels: 5,
  selectFormWhite: !1,
  multiple: !1,
  selectOptionsSelectedLabel: "options selected",
  selectOptionHeight: 38,
  selectAll: !0,
  selectAllLabel: "Select all",
  selectSearchPlaceholder: "Search...",
  selectSize: "default",
  selectVisibleOptions: 5,
  selectFilter: !1,
  selectFilterDebounce: 300,
  selectNoResultText: "No results",
  selectValidation: !1,
  selectValidFeedback: "Valid",
  selectInvalidFeedback: "Invalid",
  selectPlaceholder: ""
}, ng = {
  selectAutoSelect: "boolean",
  selectContainer: "string",
  selectClearButton: "boolean",
  disabled: "boolean",
  selectDisplayedLabels: "number",
  selectFormWhite: "boolean",
  multiple: "boolean",
  selectOptionsSelectedLabel: "string",
  selectOptionHeight: "number",
  selectAll: "boolean",
  selectAllLabel: "string",
  selectSearchPlaceholder: "string",
  selectSize: "string",
  selectVisibleOptions: "number",
  selectFilter: "boolean",
  selectFilterDebounce: "number",
  selectNoResultText: "string",
  selectValidation: "boolean",
  selectValidFeedback: "string",
  selectInvalidFeedback: "string",
  selectPlaceholder: "string"
}, og = {
  dropdown: "relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700",
  formCheckInput: "relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent",
  formOutline: "relative",
  initialized: "hidden",
  inputGroup: "flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200",
  noResult: "flex items-center px-4",
  optionsList: "list-none m-0 p-0",
  optionsWrapper: "overflow-y-auto",
  optionsWrapperScrollbar: "[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded",
  selectArrow: "absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5",
  selectArrowWhite: "text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white",
  selectArrowDefault: "top-2",
  selectArrowLg: "top-[13px]",
  selectArrowSm: "top-1",
  selectClearBtn: "absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200",
  selectClearBtnWhite: "!text-gray-50",
  selectClearBtnDefault: "top-2 text-base",
  selectClearBtnLg: "top-[11px] text-base",
  selectClearBtnSm: "top-1 text-[0.8rem]",
  selectDropdownContainer: "z-[1070]",
  selectFakeValue: "transform-none hidden data-[te-input-state-active]:block",
  selectFilterInput: "relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200",
  selectInput: "peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600",
  selectInputWhite: "!text-gray-50",
  selectInputSizeDefault: "py-[0.32rem] px-3 leading-[1.6]",
  selectInputSizeLg: "py-[0.32rem] px-3 leading-[2.15]",
  selectInputSizeSm: "py-[0.33rem] px-3 text-xs leading-[1.5]",
  selectLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary",
  selectLabelWhite: "!text-gray-50",
  selectLabelSizeDefault: "pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]",
  selectLabelSizeLg: "pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]",
  selectLabelSizeSm: "pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]",
  selectOption: "flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30",
  selectOptionGroup: "group/opt",
  selectOptionGroupLabel: "flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300",
  selectOptionIcon: "w-7 h-7 rounded-full",
  selectOptionSecondaryText: "block text-[0.8rem] text-gray-500 dark:text-gray-300",
  selectOptionText: "group",
  selectValidationValid: "hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block",
  selectValidationInvalid: "hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block"
}, rg = {
  dropdown: "string",
  formCheckInput: "string",
  formOutline: "string",
  initialized: "string",
  inputGroup: "string",
  noResult: "string",
  optionsList: "string",
  optionsWrapper: "string",
  optionsWrapperScrollbar: "string",
  selectArrow: "string",
  selectArrowDefault: "string",
  selectArrowLg: "string",
  selectArrowSm: "string",
  selectClearBtn: "string",
  selectClearBtnDefault: "string",
  selectClearBtnLg: "string",
  selectClearBtnSm: "string",
  selectDropdownContainer: "string",
  selectFakeValue: "string",
  selectFilterInput: "string",
  selectInput: "string",
  selectInputSizeDefault: "string",
  selectInputSizeLg: "string",
  selectInputSizeSm: "string",
  selectLabel: "string",
  selectLabelSizeDefault: "string",
  selectLabelSizeLg: "string",
  selectLabelSizeSm: "string",
  selectOption: "string",
  selectOptionGroup: "string",
  selectOptionGroupLabel: "string",
  selectOptionIcon: "string",
  selectOptionSecondaryText: "string",
  selectOptionText: "string"
};
class $o {
  constructor(t, e, i) {
    this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._config.selectPlaceholder && !this._config.multiple && this._addPlaceholderOption(), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new _m(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = bt("select-wrapper-"), this._dropdownContainerId = bt("select-dropdown-container-"), this._selectAllId = bt("select-all-"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions, this._popper = null, this._input = null, this._label = d.next(this._element, Um)[0], this._notch = null, this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = d.next(
      t,
      Jm
    )[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), this._element && I.setData(t, fi, this);
  }
  static get NAME() {
    return Pn;
  }
  get filterInput() {
    return d.findOne(
      Xm,
      this._dropdownContainer
    );
  }
  get dropdown() {
    return d.findOne(Gm, this._dropdownContainer);
  }
  get optionsList() {
    return d.findOne(
      Sa,
      this._dropdownContainer
    );
  }
  get optionsWrapper() {
    return d.findOne(
      qm,
      this._dropdownContainer
    );
  }
  get clearButton() {
    return d.findOne(Qm, this._wrapper);
  }
  get options() {
    return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;
  }
  get value() {
    return this.multiple ? this._selectionModel.values : this._selectionModel.value;
  }
  get multiple() {
    return this._config.multiple;
  }
  get hasSelectAll() {
    return this.multiple && this._config.selectAll;
  }
  get hasSelection() {
    return this._selectionModel.selection || this._selectionModel.selections.length > 0;
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...sg,
      ...e,
      ...t
    }, this._element.hasAttribute("multiple") && (t.multiple = !0), this._element.hasAttribute("disabled") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute("tabIndex")), L(Pn, t, ng), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...og,
      ...e,
      ...t
    }, L(Pn, t, rg), t;
  }
  _addPlaceholderOption() {
    const t = new Option("", "", !0, !0);
    t.hidden = !0, t.selected = !0, this._element.prepend(t);
  }
  _getOptionsToRender(t) {
    const e = [];
    return t.childNodes.forEach((n) => {
      if (n.nodeName === "OPTGROUP") {
        const o = {
          id: bt("group-"),
          label: n.label,
          disabled: n.hasAttribute("disabled"),
          hidden: n.hasAttribute("hidden"),
          options: []
        };
        n.childNodes.forEach((a) => {
          a.nodeName === "OPTION" && o.options.push(
            this._createOptionObject(a, o)
          );
        }), e.push(o);
      } else
        n.nodeName === "OPTION" && e.push(this._createOptionObject(n));
    }), e;
  }
  _getPlainOptions(t) {
    if (!d.findOne("optgroup", this._element))
      return t;
    const i = [];
    return t.forEach((n) => {
      Object.prototype.hasOwnProperty.call(
        n,
        "options"
      ) ? n.options.forEach((r) => {
        i.push(r);
      }) : i.push(n);
    }), i;
  }
  _createOptionObject(t, e = {}) {
    const i = bt("option-"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : !1, r = t.selected || t.hasAttribute(ci), a = t.hasAttribute("disabled") || o, l = t.hasAttribute("hidden") || e && e.hidden, p = this.multiple, u = t.value, f = t.label, _ = c.getDataAttribute(
      t,
      "selectSecondaryText"
    ), m = c.getDataAttribute(t, "select-icon");
    return new Ca(
      i,
      t,
      p,
      u,
      f,
      r,
      a,
      l,
      _,
      n,
      m
    );
  }
  _getNavigationOptions() {
    const t = this.options.filter((e) => !e.hidden);
    return this.hasSelectAll ? [this._selectAllOption, ...t] : t;
  }
  _init() {
    this._renderMaterialWrapper(), this._wrapper = d.findOne(`#${this._wrapperId}`), this._input = d.findOne(Oa, this._wrapper), this._config.disabled && this._input.setAttribute(Bn, "");
    const t = this._config.selectContainer;
    t === "body" ? this._container = document.body : this._container = d.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = Aa(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    ), this._setFirstActiveOption(), this._listenToFocusChange();
  }
  _renderMaterialWrapper() {
    const t = Dm(
      this._wrapperId,
      this._config,
      this._label,
      this._classes
    );
    this._element.parentNode.insertBefore(t, this._element), c.addClass(this._element, this._classes.initialized), t.appendChild(this._element);
  }
  _initOutlineInput() {
    const t = d.findOne(
      Ia,
      this._wrapper
    );
    new W(
      t,
      {
        inputFormWhite: this._config.selectFormWhite
      },
      this._classes
    ).init(), this._notch = d.findOne(Hn, this._wrapper);
  }
  _bindComponentEvents() {
    this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();
  }
  _setDefaultSelections() {
    this.options.forEach((t) => {
      t.selected && this._selectionModel.select(t);
    });
  }
  _listenToComponentKeydown() {
    h.on(this._wrapper, "keydown", this._handleKeydown.bind(this));
  }
  _handleKeydown(t) {
    this._isOpen && !this._config.selectFilter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
  }
  _handleOpenKeydown(t) {
    const e = t.keyCode, i = e === Li || e === rt && t.altKey || e === Oi;
    if (e === Oi && this._config.selectAutoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), i) {
      this.close(), this._input.focus();
      return;
    }
    switch (e) {
      case z:
        this._setNextOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case rt:
        this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case He:
        this._setFirstOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case We:
        this._setLastOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case lt:
        t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));
        return;
      default:
        return;
    }
    t.preventDefault();
  }
  _handleClosedKeydown(t) {
    const e = t.keyCode;
    if (e === lt && t.preventDefault(), (e === lt || e === z && t.altKey || e === z && this.multiple) && this.open(), this.multiple)
      switch (e) {
        case z:
          this.open();
          break;
        case rt:
          this.open();
          break;
        default:
          return;
      }
    else
      switch (e) {
        case z:
          this._setNextOptionActive(), this._handleSelection(this._activeOption);
          break;
        case rt:
          this._setPreviousOptionActive(), this._handleSelection(this._activeOption);
          break;
        case He:
          this._setFirstOptionActive(), this._handleSelection(this._activeOption);
          break;
        case We:
          this._setLastOptionActive(), this._handleSelection(this._activeOption);
          break;
        default:
          return;
      }
    t.preventDefault();
  }
  _scrollToOption(t) {
    if (!t)
      return;
    let e;
    const i = this.options.filter((u) => !u.hidden);
    this.hasSelectAll ? e = i.indexOf(t) + 1 : e = i.indexOf(t);
    const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.selectOptionHeight, p = r.scrollTop;
    if (e > -1) {
      const u = o * l, f = u + l > p + a;
      u < p ? r.scrollTop = u : f ? r.scrollTop = u - a + l : r.scrollTop = p;
    }
  }
  _getNumberOfGroupsBeforeOption(t) {
    const e = this.options.filter((r) => !r.hidden), i = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t - 1 : t;
    let o = 0;
    for (let r = 0; r <= n; r++)
      e[r].groupId && i[o] && i[o].id && e[r].groupId === i[o].id && o++;
    return o;
  }
  _setNextOptionActive() {
    let t = this._activeOptionIndex + 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t += 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setPreviousOptionActive() {
    let t = this._activeOptionIndex - 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t -= 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setFirstOptionActive() {
    const e = this._getNavigationOptions();
    this._updateActiveOption(e[0], 0);
  }
  _setLastOptionActive() {
    const t = this._getNavigationOptions(), e = t.length - 1;
    this._updateActiveOption(t[e], e);
  }
  _updateActiveOption(t, e) {
    const i = this._activeOption;
    i && i.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;
  }
  _listenToWrapperClick() {
    h.on(this._wrapper, "click", () => {
      this.toggle();
    });
  }
  _listenToClearBtnClick() {
    h.on(this.clearButton, "click", (t) => {
      t.preventDefault(), t.stopPropagation(), this._handleClear();
    });
  }
  _listenToClearBtnKeydown() {
    h.on(this.clearButton, "keydown", (t) => {
      t.keyCode === lt && (this._handleClear(), t.preventDefault(), t.stopPropagation());
    });
  }
  _handleClear() {
    if (this.multiple)
      this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();
    else {
      const t = this._selectionModel.selection;
      this._selectionModel.clear(), t.deselect();
    }
    this._fakeValue.innerHTML = "", this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();
  }
  _listenToOptionsClick() {
    h.on(this.optionsWrapper, "click", (t) => {
      if (t.target.hasAttribute(
        Km
      ))
        return;
      const i = t.target.nodeName === "DIV" ? t.target : d.closest(t.target, Zm);
      if (i.hasAttribute(zm)) {
        this._handleSelectAll();
        return;
      }
      const o = i.dataset.teId, r = this.options.find((a) => a.id === o);
      r && !r.disabled && this._handleSelection(r);
    });
  }
  _handleSelectAll() {
    this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _selectAllOptions(t) {
    t.forEach((e) => {
      !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());
    });
  }
  _deselectAllOptions(t) {
    t.forEach((e) => {
      e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());
    });
  }
  _handleSelection(t) {
    this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleAutoSelection(t) {
    this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleSingleSelection(t) {
    this._singleOptionSelect(t), this.close(), this._input.focus();
  }
  _singleOptionSelect(t) {
    const e = this._selectionModel.selections[0];
    e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute(ci, !1), h.trigger(this._element, wa, {
      value: e.value
    })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute(ci, !0), h.trigger(this._element, ya, {
      value: t.value
    }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());
  }
  _handleMultiSelection(t) {
    t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute(ci, !1), h.trigger(this._element, wa, {
      value: t.value
    })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute(ci, !0), h.trigger(this._element, ya, {
      value: t.value
    })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _emitValueChangeEvent(t) {
    h.trigger(this._element, Ym, { value: t });
  }
  _emitNativeChangeEvent() {
    h.trigger(this._element, jm);
  }
  _updateInputValue() {
    const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
    let e;
    this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = "" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label;
  }
  _isSelectionValid(t) {
    return !(t && (t.disabled || t.value === ""));
  }
  _isLabelEmpty(t) {
    return !!(t && t.label === "");
  }
  _appendFakeValue() {
    if (!this._selectionModel.selection || this._selectionModel._multiple)
      return;
    const t = this._selectionModel.selection.label;
    this._fakeValue = Wm(t, this._classes), d.findOne(
      Ia,
      this._wrapper
    ).appendChild(this._fakeValue);
  }
  _updateLabelPosition() {
    const t = this._element.hasAttribute(xa), e = this._input.value !== "";
    this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q, "")));
  }
  _updateLabelPositionWhileClosing() {
    this._label && (this._input.value !== "" || this._isFakeValueActive ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q)));
  }
  _updateFakeLabelPosition() {
    this._fakeValue && (this._input.value === "" && this._fakeValue.innerHTML !== "" && !this._config.selectPlaceholder ? (this._isFakeValueActive = !0, this._fakeValue.setAttribute(q, "")) : (this._isFakeValueActive = !1, this._fakeValue.removeAttribute(q)));
  }
  _updateClearButtonVisibility() {
    if (!this.clearButton)
      return;
    this._selectionModel.selection || this._selectionModel.selections.length > 0 ? c.addStyle(this.clearButton, { display: "block" }) : c.addStyle(this.clearButton, { display: "none" });
  }
  _updateSelectAllState() {
    const t = this._selectAllOption.selected, e = co(this.options);
    !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();
  }
  toggle() {
    this._isOpen ? this.close() : this.open();
  }
  open() {
    const t = this._config.disabled, e = h.trigger(this._element, Fm);
    this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.selectFilter && (setTimeout(() => {
      this.filterInput.focus();
    }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, this._updateLabelPosition(), this._setInputActiveStyles());
  }
  _openDropdown() {
    this._popper = Ee(this._input, this._dropdownContainer, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {
      this.dropdown.setAttribute(ka, "");
    }, 0);
  }
  _updateDropdownWidth() {
    const t = this._input.offsetWidth;
    c.addStyle(this._dropdownContainer, { width: `${t}px` });
  }
  _setFirstActiveOption() {
    const t = this._getNavigationOptions(), e = this._activeOption;
    e && e.removeActiveStyles();
    const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
    i ? (this._activeOption = i, i.setActiveStyles(), this._activeOptionIndex = t.findIndex(
      (n) => n === i
    )) : (this._activeOption = null, this._activeOptionIndex = -1);
  }
  _setInputActiveStyles() {
    this._input.setAttribute(Kt, ""), d.findOne(Hn, this._wrapper).setAttribute(
      Kt,
      ""
    );
  }
  _listenToWindowResize() {
    h.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    this._dropdownContainer && this._updateDropdownWidth();
  }
  _listenToSelectSearch() {
    this.filterInput.addEventListener("input", (t) => {
      const e = t.target.value, i = this._config.selectFilterDebounce;
      this._debounceFilter(e, i);
    });
  }
  _debounceFilter(t, e) {
    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
      this._filterOptions(t);
    }, e);
  }
  _filterOptions(t) {
    const e = [];
    this._optionsToRender.forEach((o) => {
      const r = Object.prototype.hasOwnProperty.call(
        o,
        "options"
      ), a = !r && o.label.toLowerCase().includes(t.toLowerCase()), l = {};
      r && (l.label = o.label, l.options = this._filter(t, o.options), l.options.length > 0 && e.push(l)), a && e.push(o);
    });
    const i = this._config.selectNoResultText !== "", n = e.length !== 0;
    if (n)
      this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();
    else if (!n && i) {
      const o = this._getNoResultTemplate();
      this.optionsWrapper.innerHTML = o;
    }
  }
  _updateOptionsListTemplate(t) {
    const e = d.findOne(Sa, this._dropdownContainer) || d.findOne(tg, this._dropdownContainer), i = cc(
      t,
      this._selectAllOption,
      this._config,
      this._classes
    );
    this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(i);
  }
  _getNoResultTemplate() {
    return `<div class="${this._classes.noResult}" ${pc} style="height: ${this._config.selectOptionHeight}px">${this._config.selectNoResultText}</div>`;
  }
  _filter(t, e) {
    const i = t.toLowerCase();
    return e.filter(
      (n) => n.label.toLowerCase().includes(i)
    );
  }
  _listenToDropdownKeydown() {
    h.on(
      this.dropdown,
      "keydown",
      this._handleOpenKeydown.bind(this)
    );
  }
  _listenToOutsideClick() {
    this._outsideClick = this._handleOutSideClick.bind(this), h.on(document, "click", this._outsideClick);
  }
  _listenToFocusChange(t = !0) {
    if (t === !1) {
      h.off(
        this._input,
        "focus",
        () => this._notch.setAttribute(Kt, "")
      ), h.off(
        this._input,
        "blur",
        () => this._notch.removeAttribute(Kt)
      );
      return;
    }
    h.on(
      this._input,
      "focus",
      () => this._notch.setAttribute(Kt, "")
    ), h.on(
      this._input,
      "blur",
      () => this._notch.removeAttribute(Kt)
    );
  }
  _handleOutSideClick(t) {
    const e = this._wrapper && this._wrapper.contains(t.target), i = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
    let o;
    this._toggleButton || (this._elementToggle = d.find(eg)), this._elementToggle && this._elementToggle.forEach((r) => {
      const a = c.getDataAttribute(
        r,
        "select-toggle"
      );
      (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));
    }), !e && !i && !n && !o && this.close();
  }
  close() {
    const t = h.trigger(this._element, Vm);
    !this._isOpen || t.defaultPrevented || (this._config.selectFilter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), this.dropdown.removeAttribute(ka), setTimeout(() => {
      this._input.removeAttribute(Kt), this._input.blur(), d.findOne(Hn, this._wrapper).removeAttribute(
        Kt
      ), this._label && !this.hasSelection && (this._label.removeAttribute(q), this._notch.setAttribute(q, ""), this._input.removeAttribute(q), this._notch.removeAttribute(q)), this._updateLabelPositionWhileClosing();
    }, 0), setTimeout(() => {
      this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, h.off(this.dropdown, "transitionend");
    }, ig));
  }
  _resetFilterState() {
    this.filterInput.value = "", this._filteredOptionsList = null;
  }
  _removeDropdownEvents() {
    h.off(document, "click", this._outsideClick), this._config.selectFilter && h.off(this.dropdown, "keydown"), h.off(this.optionsWrapper, "click");
  }
  _addMutationObserver() {
    this._mutationObserver = new MutationObserver(() => {
      this._wrapper && (this._updateSelections(), this._updateDisabledState());
    }), this._observeMutationObserver();
  }
  _updateSelections() {
    this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();
    const t = this._config.filter && this.filterInput && this.filterInput.value;
    this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = Aa(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    );
  }
  _updateDisabledState() {
    const t = d.findOne(Oa, this._wrapper);
    this._element.hasAttribute("disabled") ? (this._config.disabled = !0, t.setAttribute("disabled", ""), t.setAttribute(Bn, "")) : (this._config.disabled = !1, t.removeAttribute("disabled"), t.removeAttribute(Bn));
  }
  _observeMutationObserver() {
    this._mutationObserver && this._mutationObserver.observe(this._element, {
      attributes: !0,
      childList: !0,
      characterData: !0,
      subtree: !0
    });
  }
  _disconnectMutationObserver() {
    this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);
  }
  _createSelectAllOption() {
    const t = this._selectAllId, e = null, i = !0, n = "select-all", o = this._config.selectAllLabel, r = co(this.options), a = !1, l = !1, p = null, u = null, f = null;
    return new Ca(
      t,
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      p,
      u,
      f
    );
  }
  dispose() {
    this._removeComponentEvents(), this._destroyMaterialSelect(), this._listenToFocusChange(!1), I.removeData(this._element, fi);
  }
  _removeComponentEvents() {
    h.off(this.input, "click"), h.off(this.wrapper, this._handleKeydown.bind(this)), h.off(this.clearButton, "click"), h.off(this.clearButton, "keydown"), h.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _destroyMaterialSelect() {
    this._isOpen && this.close(), this._destroyMaterialTemplate();
  }
  _destroyMaterialTemplate() {
    const t = this._wrapper.parentNode, e = d.find("label", this._wrapper);
    t.appendChild(this._element), e.forEach((i) => {
      t.appendChild(i);
    }), e.forEach((i) => {
      i.removeAttribute(q);
    }), c.removeClass(this._element, this._classes.initialized), this._element.removeAttribute(xa), t.removeChild(this._wrapper);
  }
  setValue(t) {
    this.options.filter((i) => i.selected).forEach((i) => i.nativeOption.selected = !1), Array.isArray(t) ? t.forEach((i) => {
      this._selectByValue(i);
    }) : this._selectByValue(t), this._updateSelections();
  }
  _selectByValue(t) {
    const e = this.options.find(
      (i) => i.value === t
    );
    return e ? (e.nativeOption.selected = !0, !0) : !1;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, fi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new $o(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, fi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const ag = ({ inputID: s, labelText: t }, e) => `<div data-te-chips-input-wrapper data-te-input-wrapper-init class="${e.chipsInputWrapper}">
      <input
          type="text"
          class="${e.chipsInput}"
          id="${s}"
          placeholder="Example label" />
        <label
          for="${s}"
          class="${e.chipsLabel}"
          >${t}
        </label>
      </div>
    </div>`, lg = ({ text: s, iconSVG: t }, e) => `<div data-te-chip-init data-te-ripple-init class="${e.chipElement}">
    <span data-te-chip-text>${s}</span> 
      <span data-te-chip-close class="${e.chipCloseIcon}">
        ${t}
      </span>
  </div>`, Ds = "chip", cg = `te.${Ds}`, _c = "data-te-chip-close", Wn = `[${_c}]`, hg = "delete.te.chips", dg = "select.te.chip", ug = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3 h-3"> <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>', pg = {
  text: "string",
  closeIcon: "boolean",
  img: "object",
  iconSVG: "string"
}, _g = {
  text: "",
  closeIcon: !1,
  img: { path: "", alt: "" },
  iconSVG: ug
}, fg = {
  icon: "float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out",
  chipElement: "flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded",
  chipCloseIcon: "w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out"
}, mg = {
  icon: "string",
  chipElement: "string",
  chipCloseIcon: "string"
};
class hi {
  constructor(t, e = {}, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i);
  }
  // Getters
  static get NAME() {
    return Ds;
  }
  // Public
  init() {
    this._appendCloseIcon(), this._handleDelete(), this._handleTextChip(), this._handleClickOnChip();
  }
  dispose() {
    this._element = null, this._options = null, h.off(this._element, "click");
  }
  appendChip() {
    const { text: t, closeIcon: e, iconSVG: i } = this._options;
    return lg({ text: t, closeIcon: e, iconSVG: i }, this._classes);
  }
  // Private
  _appendCloseIcon(t = this._element) {
    if (!(d.find(Wn, this._element).length > 0) && this._options.closeIcon) {
      const e = D("span");
      e.classList = this._classes.icon, e.setAttribute(_c), e.innerHTML = this._options.iconSVG, t.insertAdjacentElement("beforeend", e);
    }
  }
  _handleClickOnChip() {
    h.on(this._element, "click", (t) => {
      const { textContent: e } = t.target, i = {};
      i.tag = e.trim(), h.trigger(dg, { event: t, obj: i });
    });
  }
  _handleDelete() {
    d.find(
      Wn,
      this._element
    ).length !== 0 && h.on(this._element, "click", Wn, () => {
      h.trigger(this._element, hg), this._element.remove();
    });
  }
  _handleTextChip() {
    this._element.innerText === "" && (this._element.innerText = this._options.text);
  }
  _getConfig(t) {
    const e = {
      ..._g,
      ...c.getDataAttributes(this._element),
      ...t
    };
    return L(Ds, e, pg), e;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...fg,
      ...e,
      ...t
    }, L(Ds, t, mg), t;
  }
  static getInstance(t) {
    return I.getData(t, cg);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const wi = "chips", Ri = `data-te-${wi}`, Da = `te.${wi}`, gg = `${Ri}-input-init`, ft = `${Ri}-active`, $a = `${Ri}-initial`, fc = `${Ri}-placeholder`, bg = `${Ri}-input-wrapper`, ho = "data-te-chip-init", mc = "data-te-chip-close", gc = "data-te-chip-text", vg = `[${ft}]`, uo = `[${ho}]`, Tg = `${uo}${vg}`, Vn = `[${mc}]`, Eg = `[${bg}]`, Cg = `[${gc}]`, Ag = `[${fc}]`, yg = "data-te-input-notch-leading-ref", wg = "data-te-input-notch-middle-ref", xg = `[${yg}]`, kg = `[${wg}]`, Oe = "data-te-input-state-active", Fn = "[data-te-input-notch-ref]", Og = "add.te.chips", Sg = "arrowDown.te.chips", Ig = "arrowLeft.te.chips", Dg = "arrowRight.te.chips", $g = "arrowUp.te.chips", La = "delete.te.chips", Ma = "select.te.chips", Lg = {
  inputID: "string",
  parentSelector: "string",
  initialValues: "array",
  editable: "boolean",
  labelText: "string",
  inputClasses: "object",
  inputOptions: "object"
}, Mg = {
  inputID: bt("chips-input-"),
  parentSelector: "",
  initialValues: [{ tag: "init1" }, { tag: "init2" }],
  editable: !1,
  labelText: "Example label",
  inputClasses: {},
  inputOptions: {}
}, Ng = {
  opacity: "opacity-0",
  inputWrapperPadding: "p-[5px]",
  transition: "transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  contentEditable: "outline-none !border-[3px] !border-solid !border-[#b2b3b4]",
  chipsInputWrapper: "relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  chipsInput: "peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0",
  chipsLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200"
}, Rg = {
  opacity: "string",
  inputWrapperPadding: "string",
  transition: "string",
  contentEditable: "string",
  chipsInputWrapper: "string",
  chipsInput: "string",
  chipsLabel: "string"
};
class K0 extends hi {
  constructor(e, i = {}, n) {
    super(e, i);
    At(this, "_handleBlurInput", ({ target: e }) => {
      e.value.length > 0 && this._handleCreateChip(e, e.value), this.allChips.length > 0 ? (e.setAttribute(ft, ""), this.input.setAttribute(Oe, ""), d.findOne(
        Fn,
        this.input.parentNode
      ).setAttribute(Oe, ""), this.chipsInputWrapper.classList.add(
        ...this._classes.inputWrapperPadding.split(" ")
      )) : (e.removeAttribute(ft), this.input.removeAttribute(Oe), d.findOne(
        Fn,
        this.input.parentNode
      ).removeAttribute(Oe), this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      )), this.allChips.forEach((i) => i.removeAttribute(ft));
    });
    this._element = e, this._inputInstance = null, this._element && I.setData(e, Da, this), this._options = this._getConfig(i), this._classes = this._getClasses(n), this.numberClicks = 0, this.init();
  }
  // Getters
  static get NAME() {
    return wi;
  }
  get activeChip() {
    return d.findOne(Tg, this._element);
  }
  get input() {
    return d.findOne("input", this._element);
  }
  get allChips() {
    return d.find(uo, this._element);
  }
  get chipsInputWrapper() {
    return d.findOne(Eg, this._element);
  }
  // Public
  init() {
    this._setChipsClass(), this._appendInputToElement(fc), this._handleInitialValue(), this._handleInputText(), this._handleKeyboard(), this._handleChipsOnSelect(), this._handleEditable(), this._handleChipsFocus(), this._handleClicksOnChips(), this._inputInstance._getLabelWidth(), this._inputInstance._applyNotch();
  }
  dispose() {
    this._element = null, this._options = null;
  }
  // Private
  _getNotchData() {
    this._notchMiddle = d.findOne(
      kg,
      this._element
    ), this._notchLeading = d.findOne(
      xg,
      this._element
    );
  }
  _setChipsClass() {
    this._element.setAttribute(gg, "");
  }
  _handleDeleteEvents(e) {
    const [i] = this.allChips.slice(-1);
    if (this.activeChip === null)
      i.remove(), this._handleEvents(e, La);
    else {
      const n = this.allChips.findIndex((a) => a === this.activeChip), o = this._handleActiveChipAfterRemove(n), r = [];
      if (this.activeChip === null)
        return;
      this.activeChip.remove(), this._handleEvents(e, La), this.numberClicks = n, o.setAttribute(ft, ""), this.allChips.forEach((a) => {
        a.hasAttribute(ft) && (r.push(a), r.length > 1 && this.allChips.forEach((l) => l.remove()));
      });
    }
  }
  _handleUpEvents(e) {
    this.numberClicks += 1, this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0), this._handleRightKeyboardArrow(this.numberClicks), this._handleEvents(e, Dg), this._handleEvents(e, $g);
  }
  _handleDownEvents(e) {
    this.numberClicks -= 1, this.numberClicks <= 0 && (this.numberClicks = this.allChips.length), this._handleLeftKeyboardArrow(this.numberClicks), this._handleEvents(e, Ig), this._handleEvents(e, Sg);
  }
  _keyboardEvents(e) {
    const { target: i, keyCode: n, ctrlKey: o } = e;
    i.value.length > 0 || this.allChips.length === 0 || (n === I_ || n === D_ ? this._handleDeleteEvents(e) : n === Be || n === rt ? this._handleUpEvents(e) : n === Pe || n === z ? this._handleDownEvents(e) : n === 65 && o && this._handleAddActiveClass());
  }
  _handleKeyboard() {
    h.on(
      this.input,
      "keydown",
      (e) => this._keyboardEvents(e)
    );
  }
  _handleEditable() {
    const { editable: e } = this._options;
    e && this.allChips.forEach((i) => {
      h.on(i, "dblclick", (n) => {
        const o = d.findOne(Vn, i);
        i.classList.add(...this._classes.contentEditable.split(" ")), i.contentEditable = !0, i.focus(), setTimeout(() => {
          c.addStyle(o, { display: "none" });
        }, 200), o.classList.add(...this._classes.opacity.split(" ")), n.target.textContent, h.trigger(i, Ma, {
          event: n,
          allChips: this.allChips
        });
      }), h.on(document, "click", ({ target: n }) => {
        const o = d.findOne(Vn, i), r = d.findOne(Cg, i), a = n === i, l = i && i.contains(n);
        !a && !l && (i.contentEditable = !1, i.classList.remove(...this._classes.contentEditable.split(" ")), r.textContent !== "" && setTimeout(() => {
          c.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
        }, 160)), r.textContent === "" && (setTimeout(() => {
          i.classList.add(...this._classes.opacity.split(" "));
        }, 200), setTimeout(() => {
          i.remove();
        }, 300));
      });
    });
  }
  _handleRemoveActiveClass() {
    this.allChips.forEach((e) => e.removeAttribute(ft));
  }
  _handleAddActiveClass() {
    this.allChips.forEach((e) => e.setAttribute(ft, ""));
  }
  _handleRightKeyboardArrow(e) {
    this._handleRemoveActiveClass(), e === 0 && (e = 1), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleLeftKeyboardArrow(e) {
    this._handleRemoveActiveClass(), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleActiveChipAfterRemove(e) {
    const i = e === 0 ? 1 : e - 1;
    return this.allChips[i];
  }
  _handleClicksOnChips() {
    h.on(this._element, "click", () => {
      this.allChips.length === 0 && (this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      ), this.input.removeAttribute(ft));
    });
  }
  _handleTextContent() {
    const e = [];
    return this.allChips.forEach((i) => e.push({ tag: i.textContent.trim() })), e;
  }
  _handleEvents(e, i) {
    const n = this._handleTextContent(), o = this.allChips.filter(
      (r) => r.hasAttribute(ft) && r
    );
    h.trigger(this._element, i, {
      event: e,
      allChips: this.allChips,
      arrOfObjects: n,
      active: o,
      activeObj: {
        tag: o.length <= 0 ? "" : o[0].textContent.trim()
      }
    });
  }
  _handleChipsFocus() {
    h.on(this._element, "click", ({ target: { attributes: e } }) => {
      const i = [...e];
      i.includes(ho) || i.includes(mc) || i.includes(gc) || this.input.focus();
    });
  }
  _handleInitialValue() {
    if (this._appendInputToElement($a), this._element.hasAttribute($a)) {
      const { initialValues: e } = this._options;
      e.forEach(
        ({ tag: i }) => this._handleCreateChip(this.input, i)
      ), d.findOne(
        Fn,
        this.input.parentNode
      ).setAttribute(Oe, ""), this.input.setAttribute(ft, ""), this.input.setAttribute(Oe, "");
    }
    this.allChips.length > 0 && (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    ));
  }
  _handleKeysInputToElement(e) {
    const { keyCode: i, target: n } = e;
    if (n.hasAttribute(ho)) {
      const o = d.findOne(Vn, n);
      i === lt && (n.contentEditable = !1, n.classList.remove(...this._classes.contentEditable.split(" ")), n.textContent !== "" ? setTimeout(() => {
        c.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
      }, 160) : n.textContent === "" && (setTimeout(() => {
        n.classList.add(...this._classes.opacity.split(" "));
      }, 200), setTimeout(() => {
        n.remove();
      }, 300)));
      return;
    }
    if (i === lt) {
      if (n.value === "")
        return;
      this._handleCreateChip(n, n.value), this._handleRemoveActiveClass(), this.numberClicks = this.allChips.length + 1, this._handleEvents(e, Og);
    }
    this.allChips.length > 0 ? (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    )) : this.chipsInputWrapper.classList.remove(
      ...this._classes.inputWrapperPadding.split(" ")
    );
  }
  _handleInputText() {
    const e = d.findOne(
      Ag,
      this._element
    );
    h.on(
      this._element,
      "keyup",
      e,
      (i) => this._handleKeysInputToElement(i)
    ), h.on(this.input, "blur", (i) => this._handleBlurInput(i));
  }
  _appendInputToElement(e) {
    if (!this._element.hasAttribute(e))
      return;
    const i = ag(this._options, this._classes);
    this._element.insertAdjacentHTML("beforeend", i);
    const n = d.findOne(
      "[data-te-chips-input-wrapper]",
      this._element
    );
    this._inputInstance = new W(
      n,
      this._options.inputOptions,
      this._options.inputClasses
    );
  }
  _handleCreateChip(e, i) {
    const n = D("div"), o = hi.getInstance(n), r = new hi(o, { text: i }, this._classes);
    this._options.parentSelector !== "" ? document.querySelector(this._options.parentSelector).insertAdjacentHTML("beforeend", r.appendChip()) : e.insertAdjacentHTML("beforebegin", r.appendChip()), e.value = "", d.find(uo).forEach((a) => {
      let l = hi.getInstance(a);
      return l || (l = new hi(a, {}, this._classes)), l.init();
    }), this._handleEditable();
  }
  _handleChipsOnSelect() {
    this.allChips.forEach((e) => {
      h.on(this._element, "click", (i) => {
        h.trigger(e, Ma, {
          event: i,
          allChips: this.allChips
        });
      });
    });
  }
  _handleAddActiveClassWithKebyboard(e) {
    let i;
    this.allChips[e - 1] === void 0 ? i = this.allChips[e - 2] : i = this.allChips[e - 1], i.setAttribute(ft);
  }
  _getConfig(e) {
    const i = {
      ...Mg,
      ...c.getDataAttributes(this._element),
      ...e
    };
    return L(wi, i, Lg), i;
  }
  _getClasses(e) {
    const i = c.getDataClassAttributes(this._element);
    return e = {
      ...Ng,
      ...i,
      ...e
    }, L(wi, e, Rg), e;
  }
  static getInstance(e) {
    return I.getData(e, Da);
  }
  static getOrCreateInstance(e, i = {}) {
    return this.getInstance(e) || new this(e, typeof i == "object" ? i : null);
  }
}
const zt = {
  plugins: {
    legend: {
      labels: {
        color: "rgb(102,102,102)"
      }
    }
  }
}, mi = {
  line: {
    options: {
      ...zt,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.0)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bar: {
    options: {
      ...zt,
      backgroundColor: "rgb(59, 112, 202)",
      borderWidth: 0,
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !0,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  pie: {
    options: {
      ...zt,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  doughnut: {
    options: {
      ...zt,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  polarArea: {
    options: {
      ...zt,
      elements: {
        arc: { backgroundColor: "rgba(59, 112, 202, 0.5)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  radar: {
    options: {
      ...zt,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  scatter: {
    options: {
      ...zt,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bubble: {
    options: {
      ...zt,
      elements: {
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      scales: {
        x: {
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  }
};
var Pg = function(t) {
  return Bg(t) && !Hg(t);
};
function Bg(s) {
  return !!s && typeof s == "object";
}
function Hg(s) {
  var t = Object.prototype.toString.call(s);
  return t === "[object RegExp]" || t === "[object Date]" || Fg(s);
}
var Wg = typeof Symbol == "function" && Symbol.for, Vg = Wg ? Symbol.for("react.element") : 60103;
function Fg(s) {
  return s.$$typeof === Vg;
}
function Yg(s) {
  return Array.isArray(s) ? [] : {};
}
function Si(s, t) {
  return t.clone !== !1 && t.isMergeableObject(s) ? Xe(Yg(s), s, t) : s;
}
function jg(s, t, e) {
  return s.concat(t).map(function(i) {
    return Si(i, e);
  });
}
function Kg(s, t) {
  if (!t.customMerge)
    return Xe;
  var e = t.customMerge(s);
  return typeof e == "function" ? e : Xe;
}
function zg(s) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(s).filter(function(t) {
    return Object.propertyIsEnumerable.call(s, t);
  }) : [];
}
function Na(s) {
  return Object.keys(s).concat(zg(s));
}
function bc(s, t) {
  try {
    return t in s;
  } catch {
    return !1;
  }
}
function Ug(s, t) {
  return bc(s, t) && !(Object.hasOwnProperty.call(s, t) && Object.propertyIsEnumerable.call(s, t));
}
function Xg(s, t, e) {
  var i = {};
  return e.isMergeableObject(s) && Na(s).forEach(function(n) {
    i[n] = Si(s[n], e);
  }), Na(t).forEach(function(n) {
    Ug(s, n) || (bc(s, n) && e.isMergeableObject(t[n]) ? i[n] = Kg(n, e)(s[n], t[n], e) : i[n] = Si(t[n], e));
  }), i;
}
function Xe(s, t, e) {
  e = e || {}, e.arrayMerge = e.arrayMerge || jg, e.isMergeableObject = e.isMergeableObject || Pg, e.cloneUnlessOtherwiseSpecified = Si;
  var i = Array.isArray(t), n = Array.isArray(s), o = i === n;
  return o ? i ? e.arrayMerge(s, t, e) : Xg(s, t, e) : Si(t, e);
}
Xe.all = function(t, e) {
  if (!Array.isArray(t))
    throw new Error("first argument should be an array");
  return t.reduce(function(i, n) {
    return Xe(i, n, e);
  }, {});
};
var Gg = Xe, po = Gg;
const Ra = "chart", _s = "te.chart", qg = "chart", Yn = (s, t, e) => {
  const i = (n, o, r) => {
    const a = n.slice();
    return o.forEach((l, p) => {
      typeof a[p] > "u" ? a[p] = r.cloneUnlessOtherwiseSpecified(
        l,
        r
      ) : r.isMergeableObject(l) ? a[p] = po(n[p], l, r) : n.indexOf(l) === -1 && a.push(l);
    }), a;
  };
  return po(e[t], s, {
    arrayMerge: i
  });
}, Zg = {
  darkTicksColor: "#fff",
  darkLabelColor: "#fff",
  darkGridLinesColor: "#555",
  darkmodeOff: "undefined",
  darkMode: null,
  darkBgColor: "#262626",
  darkBgColorLight: "#fff",
  options: null
}, Qg = {
  darkTicksColor: "string",
  darkLabelColor: "string",
  darkGridLinesColor: "string",
  darkmodeOff: "(string|null)",
  darkMode: "(string|null)",
  darkBgColor: "string",
  darkBgColorLight: "string",
  options: "(object|null)"
};
class vc {
  constructor(t, e, i = {}, n = {}) {
    this._waitForCharts(t, e, i, n);
  }
  async _getChartjs() {
    const {
      Chart: t,
      ArcElement: e,
      LineElement: i,
      BarElement: n,
      PointElement: o,
      BarController: r,
      BubbleController: a,
      DoughnutController: l,
      LineController: p,
      PieController: u,
      PolarAreaController: f,
      RadarController: _,
      ScatterController: m,
      CategoryScale: g,
      LinearScale: v,
      LogarithmicScale: b,
      RadialLinearScale: C,
      TimeScale: y,
      TimeSeriesScale: E,
      Decimation: T,
      Filler: A,
      Legend: w,
      Title: S,
      Tooltip: k,
      SubTitle: x
    } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_tw-elements_dist_js_chart_es_js").then(__webpack_require__.bind(__webpack_require__, /*! ./chart.es.js */ "./node_modules/tw-elements/dist/js/chart.es.js")).then(($) => $.f);
    return t.register(
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      p,
      u,
      f,
      _,
      m,
      g,
      v,
      b,
      C,
      y,
      E,
      T,
      A,
      w,
      S,
      k,
      x
    ), t;
  }
  async _getChartDataLabels() {
    return await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_tw-elements_dist_js_chart_es_js"), __webpack_require__.e("vendors-node_modules_tw-elements_dist_js_chartjs-plugin-datalabels_es_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./chartjs-plugin-datalabels.es.js */ "./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js"));
  }
  async _waitForCharts(t, e, i = {}, n = {}) {
    if (this._Chartjs = await this._getChartjs(), this._ChartDataLabels = await this._getChartDataLabels(), this._element = t, this._data = e, this._options = i, this._type = e.type, this._canvas = null, this._chart = null, this._darkOptions = this._getDarkConfig(n), this._darkModeClassContainer = document.querySelector("html"), this._prevConfig = null, this._observer = null, this._element && (I.setData(t, _s, this), c.addClass(this._element, qg), this._chartConstructor()), this._darkOptions.darkmodeOff !== null) {
      const o = this._darkOptions.darkMode === "dark" ? "dark" : this._darkOptions.darkMode === "light" ? "light" : this.systemColorMode;
      this._handleMode(o), this._observer = new MutationObserver(this._observerCallback.bind(this)), this._observer.observe(this._darkModeClassContainer, {
        attributes: !0
      });
    }
  }
  // Getters
  static get NAME() {
    return Ra;
  }
  get systemColorMode() {
    return localStorage.theme || (this._darkModeClassContainer.classList.contains("dark") ? "dark" : "light");
  }
  // Public
  dispose() {
    this._observer.disconnect(), I.removeData(this._element, _s), this._element = null;
  }
  update(t, e) {
    t && (this._data = { ...this._data, ...t }, this._chart.data = this._data);
    const i = Object.prototype.hasOwnProperty.call(
      e,
      "options"
    ) ? e : { options: { ...e } };
    this._options = po(this._options, i), this._chart.options = Yn(
      this._options,
      this._type,
      mi
    ).options, this._chart.update();
  }
  setTheme(t) {
    t !== "dark" && t !== "light" || !this._data || this._handleMode(t);
  }
  // Private
  _getDarkConfig(t) {
    let e = {};
    const i = c.getDataAttributes(this._element);
    Object.keys(i).forEach(
      (p) => p.startsWith("dark") && (e[p] = i[p])
    ), e = {
      ...Zg,
      ...e
    };
    const n = {
      y: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      },
      x: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      }
    }, o = {
      r: {
        ticks: {
          color: e.darkTicksColor,
          backdropColor: e.darkBgColor
        },
        grid: {
          color: e.darkGridLinesColor
        },
        pointLabels: {
          color: e.darkTicksColor
        }
      }
    }, l = {
      scales: ["pie", "doughnut", "polarArea", "radar"].includes(this._type) ? ["polarArea", "radar"].includes(this._type) ? o : {} : n,
      plugins: {
        legend: {
          labels: {
            color: e.darkLabelColor
          }
        }
      }
    };
    return t = {
      ...e,
      options: {
        ...l
      },
      ...t
    }, L(Ra, t, Qg), t;
  }
  _chartConstructor() {
    if (this._data) {
      this._createCanvas();
      const t = Yn(this._options, this._type, mi), e = [];
      t.dataLabelsPlugin && e.push(this._ChartDataLabels.default), this._prevConfig = t, this._chart = new this._Chartjs(this._canvas, {
        ...this._data,
        ...t,
        plugins: e
      });
    }
  }
  _createCanvas() {
    this._canvas || (this._element.nodeName === "CANVAS" ? this._canvas = this._element : (this._canvas = D("canvas"), this._element.appendChild(this._canvas)));
  }
  _handleMode(t) {
    t === "dark" ? (this._changeDatasetBorderColor(), this.update(null, this._darkOptions.options)) : (this._changeDatasetBorderColor(!1), this._prevConfig && this.update(null, this._prevConfig));
  }
  _observerCallback(t) {
    for (const e of t)
      e.type === "attributes" && this._handleMode(this.systemColorMode);
  }
  _changeDatasetBorderColor(t = !0) {
    [...this._data.data.datasets].forEach(
      (e) => ["pie", "doughnut", "polarArea"].includes(this._type) && (e.borderColor = t ? this._darkOptions.darkBgColor : this._darkOptions.darkBgColorLight)
    );
  }
  static jQueryInterface(t, e, i) {
    return this.each(function() {
      let n = I.getData(this, _s);
      if (!(!n && /dispose/.test(t))) {
        if (!n) {
          const o = e ? Yn(e, i, mi) : mi[i];
          n = new vc(this, {
            ...t,
            ...o
          });
        }
        if (typeof t == "string") {
          if (typeof n[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          n[t](e, i);
        }
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, _s);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function $t(s) {
  return getComputedStyle(s);
}
function ot(s, t) {
  for (var e in t) {
    var i = t[e];
    typeof i == "number" && (i = i + "px"), s.style[e] = i;
  }
  return s;
}
function fs(s) {
  var t = document.createElement("div");
  return t.className = s, t;
}
var Pa = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function Zt(s, t) {
  if (!Pa)
    throw new Error("No element matching method supported");
  return Pa.call(s, t);
}
function Ne(s) {
  s.remove ? s.remove() : s.parentNode && s.parentNode.removeChild(s);
}
function Ba(s, t) {
  return Array.prototype.filter.call(
    s.children,
    function(e) {
      return Zt(e, t);
    }
  );
}
var j = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(s) {
      return "ps__thumb-" + s;
    },
    rail: function(s) {
      return "ps__rail-" + s;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(s) {
      return "ps--active-" + s;
    },
    scrolling: function(s) {
      return "ps--scrolling-" + s;
    }
  }
}, Tc = { x: null, y: null };
function Ec(s, t) {
  var e = s.element.classList, i = j.state.scrolling(t);
  e.contains(i) ? clearTimeout(Tc[t]) : e.add(i);
}
function Cc(s, t) {
  Tc[t] = setTimeout(
    function() {
      return s.isAlive && s.element.classList.remove(j.state.scrolling(t));
    },
    s.settings.scrollingThreshold
  );
}
function Jg(s, t) {
  Ec(s, t), Cc(s, t);
}
var Pi = function(t) {
  this.element = t, this.handlers = {};
}, Ac = { isEmpty: { configurable: !0 } };
Pi.prototype.bind = function(t, e) {
  typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);
};
Pi.prototype.unbind = function(t, e) {
  var i = this;
  this.handlers[t] = this.handlers[t].filter(function(n) {
    return e && n !== e ? !0 : (i.element.removeEventListener(t, n, !1), !1);
  });
};
Pi.prototype.unbindAll = function() {
  for (var t in this.handlers)
    this.unbind(t);
};
Ac.isEmpty.get = function() {
  var s = this;
  return Object.keys(this.handlers).every(
    function(t) {
      return s.handlers[t].length === 0;
    }
  );
};
Object.defineProperties(Pi.prototype, Ac);
var Je = function() {
  this.eventElements = [];
};
Je.prototype.eventElement = function(t) {
  var e = this.eventElements.filter(function(i) {
    return i.element === t;
  })[0];
  return e || (e = new Pi(t), this.eventElements.push(e)), e;
};
Je.prototype.bind = function(t, e, i) {
  this.eventElement(t).bind(e, i);
};
Je.prototype.unbind = function(t, e, i) {
  var n = this.eventElement(t);
  n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);
};
Je.prototype.unbindAll = function() {
  this.eventElements.forEach(function(t) {
    return t.unbindAll();
  }), this.eventElements = [];
};
Je.prototype.once = function(t, e, i) {
  var n = this.eventElement(t), o = function(r) {
    n.unbind(e, o), i(r);
  };
  n.bind(e, o);
};
function ms(s) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(s);
  var t = document.createEvent("CustomEvent");
  return t.initCustomEvent(s, !1, !1, void 0), t;
}
function Bs(s, t, e, i, n) {
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var o;
  if (t === "top")
    o = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  else if (t === "left")
    o = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  else
    throw new Error("A proper axis should be provided");
  tb(s, e, o, i, n);
}
function tb(s, t, e, i, n) {
  var o = e[0], r = e[1], a = e[2], l = e[3], p = e[4], u = e[5];
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var f = s.element;
  s.reach[l] = null, f[a] < 1 && (s.reach[l] = "start"), f[a] > s[o] - s[r] - 1 && (s.reach[l] = "end"), t && (f.dispatchEvent(ms("ps-scroll-" + l)), t < 0 ? f.dispatchEvent(ms("ps-scroll-" + p)) : t > 0 && f.dispatchEvent(ms("ps-scroll-" + u)), i && Jg(s, l)), s.reach[l] && (t || n) && f.dispatchEvent(ms("ps-" + l + "-reach-" + s.reach[l]));
}
function V(s) {
  return parseInt(s, 10) || 0;
}
function eb(s) {
  return Zt(s, "input,[contenteditable]") || Zt(s, "select,[contenteditable]") || Zt(s, "textarea,[contenteditable]") || Zt(s, "button,[contenteditable]");
}
function ib(s) {
  var t = $t(s);
  return V(t.width) + V(t.paddingLeft) + V(t.paddingRight) + V(t.borderLeftWidth) + V(t.borderRightWidth);
}
var $e = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function Bt(s) {
  var t = s.element, e = Math.floor(t.scrollTop), i = t.getBoundingClientRect();
  s.containerWidth = Math.round(i.width), s.containerHeight = Math.round(i.height), s.contentWidth = t.scrollWidth, s.contentHeight = t.scrollHeight, t.contains(s.scrollbarXRail) || (Ba(t, j.element.rail("x")).forEach(
    function(n) {
      return Ne(n);
    }
  ), t.appendChild(s.scrollbarXRail)), t.contains(s.scrollbarYRail) || (Ba(t, j.element.rail("y")).forEach(
    function(n) {
      return Ne(n);
    }
  ), t.appendChild(s.scrollbarYRail)), !s.settings.suppressScrollX && s.containerWidth + s.settings.scrollXMarginOffset < s.contentWidth ? (s.scrollbarXActive = !0, s.railXWidth = s.containerWidth - s.railXMarginWidth, s.railXRatio = s.containerWidth / s.railXWidth, s.scrollbarXWidth = Ha(
    s,
    V(s.railXWidth * s.containerWidth / s.contentWidth)
  ), s.scrollbarXLeft = V(
    (s.negativeScrollAdjustment + t.scrollLeft) * (s.railXWidth - s.scrollbarXWidth) / (s.contentWidth - s.containerWidth)
  )) : s.scrollbarXActive = !1, !s.settings.suppressScrollY && s.containerHeight + s.settings.scrollYMarginOffset < s.contentHeight ? (s.scrollbarYActive = !0, s.railYHeight = s.containerHeight - s.railYMarginHeight, s.railYRatio = s.containerHeight / s.railYHeight, s.scrollbarYHeight = Ha(
    s,
    V(s.railYHeight * s.containerHeight / s.contentHeight)
  ), s.scrollbarYTop = V(
    e * (s.railYHeight - s.scrollbarYHeight) / (s.contentHeight - s.containerHeight)
  )) : s.scrollbarYActive = !1, s.scrollbarXLeft >= s.railXWidth - s.scrollbarXWidth && (s.scrollbarXLeft = s.railXWidth - s.scrollbarXWidth), s.scrollbarYTop >= s.railYHeight - s.scrollbarYHeight && (s.scrollbarYTop = s.railYHeight - s.scrollbarYHeight), sb(t, s), s.scrollbarXActive ? t.classList.add(j.state.active("x")) : (t.classList.remove(j.state.active("x")), s.scrollbarXWidth = 0, s.scrollbarXLeft = 0, t.scrollLeft = s.isRtl === !0 ? s.contentWidth : 0), s.scrollbarYActive ? t.classList.add(j.state.active("y")) : (t.classList.remove(j.state.active("y")), s.scrollbarYHeight = 0, s.scrollbarYTop = 0, t.scrollTop = 0);
}
function Ha(s, t) {
  return s.settings.minScrollbarLength && (t = Math.max(t, s.settings.minScrollbarLength)), s.settings.maxScrollbarLength && (t = Math.min(t, s.settings.maxScrollbarLength)), t;
}
function sb(s, t) {
  var e = { width: t.railXWidth }, i = Math.floor(s.scrollTop);
  t.isRtl ? e.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth - t.contentWidth : e.left = s.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - i : e.top = t.scrollbarXTop + i, ot(t.scrollbarXRail, e);
  var n = { top: i, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + s.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - s.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + s.scrollLeft, ot(t.scrollbarYRail, n), ot(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), ot(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function nb(s) {
  s.element, s.event.bind(s.scrollbarY, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarYRail, "mousedown", function(t) {
    var e = t.pageY - window.pageYOffset - s.scrollbarYRail.getBoundingClientRect().top, i = e > s.scrollbarYTop ? 1 : -1;
    s.element.scrollTop += i * s.containerHeight, Bt(s), t.stopPropagation();
  }), s.event.bind(s.scrollbarX, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarXRail, "mousedown", function(t) {
    var e = t.pageX - window.pageXOffset - s.scrollbarXRail.getBoundingClientRect().left, i = e > s.scrollbarXLeft ? 1 : -1;
    s.element.scrollLeft += i * s.containerWidth, Bt(s), t.stopPropagation();
  });
}
function ob(s) {
  Wa(s, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]), Wa(s, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function Wa(s, t) {
  var e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], a = t[5], l = t[6], p = t[7], u = t[8], f = s.element, _ = null, m = null, g = null;
  function v(y) {
    y.touches && y.touches[0] && (y[n] = y.touches[0].pageY), f[l] = _ + g * (y[n] - m), Ec(s, p), Bt(s), y.stopPropagation(), y.type.startsWith("touch") && y.changedTouches.length > 1 && y.preventDefault();
  }
  function b() {
    Cc(s, p), s[u].classList.remove(j.state.clicking), s.event.unbind(s.ownerDocument, "mousemove", v);
  }
  function C(y, E) {
    _ = f[l], E && y.touches && (y[n] = y.touches[0].pageY), m = y[n], g = (s[i] - s[e]) / (s[o] - s[a]), E ? s.event.bind(s.ownerDocument, "touchmove", v) : (s.event.bind(s.ownerDocument, "mousemove", v), s.event.once(s.ownerDocument, "mouseup", b), y.preventDefault()), s[u].classList.add(j.state.clicking), y.stopPropagation();
  }
  s.event.bind(s[r], "mousedown", function(y) {
    C(y);
  }), s.event.bind(s[r], "touchstart", function(y) {
    C(y, !0);
  });
}
function rb(s) {
  var t = s.element, e = function() {
    return Zt(t, ":hover");
  }, i = function() {
    return Zt(s.scrollbarX, ":focus") || Zt(s.scrollbarY, ":focus");
  };
  function n(o, r) {
    var a = Math.floor(t.scrollTop);
    if (o === 0) {
      if (!s.scrollbarYActive)
        return !1;
      if (a === 0 && r > 0 || a >= s.contentHeight - s.containerHeight && r < 0)
        return !s.settings.wheelPropagation;
    }
    var l = t.scrollLeft;
    if (r === 0) {
      if (!s.scrollbarXActive)
        return !1;
      if (l === 0 && o < 0 || l >= s.contentWidth - s.containerWidth && o > 0)
        return !s.settings.wheelPropagation;
    }
    return !0;
  }
  s.event.bind(s.ownerDocument, "keydown", function(o) {
    if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !i())) {
      var r = document.activeElement ? document.activeElement : s.ownerDocument.activeElement;
      if (r) {
        if (r.tagName === "IFRAME")
          r = r.contentDocument.activeElement;
        else
          for (; r.shadowRoot; )
            r = r.shadowRoot.activeElement;
        if (eb(r))
          return;
      }
      var a = 0, l = 0;
      switch (o.which) {
        case 37:
          o.metaKey ? a = -s.contentWidth : o.altKey ? a = -s.containerWidth : a = -30;
          break;
        case 38:
          o.metaKey ? l = s.contentHeight : o.altKey ? l = s.containerHeight : l = 30;
          break;
        case 39:
          o.metaKey ? a = s.contentWidth : o.altKey ? a = s.containerWidth : a = 30;
          break;
        case 40:
          o.metaKey ? l = -s.contentHeight : o.altKey ? l = -s.containerHeight : l = -30;
          break;
        case 32:
          o.shiftKey ? l = s.containerHeight : l = -s.containerHeight;
          break;
        case 33:
          l = s.containerHeight;
          break;
        case 34:
          l = -s.containerHeight;
          break;
        case 36:
          l = s.contentHeight;
          break;
        case 35:
          l = -s.contentHeight;
          break;
        default:
          return;
      }
      s.settings.suppressScrollX && a !== 0 || s.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, Bt(s), n(a, l) && o.preventDefault());
    }
  });
}
function ab(s) {
  var t = s.element;
  function e(r, a) {
    var l = Math.floor(t.scrollTop), p = t.scrollTop === 0, u = l + t.offsetHeight === t.scrollHeight, f = t.scrollLeft === 0, _ = t.scrollLeft + t.offsetWidth === t.scrollWidth, m;
    return Math.abs(a) > Math.abs(r) ? m = p || u : m = f || _, m ? !s.settings.wheelPropagation : !0;
  }
  function i(r) {
    var a = r.deltaX, l = -1 * r.deltaY;
    return (typeof a > "u" || typeof l > "u") && (a = -1 * r.wheelDeltaX / 6, l = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = r.wheelDelta), r.shiftKey ? [-l, -a] : [a, l];
  }
  function n(r, a, l) {
    if (!$e.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(r))
      return !1;
    for (var p = r; p && p !== t; ) {
      if (p.classList.contains(j.element.consuming))
        return !0;
      var u = $t(p);
      if (l && u.overflowY.match(/(scroll|auto)/)) {
        var f = p.scrollHeight - p.clientHeight;
        if (f > 0 && (p.scrollTop > 0 && l < 0 || p.scrollTop < f && l > 0))
          return !0;
      }
      if (a && u.overflowX.match(/(scroll|auto)/)) {
        var _ = p.scrollWidth - p.clientWidth;
        if (_ > 0 && (p.scrollLeft > 0 && a < 0 || p.scrollLeft < _ && a > 0))
          return !0;
      }
      p = p.parentNode;
    }
    return !1;
  }
  function o(r) {
    var a = i(r), l = a[0], p = a[1];
    if (!n(r.target, l, p)) {
      var u = !1;
      s.settings.useBothWheelAxes ? s.scrollbarYActive && !s.scrollbarXActive ? (p ? t.scrollTop -= p * s.settings.wheelSpeed : t.scrollTop += l * s.settings.wheelSpeed, u = !0) : s.scrollbarXActive && !s.scrollbarYActive && (l ? t.scrollLeft += l * s.settings.wheelSpeed : t.scrollLeft -= p * s.settings.wheelSpeed, u = !0) : (t.scrollTop -= p * s.settings.wheelSpeed, t.scrollLeft += l * s.settings.wheelSpeed), Bt(s), u = u || e(l, p), u && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? s.event.bind(t, "wheel", o) : typeof window.onmousewheel < "u" && s.event.bind(t, "mousewheel", o);
}
function lb(s) {
  if (!$e.supportsTouch && !$e.supportsIePointer)
    return;
  var t = s.element;
  function e(g, v) {
    var b = Math.floor(t.scrollTop), C = t.scrollLeft, y = Math.abs(g), E = Math.abs(v);
    if (E > y) {
      if (v < 0 && b === s.contentHeight - s.containerHeight || v > 0 && b === 0)
        return window.scrollY === 0 && v > 0 && $e.isChrome;
    } else if (y > E && (g < 0 && C === s.contentWidth - s.containerWidth || g > 0 && C === 0))
      return !0;
    return !0;
  }
  function i(g, v) {
    t.scrollTop -= v, t.scrollLeft -= g, Bt(s);
  }
  var n = {}, o = 0, r = {}, a = null;
  function l(g) {
    return g.targetTouches ? g.targetTouches[0] : g;
  }
  function p(g) {
    return g.pointerType && g.pointerType === "pen" && g.buttons === 0 ? !1 : !!(g.targetTouches && g.targetTouches.length === 1 || g.pointerType && g.pointerType !== "mouse" && g.pointerType !== g.MSPOINTER_TYPE_MOUSE);
  }
  function u(g) {
    if (p(g)) {
      var v = l(g);
      n.pageX = v.pageX, n.pageY = v.pageY, o = (/* @__PURE__ */ new Date()).getTime(), a !== null && clearInterval(a);
    }
  }
  function f(g, v, b) {
    if (!t.contains(g))
      return !1;
    for (var C = g; C && C !== t; ) {
      if (C.classList.contains(j.element.consuming))
        return !0;
      var y = $t(C);
      if (b && y.overflowY.match(/(scroll|auto)/)) {
        var E = C.scrollHeight - C.clientHeight;
        if (E > 0 && (C.scrollTop > 0 && b < 0 || C.scrollTop < E && b > 0))
          return !0;
      }
      if (v && y.overflowX.match(/(scroll|auto)/)) {
        var T = C.scrollWidth - C.clientWidth;
        if (T > 0 && (C.scrollLeft > 0 && v < 0 || C.scrollLeft < T && v > 0))
          return !0;
      }
      C = C.parentNode;
    }
    return !1;
  }
  function _(g) {
    if (p(g)) {
      var v = l(g), b = { pageX: v.pageX, pageY: v.pageY }, C = b.pageX - n.pageX, y = b.pageY - n.pageY;
      if (f(g.target, C, y))
        return;
      i(C, y), n = b;
      var E = (/* @__PURE__ */ new Date()).getTime(), T = E - o;
      T > 0 && (r.x = C / T, r.y = y / T, o = E), e(C, y) && g.preventDefault();
    }
  }
  function m() {
    s.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {
      if (s.isInitialized) {
        clearInterval(a);
        return;
      }
      if (!r.x && !r.y) {
        clearInterval(a);
        return;
      }
      if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {
        clearInterval(a);
        return;
      }
      if (!s.element) {
        clearInterval(a);
        return;
      }
      i(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;
    }, 10));
  }
  $e.supportsTouch ? (s.event.bind(t, "touchstart", u), s.event.bind(t, "touchmove", _), s.event.bind(t, "touchend", m)) : $e.supportsIePointer && (window.PointerEvent ? (s.event.bind(t, "pointerdown", u), s.event.bind(t, "pointermove", _), s.event.bind(t, "pointerup", m)) : window.MSPointerEvent && (s.event.bind(t, "MSPointerDown", u), s.event.bind(t, "MSPointerMove", _), s.event.bind(t, "MSPointerUp", m)));
}
var cb = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, hb = {
  "click-rail": nb,
  "drag-thumb": ob,
  keyboard: rb,
  wheel: ab,
  touch: lb
}, Bi = function(t, e) {
  var i = this;
  if (e === void 0 && (e = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = t, t.classList.add(j.main), this.settings = cb();
  for (var n in e)
    this.settings[n] = e[n];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var o = function() {
    return t.classList.add(j.state.focus);
  }, r = function() {
    return t.classList.remove(j.state.focus);
  };
  this.isRtl = $t(t).direction === "rtl", this.isRtl === !0 && t.classList.add(j.rtl), this.isNegativeScroll = function() {
    var p = t.scrollLeft, u = null;
    return t.scrollLeft = -1, u = t.scrollLeft < 0, t.scrollLeft = p, u;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new Je(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = fs(j.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = fs(j.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", o), this.event.bind(this.scrollbarX, "blur", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var a = $t(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = V(a.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = V(a.borderLeftWidth) + V(a.borderRightWidth), ot(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = V(a.marginLeft) + V(a.marginRight), ot(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = fs(j.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = fs(j.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", o), this.event.bind(this.scrollbarY, "blur", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var l = $t(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = V(l.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? ib(this.scrollbarY) : null, this.railBorderYWidth = V(l.borderTopWidth) + V(l.borderBottomWidth), ot(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = V(l.marginTop) + V(l.marginBottom), ot(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(p) {
    return hb[p](i);
  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(p) {
    return i.onScroll(p);
  }), Bt(this);
};
Bi.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ot(this.scrollbarXRail, { display: "block" }), ot(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = V($t(this.scrollbarXRail).marginLeft) + V($t(this.scrollbarXRail).marginRight), this.railYMarginHeight = V($t(this.scrollbarYRail).marginTop) + V($t(this.scrollbarYRail).marginBottom), ot(this.scrollbarXRail, { display: "none" }), ot(this.scrollbarYRail, { display: "none" }), Bt(this), Bs(this, "top", 0, !1, !0), Bs(this, "left", 0, !1, !0), ot(this.scrollbarXRail, { display: "" }), ot(this.scrollbarYRail, { display: "" }));
};
Bi.prototype.onScroll = function(t) {
  this.isAlive && (Bt(this), Bs(this, "top", this.element.scrollTop - this.lastScrollTop), Bs(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
Bi.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), Ne(this.scrollbarX), Ne(this.scrollbarY), Ne(this.scrollbarXRail), Ne(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
Bi.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(t) {
    return !t.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const jn = "perfectScrollbar", db = "perfect-scrollbar", gs = "te.perfectScrollbar", kt = "te", Ot = "ps", Kn = [
  { te: `scrollX.${kt}.${Ot}`, ps: "ps-scroll-x" },
  { te: `scrollY.${kt}.${Ot}`, ps: "ps-scroll-y" },
  { te: `scrollUp.${kt}.${Ot}`, ps: "ps-scroll-up" },
  { te: `scrollDown.${kt}.${Ot}`, ps: "ps-scroll-down" },
  { te: `scrollLeft.${kt}.${Ot}`, ps: "ps-scroll-left" },
  { te: `scrollRight.${kt}.${Ot}`, ps: "ps-scroll-right" },
  { te: `scrollXEnd.${kt}.${Ot}`, ps: "ps-x-reach-end" },
  { te: `scrollYEnd.${kt}.${Ot}`, ps: "ps-y-reach-end" },
  { te: `scrollXStart.${kt}.${Ot}`, ps: "ps-x-reach-start" },
  { te: `scrollYStart.${kt}.${Ot}`, ps: "ps-y-reach-start" }
], ub = {
  handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
  wheelSpeed: 1,
  wheelPropagation: !0,
  swipeEasing: !0,
  minScrollbarLength: null,
  maxScrollbarLength: null,
  scrollingThreshold: 1e3,
  useBothWheelAxes: !1,
  suppressScrollX: !1,
  suppressScrollY: !1,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0,
  positionRight: !0
}, pb = {
  handlers: "(string|array)",
  wheelSpeed: "number",
  wheelPropagation: "boolean",
  swipeEasing: "boolean",
  minScrollbarLength: "(number|null)",
  maxScrollbarLength: "(number|null)",
  scrollingThreshold: "number",
  useBothWheelAxes: "boolean",
  suppressScrollX: "boolean",
  suppressScrollY: "boolean",
  scrollXMarginOffset: "number",
  scrollYMarginOffset: "number",
  positionRight: "boolean"
}, _b = {
  ps: "group/ps overflow-hidden [overflow-anchor:none] touch-none",
  railX: "group/x absolute bottom-0 h-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-x]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none",
  railXColors: "group-[&.ps--active-x]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]",
  railXThumb: "absolute bottom-0.5 rounded-md h-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:h-[11px] group-focus/x:h-[0.6875rem] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none",
  railXThumbColors: "bg-[#aaa] group-hover/x:bg-[#999] group-focus/x:bg-[#999]",
  railY: "group/y absolute right-0 w-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-y]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none",
  railYColors: "group-[&.ps--active-y]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]",
  railYThumb: "absolute right-0.5 rounded-md w-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_width_.2s_ease-in-out,_opacity] group-hover/y:w-[11px] group-focus/y:w-[0.6875rem] group-[&.ps--clicking]/y:w-[11px] outline-none",
  railYThumbColors: "bg-[#aaa] group-hover/y:bg-[#999] group-focus/y:bg-[#999] group-[&.ps--clicking]/y:bg-[#999]"
}, fb = {
  ps: "string",
  railX: "string",
  railXColors: "string",
  railXThumb: "string",
  railXThumbColors: "string",
  railY: "string",
  railYColors: "string",
  railYThumb: "string",
  railYThumbColors: "string"
};
class Lo {
  constructor(t, e = {}, i = {}) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this.perfectScrollbar = null, this._observer = null, this._psClasses = [
      {
        ps: "ps__rail-x",
        te: this._classes.railX,
        teColor: this._classes.railXColors
      },
      {
        ps: "ps__rail-y",
        te: this._classes.railY,
        teColor: this._classes.railYColors
      },
      {
        ps: "ps__thumb-x",
        te: this._classes.railXThumb,
        teColor: this._classes.railXThumbColors
      },
      {
        ps: "ps__thumb-y",
        te: this._classes.railYThumb,
        teColor: this._classes.railYThumbColors
      }
    ], this._element && (I.setData(t, gs, this), c.addClass(this._element, db)), this.init();
  }
  // Getters
  static get NAME() {
    return jn;
  }
  get railX() {
    return d.findOne(".ps__rail-x", this._element);
  }
  get railY() {
    return d.findOne(".ps__rail-y", this._element);
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return e.handlers !== void 0 && (e.handlers = e.handlers.split(" ")), t = {
      ...ub,
      ...e,
      ...t
    }, L(jn, t, pb), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ..._b,
      ...e,
      ...t
    }, L(jn, t, fb), t;
  }
  // Public
  dispose() {
    this._options.positionRight && this._observer.disconnect(), I.removeData(this._element, gs), this._element = null, this._dataAttrOptions = null, this._options = null, this.perfectScrollbar.destroy(), this.removeEvent(Kn), this.perfectScrollbar = null;
  }
  init() {
    if (this.perfectScrollbar = new Bi(this._element, this._options), this._addPerfectScrollbarStyles(), this._updateScrollPosition(), this.perfectScrollbar.update(), this._initEvents(Kn), this._options.positionRight) {
      this._observer = new ResizeObserver(() => {
        setTimeout(() => {
          this._updateScrollPosition();
        }, 100);
      });
      const t = {
        attributes: !0,
        attributeFilter: ["class", "className"]
      };
      this._observer.observe(this._element, t);
    }
  }
  _updateScrollPosition() {
    const t = getComputedStyle(this._element).getPropertyValue("height"), e = getComputedStyle(this._element).getPropertyValue("width");
    this.railX && (this.railX.style.transform = `translateY(calc(-100% + ${this._canTransform(t) ? t : "0px"}))`), this.railY && (this.railY.style.transform = `translateX(calc(-100% + ${this._canTransform(e) ? e : "0px"}))`);
  }
  _canTransform(t) {
    return t && t.includes("px");
  }
  update() {
    return this.perfectScrollbar.update();
  }
  _initEvents(t = []) {
    t.forEach(
      ({ ps: e, te: i }) => h.on(
        this._element,
        e,
        (n) => h.trigger(this._element, i, { e: n })
      )
    );
  }
  _addPerfectScrollbarStyles() {
    this._psClasses.forEach((t) => {
      const e = d.findOne(`.${t.ps}`, this._element);
      c.addClass(e, t.te), c.addClass(e, t.teColor);
    }), c.addClass(this._element, this._classes.ps), c.removeClass(this._element, "ps");
  }
  removeEvent(t) {
    let e = [];
    typeof t == "string" && (e = Kn.filter(({ te: i }) => i === t)), e.forEach(({ ps: i, te: n }) => {
      h.off(this._element, i), h.off(this._element, n);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = I.getData(this, gs);
      const i = typeof t == "object" && t;
      if (!(!e && /dispose|hide/.test(t)) && (e || (e = new Lo(this, i)), typeof t == "string")) {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, gs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const yc = Lo, mb = "data-te-datatable-select-ref", gb = "data-te-datatable-pagination-nav-ref", bb = "data-te-datatable-pagination-right-ref", vb = "data-te-datatable-pagination-left-ref", Tb = "data-te-datatable-pagination-start-ref", Eb = "data-te-datatable-pagination-end-ref", Cb = ({
  text: s,
  entries: t,
  entriesOptions: e,
  fullPagination: i,
  rowsText: n,
  allText: o,
  paginationStartIconTemplate: r,
  paginationLeftIconTemplate: a,
  paginationRightIconTemplate: l,
  paginationEndIconTemplate: p,
  classes: u
}, f, _) => {
  const m = e.map((g) => g === "All" ? `<option value="${g}" ${g === t ? "selected" : ""}>${o}</option>` : `<option value="${g}" ${g === t ? "selected" : ""}>${g}</option>`).join(`
`);
  return `
<div class="${u.pagination} ${_ ? `${u.paginationBordered}` : ""} ${u.borderColor} ${u.color}">
  <div class="${u.selectItemsWrapper}">  
    <p class="${u.paginationRowsText} ${f ? `${u.loadingPaginationRowsText}` : ""}">${n}</p>
    <div class="${u.selectWrapper} ${f ? `${u.loadingPaginationSelectWrapper}` : ""}">
      <select name="entries"
        ${f ? "disabled" : ""} class="select" ${mb}>
        ${m}
      </select>
    </div>
  </div>
  <div class="${u.paginationNav} ${f ? `${u.loadingPaginationNav}` : ""}" ${gb}>
  ${s}
  </div>
  <div class="${u.paginationButtonsWrapper}">
    ${i ? `<button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationStartButton}" ${Tb}>
           ${r}
          </button>` : ""}
    <button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationLeftButton}" ${vb}>
      ${a}
  </button>
    <button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationRightButton}" ${bb}>
      ${l}
  </button>
    ${i ? `<button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationEndButton}" ${Eb}>
           ${p}
          </button>` : ""}
  </div>
</div>
`;
}, Ab = "data-te-datatable-sort-icon-ref", yb = "data-te-datatable-header-checkbox-ref", wb = (s, t, e, i, n, o, r, a) => {
  const l = e ? `
  <th scope="col">
    <div class="${a.checkboxHeaderWrapper}">
      <input
        class="${a.checkboxHeader}"
        type="checkbox"
        value=""
        ${yb}
        />
    </div>
  </th>
  ` : '<th scope="col"></th>', p = s.map((u, f) => {
    const _ = u.fixed ? s.filter((m, g) => m.fixed === u.fixed && g < f).reduce((m, g) => m + g.width, 0) : null;
    return `<th class="${a.column} ${i ? `${a.tableBordered}` : ""} ${a.borderColor} ${n ? `${a.sm}` : ""} ${u.fixed ? `${a.fixedHeader} ${a.color}` : ""} ${o ? `${a.loadingColumn}` : ""}" style="${u.fixed ? `${u.fixed === "right" ? "right" : "left"}: ${_}px;` : ""}" scope="col">${u.sort ? `<div class="${a.sortIconWrapper}"><span class="${a.sortIcon} ${o ? "invisible" : ""}" data-te-sort="${u.field}" ${Ab}>${r}</span>` : ""} <span class="${u.sort ? "" : "pl-[18px]"}">${u.label}</span></div></th>`;
  });
  return [t ? l : "", ...p].join(`
`);
}, xb = "data-te-datatable-row-ref", kb = "data-te-datatable-row-checkbox-ref", Ob = "data-te-datatable-cell-ref", Sb = ({
  rows: s,
  columns: t,
  noFoundMessage: e,
  edit: i,
  selectable: n,
  loading: o,
  bordered: r,
  borderless: a,
  striped: l,
  hover: p,
  sm: u,
  classes: f
}) => {
  const _ = s.map((m) => {
    const g = `
      <td data-te-field="checkbox" class="${r ? `${f.tableBordered} ${f.borderColor}` : ""}">
        <div class="${f.checkboxRowWrapper}">
          <input
            class="${f.checkboxRow}"
            type="checkbox"
            value=""
            data-te-row-index="${m.rowIndex}"  ${kb}/>
        </div>
      </td>`, v = t.map((b, C) => {
      const y = {};
      if (b.width && (y["min-width"] = `${b.width - 1}px`, y["max-width"] = `${b.width}px`, y.width = `${b.width}px`), b.fixed) {
        const T = t.filter((A, w) => A.fixed === b.fixed && w < C).reduce((A, w) => A + w.width, 0);
        y[b.fixed === "right" ? "right" : "left"] = `${T}px`;
      }
      return `<td style="${Object.keys(y).map((T) => `${T}: ${y[T]}`).join("; ")}" class="${f.rowItem} ${f.borderColor} ${i ? `${f.edit}` : ""} ${r ? `${f.tableBordered}` : ""} ${u ? `${f.sm}` : ""} ${b.fixed ? `${f.fixedHeader} ${f.color}` : ""}" ${Ob} data-te-field="${b.field}" ${i && 'contenteditable="true"'}>${m[b.field]}</td>`;
    }).join("");
    return `<tr scope="row" class="${f.row} ${f.borderColor} ${f.rowAnimation} ${l ? `${f.striped}` : ""} ${a ? `${f.borderless}` : ""} ${p ? `${f.hoverRow}` : ""}" data-te-index="${m.rowIndex}" ${xb}>${n ? g : ""}${v}</tr>`;
  });
  return s.length > 0 || o ? _.join(`
`) : `<tr class="${f.noFoundMessageWrapper} ${f.borderColor}"><td class="${f.noFoundMessage}">${e}</td></tr>`;
}, Ib = "data-te-datatable-inner-ref", Db = "data-te-datatable-header-ref", Va = ({
  columns: s,
  rows: t,
  noFoundMessage: e,
  edit: i,
  multi: n,
  selectable: o,
  loading: r,
  loadingMessage: a,
  pagination: l,
  bordered: p,
  borderless: u,
  striped: f,
  hover: _,
  fixedHeader: m,
  sm: g,
  sortIconTemplate: v,
  classes: b
}) => {
  const C = Sb({
    rows: t,
    columns: s,
    noFoundMessage: e,
    edit: i,
    loading: r,
    selectable: o,
    bordered: p,
    borderless: u,
    striped: f,
    hover: _,
    sm: g,
    classes: b
  }), y = wb(
    s,
    o,
    n,
    p,
    g,
    r,
    v,
    b
  );
  return { table: `
<div class="${b.color}" ${Ib}>
  <table class="${b.table}">
    <thead class="${b.tableHeader} ${p ? `${b.tableBordered}` : ""} ${u ? `${b.borderless}` : ""} ${b.borderColor}" ${Db}>
      <tr>
        ${y}
      </tr>
    </thead>
    <tbody class="${m ? `${b.fixedHeaderBody}` : ""}">
      ${r ? "" : C}
    </tbody>
  </table>
</div>
${r ? `
  <div class="${b.loadingItemsWrapper}">
    <div class="${b.loadingProgressBarWrapper}">
      <div class="${b.loadingProgressBar}"></div>
    </div>
  </div>
<p class="${b.loadingMessage}">${a}</p>
` : ""}
${l.enable ? Cb(l, r, p) : ""}
  `, rows: C, column: y };
}, $b = ({ rows: s, field: t, order: e }) => s.sort((n, o) => {
  let r = n[t], a = o[t];
  return typeof r == "string" && (r = r.toLowerCase()), typeof a == "string" && (a = a.toLowerCase()), r < a ? e === "desc" ? 1 : -1 : r > a ? e === "desc" ? -1 : 1 : 0;
}), Lb = (s, t, e) => {
  if (!t)
    return s;
  const i = (n) => {
    const o = document.createElement("div");
    return o.innerHTML = n, n = o.textContent || o.innerText || "", n.toString().toLowerCase().match(t.toLowerCase());
  };
  return s.filter((n) => {
    if (e && typeof e == "string")
      return i(n[e]);
    let o = Object.values(n);
    return e && Array.isArray(e) && (o = Object.keys(n).filter((r) => e.includes(r)).map((r) => n[r])), o.filter((r) => i(r)).length > 0;
  });
}, Fa = ({ rows: s, entries: t, activePage: e }) => {
  const i = e * t;
  return s.slice(i, i + Number(t));
}, xi = "datatable", _t = `data-te-${xi}`, gi = `te.${xi}`, zs = `.${gi}`, Mb = `[${_t}-inner-ref]`, zn = `[${_t}-cell-ref]`, Nb = `[${_t}-header-ref]`, Rb = `[${_t}-header-checkbox-ref]`, Pb = `[${_t}-pagination-right-ref]`, Bb = `[${_t}-pagination-left-ref]`, Hb = `[${_t}-pagination-start-ref]`, Wb = `[${_t}-pagination-end-ref]`, Vb = `[${_t}-pagination-nav-ref]`, Fb = `[${_t}-select-ref]`, Un = `[${_t}-sort-icon-ref]`, di = `[${_t}-row-ref]`, Xn = `[${_t}-row-checkbox-ref]`, Yb = `selectRows${zs}`, Ya = `render${zs}`, jb = `rowClick${zs}`, Kb = `update${zs}`, zb = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 10.5L12 3m0 0l7.5 7.5M12 3v18" />
</svg>`, Ub = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M18.75 19.5l-7.5-7.5 7.5-7.5m-6 15L5.25 12l7.5-7.5" />
</svg>`, Xb = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
</svg>`, Gb = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
</svg>`, qb = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M11.25 4.5l7.5 7.5-7.5 7.5m-6-15l7.5 7.5-7.5 7.5"/>
</svg>`, Zb = "border-neutral-200 dark:border-neutral-500", Qb = "border-none", Jb = "relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400", tv = "mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center", ev = "relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400", iv = "mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center", sv = "bg-white dark:bg-neutral-800", nv = "py-4 pl-1 text-clip overflow-hidden text-[#212529] dark:text-white", ov = "focus:outline-none", rv = "sticky top-0 z-30", av = "sticky z-10 bg-inherit", lv = "hover:bg-neutral-100 dark:hover:bg-neutral-700", cv = "pointer-events-none cursor-none text-neutral-400 dark:text-neutral-300", hv = "h-[2px] relative w-full overflow-hidden", dv = "text-center text-neutral-500 font-ligh text-sm my-4 dark:text-neutral-400", uv = "text-neutral-500 dark:text-neutral-300", pv = "text-neutral-500 dark:text-neutral-300", _v = "pointer-events-none cursor-none", fv = "h-full w-[45%] bg-primary-400 dark:bg-primary-600", mv = "h-full animate-[progress_3s_ease-in-out_infinite]", gv = "pl-2 py-3 font-light text-sm dark:text-neutral-300", bv = "border-b", vv = "flex md:flex-row justify-end items-center py-2 space-x-4 text-sm flex-col leading-[1.6]", Tv = "border border-t-0", Ev = "order-1 my-3 md:order-none md:my-0 md:pr-1", Cv = "inline-block rounded p-2.5 text-xs font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", Av = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", yv = "font-normal order-2 mb-3 md:order-none md:mb-0", wv = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", xv = "font-light", kv = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", Ov = "border-b", Sv = "transition ease-in-out duration-300 motion-reduce:transition-none", Iv = "whitespace-nowrap text-clip overflow-hidden px-[1.4rem] py-4", Dv = "relative", $v = "!bg-neutral-100 dark:!bg-neutral-600", Lv = "flex items-center space-x-4 order-3 md:order-none", Mv = "w-[70px]", Nv = "!py-2", Rv = "w-[15px] h-[10px] origin-bottom font-black mr-1 opacity-0 text-neutral-500 group-hover:opacity-100 transition hover:ease-in-out transform ease-linear duration-300 motion-reduce:transition-none dark:text-neutral-400", Pv = "flex flex-row group", Bv = "[&:nth-child(odd)]:bg-neutral-50 [&:nth-child(odd)]:dark:bg-neutral-700", Hv = "border", Wv = "border-b font-normal px-[1.4rem]", Vv = "text-left text-sm font-light w-full leading-[1.6]", Fv = {
  bordered: "boolean",
  borderless: "boolean",
  clickableRows: "boolean",
  defaultValue: "string",
  edit: "boolean",
  entries: "(number|string)",
  entriesOptions: "array",
  fullPagination: "boolean",
  hover: "boolean",
  loading: "boolean",
  loadingMessage: "string",
  maxWidth: "(null|number|string)",
  maxHeight: "(null|number|string)",
  multi: "boolean",
  noFoundMessage: "string",
  pagination: "boolean",
  selectable: "boolean",
  sm: "boolean",
  sortField: "(null|string)",
  sortOrder: "string",
  fixedHeader: "boolean",
  striped: "boolean",
  rowsText: "string",
  ofText: "string",
  allText: "string",
  forceSort: "boolean",
  sortIconTemplate: "string",
  paginationStartIconTemplate: "string",
  paginationEndIconTemplate: "string",
  paginationLeftIconTemplate: "string",
  paginationRightIconTemplate: "string"
}, Yv = {
  bordered: !1,
  borderless: !1,
  clickableRows: !1,
  defaultValue: "-",
  edit: !1,
  entries: 10,
  entriesOptions: [10, 25, 50, 200],
  fixedHeader: !1,
  fullPagination: !1,
  hover: !1,
  loading: !1,
  loadingMessage: "Loading results...",
  maxWidth: null,
  maxHeight: null,
  multi: !1,
  noFoundMessage: "No matching results found",
  pagination: !0,
  selectable: !1,
  sm: !1,
  sortField: null,
  sortOrder: "asc",
  striped: !1,
  rowsText: "Rows per page:",
  ofText: "of",
  allText: "All",
  forceSort: !1,
  sortIconTemplate: zb,
  paginationStartIconTemplate: Ub,
  paginationEndIconTemplate: qb,
  paginationLeftIconTemplate: Xb,
  paginationRightIconTemplate: Gb
}, jv = {
  label: "string",
  field: "string",
  fixed: "(boolean|string)",
  format: "(function|null)",
  width: "(number|null)",
  sort: "boolean",
  columnIndex: "number"
}, Kv = {
  label: "",
  field: "",
  fixed: !1,
  format: null,
  width: null,
  sort: !0,
  columnIndex: 0
}, zv = {
  table: Vv,
  tableHeader: Wv,
  column: nv,
  pagination: vv,
  selectWrapper: Mv,
  scroll: Dv,
  tableBordered: Hv,
  paginationBordered: Tv,
  borderless: Qb,
  checkboxRowWrapper: iv,
  checkboxRow: ev,
  checkboxHeaderWrapper: tv,
  checkboxHeader: Jb,
  row: Ov,
  rowItem: Iv,
  striped: Bv,
  sortIconWrapper: Pv,
  sortIcon: Rv,
  paginationRowsText: xv,
  paginationNav: yv,
  paginationButtonsWrapper: Ev,
  hoverRow: lv,
  borderColor: Zb,
  color: sv,
  fixedHeader: rv,
  fixedHeaderBody: av,
  selectableRow: $v,
  rowAnimation: Sv,
  sm: Nv,
  edit: ov,
  selectItemsWrapper: Lv,
  paginationStartButton: kv,
  paginationLeftButton: Av,
  paginationRightButton: wv,
  paginationEndButton: Cv,
  loadingItemsWrapper: hv,
  loadingProgressBarWrapper: mv,
  loadingProgressBar: fv,
  loadingMessage: dv,
  loadingPaginationRowsText: pv,
  loadingPaginationSelectWrapper: _v,
  loadingPaginationNav: uv,
  loadingColumn: cv,
  noFoundMessageWrapper: bv,
  noFoundMessage: gv
}, Uv = {
  table: "string",
  tableHeader: "string",
  column: "string",
  pagination: "string",
  selectWrapper: "string",
  scroll: "string",
  tableBordered: "string",
  paginationBordered: "string",
  borderless: "string",
  checkboxRowWrapper: "string",
  checkboxRow: "string",
  checkboxHeaderWrapper: "string",
  checkboxHeader: "string",
  row: "string",
  rowItem: "string",
  striped: "string",
  sortIconWrapper: "string",
  sortIcon: "string",
  paginationRowsText: "string",
  paginationNav: "string",
  paginationButtonsWrapper: "string",
  hoverRow: "string",
  borderColor: "string",
  color: "string",
  fixedHeader: "string",
  fixedHeaderBody: "string",
  selectableRow: "string",
  rowAnimation: "string",
  sm: "string",
  edit: "string",
  selectItemsWrapper: "string",
  paginationStartButton: "string",
  paginationLeftButton: "string",
  paginationRightButton: "string",
  paginationEndButton: "string",
  loadingItemsWrapper: "string",
  loadingProgressBarWrapper: "string",
  loadingProgressBar: "string",
  loadingMessage: "string",
  loadingPaginationRowsText: "string",
  loadingPaginationSelectWrapper: "string",
  loadingPaginationNav: "string",
  loadingColumn: "string",
  noFoundMessageWrapper: "string",
  noFoundMessage: "string"
};
class wc {
  constructor(t, e = {}, i = {}, n = {}) {
    this._element = t, this._options = this._getOptions(i), this._classes = this._getClasses(n), this._sortReverse = !1, this._activePage = 0, this._search = "", this._searchColumn = null, this._paginationLeft = null, this._paginationRight = null, this._paginationStart = null, this._paginationEnd = null, this._select = null, this._selectInstance = null, this._selected = [], this._checkboxes = null, this._headerCheckbox = null, this._rows = this._getRows(e.rows), this._columns = this._getColumns(e.columns), this._element && (I.setData(t, gi, this), this._perfectScrollbar = null, this._setup());
  }
  // Getters
  static get NAME() {
    return xi;
  }
  get columns() {
    return this._columns.map((t, e) => {
      let i = {
        ...Kv,
        field: `field_${e}`,
        columnIndex: e
      };
      return typeof t == "string" ? i.label = t : typeof t == "object" && (i = {
        ...i,
        ...t
      }), L("column", i, jv), i;
    });
  }
  get rows() {
    return this._rows.map((t, e) => {
      const i = {
        rowIndex: e
      };
      return Array.isArray(t) ? this.columns.forEach((n, o) => {
        t[o] === 0 ? i[n.field] = t[o] : i[n.field] = t[o] || this._options.defaultValue;
      }) : typeof t == "object" && this.columns.forEach((n) => {
        t[n.field] === 0 ? i[n.field] = t[n.field] : i[n.field] = t[n.field] || this._options.defaultValue;
      }), i;
    });
  }
  get searchResult() {
    return Lb(this.rows, this._search, this._searchColumn);
  }
  get computedRows() {
    let t = [...this.searchResult];
    return this._options.sortOrder && (t = $b({
      rows: t,
      field: this._options.sortField,
      order: this._options.sortOrder
    })), this._options.pagination && (this._options.entries === "All" ? t = Fa({
      rows: t,
      entries: t.length,
      activePage: this._activePage
    }) : t = Fa({
      rows: t,
      entries: this._options.entries,
      activePage: this._activePage
    })), t;
  }
  get pages() {
    return this._options.entries === "All" ? 1 : Math.ceil(this.searchResult.length / this._options.entries);
  }
  get navigationText() {
    const t = this._activePage * this._options.entries;
    return this.searchResult.length === 0 ? `0 ${this._options.ofText} 0` : this._options.entries === "All" ? `1 - ${this.searchResult.length} ${this._options.ofText} ${this.searchResult.length}` : `${t + 1} - ${this.computedRows.length + t} ${this._options.ofText} ${this.searchResult.length}`;
  }
  get tableOptions() {
    return {
      classes: this._classes,
      columns: this.columns,
      rows: this.computedRows,
      noFoundMessage: this._options.noFoundMessage,
      edit: this._options.edit,
      loading: this._options.loading,
      loaderClass: this._options.loaderClass,
      loadingMessage: this._options.loadingMessage,
      selectable: this._options.selectable,
      multi: this._options.multi,
      bordered: this._options.bordered,
      borderless: this._options.borderless,
      striped: this._options.striped,
      hover: this._options.hover,
      fixedHeader: this._options.fixedHeader,
      sm: this._options.sm,
      sortIconTemplate: this._options.sortIconTemplate,
      pagination: {
        enable: this._options.pagination,
        text: this.navigationText,
        entries: this._options.entries,
        entriesOptions: this._options.entriesOptions,
        fullPagination: this._options.fullPagination,
        rowsText: this._options.rowsText,
        ofText: this._options.ofText,
        allText: this._options.allText,
        paginationStartIconTemplate: this._options.paginationStartIconTemplate,
        paginationLeftIconTemplate: this._options.paginationLeftIconTemplate,
        paginationRightIconTemplate: this._options.paginationRightIconTemplate,
        paginationEndIconTemplate: this._options.paginationEndIconTemplate,
        classes: this._classes
      },
      forceSort: this._options.forceSort
    };
  }
  // Public
  update(t, e = {}) {
    t && t.rows && (this._rows = t.rows), t && t.columns && (this._columns = t.columns), this._clearClassList(e), this._options = this._getOptions({ ...this._options, ...e }), this._setup(), this._performSort();
  }
  dispose() {
    this._selectInstance && this._selectInstance.dispose(), I.removeData(this._element, gi), this._removeEventListeners(), this._perfectScrollbar.destroy(), this._element = null;
  }
  search(t, e) {
    this._search = t, this._searchColumn = e, this._activePage = 0, this._options.pagination && this._toggleDisableState(), this._renderRows(), this._options.maxHeight && (this._perfectScrollbar.element.scrollTop = 0, this._perfectScrollbar.update());
  }
  sort(t, e = "asc") {
    this._options.sortOrder = e, typeof t == "string" ? this._options.sortField = this.columns.find(
      (n) => n.label === t
    ).field : this._options.sortField = t.field;
    const i = d.findOne(
      `[data-te-sort="${this._options.sortField}"]`,
      this._element
    );
    this._activePage = 0, this._toggleDisableState(), this._renderRows(), this._setActiveSortIcon(i);
  }
  setActivePage(t) {
    t < this.pages && this._changeActivePage(t);
  }
  // Private
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...zv,
      ...e,
      ...t
    }, L(xi, t, Uv), t;
  }
  _changeActivePage(t) {
    this._activePage = t, this._toggleDisableState(), this._renderRows();
  }
  _clearClassList(t) {
    ["hover", "bordered", "borderless", "sm", "striped"].forEach((e) => {
      this._options[e] && !t[e] && c.removeDataAttribute(`data-te-${e}`);
    });
  }
  _emitSelectEvent() {
    h.trigger(this._element, Yb, {
      selectedRows: this.rows.filter(
        (t) => this._selected.indexOf(t.rowIndex) !== -1
      ),
      selectedIndexes: this._selected,
      allSelected: this._selected.length === this.rows.length
    });
  }
  _getRows(t = []) {
    const e = d.findOne("tbody", this._element);
    return e ? [...d.find("tr", e).map((n) => d.find("td", n).map((o) => o.innerHTML)), ...t] : t;
  }
  _getColumns(t = []) {
    const e = d.findOne("thead", this._element);
    if (!e)
      return t;
    const i = d.findOne("tr", e);
    return [...d.find("th", i).map((o) => ({
      label: o.innerHTML,
      ...c.getDataAttributes(o)
    })), ...t];
  }
  _getCSSValue(t) {
    return typeof t == "string" ? t : `${t}px`;
  }
  _getOptions(t) {
    const e = {
      ...Yv,
      ...c.getDataAttributes(this._element),
      ...t
    };
    return L(xi, e, Fv), e;
  }
  _setActiveRows() {
    d.find(di, this._element).forEach((t) => {
      this._selected.includes(c.getDataAttribute(t, "index")) ? c.addClass(t, `active ${this._classes.selectableRow}`) : c.removeClass(t, `active ${this._classes.selectableRow}`);
    });
  }
  _setEntries(t) {
    this._options = this._getOptions({
      ...this._options,
      entries: t.target.value
    }), this._activePage > this.pages - 1 && (this._activePage = this.pages - 1), this._toggleDisableState(), this._renderRows();
  }
  _setSelected() {
    d.find(Xn, this._element).forEach(
      (t) => {
        const e = c.getDataAttribute(t, "rowIndex");
        t.checked = this._selected.includes(e);
      }
    ), this._setActiveRows();
  }
  _setActiveSortIcon(t) {
    d.find(Un, this._element).forEach((e) => {
      const i = this._options.sortOrder === "desc" && e === t ? 180 : 0;
      c.style(e, {
        transform: `rotate(${i}deg)`
      }), e === t && this._options.sortOrder ? c.addClass(e, "opacity-100") : c.removeClass(e, "opacity-100");
    });
  }
  _setup() {
    this._renderTable(), this._options.pagination && this._setupPagination(), this._options.edit && this._setupEditable(), this._options.clickableRows && this._setupClickableRows(), this._options.selectable && this._setupSelectable(), this._setupScroll(), this._setupSort();
  }
  _setupClickableRows() {
    d.find(di, this._element).forEach((t) => {
      const e = c.getDataAttribute(t, "index");
      c.addClass(t, "cursor-pointer"), h.on(t, "click", (i) => {
        d.matches(i.target, Xn) || h.trigger(this._element, jb, {
          index: e,
          row: this.rows[e]
        });
      });
    });
  }
  _setupEditable() {
    d.find(di, this._element).forEach((t) => {
      const e = c.getDataAttribute(t, "index");
      d.find(zn, t).forEach((i) => {
        h.on(i, "input", (n) => this._updateRow(n, e));
      });
    });
  }
  _setupScroll() {
    const t = d.findOne(Mb, this._element), e = {};
    if (this._options.maxHeight && (e.maxHeight = this._getCSSValue(this._options.maxHeight)), this._options.maxWidth) {
      const i = this._getCSSValue(this._options.maxWidth);
      e.maxWidth = i, c.style(this._element, { maxWidth: i });
    }
    if (c.style(t, e), c.addClass(t, `${this._classes.scroll}`), this._options.fixedHeader) {
      let i = d.find(Nb, this._element);
      this._options.selectable && (i = i.filter((n, o) => (c.addClass(
        n,
        `${this._classes.fixedHeader} ${this._classes.color}`
      ), o !== 0))), i.forEach((n, o) => {
        c.addClass(
          n,
          `${this._classes.fixedHeader} ${this._classes.color}`
        ), this.columns[o].fixed && c.addClass(n, "!z-40");
      });
    }
    this._perfectScrollbar = new yc(t);
  }
  _setupSort() {
    d.find(Un, this._element).forEach((t) => {
      const e = c.getDataAttribute(t, "sort"), [i] = d.parents(t, "th");
      if (this.columns.sort)
        c.addClass(i, "cursor-pointer");
      else
        return;
      e === this._options.sortField && this._setActiveSortIcon(t), h.on(i, "click", () => {
        this._options.sortField === e && this._options.sortOrder === "asc" ? this._options.sortOrder = "desc" : this._options.sortField === e && this._options.sortOrder === "desc" ? this._options.sortOrder = this._options.forceSort ? "asc" : null : this._options.sortOrder = "asc", this._options.sortField = e, this._activePage = 0, this._performSort(), this._setActiveSortIcon(t);
      });
    });
  }
  _performSort() {
    this._toggleDisableState(), this._renderRows();
  }
  _setupSelectable() {
    this._checkboxes = d.find(Xn, this._element), this._headerCheckbox = d.findOne(
      Rb,
      this._element
    ), h.on(
      this._headerCheckbox,
      "input",
      (t) => this._toggleSelectAll(t)
    ), this._checkboxes.forEach((t) => {
      const e = c.getDataAttribute(t, "rowIndex");
      h.on(
        t,
        "input",
        (i) => this._toggleSelectRow(i, e)
      );
    });
  }
  _setupPagination() {
    this._paginationRight = d.findOne(
      Pb,
      this._element
    ), this._paginationLeft = d.findOne(
      Bb,
      this._element
    ), h.on(
      this._paginationRight,
      "click",
      () => this._changeActivePage(this._activePage + 1)
    ), h.on(
      this._paginationLeft,
      "click",
      () => this._changeActivePage(this._activePage - 1)
    ), this._options.fullPagination && (this._paginationStart = d.findOne(
      Hb,
      this._element
    ), this._paginationEnd = d.findOne(
      Wb,
      this._element
    ), h.on(
      this._paginationStart,
      "click",
      () => this._changeActivePage(0)
    ), h.on(
      this._paginationEnd,
      "click",
      () => this._changeActivePage(this.pages - 1)
    )), this._toggleDisableState(), this._setupPaginationSelect();
  }
  _setupPaginationSelect() {
    this._select = d.findOne(Fb, this._element), this._selectInstance = new $o(this._select), h.on(
      this._select,
      "valueChange.te.select",
      (t) => this._setEntries(t)
    );
  }
  _removeEventListeners() {
    this._options.pagination && (h.off(this._paginationRight, "click"), h.off(this._paginationLeft, "click"), h.off(this._select, "valueChange.te.select"), this._options.fullPagination && (h.off(this._paginationStart, "click"), h.off(this._paginationEnd, "click"))), this._options.edit && d.find(zn, this._element).forEach((t) => {
      h.off(t, "input");
    }), this._options.clickableRows && d.find(di, this._element).forEach((t) => {
      h.off(t, "click");
    }), d.find(Un, this._element).forEach((t) => {
      const [e] = d.parents(t, "th");
      h.off(e, "click");
    }), this._options.selectable && (h.off(this._headerCheckbox, "input"), this._checkboxes.forEach((t) => {
      h.off(t, "input");
    }));
  }
  _renderTable() {
    this._element.innerHTML = Va(this.tableOptions).table, this._formatCells(), h.trigger(this._element, Ya);
  }
  _renderRows() {
    const t = d.findOne("tbody", this._element);
    if (this._options.pagination) {
      const e = d.findOne(
        Vb,
        this._element
      );
      e.innerText = this.navigationText;
    }
    t.innerHTML = Va(this.tableOptions).rows, this._formatCells(), this._options.edit && this._setupEditable(), this._options.selectable && (this._setupSelectable(), this._setSelected()), this._options.clickableRows && this._setupClickableRows(), h.trigger(this._element, Ya);
  }
  _formatCells() {
    d.find(di, this._element).forEach((e) => {
      const i = c.getDataAttribute(e, "index");
      d.find(zn, e).forEach((o) => {
        const r = c.getDataAttribute(o, "field"), a = this.columns.find((l) => l.field === r);
        a && a.format !== null && a.format(o, this.rows[i][r]);
      });
    });
  }
  _toggleDisableState() {
    this._options.pagination !== !1 && (this._activePage === 0 || this._options.loading ? (this._paginationLeft.setAttribute("disabled", ""), this._options.fullPagination && this._paginationStart.setAttribute("disabled", "")) : (this._paginationLeft.removeAttribute("disabled"), this._options.fullPagination && this._paginationStart.removeAttribute("disabled")), this._activePage === this.pages - 1 || this._options.loading || this.pages === 0 ? (this._paginationRight.setAttribute("disabled", ""), this._options.fullPagination && this._paginationEnd.setAttribute("disabled", "")) : (this._paginationRight.removeAttribute("disabled"), this._options.fullPagination && this._paginationEnd.removeAttribute("disabled")));
  }
  _toggleSelectAll(t) {
    t.target.checked ? this._selected = this.rows.map((e) => e.rowIndex) : this._selected = [], this._setSelected(), this._emitSelectEvent();
  }
  _toggleSelectRow(t, e) {
    t.target.checked ? this._options.multi && !this._selected.includes(e) ? this._selected = [...this._selected, e] : (this._selected = [e], this._checkboxes.forEach((i) => {
      i !== t.target && (i.checked = !1);
    })) : this._selected = this._selected.filter((i) => i !== e), this._options.multi && !t.target.checked && (this._headerCheckbox.checked = !1), this._setActiveRows(), this._emitSelectEvent();
  }
  _updateRow(t, e) {
    const i = c.getDataAttribute(t.target, "field"), n = t.target.textContent, o = this._rows[e];
    if (Array.isArray(o)) {
      const a = this.columns.find((l) => l.field === i).columnIndex;
      o[a] = n;
    } else
      o[i] = n;
    h.trigger(this._element, Kb, {
      rows: this._rows,
      columns: this._columns
    });
  }
  static jQueryInterface(t, e, i) {
    return this.each(function() {
      let n = I.getData(this, gi);
      const o = typeof t == "object" && t;
      if (!(!n && /dispose/.test(t)) && (n || (n = new wc(this, o, e)), typeof t == "string")) {
        if (typeof n[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        n[t](e, i);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, gi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const ja = "rating", $s = "te.rating", Xv = "data-te-rating-init", Gv = "[data-te-rating-icon-ref]", ti = `.${$s}`, qv = "ArrowLeft", Zv = "ArrowRight", Qv = {
  tooltip: "string",
  value: "(string|number)",
  readonly: "boolean",
  after: "string",
  before: "string",
  dynamic: "boolean",
  active: "string"
}, Jv = {
  tooltip: "top",
  value: "",
  readonly: !1,
  after: "",
  before: "",
  dynamic: !1,
  active: "fill-current"
}, Ka = `onSelect${ti}`, t0 = `onHover${ti}`, za = `keyup${ti}`, Ua = `focusout${ti}`, Xa = `keydown${ti}`, Ga = `mousedown${ti}`;
class z0 {
  constructor(t, e) {
    this._element = t, this._icons = d.find(Gv, this._element), this._options = this._getConfig(e), this._index = -1, this._savedIndex = null, this._originalClassList = [], this._originalIcons = [], this._fn = {}, this._tooltips = [], this._element && (I.setData(t, $s, this), this._init());
  }
  // Getters
  static get NAME() {
    return ja;
  }
  dispose() {
    I.removeData(this._element, $s), this._options.readonly || (h.off(this._element, za), h.off(this._element, Ua), h.off(this._element, Xa), this._element.removeEventListener("mouseleave", this._fn.mouseleave), this._icons.forEach((t, e) => {
      h.off(t, Ga), t.removeEventListener("mouseenter", this._fn.mouseenter[e]), c.removeClass(t, "cursor-pointer");
    }), this._tooltips.forEach((t) => {
      t._element.removeAttribute(Xv), t.dispose();
    }), this._icons.removeAttribute("tabIndex")), this._element = null;
  }
  // Private
  _init() {
    this._options.readonly || (this._bindMouseEnter(), this._bindMouseLeave(), this._bindMouseDown(), this._bindKeyDown(), this._bindKeyUp(), this._bindFocusLost(), this._icons.forEach((t) => {
      c.addClass(t, "cursor-pointer");
    })), this._options.dynamic && (this._saveOriginalClassList(), this._saveOriginalIcons()), this._setCustomText(), this._setToolTips(), this._options.value && (this._index = this._options.value - 1, this._updateRating(this._index));
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...Jv,
      ...e,
      ...t
    }, L(ja, t, Qv), t;
  }
  _bindMouseEnter() {
    this._fn.mouseenter = [], this._icons.forEach((t, e) => {
      t.addEventListener(
        "mouseenter",
        // this._fn.mouseenter[i] is needed to create reference and unpin events after call dispose
        // prettier-ignore
        this._fn.mouseenter[e] = (i) => {
          this._index = this._icons.indexOf(i.target), this._updateRating(this._index), this._triggerEvents(t, t0);
        }
      );
    });
  }
  _bindMouseLeave() {
    this._element.addEventListener(
      "mouseleave",
      // this._fn.mouseleave is needed to create reference and unpin events after call dispose
      // prettier-ignore
      this._fn.mouseleave = () => {
        this._savedIndex !== null ? (this._updateRating(this._savedIndex), this._index = this._savedIndex) : this._options.value ? (this._updateRating(this._options.value - 1), this._index = this._options.value - 1) : (this._index = -1, this._clearRating());
      }
    );
  }
  _bindMouseDown() {
    this._icons.forEach((t) => {
      h.on(t, Ga, () => {
        this._setElementOutline("none"), this._savedIndex = this._index, this._triggerEvents(t, Ka);
      });
    });
  }
  _bindKeyDown() {
    this._element.tabIndex = 0, h.on(
      this._element,
      Xa,
      (t) => this._updateAfterKeyDown(t)
    );
  }
  _bindKeyUp() {
    h.on(
      this._element,
      za,
      () => this._setElementOutline("auto")
    );
  }
  _bindFocusLost() {
    h.on(
      this._element,
      Ua,
      () => this._setElementOutline("none")
    );
  }
  _setElementOutline(t) {
    this._element.style.outline = t;
  }
  _triggerEvents(t, e) {
    h.trigger(t, e, {
      value: this._index + 1
    });
  }
  _updateAfterKeyDown(t) {
    const e = this._icons.length - 1, i = this._index;
    t.key === Zv && this._index < e && (this._index += 1), t.key === qv && this._index > -1 && (this._index -= 1), i !== this._index && (this._savedIndex = this._index, this._updateRating(this._savedIndex), this._triggerEvents(this._icons[this._savedIndex], Ka));
  }
  _updateRating(t) {
    this._clearRating(), this._options.dynamic && this._restoreOriginalIcon(t), this._icons.forEach((e, i) => {
      i <= t && c.addClass(e.querySelector("svg"), this._options.active);
    });
  }
  _clearRating() {
    this._icons.forEach((t, e) => {
      const i = t.querySelector("svg");
      this._options.dynamic && (t.classList = this._originalClassList[e], i.innerHTML = this._originalIcons[e]), c.removeClass(i, this._options.active);
    });
  }
  _setToolTips() {
    this._icons.forEach((t, e) => {
      const i = c.getDataAttribute(t, "toggle");
      t.title && !i && (c.setDataAttribute(t, "toggle", "tooltip"), this._tooltips[e] = new Qe(t, {
        placement: this._options.tooltip
      }));
    });
  }
  _setCustomText() {
    this._icons.forEach((t) => {
      const e = c.getDataAttribute(t, "after"), i = c.getDataAttribute(t, "before");
      e && t.insertAdjacentHTML("afterEnd", e), i && t.insertAdjacentHTML("beforeBegin", i);
    });
  }
  _saveOriginalClassList() {
    this._icons.forEach((t) => {
      const e = t.classList.value;
      this._originalClassList.push(e);
    });
  }
  _saveOriginalIcons() {
    this._icons.forEach((t) => {
      const e = t.querySelector("svg").innerHTML;
      this._originalIcons.push(e);
    });
  }
  _restoreOriginalIcon(t) {
    const e = this._originalClassList[t], i = this._originalIcons[t];
    this._icons.forEach((n, o) => {
      if (o <= t) {
        const r = n.querySelector("svg");
        r.innerHTML = i, n.classList = e;
      }
    });
  }
  // Static
  static getInstance(t) {
    return I.getData(t, $s);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Gn = "popconfirm", bi = "te.popconfirm", xc = `.${bi}`, e0 = `cancel${xc}`, i0 = `confirm${xc}`, s0 = "[data-te-popconfirm-body]", qn = "data-te-popconfirm-popover", n0 = "data-te-popconfirm-modal", qa = "data-te-popconfirm-backdrop", o0 = {
  popconfirmMode: "string",
  message: "string",
  cancelText: "(null|string)",
  okText: "(null|string)",
  popconfirmIconTemplate: "string",
  cancelLabel: "(null|string)",
  confirmLabel: "(null|string)",
  position: "(null|string)"
}, r0 = {
  popconfirmMode: "inline",
  message: "Are you sure?",
  cancelText: "Cancel",
  okText: "OK",
  popconfirmIconTemplate: "",
  cancelLabel: "Cancel",
  confirmLabel: "Confirm",
  position: "bottom"
}, a0 = {
  backdrop: "string",
  body: "string",
  btnCancel: "string",
  btnConfirm: "string",
  btnsContainer: "string",
  fade: "string",
  icon: "string",
  message: "string",
  messageText: "string",
  modal: "string",
  popover: "string"
}, l0 = {
  backdrop: "h-full w-full z-[1070] fixed top-0 left-0 bg-[#00000066] flex justify-center items-center",
  body: "p-[1rem] bg-white rounded-[0.5rem] opacity-0 dark:bg-neutral-700",
  btnCancel: "inline-block rounded bg-primary-100 px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-primary-700 transition duration-150 ease-in-out hover:bg-primary-accent-100 focus:bg-primary-accent-100 focus:outline-none focus:ring-0 active:bg-primary-accent-200",
  btnConfirm: "inline-block rounded bg-primary px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-white shadow-[0_4px_9px_-4px_#3b71ca] transition duration-150 ease-in-out hover:bg-primary-600 hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:bg-primary-600 focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:outline-none focus:ring-0 active:bg-primary-700 active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] dark:shadow-[0_4px_9px_-4px_rgba(59,113,202,0.5)] dark:hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)]",
  btnsContainer: "flex justify-end space-x-2",
  fade: "transition-opacity duration-[150ms] ease-linear",
  icon: "pr-2",
  message: "flex mb-3",
  messageText: "text-neutral-600 dark:text-white",
  modal: "absolute w-[300px] z-[1080] shadow-sm rounded-[0.5rem]",
  popover: "w-[300px] border-0 rounded-[0.5rem] z-[1080] shadow-sm"
};
class kc {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._popper = null, this._cancelButton = "", this._confirmButton = "", this._isOpen = !1, this._uid = this._element.id ? `popconfirm-${this._element.id}` : bt("popconfirm-"), t && I.setData(t, bi, this), this._clickHandler = this.open.bind(this), h.on(this._element, "click", this._clickHandler);
  }
  // Getters
  static get NAME() {
    return Gn;
  }
  get container() {
    return d.findOne(`#${this._uid}`);
  }
  get popconfirmBody() {
    return d.findOne(
      s0,
      this.container
    );
  }
  // Public
  dispose() {
    (this._isOpen || this.container !== null) && this.close(), I.removeData(this._element, bi), h.off(this._element, "click", this._clickHandler), this._element = null;
  }
  open() {
    this._isOpen || (this._options.popconfirmMode === "inline" ? this._openPopover(this._getPopoverTemplate()) : this._openModal(this._getModalTemplate()), this._handleCancelButtonClick(), this._handleConfirmButtonClick(), this._listenToEscapeKey(), this._listenToOutsideClick());
  }
  close() {
    if (this._isOpen) {
      if (this._popper !== null || d.findOne(`[${qn}]`) !== null)
        h.on(
          this.popconfirmBody,
          "transitionend",
          this._handlePopconfirmTransitionEnd.bind(this)
        ), c.removeClass(this.popconfirmBody, "opacity-100");
      else {
        const t = d.findOne(
          `[${qa}]`
        );
        c.removeClass(this.popconfirmBody, "opacity-100"), document.body.removeChild(t), this._isOpen = !1;
      }
      h.off(document, "click", this._handleOutsideClick.bind(this)), h.off(document, "keydown", this._handleEscapeKey.bind(this));
    }
  }
  _handlePopconfirmTransitionEnd(t) {
    if (t.target !== this.popconfirmBody)
      return;
    const e = d.findOne(
      `[${qn}]`
    );
    h.off(this.popconfirmBody, "transitionend"), this._isOpen && t && t.propertyName === "opacity" && (this._popper.destroy(), e && document.body.removeChild(e), this._isOpen = !1);
  }
  // Private
  _getPopoverTemplate() {
    const t = D("div"), e = this._getPopconfirmTemplate();
    return t.setAttribute(qn, ""), c.addClass(t, this._classes.popover), t.id = this._uid, t.innerHTML = e, t;
  }
  _getModalTemplate() {
    const t = D("div"), e = this._getPopconfirmTemplate();
    return t.setAttribute(n0, ""), c.addClass(t, `${this._classes.modal}`), t.id = this._uid, t.innerHTML = e, t;
  }
  _getPopconfirmTemplate() {
    return `<div data-te-popconfirm-body class="${this._classes.body}">
      <p class="${this._classes.message}">
      ${this._options.popconfirmIconTemplate ? `<span class="${this._classes.icon}">${this._options.popconfirmIconTemplate}</span>` : ""}
      <span class="${this._classes.messageText}">${this._options.message}</span>
      </p>
      <div class="${this._classes.btnsContainer}">
      ${this._options.cancelText ? `<button type="button" data-te-ripple-init data-te-ripple-color="light" id="popconfirm-button-cancel" aria-label="${this._options.cancelLabel}"
        class="${this._classes.btnCancel}">${this._options.cancelText}</button>` : ""}
      <button type="button" data-te-ripple-init data-te-ripple-color="light" id="popconfirm-button-confirm"
      aria-label="${this._options.confirmLabel}"
      class="${this._classes.btnConfirm}">${this._options.okText ? this._options.okText : "Ok"}</button>
      </div>
    </div>`;
  }
  _getConfig(t) {
    return t = {
      ...r0,
      ...c.getDataAttributes(this._element),
      ...t
    }, L(Gn, t, o0), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...l0,
      ...e,
      ...t
    }, L(Gn, t, a0), t;
  }
  _openPopover(t) {
    this._popper = Ee(this._element, t, {
      placement: this._translatePositionValue(),
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 5]
          }
        }
      ]
    }), document.body.appendChild(t), setTimeout(() => {
      c.addClass(
        this.popconfirmBody,
        `${this._classes.fade} opacity-100`
      ), this._isOpen = !0;
    }, 0);
  }
  _openModal(t) {
    const e = D("div");
    e.setAttribute(qa, ""), c.addClass(e, this._classes.backdrop), document.body.appendChild(e), e.appendChild(t), c.addClass(this.popconfirmBody, "opacity-100"), this._isOpen = !0;
  }
  _handleCancelButtonClick() {
    const t = this.container;
    this._cancelButton = d.findOne(
      "#popconfirm-button-cancel",
      t
    ), Ue.getOrCreateInstance(this._cancelButton, { rippleColor: "light" }), this._cancelButton !== null && h.on(this._cancelButton, "click", () => {
      this.close(), h.trigger(this._element, e0);
    });
  }
  _handleConfirmButtonClick() {
    const t = this.container;
    this._confirmButton = d.findOne(
      "#popconfirm-button-confirm",
      t
    ), Ue.getOrCreateInstance(this._confirmButton, { rippleColor: "light" }), h.on(this._confirmButton, "click", () => {
      this.close(), h.trigger(this._element, i0);
    });
  }
  _listenToEscapeKey() {
    h.on(document, "keydown", this._handleEscapeKey.bind(this));
  }
  _handleEscapeKey(t) {
    t.keyCode === Li && this.close();
  }
  _listenToOutsideClick() {
    h.on(document, "click", this._handleOutsideClick.bind(this));
  }
  _handleOutsideClick(t) {
    const e = this.container, i = t.target === e, n = e && e.contains(t.target), o = t.target === this._element, r = this._element && this._element.contains(t.target);
    !i && !n && !o && !r && this.close();
  }
  _translatePositionValue() {
    switch (this._options.position) {
      case "top left":
        return "top-end";
      case "top":
        return "top";
      case "top right":
        return "top-start";
      case "bottom left":
        return "bottom-end";
      case "bottom":
        return "bottom";
      case "bottom right":
        return "bottom-start";
      case "left":
        return "left";
      case "left top":
        return "left-end";
      case "left bottom":
        return "left-start";
      case "right":
        return "right";
      case "right top":
        return "right-end";
      case "right bottom":
        return "right-start";
      case void 0:
        return "bottom";
      default:
        return "bottom";
    }
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const i = I.getData(this, bi), n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t))) {
        if (!i)
          return new kc(this, n);
        if (typeof t == "string") {
          if (typeof i[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          i[t](e);
        }
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, bi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Zn = "lightbox", vi = "te.lightbox", c0 = `.${vi}`, h0 = ".data-api", Se = `click${c0}${h0}`, Oc = "[data-te-lightbox-init]", d0 = `${Oc} img:not([data-te-lightbox-disabled])`, Za = "data-te-lightbox-caption", u0 = "data-te-lightbox-disabled", St = "data-te-lightbox-active", p0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 12h-15m0 0l6.75 6.75M4.5 12l6.75-6.75" />
</svg>
`, _0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75" />
</svg>
`, f0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
</svg>
`, m0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25" />
</svg>
`, g0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6" />
</svg>
`, b0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
<path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6" />
</svg>
`, v0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
</svg>
`, T0 = {
  container: "string",
  zoomLevel: "(number|string)",
  prevIconTemplate: "string",
  nextIconTemplate: "string",
  showFullscreenIconTemplate: "string",
  hideFullscreenIconTemplate: "string",
  zoomInIconTemplate: "string",
  closeIconTemplate: "string",
  zoomOutIconTemplate: "string",
  spinnerContent: "string"
}, E0 = {
  container: "body",
  zoomLevel: 1,
  prevIconTemplate: p0,
  nextIconTemplate: _0,
  showFullscreenIconTemplate: f0,
  hideFullscreenIconTemplate: m0,
  zoomInIconTemplate: g0,
  zoomOutIconTemplate: b0,
  closeIconTemplate: v0,
  spinnerContent: "Loading..."
}, C0 = {
  caption: "text-white text-ellipsis overflow-hidden whitespace-nowrap mx-[10px] text-center",
  captionWrapper: "fixed left-0 bottom-0 w-full h-[50px] flex justify-center items-center",
  closeBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  fullscreenBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  gallery: "invisible fixed left-0 top-0 w-full h-full z-[1100] pointer-events-none opacity-0 bg-[#000000e6] transition-all duration-[400ms] motion-reduce:transition-none",
  galleryContent: "fixed top-[50px] left-[50px] w-[calc(100%-100px)] h-[calc(100%-100px)]",
  galleryCounter: "flex justify-center items-center px-[10px] mb-0 h-full text-[#b3b3b3]",
  img: "absolute left-0 top-0 w-full max-h-full h-auto cursor-pointer pointer-events-auto",
  imgWrapper: "absolute top-0 left-0 w-full h-full opacity-0 transform scale-[0.25] transition-all duration-[400ms] ease-out pointer-events-none motion-reduce:transition-none motion-reduce:transform-none",
  leftTools: "float-left h-full",
  loader: "fixed left-0 top-0 z-[2] w-full h-full text-neutral-50 opacity-1 flex justify-center items-center pointer-events-none transition-opacity duration-[1000ms] motion-reduce:transition-none",
  nextBtn: "border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  nextBtnWrapper: "fixed right-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none",
  prevBtn: "border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  prevBtnWrapper: "fixed left-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none",
  rightTools: "float-right",
  spinner: "inline-block h-8 w-8 animate-[spinner-grow_0.75s_linear_infinite] rounded-full bg-current align-[-0.125em] motion-reduce:animate-[spinner-grow_1.5s_linear_infinite]",
  spinnerContent: "!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]",
  toolbar: "absolute top-0 left-0 w-full h-[50px] z-20 transition-opacity duration-[400ms] motion-reduce:transition-none",
  vertical: "h-full max-h-full w-auto",
  zoomBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none"
}, A0 = {
  caption: "string",
  captionWrapper: "string",
  closeBtn: "string",
  fullscreenBtn: "string",
  gallery: "string",
  galleryContent: "string",
  galleryCounter: "string",
  img: "string",
  imgWrapper: "string",
  leftTools: "string",
  loader: "string",
  nextBtn: "string",
  nextBtnWrapper: "string",
  prevBtn: "string",
  prevBtnWrapper: "string",
  rightTools: "string",
  spinner: "string",
  spinnerContent: "string",
  toolbar: "string",
  vertical: "string",
  zoomBtn: "string"
};
class Ls {
  constructor(t, e = {}, i) {
    this._element = t, this._options = e, this._classes = this._getClasses(i), this._getContainer(), this._id = `lightbox-${Math.random().toString(36).substr(2, 9)}`, this._activeImg = 0, this._images = [], this._zoom = 1, this._gallery = null, this._galleryToolbar = null, this._galleryContent = null, this._loader = null, this._imgCounter = null, this._animating = !1, this._fullscreen = !1, this._zoomBtn = null, this._fullscreenBtn = null, this._toolsToggleTimer = 0, this._mousedown = !1, this._mousedownPositionX = 0, this._mousedownPositionY = 0, this._originalPositionX = 0, this._originalPositionY = 0, this._positionX = 0, this._positionY = 0, this._zoomTimer = 0, this._tapCounter = 0, this._tapTime = 0, this._rightArrow = null, this._leftArrowWrapper = null, this._rightArrowWrapper = null, this._initiated = !1, this._multitouch = !1, this._touchZoomPosition = [], this._element && (I.setData(t, vi, this), this.init());
  }
  // Getters
  static get NAME() {
    return Zn;
  }
  get activeImg() {
    return this._activeImg;
  }
  get currentImg() {
    return d.findOne(
      `[${St}]`,
      this._galleryContent
    );
  }
  get options() {
    const t = {
      ...E0,
      ...c.getDataAttributes(this._element),
      ...this._options
    };
    return L(Zn, t, T0), t;
  }
  // Public
  init() {
    this._initiated || (this._appendTemplate(), this._initiated = !0);
  }
  open(t = 0) {
    this._getImages(), this._setActiveImg(t), this._sortImages(), this._triggerEvents("open", "opened"), this._loadImages().then((e) => {
      this._resizeImages(e), this._toggleTemplate(), this._addEvents(), this._focusFullscreenBtn();
    });
  }
  close() {
    this.reset(), this._removeEvents(), this._toggleTemplate(), this._triggerEvents("close", "closed");
  }
  slide(t = "right") {
    this._animating === !0 || this._images.length <= 1 || (this._triggerEvents("slide", "slided"), this._beforeSlideEvents(), t === "right" && this._slideHorizontally(t), t === "left" && this._slideHorizontally(t), t === "first" && this._slideToTarget(t), t === "last" && this._slideToTarget(t), this._afterSlideEvents());
  }
  zoomIn() {
    this._zoom >= 3 || (this._triggerEvents("zoomIn", "zoomedIn"), this._zoom += parseFloat(this.options.zoomLevel), c.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn());
  }
  zoomOut() {
    this._zoom <= 1 || (this._triggerEvents("zoomOut", "zoomedOut"), this._zoom -= parseFloat(this.options.zoomLevel), c.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn(), this._updateImgPosition());
  }
  toggleFullscreen() {
    this._fullscreen === !1 ? (this._fullscreenBtn.setAttribute(St, ""), this._fullscreenBtn.innerHTML = this.options.hideFullscreenIconTemplate, this._gallery.requestFullscreen && this._gallery.requestFullscreen(), this._fullscreen = !0) : (this._fullscreenBtn.removeAttribute(St), document.exitFullscreen && document.exitFullscreen(), this._fullscreen = !1);
  }
  reset() {
    this._restoreDefaultFullscreen(), this._restoreDefaultPosition(), this._restoreDefaultZoom(), clearTimeout(this._toolsToggleTimer), clearTimeout(this._doubleTapTimer);
  }
  dispose() {
    h.off(
      document,
      Se,
      d0,
      this.toggle
    ), this._galleryContent && this._removeEvents(), this._gallery && this._gallery.remove(), I.removeData(this._element, vi), this._element = null;
  }
  // Private
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...C0,
      ...e,
      ...t
    }, L(Zn, t, A0), t;
  }
  _getImages() {
    const e = d.find("img", this._element).filter(
      (i) => !i.hasAttribute(u0)
    );
    this._images = e;
  }
  _getContainer() {
    this._container = d.findOne(this.options.container);
  }
  _setActiveImg(t) {
    this._activeImg = typeof t == "number" ? t : this._images.indexOf(t.target);
  }
  _appendTemplate() {
    this._gallery = D("div"), c.addClass(this._gallery, `${this._classes.gallery}`), this._element.dataset.id = this._id, this._gallery.id = this._id, this._appendLoader(), this._appendToolbar(), this._appendContent(), this._appendArrows(), this._appendCaption(), this._container.append(this._gallery);
  }
  _appendToolbar() {
    this._galleryToolbar = D("div"), this._imgCounter = D("p"), this._fullscreenBtn = D("button"), this._zoomBtn = D("button");
    const t = D("button"), e = D("div"), i = D("div");
    c.addClass(this._galleryToolbar, `${this._classes.toolbar}`), c.addClass(this._imgCounter, `${this._classes.galleryCounter}`), c.addClass(this._fullscreenBtn, `${this._classes.fullscreenBtn}`), c.addClass(this._zoomBtn, `${this._classes.zoomInBtn}`), c.addClass(this._zoomBtn, this._classes.zoomBtn), c.addClass(e, `${this._classes.leftTools}`), c.addClass(i, `${this._classes.rightTools}`), c.addClass(t, `${this._classes.closeBtn}`), this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, t.innerHTML = this.options.closeIconTemplate, this._zoomBtn.innerHTML = this.options.zoomInIconTemplate, this._fullscreenBtn.setAttribute("aria-label", "Toggle fullscreen"), this._zoomBtn.setAttribute("aria-label", "Zoom in"), t.setAttribute("aria-label", "Close"), h.on(
      this._fullscreenBtn,
      Se,
      () => this.toggleFullscreen()
    ), h.on(
      this._zoomBtn,
      Se,
      () => this._toggleZoom()
    ), h.on(t, Se, () => this.close()), e.append(this._imgCounter), i.append(this._fullscreenBtn), i.append(this._zoomBtn), i.append(t), this._galleryToolbar.append(e), this._galleryToolbar.append(i), this._gallery.append(this._galleryToolbar);
  }
  _appendContent() {
    this._galleryContent = D("div"), c.addClass(
      this._galleryContent,
      `${this._classes.galleryContent}`
    ), this._gallery.append(this._galleryContent);
  }
  _appendLoader() {
    this._loader = D("div");
    const t = D("div"), e = D("span");
    c.addClass(this._loader, `${this._classes.loader}`), c.addClass(t, `${this._classes.spinner}`), c.addClass(e, `${this._classes.spinnerContent}`), t.setAttribute("role", "status"), e.innerHTML = this.options.spinnerContent, t.append(e), this._loader.append(t), this._gallery.append(this._loader);
  }
  _appendArrows() {
    this._leftArrowWrapper = D("div"), c.addClass(
      this._leftArrowWrapper,
      `${this._classes.prevBtnWrapper}`
    );
    const t = D("button");
    t.setAttribute("aria-label", "Previous"), c.addClass(t, `${this._classes.prevBtn}`), h.on(t, Se, () => this.slide("left")), this._leftArrowWrapper.append(t), this._rightArrowWrapper = D("div"), c.addClass(
      this._rightArrowWrapper,
      `${this._classes.nextBtnWrapper}`
    ), this._rightArrow = D("button"), this._rightArrow.setAttribute("aria-label", "Next"), c.addClass(this._rightArrow, `${this._classes.nextBtn}`), h.on(this._rightArrow, Se, () => this.slide()), this._rightArrowWrapper.append(this._rightArrow), this._rightArrow.innerHTML = this.options.nextIconTemplate, t.innerHTML = this.options.prevIconTemplate, this._getImages(), !(this._images.length <= 1) && (this._gallery.append(this._leftArrowWrapper), this._gallery.append(this._rightArrowWrapper));
  }
  _appendCaption() {
    const t = D("div"), e = D("p");
    e.setAttribute(Za, ""), c.addClass(t, `${this._classes.captionWrapper}`), c.addClass(e, `${this._classes.caption}`), t.append(e), this._gallery.append(t);
  }
  _sortImages() {
    for (let t = 0; t < this._activeImg; t++)
      this._images.push(this._images.shift());
  }
  async _loadImages() {
    const t = [], e = [];
    this._galleryContent.innerHTML = "";
    let i = 0;
    return this._images.forEach((n, o) => {
      t.push(
        new Promise((r) => {
          const a = new Image(), l = D("div");
          c.addClass(l, `${this._classes.imgWrapper}`), c.addClass(a, `${this._classes.img}`), this._addImgStyles(a, l, i, o, n), l.append(a), this._galleryContent.append(l), a.onload = r, a.src = n.dataset.teImg || n.src, e.push(a), i += 100;
        })
      );
    }), await Promise.all(t), e;
  }
  _addImgStyles(t, e, i, n, o) {
    t.alt = o.alt, t.draggable = !1, c.style(e, {
      position: "absolute",
      left: `${i}%`,
      top: 0
    }), (o.dataset.teCaption || o.dataset.teCaption === "") && (t.dataset.caption = o.dataset.teCaption), i === 0 ? (o.width < o.height && c.addClass(t, `${this._classes.vertical}`), c.style(e, { opacity: 1 }), t.setAttribute(St, "")) : t.removeAttribute(St), n === this._images.length - 1 && this._images.length > 1 && c.style(e, { left: "-100%" });
  }
  _resizeImages(t) {
    t.forEach((e) => {
      this._calculateImgSize(e);
    });
  }
  _calculateImgSize(t) {
    t.width >= t.height ? (t.style.width = "100%", t.style.maxWidth = "100%", t.style.height = "auto", t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`, t.style.left = 0) : (t.style.height = "100%", t.style.maxHeight = "100%", t.style.width = "auto", t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`, t.style.top = 0), t.width >= t.parentNode.offsetWidth && (t.style.width = `${t.parentNode.offsetWidth}px`, t.style.height = "auto", t.style.left = 0, t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`), t.height >= t.parentNode.offsetHeight && (t.style.height = `${t.parentNode.offsetHeight}px`, t.style.width = "auto", t.style.top = 0, t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`), this._positionX = parseFloat(t.style.left) || 0, this._positionY = parseFloat(t.style.top) || 0;
  }
  _onResize() {
    this._images = d.find("img", this._galleryContent), this._images.forEach((t) => {
      this._calculateImgSize(t);
    });
  }
  _onFullscreenChange() {
    (document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) === void 0 && (this._fullscreen = !1, this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, this._fullscreenBtn.removeAttribute(St));
  }
  _beforeSlideEvents() {
    this._animationStart(), this._restoreDefaultZoom(), this._restoreDefaultPosition(), this._resetDoubleTap();
  }
  _slideHorizontally(t) {
    this._images = d.find("img", this._galleryContent), this._images.forEach((e) => {
      let i;
      t === "right" ? (i = parseInt(e.parentNode.style.left, 10) - 100, i < -100 && (i = (this._images.length - 2) * 100)) : (i = parseInt(e.parentNode.style.left, 10) + 100, i === (this._images.length - 1) * 100 && (i = -100)), this._slideImg(e, i);
    }), this._updateActiveImg(t);
  }
  _slideImg(t, e) {
    e === 0 ? (t.setAttribute(St, ""), c.style(t.parentNode, { opacity: 1, transform: "scale(1)" })) : (t.removeAttribute(St), c.style(t.parentNode, {
      opacity: 0,
      transform: "scale(0.25)"
    })), t.parentNode.style.left = `${e}%`;
  }
  _slideToTarget(t) {
    t === "first" && this._activeImg === 0 || t === "last" && this._activeImg === this._images.length - 1 || (this.reset(), this._removeEvents(), this._showLoader(), this._getImages(), this._activeImg = t === "first" ? 0 : this._images.length - 1, this._sortImages(), c.style(this.currentImg.parentNode, {
      transform: "scale(0.25)",
      opacity: 0
    }), setTimeout(() => {
      this._loadImages().then((e) => {
        this._resizeImages(e), this._addEvents(), this._updateCaption(), this._hideLoader(), setTimeout(() => {
          c.style(this.currentImg.parentNode, {
            transform: "scale(1)",
            opacity: 1
          });
        }, 10);
      });
    }, 400));
  }
  _updateActiveImg(t) {
    t === "right" && (this._activeImg === this._images.length - 1 ? this._activeImg = 0 : this._activeImg++), t === "left" && (this._activeImg === 0 ? this._activeImg = this._images.length - 1 : this._activeImg--);
  }
  _afterSlideEvents() {
    this._updateCounter(), this._updateCaption();
  }
  _updateCounter() {
    this._images.length <= 1 || setTimeout(() => {
      this._imgCounter.innerHTML = `${this._activeImg + 1} / ${this._images.length}`;
    }, 200);
  }
  _updateCaption() {
    setTimeout(() => {
      let t = this.currentImg.alt;
      (this.currentImg.dataset.caption || this.currentImg.dataset.caption === "") && (t = this.currentImg.dataset.caption), d.findOne(
        `[${Za}]`,
        this._gallery
      ).innerHTML = t;
    }, 200);
  }
  _toggleTemplate() {
    this._gallery.style.visibility === "visible" ? (c.style(this.currentImg.parentNode, {
      transform: "scale(0.25)"
    }), setTimeout(() => {
      this._hideGallery(), this._enableScroll(), this._showLoader();
    }, 100)) : (this._showGallery(), this._disableScroll(), this._updateCounter(), this._updateCaption(), this._setToolsToggleTimout(), this._hideLoader());
  }
  _showLoader() {
    c.style(this._loader, { opacity: 1 });
  }
  _hideLoader() {
    c.style(this._loader, { opacity: 0 });
  }
  _hideGallery() {
    c.style(this._gallery, {
      opacity: 0,
      pointerEvents: "none",
      visibility: "hidden"
    });
  }
  _showGallery() {
    c.style(this._gallery, {
      opacity: 1,
      pointerEvents: "initial",
      visibility: "visible"
    }), setTimeout(() => {
      c.style(this.currentImg.parentNode, { transform: "scale(1)" });
    }, 50);
  }
  _toggleZoom() {
    this._zoom !== 1 ? this.zoomOut() : this.zoomIn();
  }
  _updateZoomBtn() {
    this._zoom > 1 ? (this._zoomBtn.setAttribute(St, ""), this._zoomBtn.setAttribute("aria-label", "Zoom out"), this._zoomBtn.innerHTML = this.options.zoomOutIconTemplate) : (this._zoomBtn.removeAttribute(St), this._zoomBtn.setAttribute("aria-label", "Zoom in"), this._zoomBtn.innerHTML = this.options.zoomInIconTemplate);
  }
  _updateImgPosition() {
    this._zoom === 1 && this._restoreDefaultPosition();
  }
  _addEvents() {
    const t = d.find("img", this._galleryContent);
    this._onWindowTouchmove = this._onWindowTouchmove.bind(this), this._onWindowTouchstart = this._onWindowTouchstart.bind(this), this._onImgMousedown = this._onMousedown.bind(this), this._onImgMousemove = this._onMousemove.bind(this), this._onImgWheel = this._onZoom.bind(this), this._onImgMouseup = this._onMouseup.bind(this), this._onImgTouchend = this._onTouchend.bind(this), this._onImgDoubleClick = this._onDoubleClick.bind(this), this._onWindowResize = this._onResize.bind(this), this._onWindowFullscreenChange = this._onFullscreenChange.bind(this), this._onAnyImgAction = this._resetToolsToggler.bind(this), this._onGalleryClick = this._onBackdropClick.bind(this), this._onKeyupEvent = this._onKeyup.bind(this), this._onRightArrowKeydownEvent = this._onRightArrowKeydown.bind(this), this._onFullscreenBtnKeydownEvent = this._onFullscreenBtnKeydown.bind(this), t.forEach((e) => {
      h.on(e, "mousedown", this._onImgMousedown, {
        passive: !0
      }), h.on(e, "touchstart", this._onImgMousedown, {
        passive: !0
      }), h.on(e, "mousemove", this._onImgMousemove, {
        passive: !0
      }), h.on(e, "touchmove", this._onImgMousemove, {
        passive: !0
      }), h.on(e, "wheel", this._onImgWheel, { passive: !0 }), h.on(e, "dblclick", this._onImgDoubleClick, {
        passive: !0
      });
    }), document.addEventListener("touchmove", this._onWindowTouchmove, {
      passive: !1
    }), h.on(window, "touchstart", this._onWindowTouchstart), h.on(window, "mouseup", this._onImgMouseup), h.on(window, "touchend", this._onImgTouchend), h.on(window, "resize", this._onWindowResize), h.on(window, "orientationchange", this._onWindowResize), h.on(window, "keyup", this._onKeyupEvent), h.on(window, "fullscreenchange", this._onWindowFullscreenChange), h.on(this._gallery, "mousemove", this._onAnyImgAction), h.on(this._gallery, "click", this._onGalleryClick), h.on(
      this._rightArrow,
      "keydown",
      this._onRightArrowKeydownEvent
    ), h.on(
      this._fullscreenBtn,
      "keydown",
      this._onFullscreenBtnKeydownEvent
    );
  }
  _removeEvents() {
    d.find("img", this._galleryContent).forEach((e) => {
      h.off(e, "mousedown", this._onImgMousedown), h.off(e, "touchstart", this._onImgMousedown), h.off(e, "mousemove", this._onImgMousemove), h.off(e, "touchmove", this._onImgMousemove), h.off(e, "wheel", this._onImgWheel), h.off(e, "dblclick", this._onImgDoubleClick);
    }), document.removeEventListener("touchmove", this._onWindowTouchmove, {
      passive: !1
    }), h.off(window, "touchstart", this._onWindowTouchstart), h.off(window, "mouseup", this._onImgMouseup), h.off(window, "touchend", this._onImgTouchend), h.off(window, "resize", this._onWindowResize), h.off(window, "orientationchange", this._onWindowResize), h.off(window, "keyup", this._onKeyupEvent), h.off(
      window,
      "fullscreenchange",
      this._onWindowFullscreenChange
    ), h.off(this._gallery, "mousemove", this._onAnyImgAction), h.off(this._gallery, "click", this._onGalleryClick), h.off(
      this._rightArrow,
      "keydown",
      this._onRightArrowKeydownEvent
    ), h.off(
      this._fullscreenBtn,
      "keydown",
      this._onFullscreenBtnKeydownEvent
    );
  }
  _onMousedown(t) {
    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;
    this._originalPositionX = parseFloat(this.currentImg.style.left) || 0, this._originalPositionY = parseFloat(this.currentImg.style.top) || 0, this._positionX = this._originalPositionX, this._positionY = this._originalPositionY, this._mousedownPositionX = i * (1 / this._zoom) - this._positionX, this._mousedownPositionY = n * (1 / this._zoom) - this._positionY, this._mousedown = !0, t.type === "touchstart" && t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);
  }
  _onMousemove(t) {
    if (!this._mousedown)
      return;
    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;
    if (e && this._resetToolsToggler(), !this._multitouch)
      if (this._zoom !== 1)
        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, this._positionY = n * (1 / this._zoom) - this._mousedownPositionY, c.style(this.currentImg, {
          left: `${this._positionX}px`,
          top: `${this._positionY}px`
        });
      else {
        if (this._images.length <= 1)
          return;
        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, c.style(this.currentImg, { left: `${this._positionX}px` });
      }
  }
  _onMouseup(t) {
    this._mousedown = !1, this._moveImg(t.target);
  }
  _onTouchend(t) {
    this._mousedown = !1, this._multitouch ? t.targetTouches.length === 0 && (this._multitouch = !1, this._touchZoomPosition = []) : this._multitouch || (this._checkDoubleTap(t), this._moveImg(t.target));
  }
  _calculateTouchZoom(t) {
    const e = Math.hypot(
      this._touchZoomPosition[1].pageX - this._touchZoomPosition[0].pageX,
      this._touchZoomPosition[1].pageY - this._touchZoomPosition[0].pageY
    ), i = Math.hypot(
      t.touches[1].pageX - t.touches[0].pageX,
      t.touches[1].pageY - t.touches[0].pageY
    ), n = Math.abs(e - i), o = t.view.screen.width;
    n > o * 0.03 && (e <= i ? this.zoomIn() : this.zoomOut(), this._touchZoomPosition = t.touches);
  }
  _onWindowTouchstart(t) {
    t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);
  }
  _onWindowTouchmove(t) {
    t.preventDefault(), t.type === "touchmove" && t.targetTouches.length > 1 && this._calculateTouchZoom(t);
  }
  _onRightArrowKeydown(t) {
    switch (t.keyCode) {
      case 9:
        if (t.shiftKey)
          break;
        t.preventDefault(), this._focusFullscreenBtn();
        break;
    }
  }
  _onFullscreenBtnKeydown(t) {
    switch (t.keyCode) {
      case 9:
        if (!t.shiftKey)
          break;
        t.preventDefault(), this._focusRightArrow();
        break;
    }
  }
  _onKeyup(t) {
    switch (this._resetToolsToggler(), t.keyCode) {
      case 39:
        this.slide();
        break;
      case 37:
        this.slide("left");
        break;
      case 27:
        this.close();
        break;
      case 36:
        this.slide("first");
        break;
      case 35:
        this.slide("last");
        break;
      case 38:
        this.zoomIn();
        break;
      case 40:
        this.zoomOut();
        break;
    }
  }
  _focusFullscreenBtn() {
    setTimeout(() => {
      this._fullscreenBtn.focus();
    }, 100);
  }
  _focusRightArrow() {
    this._rightArrow.focus();
  }
  _moveImg(t) {
    if (this._multitouch || this._zoom !== 1 || t !== this.currentImg || this._images.length <= 1)
      return;
    const e = this._positionX - this._originalPositionX;
    e > 0 ? this.slide("left") : e < 0 && this.slide();
  }
  _checkDoubleTap(t) {
    clearTimeout(this._doubleTapTimer);
    const i = (/* @__PURE__ */ new Date()).getTime() - this._tapTime;
    this._tapCounter > 0 && i < 500 ? (this._onDoubleClick(t), this._doubleTapTimer = setTimeout(() => {
      this._tapTime = (/* @__PURE__ */ new Date()).getTime(), this._tapCounter = 0;
    }, 300)) : (this._tapCounter++, this._tapTime = (/* @__PURE__ */ new Date()).getTime());
  }
  _resetDoubleTap() {
    this._tapTime = 0, this._tapCounter = 0, clearTimeout(this._doubleTapTimer);
  }
  _onDoubleClick(t) {
    this._multitouch || (t.touches || this._setNewPositionOnZoomIn(t), this._zoom !== 1 ? this._restoreDefaultZoom() : this.zoomIn());
  }
  _onZoom(t) {
    if (t.deltaY > 0)
      this.zoomOut();
    else {
      if (this._zoom >= 3)
        return;
      this._setNewPositionOnZoomIn(t), this.zoomIn();
    }
  }
  _onBackdropClick(t) {
    this._resetToolsToggler(), t.target.tagName === "DIV" && this.close();
  }
  _setNewPositionOnZoomIn(t) {
    clearTimeout(this._zoomTimer), this._positionX = window.innerWidth / 2 - t.offsetX - 50, this._positionY = window.innerHeight / 2 - t.offsetY - 50, this.currentImg.style.transition = "all 0.5s ease-out", this.currentImg.style.left = `${this._positionX}px`, this.currentImg.style.top = `${this._positionY}px`, this._zoomTimer = setTimeout(() => {
      this.currentImg.style.transition = "none";
    }, 500);
  }
  _resetToolsToggler() {
    this._showTools(), clearTimeout(this._toolsToggleTimer), this._setToolsToggleTimout();
  }
  _setToolsToggleTimout() {
    this._toolsToggleTimer = setTimeout(() => {
      this._hideTools(), clearTimeout(this._toolsToggleTimer);
    }, 4e3);
  }
  _hideTools() {
    c.style(this._galleryToolbar, { opacity: 0 }), c.style(this._leftArrowWrapper, { opacity: 0 }), c.style(this._rightArrowWrapper, { opacity: 0 });
  }
  _showTools() {
    c.style(this._galleryToolbar, { opacity: 1 }), c.style(this._leftArrowWrapper, { opacity: 1 }), c.style(this._rightArrowWrapper, { opacity: 1 });
  }
  _disableScroll() {
    c.addClass(document.body, "overflow-y-hidden relative"), document.documentElement.scrollHeight > document.documentElement.clientHeight && c.addClass(document.body, "md:pr-[17px]");
  }
  _enableScroll() {
    setTimeout(() => {
      c.removeClass(document.body, "overflow-y-hidden relative"), c.removeClass(document.body, "md:pr-[17px]");
    }, 300);
  }
  _animationStart() {
    this._animating = !0, setTimeout(() => {
      this._animating = !1;
    }, 400);
  }
  _restoreDefaultZoom() {
    this._zoom !== 1 && (this._zoom = 1, c.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn(), this._updateImgPosition());
  }
  _restoreDefaultFullscreen() {
    this._fullscreen && this.toggleFullscreen();
  }
  _restoreDefaultPosition() {
    clearTimeout(this._zoomTimer);
    const t = this.currentImg;
    c.style(this.currentImg.parentNode, { left: 0, top: 0 }), c.style(this.currentImg, {
      transition: "all 0.5s ease-out",
      left: 0,
      top: 0
    }), this._calculateImgSize(t), setTimeout(() => {
      c.style(this.currentImg, { transition: "none" });
    }, 500);
  }
  async _triggerEvents(t, e) {
    h.trigger(this._element, `${t}.te.lightbox`), e && await setTimeout(() => {
      h.trigger(this._element, `${e}.te.lightbox`);
    }, 505);
  }
  static getInstance(t) {
    return I.getData(t, vi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static toggle() {
    return function(t) {
      const e = d.closest(
        t.target,
        `${Oc}`
      );
      (Ls.getInstance(e) || new Ls(e)).open(t);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, vi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new Ls(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
}
const y0 = (s, t = "hide") => {
  const e = `click.dismiss${s.EVENT_KEY}`, i = s.NAME;
  h.on(
    document,
    e,
    `[data-te-${i}-dismiss]`,
    function(n) {
      if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), me(this))
        return;
      const o = Qt(this) || this.closest(`.${i}`) || this.closest(`[data-te-${i}-init]`);
      if (!o)
        return;
      s.getOrCreateInstance(o)[t]();
    }
  );
}, w0 = (s) => {
  il(() => {
    const t = el();
    if (t) {
      const e = s.NAME, i = t.fn[e];
      t.fn[e] = s.jQueryInterface, t.fn[e].Constructor = s, t.fn[e].noConflict = () => (t.fn[e] = i, s.jQueryInterface);
    }
  });
}, x0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      e.preventDefault(), s.getOrCreateInstance(this).toggle();
    }
  );
}, k0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), me(this))
        return;
      s.getOrCreateInstance(this).show();
    }
  );
}, O0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      const i = Qt(this);
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), me(this))
        return;
      h.one(i, s.EVENT_HIDDEN, () => {
        Lt(this) && this.focus();
      });
      const n = d.findOne(s.OPEN_SELECTOR);
      n && n !== i && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, S0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}`,
    t,
    (e) => {
      e.preventDefault();
      const i = e.target.closest(t);
      s.getOrCreateInstance(i).toggle();
    }
  );
}, I0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      const i = Qt(this);
      ["A", "AREA"].includes(this.tagName) && e.preventDefault(), h.one(i, s.EVENT_SHOW, (r) => {
        r.defaultPrevented || h.one(i, s.EVENT_HIDDEN, () => {
          Lt(this) && this.focus();
        });
      });
      const n = d.findOne(
        `[${s.OPEN_SELECTOR}="true"]`
      );
      n && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, D0 = (s, t) => {
  h.one(
    document,
    "mousedown",
    t,
    s.autoInitial(new s())
  );
}, $0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      (e.target.tagName === "A" || e.delegateTarget && e.delegateTarget.tagName === "A") && e.preventDefault();
      const i = fo(this);
      d.find(i).forEach((o) => {
        s.getOrCreateInstance(o, { toggle: !1 }).toggle();
      });
    }
  );
}, L0 = (s, t) => {
  [].slice.call(
    document.querySelectorAll(t)
  ).map(function(i) {
    return new s(i);
  });
}, M0 = (s, t) => {
  [].slice.call(
    document.querySelectorAll(t)
  ).map(function(i) {
    return new s(i);
  });
}, N0 = (s, t) => {
  d.find(t).forEach((e) => {
    new s(e);
  }), h.on(
    document,
    `click.te.${s.NAME}.data-api`,
    `${t} img:not([data-te-lightbox-disabled])`,
    s.toggle()
  );
}, R0 = (s, t) => {
  const e = (o) => o[0] === "{" && o[o.length - 1] === "}" || o[0] === "[" && o[o.length - 1] === "]", i = (o) => typeof o != "string" ? o : e(o) ? JSON.parse(o.replace(/'/g, '"')) : o, n = (o) => {
    const r = {};
    return Object.keys(o).forEach((a) => {
      if (a.match(/dataset.*/)) {
        const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));
        r[l] = i(o[a]);
      }
    }), r;
  };
  d.find(t).forEach((o) => {
    if (c.getDataAttribute(o, "chart") !== "bubble" && c.getDataAttribute(o, "chart") !== "scatter") {
      const r = c.getDataAttributes(o), a = {
        data: {
          datasets: [n(r)]
        }
      };
      return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '"'))), new s(o, {
        ...a,
        ...mi[a.type]
      });
    }
    return null;
  });
};
class P0 {
  constructor() {
    this.inits = [];
  }
  get initialized() {
    return this.inits;
  }
  isInited(t) {
    return this.inits.includes(t);
  }
  add(t) {
    this.inits.push(t);
  }
}
const _o = new P0(), Ti = {
  alert: {
    name: "Alert",
    selector: "[data-te-alert-init]",
    isToggler: !1,
    dismissMethod: "close"
  },
  animation: {
    name: "Animate",
    selector: "[data-te-animation-init]",
    isToggler: !1
  },
  carousel: {
    name: "Carousel",
    selector: "[data-te-carousel-init]",
    isToggler: !1
  },
  chips: {
    name: "ChipsInput",
    selector: "[data-te-chips-input-init]",
    isToggler: !1
  },
  chip: {
    name: "Chip",
    selector: "[data-te-chip-init]",
    isToggler: !1,
    onInit: "init"
  },
  datepicker: {
    name: "Datepicker",
    selector: "[data-te-datepicker-init]",
    isToggler: !1
  },
  input: {
    name: "Input",
    selector: "[data-te-input-wrapper-init]",
    isToggler: !1
  },
  perfectScrollbar: {
    name: "PerfectScrollbar",
    selector: "[data-te-perfect-scrollbar-init]",
    isToggler: !1
  },
  rating: {
    name: "Rating",
    selector: "[data-te-rating-init]",
    isToggler: !1
  },
  scrollspy: {
    name: "ScrollSpy",
    selector: "[data-te-spy='scroll']",
    isToggler: !1
  },
  select: {
    name: "Select",
    selector: "[data-te-select-init]",
    isToggler: !1
  },
  sidenav: {
    name: "Sidenav",
    selector: "[data-te-sidenav-init]",
    isToggler: !1
  },
  stepper: {
    name: "Stepper",
    selector: "[data-te-stepper-init]",
    isToggler: !1
  },
  timepicker: {
    name: "Timepicker",
    selector: "[data-te-timepicker-init]",
    isToggler: !1
  },
  toast: {
    name: "Toast",
    selector: "[data-te-toast-init]",
    isToggler: !1,
    dismissMethod: "hide"
  },
  datatable: {
    name: "Datatable",
    selector: "[data-te-datatable-init]"
  },
  popconfirm: {
    name: "Popconfirm",
    selector: "[data-te-toggle='popconfirm']"
  },
  // advancedInits
  chart: {
    name: "Chart",
    selector: "[data-te-chart]",
    isToggler: !1,
    advanced: R0
  },
  // togglers
  button: {
    name: "Button",
    selector: "[data-te-toggle='button']",
    isToggler: !0,
    callback: S0
  },
  collapse: {
    name: "Collapse",
    selector: "[data-te-collapse-init]",
    isToggler: !0,
    callback: $0
  },
  dropdown: {
    name: "Dropdown",
    selector: "[data-te-dropdown-toggle-ref]",
    isToggler: !0,
    callback: x0
  },
  modal: {
    name: "Modal",
    selector: "[data-te-toggle='modal']",
    dismissMethod: "hide",
    isToggler: !0,
    callback: I0
  },
  ripple: {
    name: "Ripple",
    selector: "[data-te-ripple-init]",
    isToggler: !0,
    callback: D0
  },
  offcanvas: {
    name: "Offcanvas",
    selector: "[data-te-offcanvas-toggle]",
    dismissMethod: "hide",
    isToggler: !0,
    callback: O0
  },
  tab: {
    name: "Tab",
    selector: "[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']",
    isToggler: !0,
    callback: k0
  },
  tooltip: {
    name: "Tooltip",
    selector: "[data-te-toggle='tooltip']",
    isToggler: !1,
    callback: L0
  },
  popover: {
    name: "Popover",
    selector: "[data-te-toggle='popover']",
    isToggler: !0,
    callback: M0
  },
  lightbox: {
    name: "Lightbox",
    selector: "[data-te-lightbox-init]",
    isToggler: !0,
    callback: N0
  }
}, B0 = (s) => Ti[s.NAME] || null, H0 = (s) => {
  if (!s || _o.isInited(s.NAME))
    return;
  _o.add(s.NAME);
  const t = B0(s), e = (t == null ? void 0 : t.isToggler) || !1;
  if (w0(s), t != null && t.dismissMethod && y0(s, t.dismissMethod), t != null && t.advanced) {
    t == null || t.advanced(s, t == null ? void 0 : t.selector);
    return;
  }
  if (e) {
    t == null || t.callback(s, t == null ? void 0 : t.selector);
    return;
  }
  d.find(t == null ? void 0 : t.selector).forEach((i) => {
    let n = s.getInstance(i);
    n || (n = new s(i), t != null && t.onInit && n[t.onInit]());
  });
}, W0 = (s) => {
  s.forEach((t) => H0(t));
}, U0 = (s, t = !1) => {
  const e = Object.keys(Ti).map((i) => {
    if (!!document.querySelector(Ti[i].selector)) {
      const o = s[Ti[i].name];
      return !o && !_o.isInited(i) && t && console.warn(
        `Please import ${Ti[i].name} from "tw-elements" package and add it to a object parameter inside "initTE" function`
      ), o;
    }
  });
  W0(e);
};

//# sourceMappingURL=tw-elements.es.min.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "js/" + chunkId + ".bot.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "paris.simple2b:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkparis_simple2b"] = self["webpackChunkparis_simple2b"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!********************!*\
  !*** ./src/bot.ts ***!
  \********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
// bot.ts
__webpack_require__(/*! flowbite/dist/datepicker.js */ "./node_modules/flowbite/dist/datepicker.js");
var tw_elements_1 = __webpack_require__(/*! tw-elements */ "./node_modules/tw-elements/dist/js/tw-elements.es.min.js");
(0, tw_elements_1.initTE)({ Input: tw_elements_1.Input, Timepicker: tw_elements_1.Timepicker });

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBQU9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBLG9EQUFvRCw4Q0FBOEMsdUhBQXVILEVBQUU7QUFDM04sdURBQXVELGdEQUFnRCxzTEFBc0wsRUFBRTtBQUMvUjs7QUFFQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0EsdUJBQXVCLDhDQUE4Qyx3SEFBd0gsRUFBRTtBQUMvTDs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7O0FBU0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJNQUEyTSxlQUFlO0FBQzFOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7OztBQU1EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsdUJBQXVCO0FBQzVHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMk1BQTJNLGVBQWU7QUFDMU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7O0FBTUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDRCQUE0QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsV0FBVyxHQUFHLFVBQVU7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyTUFBMk0sZUFBZTtBQUMxTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBbUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FBYUQ7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsc0NBQXNDO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5RUFBeUUscUNBQXFDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0Q0FBNEM7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssMEdBQTBHLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU8sV0FBVyxRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd0NBQXdDO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdNQUF3TTtBQUMzTTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUIsS0FBSztBQUNMLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxHQUFHO0FBQ3ZELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EscURBQXFELHdCQUF3QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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QUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRyxJQUFJLHFCQUFxQjtBQUN0QztBQUNBLFVBQVUsR0FBRyxJQUFJLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUssSUFBSSxNQUFNLEVBQUUsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQThEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEM7QUFDQTtBQUNBLHVCQUF1Qiw4REFBOEQ7QUFDckY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKLHdDQUF3QyxFQUFFLHdDQUF3QztBQUN6TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILGtCQUFrQixtQ0FBbUMsaUJBQWlCO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVUsRUFBRSxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCLElBQUksSUFBSSxpQkFBaUIsZ0NBQWdDLE1BQU0sZ0NBQWdDO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVEsd05BQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlYQUEyQztBQUM1RDtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvSUFBb0k7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQSx3Q0FBd0MscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCLEVBQUUsb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCLEVBQUUsb0JBQW9CO0FBQzlEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQSxvREFBb0QsR0FBRyxrQ0FBa0MsR0FBRyxFQUFFLEdBQUcsMkNBQTJDLElBQUk7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNEhBQTRILHdDQUF3QztBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUErQkU7QUFDRjs7Ozs7OztVQzErWkE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRUFBRTtXQUNGOzs7OztXQ1JBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDSkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx1QkFBdUIsNEJBQTRCO1dBQ25EO1dBQ0E7V0FDQTtXQUNBLGlCQUFpQixvQkFBb0I7V0FDckM7V0FDQSxtR0FBbUcsWUFBWTtXQUMvRztXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsbUVBQW1FLGlDQUFpQztXQUNwRztXQUNBO1dBQ0E7V0FDQTs7Ozs7V0N4Q0E7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ2ZBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUM7O1dBRWpDO1dBQ0E7V0FDQTtXQUNBLEtBQUs7V0FDTCxlQUFlO1dBQ2Y7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNO1dBQ047V0FDQTtXQUNBOztXQUVBOztXQUVBOztXQUVBOztXQUVBOztXQUVBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLE1BQU0scUJBQXFCO1dBQzNCO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDckZBLFNBQVM7QUFDVCxxR0FBcUM7QUFDckMsdUhBSXFCO0FBRXJCLHdCQUFNLEVBQUMsRUFBRSxLQUFLLHVCQUFFLFVBQVUsNEJBQUUsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFyaXMuc2ltcGxlMmIvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvZGlzdC9kYXRlcGlja2VyLmpzIiwid2VicGFjazovL3BhcmlzLnNpbXBsZTJiLy4vbm9kZV9tb2R1bGVzL3R3LWVsZW1lbnRzL2Rpc3QvanMvdHctZWxlbWVudHMuZXMubWluLmpzIiwid2VicGFjazovL3BhcmlzLnNpbXBsZTJiL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3BhcmlzLnNpbXBsZTJiL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9wYXJpcy5zaW1wbGUyYi93ZWJwYWNrL3J1bnRpbWUvZW5zdXJlIGNodW5rIiwid2VicGFjazovL3BhcmlzLnNpbXBsZTJiL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9wYXJpcy5zaW1wbGUyYi93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3BhcmlzLnNpbXBsZTJiL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcGFyaXMuc2ltcGxlMmIvd2VicGFjay9ydW50aW1lL2xvYWQgc2NyaXB0Iiwid2VicGFjazovL3BhcmlzLnNpbXBsZTJiL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcGFyaXMuc2ltcGxlMmIvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vcGFyaXMuc2ltcGxlMmIvd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vcGFyaXMuc2ltcGxlMmIvLi9zcmMvYm90LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiRmxvd2JpdGVcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiRmxvd2JpdGVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiRmxvd2JpdGVcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNDgyOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiWlwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gRGF0ZVJhbmdlUGlja2VyOyB9XG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGliX2V2ZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5OCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xpYl9kYXRlX2Zvcm1hdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9EYXRlcGlja2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3MCk7XG5cblxuXG5cbi8vIGZpbHRlciBvdXQgdGhlIGNvbmZpZyBvcHRpb25zIGluYXBwcm9wcml0ZSB0byBwYXNzIHRvIERhdGVwaWNrZXJcbmZ1bmN0aW9uIGZpbHRlck9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBuZXdPcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgZGVsZXRlIG5ld09wdHMuaW5wdXRzO1xuICBkZWxldGUgbmV3T3B0cy5hbGxvd09uZVNpZGVkUmFuZ2U7XG4gIGRlbGV0ZSBuZXdPcHRzLm1heE51bWJlck9mRGF0ZXM7IC8vIHRvIGVuc3VyZSBlYWNoIGRhdGVwaWNrZXIgaGFuZGxlcyBhIHNpbmdsZSBkYXRlXG5cbiAgcmV0dXJuIG5ld09wdHM7XG59XG5cbmZ1bmN0aW9uIHNldHVwRGF0ZXBpY2tlcihyYW5nZXBpY2tlciwgY2hhbmdlRGF0ZUxpc3RlbmVyLCBlbCwgb3B0aW9ucykge1xuICAoMCxfbGliX2V2ZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAucmVnaXN0ZXJMaXN0ZW5lcnMgKi8gLmNGKShyYW5nZXBpY2tlciwgW1xuICAgIFtlbCwgJ2NoYW5nZURhdGUnLCBjaGFuZ2VEYXRlTGlzdGVuZXJdLFxuICBdKTtcbiAgbmV3IF9EYXRlcGlja2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18vKiBbXCJkZWZhdWx0XCJdICovIC5aKGVsLCBvcHRpb25zLCByYW5nZXBpY2tlcik7XG59XG5cbmZ1bmN0aW9uIG9uQ2hhbmdlRGF0ZShyYW5nZXBpY2tlciwgZXYpIHtcbiAgLy8gdG8gcHJldmVudCBib3RoIGRhdGVwaWNrZXJzIHRyaWdnZXIgdGhlIG90aGVyIHNpZGUncyB1cGRhdGUgZWFjaCBvdGhlclxuICBpZiAocmFuZ2VwaWNrZXIuX3VwZGF0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJhbmdlcGlja2VyLl91cGRhdGluZyA9IHRydWU7XG5cbiAgY29uc3QgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuICBpZiAodGFyZ2V0LmRhdGVwaWNrZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGRhdGVwaWNrZXJzID0gcmFuZ2VwaWNrZXIuZGF0ZXBpY2tlcnM7XG4gIGNvbnN0IHNldERhdGVPcHRpb25zID0ge3JlbmRlcjogZmFsc2V9O1xuICBjb25zdCBjaGFuZ2VkU2lkZSA9IHJhbmdlcGlja2VyLmlucHV0cy5pbmRleE9mKHRhcmdldCk7XG4gIGNvbnN0IG90aGVyU2lkZSA9IGNoYW5nZWRTaWRlID09PSAwID8gMSA6IDA7XG4gIGNvbnN0IGNoYW5nZWREYXRlID0gZGF0ZXBpY2tlcnNbY2hhbmdlZFNpZGVdLmRhdGVzWzBdO1xuICBjb25zdCBvdGhlckRhdGUgPSBkYXRlcGlja2Vyc1tvdGhlclNpZGVdLmRhdGVzWzBdO1xuXG4gIGlmIChjaGFuZ2VkRGF0ZSAhPT0gdW5kZWZpbmVkICYmIG90aGVyRGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gaWYgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSA+IHRoZSBlbmQsIHN3YXAgdGhlbVxuICAgIGlmIChjaGFuZ2VkU2lkZSA9PT0gMCAmJiBjaGFuZ2VkRGF0ZSA+IG90aGVyRGF0ZSkge1xuICAgICAgZGF0ZXBpY2tlcnNbMF0uc2V0RGF0ZShvdGhlckRhdGUsIHNldERhdGVPcHRpb25zKTtcbiAgICAgIGRhdGVwaWNrZXJzWzFdLnNldERhdGUoY2hhbmdlZERhdGUsIHNldERhdGVPcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZWRTaWRlID09PSAxICYmIGNoYW5nZWREYXRlIDwgb3RoZXJEYXRlKSB7XG4gICAgICBkYXRlcGlja2Vyc1swXS5zZXREYXRlKGNoYW5nZWREYXRlLCBzZXREYXRlT3B0aW9ucyk7XG4gICAgICBkYXRlcGlja2Vyc1sxXS5zZXREYXRlKG90aGVyRGF0ZSwgc2V0RGF0ZU9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghcmFuZ2VwaWNrZXIuYWxsb3dPbmVTaWRlZFJhbmdlKSB7XG4gICAgLy8gdG8gcHJldmVudCB0aGUgcmFuZ2UgZnJvbSBiZWNvbWluZyBvbmUtc2lkZWQsIGNvcHkgY2hhbmdlZCBzaWRlJ3NcbiAgICAvLyBzZWxlY3Rpb24gKG5vIG1hdHRlciBpZiBpdCdzIGVtcHR5KSB0byB0aGUgb3RoZXIgc2lkZVxuICAgIGlmIChjaGFuZ2VkRGF0ZSAhPT0gdW5kZWZpbmVkIHx8IG90aGVyRGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXREYXRlT3B0aW9ucy5jbGVhciA9IHRydWU7XG4gICAgICBkYXRlcGlja2Vyc1tvdGhlclNpZGVdLnNldERhdGUoZGF0ZXBpY2tlcnNbY2hhbmdlZFNpZGVdLmRhdGVzLCBzZXREYXRlT3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGRhdGVwaWNrZXJzWzBdLnBpY2tlci51cGRhdGUoKS5yZW5kZXIoKTtcbiAgZGF0ZXBpY2tlcnNbMV0ucGlja2VyLnVwZGF0ZSgpLnJlbmRlcigpO1xuICBkZWxldGUgcmFuZ2VwaWNrZXIuX3VwZGF0aW5nO1xufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGRhdGUgcmFuZ2UgcGlja2VyXG4gKi9cbmNsYXNzIERhdGVSYW5nZVBpY2tlciAge1xuICAvKipcbiAgICogQ3JlYXRlIGEgZGF0ZSByYW5nZSBwaWNrZXJcbiAgICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBhIGRhdGUgcmFuZ2UgcGlja2VyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIC0gY29uZmlnIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGlucHV0cyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5pbnB1dHMpXG4gICAgICA/IG9wdGlvbnMuaW5wdXRzXG4gICAgICA6IEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpKTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50LnJhbmdlcGlja2VyID0gdGhpcztcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzLnNsaWNlKDAsIDIpO1xuICAgIHRoaXMuYWxsb3dPbmVTaWRlZFJhbmdlID0gISFvcHRpb25zLmFsbG93T25lU2lkZWRSYW5nZTtcblxuICAgIGNvbnN0IGNoYW5nZURhdGVMaXN0ZW5lciA9IG9uQ2hhbmdlRGF0ZS5iaW5kKG51bGwsIHRoaXMpO1xuICAgIGNvbnN0IGNsZWFuT3B0aW9ucyA9IGZpbHRlck9wdGlvbnMob3B0aW9ucyk7XG4gICAgLy8gaW4gb3JkZXIgZm9yIGluaXRpYWwgZGF0ZSBzZXR1cCB0byB3b3JrIHJpZ2h0IHdoZW4gcGNpY0x2ZWwgPiAwLFxuICAgIC8vIGxldCBEYXRlcGlja2VyIGNvbnN0cnVjdG9yIGFkZCB0aGUgaW5zdGFuY2UgdG8gdGhlIHJhbmdlcGlja2VyXG4gICAgY29uc3QgZGF0ZXBpY2tlcnMgPSBbXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RhdGVwaWNrZXJzJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gZGF0ZXBpY2tlcnM7XG4gICAgICB9LFxuICAgIH0pO1xuICAgIHNldHVwRGF0ZXBpY2tlcih0aGlzLCBjaGFuZ2VEYXRlTGlzdGVuZXIsIHRoaXMuaW5wdXRzWzBdLCBjbGVhbk9wdGlvbnMpO1xuICAgIHNldHVwRGF0ZXBpY2tlcih0aGlzLCBjaGFuZ2VEYXRlTGlzdGVuZXIsIHRoaXMuaW5wdXRzWzFdLCBjbGVhbk9wdGlvbnMpO1xuICAgIE9iamVjdC5mcmVlemUoZGF0ZXBpY2tlcnMpO1xuICAgIC8vIG5vcm1hbGl6ZSB0aGUgcmFuZ2UgaWYgaW5pdGFsIGRhdGVzIGFyZSBnaXZlblxuICAgIGlmIChkYXRlcGlja2Vyc1swXS5kYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBvbkNoYW5nZURhdGUodGhpcywge3RhcmdldDogdGhpcy5pbnB1dHNbMF19KTtcbiAgICB9IGVsc2UgaWYgKGRhdGVwaWNrZXJzWzFdLmRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG9uQ2hhbmdlRGF0ZSh0aGlzLCB7dGFyZ2V0OiB0aGlzLmlucHV0c1sxXX0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXl9IC0gc2VsZWN0ZWQgZGF0ZSBvZiB0aGUgbGlua2VkIGRhdGUgcGlja2Vyc1xuICAgKi9cbiAgZ2V0IGRhdGVzKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVwaWNrZXJzLmxlbmd0aCA9PT0gMlxuICAgICAgPyBbXG4gICAgICAgICAgdGhpcy5kYXRlcGlja2Vyc1swXS5kYXRlc1swXSxcbiAgICAgICAgICB0aGlzLmRhdGVwaWNrZXJzWzFdLmRhdGVzWzBdLFxuICAgICAgICBdXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IHZhbHVlcyB0byB0aGUgY29uZmlnIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWcgb3B0aW9ucyB0byB1cGRhdGVcbiAgICovXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuYWxsb3dPbmVTaWRlZFJhbmdlID0gISFvcHRpb25zLmFsbG93T25lU2lkZWRSYW5nZTtcblxuICAgIGNvbnN0IGNsZWFuT3B0aW9ucyA9IGZpbHRlck9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5kYXRlcGlja2Vyc1swXS5zZXRPcHRpb25zKGNsZWFuT3B0aW9ucyk7XG4gICAgdGhpcy5kYXRlcGlja2Vyc1sxXS5zZXRPcHRpb25zKGNsZWFuT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgRGF0ZVJhbmdlUGlja2VyIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVSYW5nZVBpY2tlcn0gLSB0aGUgaW5zdGFuY2UgZGVzdHJveWVkXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGF0ZXBpY2tlcnNbMF0uZGVzdHJveSgpO1xuICAgIHRoaXMuZGF0ZXBpY2tlcnNbMV0uZGVzdHJveSgpO1xuICAgICgwLF9saWJfZXZlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC51bnJlZ2lzdGVyTGlzdGVuZXJzICovIC51VikodGhpcyk7XG4gICAgZGVsZXRlIHRoaXMuZWxlbWVudC5yYW5nZXBpY2tlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgb2YgdGhlIGRhdGUgcmFuZ2VcbiAgICpcbiAgICogVGhlIG1ldGhvZCByZXR1cm5zIERhdGUgb2JqZWN0cyBieSBkZWZhdWx0LiBJZiBmb3JtYXQgc3RyaW5nIGlzIHBhc3NlZCxcbiAgICogaXQgcmV0dXJucyBkYXRlIHN0cmluZ3MgZm9ybWF0dGVkIGluIGdpdmVuIGZvcm1hdC5cbiAgICogVGhlIHJlc3VsdCBhcnJheSBhbHdheXMgY29udGFpbnMgMiBpdGVtcyAoc3RhcnQgZGF0ZS9lbmQgZGF0ZSkgYW5kXG4gICAqIHVuZGVmaW5lZCBpcyB1c2VkIGZvciB1bnNlbGVjdGVkIHNpZGUuIChlLmcuIElmIG5vbmUgaXMgc2VsZWN0ZWQsXG4gICAqIHRoZSByZXN1bHQgd2lsbCBiZSBbdW5kZWZpbmVkLCB1bmRlZmluZWRdLiBJZiBvbmx5IHRoZSBlbmQgZGF0ZSBpcyBzZXRcbiAgICogd2hlbiBhbGxvd09uZVNpZGVkUmFuZ2UgY29uZmlnIG9wdGlvbiBpcyB0cnVlLCBbdW5kZWZpbmVkLCBlbmREYXRlXSB3aWxsXG4gICAqIGJlIHJldHVybmVkLilcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbZm9ybWF0XSAtIEZvcm1hdCBzdHJpbmcgdG8gc3RyaW5naWZ5IHRoZSBkYXRlc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBTdGFydCBhbmQgZW5kIGRhdGVzXG4gICAqL1xuICBnZXREYXRlcyhmb3JtYXQgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IGZvcm1hdFxuICAgICAgPyBkYXRlID0+ICgwLF9saWJfZGF0ZV9mb3JtYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5mb3JtYXREYXRlICovIC5wNikoZGF0ZSwgZm9ybWF0LCB0aGlzLmRhdGVwaWNrZXJzWzBdLmNvbmZpZy5sb2NhbGUpXG4gICAgICA6IGRhdGUgPT4gbmV3IERhdGUoZGF0ZSk7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRlcy5tYXAoZGF0ZSA9PiBkYXRlID09PSB1bmRlZmluZWQgPyBkYXRlIDogY2FsbGJhY2soZGF0ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBvZiB0aGUgZGF0ZSByYW5nZVxuICAgKlxuICAgKiBUaGUgbWV0aG9kIGNhbGxzIGRhdGVwaWNrZXIuc2V0RGF0ZSgpIGludGVybmFsbHkgdXNpbmcgZWFjaCBvZiB0aGVcbiAgICogYXJndW1lbnRzIGluIHN0YXJ04oaSZW5kIG9yZGVyLlxuICAgKlxuICAgKiBXaGVuIGEgY2xlYXI6IHRydWUgb3B0aW9uIG9iamVjdCBpcyBwYXNzZWQgaW5zdGVhZCBvZiBhIGRhdGUsIHRoZSBtZXRob2RcbiAgICogY2xlYXJzIHRoZSBkYXRlLlxuICAgKlxuICAgKiBJZiBhbiBpbnZhbGlkIGRhdGUsIHRoZSBzYW1lIGRhdGUgYXMgdGhlIGN1cnJlbnQgb25lIG9yIGFuIG9wdGlvbiBvYmplY3RcbiAgICogd2l0aG91dCBjbGVhcjogdHJ1ZSBpcyBwYXNzZWQsIHRoZSBtZXRob2QgY29uc2lkZXJzIHRoYXQgYXJndW1lbnQgYXMgYW5cbiAgICogXCJpbmVmZmVjdGl2ZVwiIGFyZ3VtZW50IGJlY2F1c2UgY2FsbGluZyBkYXRlcGlja2VyLnNldERhdGUoKSB3aXRoIHRob3NlXG4gICAqIHZhbHVlcyBtYWtlcyBubyBjaGFuZ2VzIHRvIHRoZSBkYXRlIHNlbGVjdGlvbi5cbiAgICpcbiAgICogV2hlbiB0aGUgYWxsb3dPbmVTaWRlZFJhbmdlIGNvbmZpZyBvcHRpb24gaXMgZmFsc2UsIHBhc3Npbmcge2NsZWFyOiB0cnVlfVxuICAgKiB0byBjbGVhciB0aGUgcmFuZ2Ugd29ya3Mgb25seSB3aGVuIGl0IGlzIGRvbmUgdG8gdGhlIGxhc3QgZWZmZWN0aXZlXG4gICAqIGFyZ3VtZW50IChpbiBvdGhlciB3b3JkcywgcGFzc2VkIHRvIHJhbmdlRW5kIG9yIHRvIHJhbmdlU3RhcnQgYWxvbmcgd2l0aFxuICAgKiBpbmVmZmVjdGl2ZSByYW5nZUVuZCkuIFRoaXMgaXMgYmVjYXVzZSB3aGVuIHRoZSBkYXRlIHJhbmdlIGlzIGNoYW5nZWQsXG4gICAqIGl0IGdldHMgbm9ybWFsaXplZCBiYXNlZCBvbiB0aGUgbGFzdCBjaGFuZ2UgYXQgdGhlIGVuZCBvZiB0aGUgY2hhbmdpbmdcbiAgICogcHJvY2Vzcy5cbiAgICpcbiAgICogQHBhcmFtIHtEYXRlfE51bWJlcnxTdHJpbmd8T2JqZWN0fSByYW5nZVN0YXJ0IC0gU3RhcnQgZGF0ZSBvZiB0aGUgcmFuZ2VcbiAgICogb3Ige2NsZWFyOiB0cnVlfSB0byBjbGVhciB0aGUgZGF0ZVxuICAgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfFN0cmluZ3xPYmplY3R9IHJhbmdlRW5kIC0gRW5kIGRhdGUgb2YgdGhlIHJhbmdlXG4gICAqIG9yIHtjbGVhcjogdHJ1ZX0gdG8gY2xlYXIgdGhlIGRhdGVcbiAgICovXG4gIHNldERhdGVzKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSB7XG4gICAgY29uc3QgW2RhdGVwaWNrZXIwLCBkYXRlcGlja2VyMV0gPSB0aGlzLmRhdGVwaWNrZXJzO1xuICAgIGNvbnN0IG9yaWdEYXRlcyA9IHRoaXMuZGF0ZXM7XG5cbiAgICAvLyBJZiByYW5nZSBub3JtYWxpemF0aW9uIHJ1bnMgb24gZXZlcnkgY2hhbmdlLCB3ZSBjYW4ndCBzZXQgYSBuZXcgcmFuZ2VcbiAgICAvLyB0aGF0IHN0YXJ0cyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHJhbmdlIGNvcnJlY3RseSBiZWNhdXNlIHRoZVxuICAgIC8vIG5vcm1hbGl6YXRpb24gcHJvY2VzcyBzd2FwcyBzdGFydOKGlO+4jmVuZCByaWdodCBhZnRlciBzZXR0aW5nIHRoZSBuZXcgc3RhcnRcbiAgICAvLyBkYXRlLiBUbyBwcmV2ZW50IHRoaXMsIHRoZSBub3JtYWxpemF0aW9uIHByb2Nlc3MgbmVlZHMgdG8gcnVuIG9uY2UgYWZ0ZXJcbiAgICAvLyBib3RoIG9mIHRoZSBuZXcgZGF0ZXMgYXJlIHNldC5cbiAgICB0aGlzLl91cGRhdGluZyA9IHRydWU7XG4gICAgZGF0ZXBpY2tlcjAuc2V0RGF0ZShyYW5nZVN0YXJ0KTtcbiAgICBkYXRlcGlja2VyMS5zZXREYXRlKHJhbmdlRW5kKTtcbiAgICBkZWxldGUgdGhpcy5fdXBkYXRpbmc7XG5cbiAgICBpZiAoZGF0ZXBpY2tlcjEuZGF0ZXNbMF0gIT09IG9yaWdEYXRlc1sxXSkge1xuICAgICAgb25DaGFuZ2VEYXRlKHRoaXMsIHt0YXJnZXQ6IHRoaXMuaW5wdXRzWzFdfSk7XG4gICAgfSBlbHNlIGlmIChkYXRlcGlja2VyMC5kYXRlc1swXSAhPT0gb3JpZ0RhdGVzWzBdKSB7XG4gICAgICBvbkNoYW5nZURhdGUodGhpcywge3RhcmdldDogdGhpcy5pbnB1dHNbMF19KTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzcwOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgXCJaXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBEYXRlcGlja2VyOyB9XG59KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL2xpYi91dGlscy5qc1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL2xpYi9kYXRlLmpzXG52YXIgbGliX2RhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvbGliL2RhdGUtZm9ybWF0LmpzXG52YXIgZGF0ZV9mb3JtYXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2Myk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvbGliL2V2ZW50LmpzXG52YXIgbGliX2V2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTgpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvaTE4bi9iYXNlLWxvY2FsZXMuanNcbi8vIGRlZmF1bHQgbG9jYWxlc1xuY29uc3QgbG9jYWxlcyA9IHtcbiAgZW46IHtcbiAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgICBkYXlzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICBkYXlzTWluOiBbXCJTdVwiLCBcIk1vXCIsIFwiVHVcIiwgXCJXZVwiLCBcIlRoXCIsIFwiRnJcIiwgXCJTYVwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICAgIG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG4gICAgdG9kYXk6IFwiVG9kYXlcIixcbiAgICBjbGVhcjogXCJDbGVhclwiLFxuICAgIHRpdGxlRm9ybWF0OiBcIk1NIHlcIlxuICB9XG59O1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9vcHRpb25zL2RlZmF1bHRPcHRpb25zLmpzXG4vLyBjb25maWcgb3B0aW9ucyB1cGRhdGFibGUgYnkgc2V0T3B0aW9ucygpIGFuZCB0aGVpciBkZWZhdWx0IHZhbHVlc1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGF1dG9oaWRlOiBmYWxzZSxcbiAgYmVmb3JlU2hvd0RheTogbnVsbCxcbiAgYmVmb3JlU2hvd0RlY2FkZTogbnVsbCxcbiAgYmVmb3JlU2hvd01vbnRoOiBudWxsLFxuICBiZWZvcmVTaG93WWVhcjogbnVsbCxcbiAgY2FsZW5kYXJXZWVrczogZmFsc2UsXG4gIGNsZWFyQnRuOiBmYWxzZSxcbiAgZGF0ZURlbGltaXRlcjogJywnLFxuICBkYXRlc0Rpc2FibGVkOiBbXSxcbiAgZGF5c09mV2Vla0Rpc2FibGVkOiBbXSxcbiAgZGF5c09mV2Vla0hpZ2hsaWdodGVkOiBbXSxcbiAgZGVmYXVsdFZpZXdEYXRlOiB1bmRlZmluZWQsIC8vIHBsYWNlaG9sZGVyLCBkZWZhdWx0cyB0byB0b2RheSgpIGJ5IHRoZSBwcm9ncmFtXG4gIGRpc2FibGVUb3VjaEtleWJvYXJkOiBmYWxzZSxcbiAgZm9ybWF0OiAnbW0vZGQveXl5eScsXG4gIGxhbmd1YWdlOiAnZW4nLFxuICBtYXhEYXRlOiBudWxsLFxuICBtYXhOdW1iZXJPZkRhdGVzOiAxLFxuICBtYXhWaWV3OiAzLFxuICBtaW5EYXRlOiBudWxsLFxuICBuZXh0QXJyb3c6ICc8c3ZnIGNsYXNzPVwidy00IGgtNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTEyLjI5MyA1LjI5M2ExIDEgMCAwMTEuNDE0IDBsNCA0YTEgMSAwIDAxMCAxLjQxNGwtNCA0YTEgMSAwIDAxLTEuNDE0LTEuNDE0TDE0LjU4NiAxMUgzYTEgMSAwIDExMC0yaDExLjU4NmwtMi4yOTMtMi4yOTNhMSAxIDAgMDEwLTEuNDE0elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIj48L3BhdGg+PC9zdmc+JyxcbiAgb3JpZW50YXRpb246ICdhdXRvJyxcbiAgcGlja0xldmVsOiAwLFxuICBwcmV2QXJyb3c6ICc8c3ZnIGNsYXNzPVwidy00IGgtNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTkuNzA3IDE2LjcwN2ExIDEgMCAwMS0xLjQxNCAwbC02LTZhMSAxIDAgMDEwLTEuNDE0bDYtNmExIDEgMCAwMTEuNDE0IDEuNDE0TDUuNDE0IDlIMTdhMSAxIDAgMTEwIDJINS40MTRsNC4yOTMgNC4yOTNhMSAxIDAgMDEwIDEuNDE0elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIj48L3BhdGg+PC9zdmc+JyxcbiAgc2hvd0RheXNPZldlZWs6IHRydWUsXG4gIHNob3dPbkNsaWNrOiB0cnVlLFxuICBzaG93T25Gb2N1czogdHJ1ZSxcbiAgc3RhcnRWaWV3OiAwLFxuICB0aXRsZTogJycsXG4gIHRvZGF5QnRuOiBmYWxzZSxcbiAgdG9kYXlCdG5Nb2RlOiAwLFxuICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gIHVwZGF0ZU9uQmx1cjogdHJ1ZSxcbiAgd2Vla1N0YXJ0OiAwLFxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgb3B0aW9uc19kZWZhdWx0T3B0aW9ucyA9IChkZWZhdWx0T3B0aW9ucyk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL2xpYi9kb20uanNcbmNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuZnVuY3Rpb24gcGFyc2VIVE1MKGh0bWwpIHtcbiAgcmV0dXJuIHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChodG1sKTtcbn1cblxuLy8gZXF1aXZhbGVudCB0byBqUXVlcnkncyA6dmlzYmxlXG5mdW5jdGlvbiBpc1Zpc2libGUoZWwpIHtcbiAgcmV0dXJuICEhKGVsLm9mZnNldFdpZHRoIHx8IGVsLm9mZnNldEhlaWdodCB8fCBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGhpZGVFbGVtZW50KGVsKSB7XG4gIGlmIChlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gYmFjayB1cCB0aGUgZXhpc3RpbmcgZGlzcGxheSBzZXR0aW5nIGluIGRhdGEtc3R5bGUtZGlzcGxheVxuICBpZiAoZWwuc3R5bGUuZGlzcGxheSkge1xuICAgIGVsLmRhdGFzZXQuc3R5bGVEaXNwbGF5ID0gZWwuc3R5bGUuZGlzcGxheTtcbiAgfVxuICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xufVxuXG5mdW5jdGlvbiBzaG93RWxlbWVudChlbCkge1xuICBpZiAoZWwuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbC5kYXRhc2V0LnN0eWxlRGlzcGxheSkge1xuICAgIC8vIHJlc3RvcmUgYmFja2VkLXVwIGRpc3BheSBwcm9wZXJ0eVxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5kYXRhc2V0LnN0eWxlRGlzcGxheTtcbiAgICBkZWxldGUgZWwuZGF0YXNldC5zdHlsZURpc3BsYXk7XG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtcHR5Q2hpbGROb2RlcyhlbCkge1xuICBpZiAoZWwuZmlyc3RDaGlsZCkge1xuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICAgIGVtcHR5Q2hpbGROb2RlcyhlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkTm9kZXMoZWwsIG5ld0NoaWxkTm9kZXMpIHtcbiAgZW1wdHlDaGlsZE5vZGVzKGVsKTtcbiAgaWYgKG5ld0NoaWxkTm9kZXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgZWwuYXBwZW5kQ2hpbGQobmV3Q2hpbGROb2Rlcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkTm9kZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgZWwuYXBwZW5kQ2hpbGQocGFyc2VIVE1MKG5ld0NoaWxkTm9kZXMpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmV3Q2hpbGROb2Rlcy5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbmV3Q2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9KTtcbiAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9vcHRpb25zL3Byb2Nlc3NPcHRpb25zLmpzXG5cblxuXG5cblxuXG5jb25zdCB7XG4gIGxhbmd1YWdlOiBkZWZhdWx0TGFuZyxcbiAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0LFxuICB3ZWVrU3RhcnQ6IGRlZmF1bHRXZWVrU3RhcnQsXG59ID0gb3B0aW9uc19kZWZhdWx0T3B0aW9ucztcblxuLy8gUmVkdWNlciBmdW5jdGlvbiB0byBmaWx0ZXIgb3V0IGludmFsaWQgZGF5LW9mLXdlZWsgZnJvbSB0aGUgaW5wdXRcbmZ1bmN0aW9uIHNhbml0aXplRE9XKGRvdywgZGF5KSB7XG4gIHJldHVybiBkb3cubGVuZ3RoIDwgNiAmJiBkYXkgPj0gMCAmJiBkYXkgPCA3XG4gICAgPyAoMCx1dGlscy8qIHB1c2hVbmlxdWUgKi8uJEMpKGRvdywgZGF5KVxuICAgIDogZG93O1xufVxuXG5mdW5jdGlvbiBjYWxjRW5kT2ZXZWVrKHN0YXJ0T2ZXZWVrKSB7XG4gIHJldHVybiAoc3RhcnRPZldlZWsgKyA2KSAlIDc7XG59XG5cbi8vIHZhbGlkYXRlIGlucHV0IGRhdGUuIGlmIGludmFsaWQsIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZVxuZnVuY3Rpb24gdmFsaWRhdGVEYXRlKHZhbHVlLCBmb3JtYXQsIGxvY2FsZSwgb3JpZ1ZhbHVlKSB7XG4gIGNvbnN0IGRhdGUgPSAoMCxkYXRlX2Zvcm1hdC8qIHBhcnNlRGF0ZSAqLy5zRykodmFsdWUsIGZvcm1hdCwgbG9jYWxlKTtcbiAgcmV0dXJuIGRhdGUgIT09IHVuZGVmaW5lZCA/IGRhdGUgOiBvcmlnVmFsdWU7XG59XG5cbi8vIFZhbGlkYXRlIHZpZXdJZC4gaWYgaW52YWxpZCwgZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlXG5mdW5jdGlvbiB2YWxpZGF0ZVZpZXdJZCh2YWx1ZSwgb3JpZ1ZhbHVlLCBtYXggPSAzKSB7XG4gIGNvbnN0IHZpZXdJZCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIHJldHVybiB2aWV3SWQgPj0gMCAmJiB2aWV3SWQgPD0gbWF4ID8gdmlld0lkIDogb3JpZ1ZhbHVlO1xufVxuXG4vLyBDcmVhdGUgRGF0ZXBpY2tlciBjb25maWd1cmF0aW9uIHRvIHNldFxuZnVuY3Rpb24gcHJvY2Vzc09wdGlvbnMob3B0aW9ucywgZGF0ZXBpY2tlcikge1xuICBjb25zdCBpbk9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgY29uc3QgY29uZmlnID0ge307XG4gIGNvbnN0IGxvY2FsZXMgPSBkYXRlcGlja2VyLmNvbnN0cnVjdG9yLmxvY2FsZXM7XG4gIGxldCB7XG4gICAgZm9ybWF0LFxuICAgIGxhbmd1YWdlLFxuICAgIGxvY2FsZSxcbiAgICBtYXhEYXRlLFxuICAgIG1heFZpZXcsXG4gICAgbWluRGF0ZSxcbiAgICBwaWNrTGV2ZWwsXG4gICAgc3RhcnRWaWV3LFxuICAgIHdlZWtTdGFydCxcbiAgfSA9IGRhdGVwaWNrZXIuY29uZmlnIHx8IHt9O1xuXG4gIGlmIChpbk9wdHMubGFuZ3VhZ2UpIHtcbiAgICBsZXQgbGFuZztcbiAgICBpZiAoaW5PcHRzLmxhbmd1YWdlICE9PSBsYW5ndWFnZSkge1xuICAgICAgaWYgKGxvY2FsZXNbaW5PcHRzLmxhbmd1YWdlXSkge1xuICAgICAgICBsYW5nID0gaW5PcHRzLmxhbmd1YWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbGFuZ2F1Z2UgKyByZWdpb24gdGFnIGNhbiBmYWxsYmFjayB0byB0aGUgb25lIHdpdGhvdXRcbiAgICAgICAgLy8gcmVnaW9uIChlLmcuIGZyLUNBIOKGkiBmcilcbiAgICAgICAgbGFuZyA9IGluT3B0cy5sYW5ndWFnZS5zcGxpdCgnLScpWzBdO1xuICAgICAgICBpZiAobG9jYWxlc1tsYW5nXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGFuZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMubGFuZ3VhZ2U7XG4gICAgaWYgKGxhbmcpIHtcbiAgICAgIGxhbmd1YWdlID0gY29uZmlnLmxhbmd1YWdlID0gbGFuZztcblxuICAgICAgLy8gdXBkYXRlIGxvY2FsZSBhcyB3ZWxsIHdoZW4gdXBkYXRpbmcgbGFuZ3VhZ2VcbiAgICAgIGNvbnN0IG9yaWdMb2NhbGUgPSBsb2NhbGUgfHwgbG9jYWxlc1tkZWZhdWx0TGFuZ107XG4gICAgICAvLyB1c2UgZGVmYXVsdCBsYW5ndWFnZSdzIHByb3BlcnRpZXMgZm9yIHRoZSBmYWxsYmFja1xuICAgICAgbG9jYWxlID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcbiAgICAgICAgd2Vla1N0YXJ0OiBkZWZhdWx0V2Vla1N0YXJ0XG4gICAgICB9LCBsb2NhbGVzW2RlZmF1bHRMYW5nXSk7XG4gICAgICBpZiAobGFuZ3VhZ2UgIT09IGRlZmF1bHRMYW5nKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obG9jYWxlLCBsb2NhbGVzW2xhbmd1YWdlXSk7XG4gICAgICB9XG4gICAgICBjb25maWcubG9jYWxlID0gbG9jYWxlO1xuICAgICAgLy8gaWYgZm9ybWF0IGFuZC9vciB3ZWVrU3RhcnQgYXJlIHRoZSBzYW1lIGFzIG9sZCBsb2NhbGUncyBkZWZhdWx0cyxcbiAgICAgIC8vIHVwZGF0ZSB0aGVtIHRvIG5ldyBsb2NhbGUncyBkZWZhdWx0c1xuICAgICAgaWYgKGZvcm1hdCA9PT0gb3JpZ0xvY2FsZS5mb3JtYXQpIHtcbiAgICAgICAgZm9ybWF0ID0gY29uZmlnLmZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gICAgICB9XG4gICAgICBpZiAod2Vla1N0YXJ0ID09PSBvcmlnTG9jYWxlLndlZWtTdGFydCkge1xuICAgICAgICB3ZWVrU3RhcnQgPSBjb25maWcud2Vla1N0YXJ0ID0gbG9jYWxlLndlZWtTdGFydDtcbiAgICAgICAgY29uZmlnLndlZWtFbmQgPSBjYWxjRW5kT2ZXZWVrKGxvY2FsZS53ZWVrU3RhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbk9wdHMuZm9ybWF0KSB7XG4gICAgY29uc3QgaGFzVG9EaXNwbGF5ID0gdHlwZW9mIGluT3B0cy5mb3JtYXQudG9EaXNwbGF5ID09PSAnZnVuY3Rpb24nO1xuICAgIGNvbnN0IGhhc1RvVmFsdWUgPSB0eXBlb2YgaW5PcHRzLmZvcm1hdC50b1ZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgIGNvbnN0IHZhbGlkRm9ybWF0U3RyaW5nID0gZGF0ZV9mb3JtYXQvKiByZUZvcm1hdFRva2Vucy50ZXN0ICovLkNMLnRlc3QoaW5PcHRzLmZvcm1hdCk7XG4gICAgaWYgKChoYXNUb0Rpc3BsYXkgJiYgaGFzVG9WYWx1ZSkgfHwgdmFsaWRGb3JtYXRTdHJpbmcpIHtcbiAgICAgIGZvcm1hdCA9IGNvbmZpZy5mb3JtYXQgPSBpbk9wdHMuZm9ybWF0O1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLmZvcm1hdDtcbiAgfVxuXG4gIC8vKioqIGRhdGVzICoqKi8vXG4gIC8vIHdoaWxlIG1pbiBhbmQgbWF4RGF0ZSBmb3IgXCJubyBsaW1pdFwiIGluIHRoZSBvcHRpb25zIGFyZSBiZXR0ZXIgdG8gYmUgbnVsbFxuICAvLyAoZXNwZWNpYWxseSB3aGVuIHVwZGF0aW5nKSwgdGhlIG9uZXMgaW4gdGhlIGNvbmZpZyBoYXZlIHRvIGJlIHVuZGVmaW5lZFxuICAvLyBiZWNhdXNlIG51bGwgaXMgdHJlYXRlZCBhcyAwICg9IHVuaXggZXBvY2gpIHdoZW4gY29tcGFyaW5nIHdpdGggdGltZSB2YWx1ZVxuICBsZXQgbWluRHQgPSBtaW5EYXRlO1xuICBsZXQgbWF4RHQgPSBtYXhEYXRlO1xuICBpZiAoaW5PcHRzLm1pbkRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1pbkR0ID0gaW5PcHRzLm1pbkRhdGUgPT09IG51bGxcbiAgICAgID8gKDAsbGliX2RhdGUvKiBkYXRlVmFsdWUgKi8uYnkpKDAsIDAsIDEpICAvLyBzZXQgMDAwMC0wMS0wMSB0byBwcmV2ZW50IG5lZ2F0aXZlIHZhbHVlcyBmb3IgeWVhclxuICAgICAgOiB2YWxpZGF0ZURhdGUoaW5PcHRzLm1pbkRhdGUsIGZvcm1hdCwgbG9jYWxlLCBtaW5EdCk7XG4gICAgZGVsZXRlIGluT3B0cy5taW5EYXRlO1xuICB9XG4gIGlmIChpbk9wdHMubWF4RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbWF4RHQgPSBpbk9wdHMubWF4RGF0ZSA9PT0gbnVsbFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogdmFsaWRhdGVEYXRlKGluT3B0cy5tYXhEYXRlLCBmb3JtYXQsIGxvY2FsZSwgbWF4RHQpO1xuICAgIGRlbGV0ZSBpbk9wdHMubWF4RGF0ZTtcbiAgfVxuICBpZiAobWF4RHQgPCBtaW5EdCkge1xuICAgIG1pbkRhdGUgPSBjb25maWcubWluRGF0ZSA9IG1heER0O1xuICAgIG1heERhdGUgPSBjb25maWcubWF4RGF0ZSA9IG1pbkR0O1xuICB9IGVsc2Uge1xuICAgIGlmIChtaW5EYXRlICE9PSBtaW5EdCkge1xuICAgICAgbWluRGF0ZSA9IGNvbmZpZy5taW5EYXRlID0gbWluRHQ7XG4gICAgfVxuICAgIGlmIChtYXhEYXRlICE9PSBtYXhEdCkge1xuICAgICAgbWF4RGF0ZSA9IGNvbmZpZy5tYXhEYXRlID0gbWF4RHQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKGluT3B0cy5kYXRlc0Rpc2FibGVkKSB7XG4gICAgY29uZmlnLmRhdGVzRGlzYWJsZWQgPSBpbk9wdHMuZGF0ZXNEaXNhYmxlZC5yZWR1Y2UoKGRhdGVzLCBkdCkgPT4ge1xuICAgICAgY29uc3QgZGF0ZSA9ICgwLGRhdGVfZm9ybWF0LyogcGFyc2VEYXRlICovLnNHKShkdCwgZm9ybWF0LCBsb2NhbGUpO1xuICAgICAgcmV0dXJuIGRhdGUgIT09IHVuZGVmaW5lZCA/ICgwLHV0aWxzLyogcHVzaFVuaXF1ZSAqLy4kQykoZGF0ZXMsIGRhdGUpIDogZGF0ZXM7XG4gICAgfSwgW10pO1xuICAgIGRlbGV0ZSBpbk9wdHMuZGF0ZXNEaXNhYmxlZDtcbiAgfVxuICBpZiAoaW5PcHRzLmRlZmF1bHRWaWV3RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgdmlld0RhdGUgPSAoMCxkYXRlX2Zvcm1hdC8qIHBhcnNlRGF0ZSAqLy5zRykoaW5PcHRzLmRlZmF1bHRWaWV3RGF0ZSwgZm9ybWF0LCBsb2NhbGUpO1xuICAgIGlmICh2aWV3RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25maWcuZGVmYXVsdFZpZXdEYXRlID0gdmlld0RhdGU7XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMuZGVmYXVsdFZpZXdEYXRlO1xuICB9XG5cbiAgLy8qKiogZGF5cyBvZiB3ZWVrICoqKi8vXG4gIGlmIChpbk9wdHMud2Vla1N0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB3a1N0YXJ0ID0gTnVtYmVyKGluT3B0cy53ZWVrU3RhcnQpICUgNztcbiAgICBpZiAoIWlzTmFOKHdrU3RhcnQpKSB7XG4gICAgICB3ZWVrU3RhcnQgPSBjb25maWcud2Vla1N0YXJ0ID0gd2tTdGFydDtcbiAgICAgIGNvbmZpZy53ZWVrRW5kID0gY2FsY0VuZE9mV2Vlayh3a1N0YXJ0KTtcbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy53ZWVrU3RhcnQ7XG4gIH1cbiAgaWYgKGluT3B0cy5kYXlzT2ZXZWVrRGlzYWJsZWQpIHtcbiAgICBjb25maWcuZGF5c09mV2Vla0Rpc2FibGVkID0gaW5PcHRzLmRheXNPZldlZWtEaXNhYmxlZC5yZWR1Y2Uoc2FuaXRpemVET1csIFtdKTtcbiAgICBkZWxldGUgaW5PcHRzLmRheXNPZldlZWtEaXNhYmxlZDtcbiAgfVxuICBpZiAoaW5PcHRzLmRheXNPZldlZWtIaWdobGlnaHRlZCkge1xuICAgIGNvbmZpZy5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQgPSBpbk9wdHMuZGF5c09mV2Vla0hpZ2hsaWdodGVkLnJlZHVjZShzYW5pdGl6ZURPVywgW10pO1xuICAgIGRlbGV0ZSBpbk9wdHMuZGF5c09mV2Vla0hpZ2hsaWdodGVkO1xuICB9XG5cbiAgLy8qKiogbXVsdGkgZGF0ZSAqKiovL1xuICBpZiAoaW5PcHRzLm1heE51bWJlck9mRGF0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG1heE51bWJlck9mRGF0ZXMgPSBwYXJzZUludChpbk9wdHMubWF4TnVtYmVyT2ZEYXRlcywgMTApO1xuICAgIGlmIChtYXhOdW1iZXJPZkRhdGVzID49IDApIHtcbiAgICAgIGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzID0gbWF4TnVtYmVyT2ZEYXRlcztcbiAgICAgIGNvbmZpZy5tdWx0aWRhdGUgPSBtYXhOdW1iZXJPZkRhdGVzICE9PSAxO1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLm1heE51bWJlck9mRGF0ZXM7XG4gIH1cbiAgaWYgKGluT3B0cy5kYXRlRGVsaW1pdGVyKSB7XG4gICAgY29uZmlnLmRhdGVEZWxpbWl0ZXIgPSBTdHJpbmcoaW5PcHRzLmRhdGVEZWxpbWl0ZXIpO1xuICAgIGRlbGV0ZSBpbk9wdHMuZGF0ZURlbGltaXRlcjtcbiAgfVxuXG4gIC8vKioqIHBpY2sgbGV2ZWwgJiB2aWV3ICoqKi8vXG4gIGxldCBuZXdQaWNrTGV2ZWwgPSBwaWNrTGV2ZWw7XG4gIGlmIChpbk9wdHMucGlja0xldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICBuZXdQaWNrTGV2ZWwgPSB2YWxpZGF0ZVZpZXdJZChpbk9wdHMucGlja0xldmVsLCAyKTtcbiAgICBkZWxldGUgaW5PcHRzLnBpY2tMZXZlbDtcbiAgfVxuICBpZiAobmV3UGlja0xldmVsICE9PSBwaWNrTGV2ZWwpIHtcbiAgICBwaWNrTGV2ZWwgPSBjb25maWcucGlja0xldmVsID0gbmV3UGlja0xldmVsO1xuICB9XG5cbiAgbGV0IG5ld01heFZpZXcgPSBtYXhWaWV3O1xuICBpZiAoaW5PcHRzLm1heFZpZXcgIT09IHVuZGVmaW5lZCkge1xuICAgIG5ld01heFZpZXcgPSB2YWxpZGF0ZVZpZXdJZChpbk9wdHMubWF4VmlldywgbWF4Vmlldyk7XG4gICAgZGVsZXRlIGluT3B0cy5tYXhWaWV3O1xuICB9XG4gIC8vIGVuc3VyZSBtYXggdmlldyA+PSBwaWNrIGxldmVsXG4gIG5ld01heFZpZXcgPSBwaWNrTGV2ZWwgPiBuZXdNYXhWaWV3ID8gcGlja0xldmVsIDogbmV3TWF4VmlldztcbiAgaWYgKG5ld01heFZpZXcgIT09IG1heFZpZXcpIHtcbiAgICBtYXhWaWV3ID0gY29uZmlnLm1heFZpZXcgPSBuZXdNYXhWaWV3O1xuICB9XG5cbiAgbGV0IG5ld1N0YXJ0VmlldyA9IHN0YXJ0VmlldztcbiAgaWYgKGluT3B0cy5zdGFydFZpZXcgIT09IHVuZGVmaW5lZCkge1xuICAgIG5ld1N0YXJ0VmlldyA9IHZhbGlkYXRlVmlld0lkKGluT3B0cy5zdGFydFZpZXcsIG5ld1N0YXJ0Vmlldyk7XG4gICAgZGVsZXRlIGluT3B0cy5zdGFydFZpZXc7XG4gIH1cbiAgLy8gZW5zdXJlIHBpY2sgbGV2ZWwgPD0gc3RhcnQgdmlldyA8PSBtYXggdmlld1xuICBpZiAobmV3U3RhcnRWaWV3IDwgcGlja0xldmVsKSB7XG4gICAgbmV3U3RhcnRWaWV3ID0gcGlja0xldmVsO1xuICB9IGVsc2UgaWYgKG5ld1N0YXJ0VmlldyA+IG1heFZpZXcpIHtcbiAgICBuZXdTdGFydFZpZXcgPSBtYXhWaWV3O1xuICB9XG4gIGlmIChuZXdTdGFydFZpZXcgIT09IHN0YXJ0Vmlldykge1xuICAgIGNvbmZpZy5zdGFydFZpZXcgPSBuZXdTdGFydFZpZXc7XG4gIH1cblxuICAvLyoqKiB0ZW1wbGF0ZSAqKiovL1xuICBpZiAoaW5PcHRzLnByZXZBcnJvdykge1xuICAgIGNvbnN0IHByZXZBcnJvdyA9IHBhcnNlSFRNTChpbk9wdHMucHJldkFycm93KTtcbiAgICBpZiAocHJldkFycm93LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uZmlnLnByZXZBcnJvdyA9IHByZXZBcnJvdy5jaGlsZE5vZGVzO1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLnByZXZBcnJvdztcbiAgfVxuICBpZiAoaW5PcHRzLm5leHRBcnJvdykge1xuICAgIGNvbnN0IG5leHRBcnJvdyA9IHBhcnNlSFRNTChpbk9wdHMubmV4dEFycm93KTtcbiAgICBpZiAobmV4dEFycm93LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uZmlnLm5leHRBcnJvdyA9IG5leHRBcnJvdy5jaGlsZE5vZGVzO1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLm5leHRBcnJvdztcbiAgfVxuXG4gIC8vKioqIG1pc2MgKioqLy9cbiAgaWYgKGluT3B0cy5kaXNhYmxlVG91Y2hLZXlib2FyZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uZmlnLmRpc2FibGVUb3VjaEtleWJvYXJkID0gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQgJiYgISFpbk9wdHMuZGlzYWJsZVRvdWNoS2V5Ym9hcmQ7XG4gICAgZGVsZXRlIGluT3B0cy5kaXNhYmxlVG91Y2hLZXlib2FyZDtcbiAgfVxuICBpZiAoaW5PcHRzLm9yaWVudGF0aW9uKSB7XG4gICAgY29uc3Qgb3JpZW50YXRpb24gPSBpbk9wdHMub3JpZW50YXRpb24udG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy9nKTtcbiAgICBjb25maWcub3JpZW50YXRpb24gPSB7XG4gICAgICB4OiBvcmllbnRhdGlvbi5maW5kKHggPT4gKHggPT09ICdsZWZ0JyB8fCB4ID09PSAncmlnaHQnKSkgfHwgJ2F1dG8nLFxuICAgICAgeTogb3JpZW50YXRpb24uZmluZCh5ID0+ICh5ID09PSAndG9wJyB8fCB5ID09PSAnYm90dG9tJykpIHx8ICdhdXRvJyxcbiAgICB9O1xuICAgIGRlbGV0ZSBpbk9wdHMub3JpZW50YXRpb247XG4gIH1cbiAgaWYgKGluT3B0cy50b2RheUJ0bk1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHN3aXRjaChpbk9wdHMudG9kYXlCdG5Nb2RlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNvbmZpZy50b2RheUJ0bk1vZGUgPSBpbk9wdHMudG9kYXlCdG5Nb2RlO1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLnRvZGF5QnRuTW9kZTtcbiAgfVxuXG4gIC8vKioqIGNvcHkgdGhlIHJlc3QgKioqLy9cbiAgT2JqZWN0LmtleXMoaW5PcHRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoaW5PcHRzW2tleV0gIT09IHVuZGVmaW5lZCAmJiAoMCx1dGlscy8qIGhhc1Byb3BlcnR5ICovLmwkKShvcHRpb25zX2RlZmF1bHRPcHRpb25zLCBrZXkpKSB7XG4gICAgICBjb25maWdba2V5XSA9IGluT3B0c1trZXldO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvcGlja2VyL3RlbXBsYXRlcy9waWNrZXJUZW1wbGF0ZS5qc1xuXG5cbmNvbnN0IHBpY2tlclRlbXBsYXRlID0gKDAsdXRpbHMvKiBvcHRpbWl6ZVRlbXBsYXRlSFRNTCAqLy56aCkoYDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyIGhpZGRlblwiPlxuICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1waWNrZXIgaW5saW5lLWJsb2NrIHJvdW5kZWQtbGcgYmctd2hpdGUgZGFyazpiZy1ncmF5LTcwMCBzaGFkb3ctbGcgcC00XCI+XG4gICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItaGVhZGVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci10aXRsZSBiZy13aGl0ZSBkYXJrOmJnLWdyYXktNzAwIGRhcms6dGV4dC13aGl0ZSBweC0yIHB5LTMgdGV4dC1jZW50ZXIgZm9udC1zZW1pYm9sZFwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItY29udHJvbHMgZmxleCBqdXN0aWZ5LWJldHdlZW4gbWItMlwiPlxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgcm91bmRlZC1sZyB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC13aGl0ZSBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGhvdmVyOnRleHQtZ3JheS05MDAgZGFyazpob3Zlcjp0ZXh0LXdoaXRlIHRleHQtbGcgcC0yLjUgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktMjAwIHByZXYtYnRuXCI+PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwidGV4dC1zbSByb3VuZGVkLWxnIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgZm9udC1zZW1pYm9sZCBweS0yLjUgcHgtNSBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTIwMCB2aWV3LXN3aXRjaFwiPjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgcm91bmRlZC1sZyB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC13aGl0ZSBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGhvdmVyOnRleHQtZ3JheS05MDAgZGFyazpob3Zlcjp0ZXh0LXdoaXRlIHRleHQtbGcgcC0yLjUgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktMjAwIG5leHQtYnRuXCI+PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1tYWluIHAtMVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWZvb3RlclwiPlxuICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItY29udHJvbHMgZmxleCBzcGFjZS14LTIgbXQtMlwiPlxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiVidXR0b25DbGFzcyUgdG9kYXktYnRuIHRleHQtd2hpdGUgYmctYmx1ZS03MDAgZGFyazpiZy1ibHVlLTYwMCBob3ZlcjpiZy1ibHVlLTgwMCBkYXJrOmhvdmVyOmJnLWJsdWUtNzAwIGZvY3VzOnJpbmctNCBmb2N1czpyaW5nLWJsdWUtMzAwIGZvbnQtbWVkaXVtIHJvdW5kZWQtbGcgdGV4dC1zbSBweC01IHB5LTIgdGV4dC1jZW50ZXIgdy0xLzJcIj48L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIlYnV0dG9uQ2xhc3MlIGNsZWFyLWJ0biB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC13aGl0ZSBiZy13aGl0ZSBkYXJrOmJnLWdyYXktNzAwIGJvcmRlciBib3JkZXItZ3JheS0zMDAgZGFyazpib3JkZXItZ3JheS02MDAgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBmb2N1czpyaW5nLTQgZm9jdXM6cmluZy1ibHVlLTMwMCBmb250LW1lZGl1bSByb3VuZGVkLWxnIHRleHQtc20gcHgtNSBweS0yIHRleHQtY2VudGVyIHctMS8yXCI+PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5gKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGVtcGxhdGVzX3BpY2tlclRlbXBsYXRlID0gKHBpY2tlclRlbXBsYXRlKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvcGlja2VyL3RlbXBsYXRlcy9kYXlzVGVtcGxhdGUuanNcblxuXG5jb25zdCBkYXlzVGVtcGxhdGUgPSAoMCx1dGlscy8qIG9wdGltaXplVGVtcGxhdGVIVE1MICovLnpoKShgPGRpdiBjbGFzcz1cImRheXNcIj5cbiAgPGRpdiBjbGFzcz1cImRheXMtb2Ytd2VlayBncmlkIGdyaWQtY29scy03IG1iLTFcIj4keygwLHV0aWxzLyogY3JlYXRlVGFnUmVwZWF0ICovLmVtKSgnc3BhbicsIDcsIHtjbGFzczogJ2RvdyBibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLWRlZmF1bHQgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBmb250LXNlbWlib2xkIHRleHQtc20nfSl9PC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWdyaWQgdy02NCBncmlkIGdyaWQtY29scy03XCI+JHsoMCx1dGlscy8qIGNyZWF0ZVRhZ1JlcGVhdCAqLy5lbSkoJ3NwYW4nLCA0MiAsIHtjbGFzczogJ2Jsb2NrIGZsZXgtMSBsZWFkaW5nLTkgYm9yZGVyLTAgcm91bmRlZC1sZyBjdXJzb3ItZGVmYXVsdCB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktOTAwIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSBoLTYgbGVhZGluZy02IHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDAnfSl9PC9kaXY+XG48L2Rpdj5gKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGVtcGxhdGVzX2RheXNUZW1wbGF0ZSA9IChkYXlzVGVtcGxhdGUpO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9waWNrZXIvdGVtcGxhdGVzL2NhbGVuZGFyV2Vla3NUZW1wbGF0ZS5qc1xuXG5cbmNvbnN0IGNhbGVuZGFyV2Vla3NUZW1wbGF0ZSA9ICgwLHV0aWxzLyogb3B0aW1pemVUZW1wbGF0ZUhUTUwgKi8uemgpKGA8ZGl2IGNsYXNzPVwiY2FsZW5kYXItd2Vla3NcIj5cbiAgPGRpdiBjbGFzcz1cImRheXMtb2Ytd2VlayBmbGV4XCI+PHNwYW4gY2xhc3M9XCJkb3cgaC02IGxlYWRpbmctNiB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktNDAwXCI+PC9zcGFuPjwvZGl2PlxuICA8ZGl2IGNsYXNzPVwid2Vla3NcIj4keygwLHV0aWxzLyogY3JlYXRlVGFnUmVwZWF0ICovLmVtKSgnc3BhbicsIDYsIHtjbGFzczogJ3dlZWsgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1kZWZhdWx0IHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZm9udC1zZW1pYm9sZCB0ZXh0LXNtJ30pfTwvZGl2PlxuPC9kaXY+YCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRlbXBsYXRlc19jYWxlbmRhcldlZWtzVGVtcGxhdGUgPSAoY2FsZW5kYXJXZWVrc1RlbXBsYXRlKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvcGlja2VyL3ZpZXdzL1ZpZXcuanNcblxuXG5cbi8vIEJhc2UgY2xhc3Mgb2YgdGhlIHZpZXcgY2xhc3Nlc1xuY2xhc3MgVmlldyB7XG4gIGNvbnN0cnVjdG9yKHBpY2tlciwgY29uZmlnKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcsIHtcbiAgICAgIHBpY2tlcixcbiAgICAgIGVsZW1lbnQ6IHBhcnNlSFRNTChgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItdmlldyBmbGV4XCI+PC9kaXY+YCkuZmlyc3RDaGlsZCxcbiAgICAgIHNlbGVjdGVkOiBbXSxcbiAgICB9KTtcbiAgICB0aGlzLmluaXQodGhpcy5waWNrZXIuZGF0ZXBpY2tlci5jb25maWcpO1xuICB9XG5cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucGlja0xldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaXNNaW5WaWV3ID0gdGhpcy5pZCA9PT0gb3B0aW9ucy5waWNrTGV2ZWw7XG4gICAgfVxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZUZvY3VzKCk7XG4gICAgdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgfVxuXG4gIC8vIEV4ZWN1dGUgYmVmb3JlU2hvdygpIGNhbGxiYWNrIGFuZCBhcHBseSB0aGUgcmVzdWx0IHRvIHRoZSBlbGVtZW50XG4gIC8vIGFyZ3M6XG4gIC8vIC0gY3VycmVudCAtIGN1cnJlbnQgdmFsdWUgb24gdGhlIGl0ZXJhdGlvbiBvbiB2aWV3IHJlbmRlcmluZ1xuICAvLyAtIHRpbWVWYWx1ZSAtIHRpbWUgdmFsdWUgb2YgdGhlIGRhdGUgdG8gcGFzcyB0byBiZWZvcmVTaG93KClcbiAgcGVyZm9ybUJlZm9yZUhvb2soZWwsIGN1cnJlbnQsIHRpbWVWYWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmJlZm9yZVNob3cobmV3IERhdGUodGltZVZhbHVlKSk7XG4gICAgc3dpdGNoICh0eXBlb2YgcmVzdWx0KSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmVzdWx0ID0ge2VuYWJsZWQ6IHJlc3VsdH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmVzdWx0ID0ge2NsYXNzZXM6IHJlc3VsdH07XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKHJlc3VsdC5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgICAoMCx1dGlscy8qIHB1c2hVbmlxdWUgKi8uJEMpKHRoaXMuZGlzYWJsZWQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5jbGFzc2VzKSB7XG4gICAgICAgIGNvbnN0IGV4dHJhQ2xhc3NlcyA9IHJlc3VsdC5jbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uZXh0cmFDbGFzc2VzKTtcbiAgICAgICAgaWYgKGV4dHJhQ2xhc3Nlcy5pbmNsdWRlcygnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICgwLHV0aWxzLyogcHVzaFVuaXF1ZSAqLy4kQykodGhpcy5kaXNhYmxlZCwgY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuY29udGVudCkge1xuICAgICAgICByZXBsYWNlQ2hpbGROb2RlcyhlbCwgcmVzdWx0LmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9waWNrZXIvdmlld3MvRGF5c1ZpZXcuanNcblxuXG5cblxuXG5cblxuXG5jbGFzcyBEYXlzVmlldyBleHRlbmRzIFZpZXcge1xuICBjb25zdHJ1Y3RvcihwaWNrZXIpIHtcbiAgICBzdXBlcihwaWNrZXIsIHtcbiAgICAgIGlkOiAwLFxuICAgICAgbmFtZTogJ2RheXMnLFxuICAgICAgY2VsbENsYXNzOiAnZGF5JyxcbiAgICB9KTtcbiAgfVxuXG4gIGluaXQob3B0aW9ucywgb25Db25zdHJ1Y3Rpb24gPSB0cnVlKSB7XG4gICAgaWYgKG9uQ29uc3RydWN0aW9uKSB7XG4gICAgICBjb25zdCBpbm5lciA9IHBhcnNlSFRNTCh0ZW1wbGF0ZXNfZGF5c1RlbXBsYXRlKS5maXJzdENoaWxkO1xuICAgICAgdGhpcy5kb3cgPSBpbm5lci5maXJzdENoaWxkO1xuICAgICAgdGhpcy5ncmlkID0gaW5uZXIubGFzdENoaWxkO1xuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChvcHRpb25zKTtcbiAgfVxuXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIGxldCB1cGRhdGVET1c7XG5cbiAgICBpZiAoKDAsdXRpbHMvKiBoYXNQcm9wZXJ0eSAqLy5sJCkob3B0aW9ucywgJ21pbkRhdGUnKSkge1xuICAgICAgdGhpcy5taW5EYXRlID0gb3B0aW9ucy5taW5EYXRlO1xuICAgIH1cbiAgICBpZiAoKDAsdXRpbHMvKiBoYXNQcm9wZXJ0eSAqLy5sJCkob3B0aW9ucywgJ21heERhdGUnKSkge1xuICAgICAgdGhpcy5tYXhEYXRlID0gb3B0aW9ucy5tYXhEYXRlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kYXRlc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmRhdGVzRGlzYWJsZWQgPSBvcHRpb25zLmRhdGVzRGlzYWJsZWQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRheXNPZldlZWtEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBvcHRpb25zLmRheXNPZldlZWtEaXNhYmxlZDtcbiAgICAgIHVwZGF0ZURPVyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRheXNPZldlZWtIaWdobGlnaHRlZCkge1xuICAgICAgdGhpcy5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQgPSBvcHRpb25zLmRheXNPZldlZWtIaWdobGlnaHRlZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudG9kYXlIaWdobGlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50b2RheUhpZ2hsaWdodCA9IG9wdGlvbnMudG9kYXlIaWdobGlnaHQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndlZWtTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndlZWtTdGFydCA9IG9wdGlvbnMud2Vla1N0YXJ0O1xuICAgICAgdGhpcy53ZWVrRW5kID0gb3B0aW9ucy53ZWVrRW5kO1xuICAgICAgdXBkYXRlRE9XID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubG9jYWxlKSB7XG4gICAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICAgICAgdGhpcy5kYXlOYW1lcyA9IGxvY2FsZS5kYXlzTWluO1xuICAgICAgdGhpcy5zd2l0Y2hMYWJlbEZvcm1hdCA9IGxvY2FsZS50aXRsZUZvcm1hdDtcbiAgICAgIHVwZGF0ZURPVyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJlZm9yZVNob3dEYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5iZWZvcmVTaG93ID0gdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2hvd0RheSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9wdGlvbnMuYmVmb3JlU2hvd0RheVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jYWxlbmRhcldlZWtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLmNhbGVuZGFyV2Vla3MgJiYgIXRoaXMuY2FsZW5kYXJXZWVrcykge1xuICAgICAgICBjb25zdCB3ZWVrc0VsZW0gPSBwYXJzZUhUTUwodGVtcGxhdGVzX2NhbGVuZGFyV2Vla3NUZW1wbGF0ZSkuZmlyc3RDaGlsZDtcbiAgICAgICAgdGhpcy5jYWxlbmRhcldlZWtzID0ge1xuICAgICAgICAgIGVsZW1lbnQ6IHdlZWtzRWxlbSxcbiAgICAgICAgICBkb3c6IHdlZWtzRWxlbS5maXJzdENoaWxkLFxuICAgICAgICAgIHdlZWtzOiB3ZWVrc0VsZW0ubGFzdENoaWxkLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHdlZWtzRWxlbSwgdGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MgJiYgIW9wdGlvbnMuY2FsZW5kYXJXZWVrcykge1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5jYWxlbmRhcldlZWtzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyV2Vla3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zaG93RGF5c09mV2VlayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9ucy5zaG93RGF5c09mV2Vlaykge1xuICAgICAgICBzaG93RWxlbWVudCh0aGlzLmRvdyk7XG4gICAgICAgIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MpIHtcbiAgICAgICAgICBzaG93RWxlbWVudCh0aGlzLmNhbGVuZGFyV2Vla3MuZG93KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGlkZUVsZW1lbnQodGhpcy5kb3cpO1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhcldlZWtzKSB7XG4gICAgICAgICAgaGlkZUVsZW1lbnQodGhpcy5jYWxlbmRhcldlZWtzLmRvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZGF5cy1vZi13ZWVrIHdoZW4gbG9jYWxlLCBkYXlzT2Z3ZWVrRGlzYWJsZWQgb3Igd2Vla1N0YXJ0IGlzIGNoYW5nZWRcbiAgICBpZiAodXBkYXRlRE9XKSB7XG4gICAgICBBcnJheS5mcm9tKHRoaXMuZG93LmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZG93ID0gKHRoaXMud2Vla1N0YXJ0ICsgaW5kZXgpICUgNztcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0aGlzLmRheU5hbWVzW2Rvd107XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IHRoaXMuZGF5c09mV2Vla0Rpc2FibGVkLmluY2x1ZGVzKGRvdykgPyAnZG93IGRpc2FibGVkIHRleHQtY2VudGVyIGgtNiBsZWFkaW5nLTYgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC1ncmF5LTQwMCBjdXJzb3Itbm90LWFsbG93ZWQnIDogJ2RvdyB0ZXh0LWNlbnRlciBoLTYgbGVhZGluZy02IHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDAnO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXBwbHkgdXBkYXRlIG9uIHRoZSBmb2N1c2VkIGRhdGUgdG8gdmlldydzIHNldHRpbmdzXG4gIHVwZGF0ZUZvY3VzKCkge1xuICAgIGNvbnN0IHZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5waWNrZXIudmlld0RhdGUpO1xuICAgIGNvbnN0IHZpZXdZZWFyID0gdmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICBjb25zdCB2aWV3TW9udGggPSB2aWV3RGF0ZS5nZXRNb250aCgpO1xuICAgIGNvbnN0IGZpcnN0T2ZNb250aCA9ICgwLGxpYl9kYXRlLyogZGF0ZVZhbHVlICovLmJ5KSh2aWV3WWVhciwgdmlld01vbnRoLCAxKTtcbiAgICBjb25zdCBzdGFydCA9ICgwLGxpYl9kYXRlLyogZGF5T2ZUaGVXZWVrT2YgKi8uZnIpKGZpcnN0T2ZNb250aCwgdGhpcy53ZWVrU3RhcnQsIHRoaXMud2Vla1N0YXJ0KTtcblxuICAgIHRoaXMuZmlyc3QgPSBmaXJzdE9mTW9udGg7XG4gICAgdGhpcy5sYXN0ID0gKDAsbGliX2RhdGUvKiBkYXRlVmFsdWUgKi8uYnkpKHZpZXdZZWFyLCB2aWV3TW9udGggKyAxLCAwKTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5mb2N1c2VkID0gdGhpcy5waWNrZXIudmlld0RhdGU7XG4gIH1cblxuICAvLyBBcHBseSB1cGRhdGUgb24gdGhlIHNlbGVjdGVkIGRhdGVzIHRvIHZpZXcncyBzZXR0aW5nc1xuICB1cGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgY29uc3Qge2RhdGVzLCByYW5nZXBpY2tlcn0gPSB0aGlzLnBpY2tlci5kYXRlcGlja2VyO1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBkYXRlcztcbiAgICBpZiAocmFuZ2VwaWNrZXIpIHtcbiAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXBpY2tlci5kYXRlcztcbiAgICB9XG4gIH1cblxuICAgLy8gVXBkYXRlIHRoZSBlbnRpcmUgdmlldyBVSVxuICByZW5kZXIoKSB7XG4gICAgLy8gdXBkYXRlIHRvZGF5IG1hcmtlciBvbiBldmVyIHJlbmRlclxuICAgIHRoaXMudG9kYXkgPSB0aGlzLnRvZGF5SGlnaGxpZ2h0ID8gKDAsbGliX2RhdGUvKiB0b2RheSAqLy5MZykoKSA6IHVuZGVmaW5lZDtcbiAgICAvLyByZWZyZXNoIGRpc2FibGVkIGRhdGVzIG9uIGV2ZXJ5IHJlbmRlciBpbiBvcmRlciB0byBjbGVhciB0aGUgb25lcyBhZGRlZFxuICAgIC8vIGJ5IGJlZm9yZVNob3cgaG9vayBhdCBwcmV2aW91cyByZW5kZXJcbiAgICB0aGlzLmRpc2FibGVkID0gWy4uLnRoaXMuZGF0ZXNEaXNhYmxlZF07XG5cbiAgICBjb25zdCBzd2l0Y2hMYWJlbCA9ICgwLGRhdGVfZm9ybWF0LyogZm9ybWF0RGF0ZSAqLy5wNikodGhpcy5mb2N1c2VkLCB0aGlzLnN3aXRjaExhYmVsRm9ybWF0LCB0aGlzLmxvY2FsZSk7XG4gICAgdGhpcy5waWNrZXIuc2V0Vmlld1N3aXRjaExhYmVsKHN3aXRjaExhYmVsKTtcbiAgICB0aGlzLnBpY2tlci5zZXRQcmV2QnRuRGlzYWJsZWQodGhpcy5maXJzdCA8PSB0aGlzLm1pbkRhdGUpO1xuICAgIHRoaXMucGlja2VyLnNldE5leHRCdG5EaXNhYmxlZCh0aGlzLmxhc3QgPj0gdGhpcy5tYXhEYXRlKTtcblxuICAgIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MpIHtcbiAgICAgIC8vIHN0YXJ0IG9mIHRoZSBVVEMgd2VlayAoTW9uZGF5KSBvZiB0aGUgMXN0IG9mIHRoZSBtb250aFxuICAgICAgY29uc3Qgc3RhcnRPZldlZWsgPSAoMCxsaWJfZGF0ZS8qIGRheU9mVGhlV2Vla09mICovLmZyKSh0aGlzLmZpcnN0LCAxLCAxKTtcbiAgICAgIEFycmF5LmZyb20odGhpcy5jYWxlbmRhcldlZWtzLndlZWtzLmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSAoMCxsaWJfZGF0ZS8qIGdldFdlZWsgKi8uUWspKCgwLGxpYl9kYXRlLyogYWRkV2Vla3MgKi8uamgpKHN0YXJ0T2ZXZWVrLCBpbmRleCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSAoMCxsaWJfZGF0ZS8qIGFkZERheXMgKi8uRTQpKHRoaXMuc3RhcnQsIGluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShjdXJyZW50KTtcbiAgICAgIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF5KCk7XG5cbiAgICAgIGVsLmNsYXNzTmFtZSA9IGBkYXRlcGlja2VyLWNlbGwgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLXBvaW50ZXIgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBkYXJrOnRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCB0ZXh0LXNtICR7dGhpcy5jZWxsQ2xhc3N9YDtcbiAgICAgIGVsLmRhdGFzZXQuZGF0ZSA9IGN1cnJlbnQ7XG4gICAgICBlbC50ZXh0Q29udGVudCA9IGRhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgICBpZiAoY3VycmVudCA8IHRoaXMuZmlyc3QpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncHJldicsICd0ZXh0LWdyYXktNTAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50ID4gdGhpcy5sYXN0KSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ25leHQnLCAndGV4dC1ncmF5LTUwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRvZGF5ID09PSBjdXJyZW50KSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3RvZGF5JywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50IDwgdGhpcy5taW5EYXRlIHx8IGN1cnJlbnQgPiB0aGlzLm1heERhdGUgfHwgdGhpcy5kaXNhYmxlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcsICdjdXJzb3Itbm90LWFsbG93ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRheXNPZldlZWtEaXNhYmxlZC5pbmNsdWRlcyhkYXkpKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJywgJ2N1cnNvci1ub3QtYWxsb3dlZCcpO1xuICAgICAgICAoMCx1dGlscy8qIHB1c2hVbmlxdWUgKi8uJEMpKHRoaXMuZGlzYWJsZWQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF5c09mV2Vla0hpZ2hsaWdodGVkLmluY2x1ZGVzKGRheSkpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnaGlnaGxpZ2h0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJhbmdlKSB7XG4gICAgICAgIGNvbnN0IFtyYW5nZVN0YXJ0LCByYW5nZUVuZF0gPSB0aGlzLnJhbmdlO1xuICAgICAgICBpZiAoY3VycmVudCA+IHJhbmdlU3RhcnQgJiYgY3VycmVudCA8IHJhbmdlRW5kKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UnLCAnYmctZ3JheS0yMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcpO1xuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1sLWxnJywgJ3JvdW5kZWQtci1sZycpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtbC1sZycpO1xuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1yLWxnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlRW5kKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnLCAncm91bmRlZC1yLWxnJyk7XG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycsICdyb3VuZGVkLWwtbGcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQuaW5jbHVkZXMoY3VycmVudCkpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyYXktOTAwJywgJ3RleHQtZ3JheS01MDAnLCAnaG92ZXI6YmctZ3JheS0xMDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ2Rhcms6aG92ZXI6YmctZ3JheS02MDAnLCAnZGFyazpiZy1ncmF5LTYwMCcsICdiZy1ncmF5LTEwMCcsICdiZy1ncmF5LTIwMCcpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZm9jdXNlZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJlZm9yZVNob3cpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtQmVmb3JlSG9vayhlbCwgY3VycmVudCwgY3VycmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZXMgb2Ygc2VsZWN0ZWQgYW5kIGZvY3VzZWQgaXRlbXNcbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCBbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdID0gdGhpcy5yYW5nZSB8fCBbXTtcbiAgICB0aGlzLmdyaWRcbiAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCcucmFuZ2UsIC5yYW5nZS1zdGFydCwgLnJhbmdlLWVuZCwgLnNlbGVjdGVkLCAuZm9jdXNlZCcpXG4gICAgICAuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UnLCAncmFuZ2Utc3RhcnQnLCAncmFuZ2UtZW5kJywgJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZm9jdXNlZCcpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWdyYXktOTAwJywgJ3JvdW5kZWQtbGcnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICB9KTtcbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBOdW1iZXIoZWwuZGF0YXNldC5kYXRlKTtcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcbiAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnLCAncm91bmRlZC1sLWxnJywgJ3JvdW5kZWQtci1sZycpXG4gICAgICBpZiAoY3VycmVudCA+IHJhbmdlU3RhcnQgJiYgY3VycmVudCA8IHJhbmdlRW5kKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnLCAnYmctZ3JheS0yMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcsICdyb3VuZGVkLWwtbGcnKTtcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycsICdyb3VuZGVkLXItbGcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZUVuZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnLCAnYmctZ3JheS0yMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcsICdyb3VuZGVkLXItbGcnKTtcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycsICdyb3VuZGVkLWwtbGcnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcsICdiZy1ncmF5LTEwMCcsICdiZy1ncmF5LTIwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mb2N1c2VkKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlIG9mIGZvY3VzZWQgaXRlbVxuICByZWZyZXNoRm9jdXMoKSB7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLnJvdW5kKCh0aGlzLmZvY3VzZWQgLSB0aGlzLnN0YXJ0KSAvIDg2NDAwMDAwKTtcbiAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmZvY3VzZWQnKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXNlZCcpO1xuICAgIH0pO1xuICAgIHRoaXMuZ3JpZC5jaGlsZHJlbltpbmRleF0uY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL3BpY2tlci92aWV3cy9Nb250aHNWaWV3LmpzXG5cblxuXG5cblxuZnVuY3Rpb24gY29tcHV0ZU1vbnRoUmFuZ2UocmFuZ2UsIHRoaXNZZWFyKSB7XG4gIGlmICghcmFuZ2UgfHwgIXJhbmdlWzBdIHx8ICFyYW5nZVsxXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IFtbc3RhcnRZLCBzdGFydE1dLCBbZW5kWSwgZW5kTV1dID0gcmFuZ2U7XG4gIGlmIChzdGFydFkgPiB0aGlzWWVhciB8fCBlbmRZIDwgdGhpc1llYXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIFtcbiAgICBzdGFydFkgPT09IHRoaXNZZWFyID8gc3RhcnRNIDogLTEsXG4gICAgZW5kWSA9PT0gdGhpc1llYXIgPyBlbmRNIDogMTIsXG4gIF07XG59XG5cbmNsYXNzIE1vbnRoc1ZpZXcgZXh0ZW5kcyBWaWV3IHtcbiAgY29uc3RydWN0b3IocGlja2VyKSB7XG4gICAgc3VwZXIocGlja2VyLCB7XG4gICAgICBpZDogMSxcbiAgICAgIG5hbWU6ICdtb250aHMnLFxuICAgICAgY2VsbENsYXNzOiAnbW9udGgnLFxuICAgIH0pO1xuICB9XG5cbiAgaW5pdChvcHRpb25zLCBvbkNvbnN0cnVjdGlvbiA9IHRydWUpIHtcbiAgICBpZiAob25Db25zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuZ3JpZCA9IHRoaXMuZWxlbWVudDtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtb250aHMnLCAnZGF0ZXBpY2tlci1ncmlkJywgJ3ctNjQnLCAnZ3JpZCcsICdncmlkLWNvbHMtNCcpO1xuICAgICAgdGhpcy5ncmlkLmFwcGVuZENoaWxkKHBhcnNlSFRNTCgoMCx1dGlscy8qIGNyZWF0ZVRhZ1JlcGVhdCAqLy5lbSkoJ3NwYW4nLCAxMiwgeydkYXRhLW1vbnRoJzogaXggPT4gaXh9KSkpO1xuICAgIH1cbiAgICBzdXBlci5pbml0KG9wdGlvbnMpO1xuICB9XG5cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMubG9jYWxlKSB7XG4gICAgICB0aGlzLm1vbnRoTmFtZXMgPSBvcHRpb25zLmxvY2FsZS5tb250aHNTaG9ydDtcbiAgICB9XG4gICAgaWYgKCgwLHV0aWxzLyogaGFzUHJvcGVydHkgKi8ubCQpKG9wdGlvbnMsICdtaW5EYXRlJykpIHtcbiAgICAgIGlmIChvcHRpb25zLm1pbkRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1pblllYXIgPSB0aGlzLm1pbk1vbnRoID0gdGhpcy5taW5EYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWluRGF0ZU9iaiA9IG5ldyBEYXRlKG9wdGlvbnMubWluRGF0ZSk7XG4gICAgICAgIHRoaXMubWluWWVhciA9IG1pbkRhdGVPYmouZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgdGhpcy5taW5Nb250aCA9IG1pbkRhdGVPYmouZ2V0TW9udGgoKTtcbiAgICAgICAgdGhpcy5taW5EYXRlID0gbWluRGF0ZU9iai5zZXREYXRlKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKDAsdXRpbHMvKiBoYXNQcm9wZXJ0eSAqLy5sJCkob3B0aW9ucywgJ21heERhdGUnKSkge1xuICAgICAgaWYgKG9wdGlvbnMubWF4RGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWF4WWVhciA9IHRoaXMubWF4TW9udGggPSB0aGlzLm1heERhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXhEYXRlT2JqID0gbmV3IERhdGUob3B0aW9ucy5tYXhEYXRlKTtcbiAgICAgICAgdGhpcy5tYXhZZWFyID0gbWF4RGF0ZU9iai5nZXRGdWxsWWVhcigpO1xuICAgICAgICB0aGlzLm1heE1vbnRoID0gbWF4RGF0ZU9iai5nZXRNb250aCgpO1xuICAgICAgICB0aGlzLm1heERhdGUgPSAoMCxsaWJfZGF0ZS8qIGRhdGVWYWx1ZSAqLy5ieSkodGhpcy5tYXhZZWFyLCB0aGlzLm1heE1vbnRoICsgMSwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJlZm9yZVNob3dNb250aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmJlZm9yZVNob3cgPSB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTaG93TW9udGggPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBvcHRpb25zLmJlZm9yZVNob3dNb250aFxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgdmlldydzIHNldHRpbmdzIHRvIHJlZmxlY3QgdGhlIHZpZXdEYXRlIHNldCBvbiB0aGUgcGlja2VyXG4gIHVwZGF0ZUZvY3VzKCkge1xuICAgIGNvbnN0IHZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5waWNrZXIudmlld0RhdGUpO1xuICAgIHRoaXMueWVhciA9IHZpZXdEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgdGhpcy5mb2N1c2VkID0gdmlld0RhdGUuZ2V0TW9udGgoKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB2aWV3J3Mgc2V0dGluZ3MgdG8gcmVmbGVjdCB0aGUgc2VsZWN0ZWQgZGF0ZXNcbiAgdXBkYXRlU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHtkYXRlcywgcmFuZ2VwaWNrZXJ9ID0gdGhpcy5waWNrZXIuZGF0ZXBpY2tlcjtcbiAgICB0aGlzLnNlbGVjdGVkID0gZGF0ZXMucmVkdWNlKChzZWxlY3RlZCwgdGltZVZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZVZhbHVlKTtcbiAgICAgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICBjb25zdCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICAgIGlmIChzZWxlY3RlZFt5ZWFyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGVjdGVkW3llYXJdID0gW21vbnRoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLHV0aWxzLyogcHVzaFVuaXF1ZSAqLy4kQykoc2VsZWN0ZWRbeWVhcl0sIG1vbnRoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9LCB7fSk7XG4gICAgaWYgKHJhbmdlcGlja2VyICYmIHJhbmdlcGlja2VyLmRhdGVzKSB7XG4gICAgICB0aGlzLnJhbmdlID0gcmFuZ2VwaWNrZXIuZGF0ZXMubWFwKHRpbWVWYWx1ZSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lVmFsdWUpO1xuICAgICAgICByZXR1cm4gaXNOYU4oZGF0ZSkgPyB1bmRlZmluZWQgOiBbZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCldO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBlbnRpcmUgdmlldyBVSVxuICByZW5kZXIoKSB7XG4gICAgLy8gcmVmcmVzaCBkaXNhYmxlZCBtb250aHMgb24gZXZlcnkgcmVuZGVyIGluIG9yZGVyIHRvIGNsZWFyIHRoZSBvbmVzIGFkZGVkXG4gICAgLy8gYnkgYmVmb3JlU2hvdyBob29rIGF0IHByZXZpb3VzIHJlbmRlclxuICAgIHRoaXMuZGlzYWJsZWQgPSBbXTtcblxuICAgIHRoaXMucGlja2VyLnNldFZpZXdTd2l0Y2hMYWJlbCh0aGlzLnllYXIpO1xuICAgIHRoaXMucGlja2VyLnNldFByZXZCdG5EaXNhYmxlZCh0aGlzLnllYXIgPD0gdGhpcy5taW5ZZWFyKTtcbiAgICB0aGlzLnBpY2tlci5zZXROZXh0QnRuRGlzYWJsZWQodGhpcy55ZWFyID49IHRoaXMubWF4WWVhcik7XG5cbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRbdGhpcy55ZWFyXSB8fCBbXTtcbiAgICBjb25zdCB5ck91dE9mUmFuZ2UgPSB0aGlzLnllYXIgPCB0aGlzLm1pblllYXIgfHwgdGhpcy55ZWFyID4gdGhpcy5tYXhZZWFyO1xuICAgIGNvbnN0IGlzTWluWWVhciA9IHRoaXMueWVhciA9PT0gdGhpcy5taW5ZZWFyO1xuICAgIGNvbnN0IGlzTWF4WWVhciA9IHRoaXMueWVhciA9PT0gdGhpcy5tYXhZZWFyO1xuICAgIGNvbnN0IHJhbmdlID0gY29tcHV0ZU1vbnRoUmFuZ2UodGhpcy5yYW5nZSwgdGhpcy55ZWFyKTtcblxuICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcbiAgICAgIGNvbnN0IGRhdGUgPSAoMCxsaWJfZGF0ZS8qIGRhdGVWYWx1ZSAqLy5ieSkodGhpcy55ZWFyLCBpbmRleCwgMSk7XG5cbiAgICAgIGVsLmNsYXNzTmFtZSA9IGBkYXRlcGlja2VyLWNlbGwgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLXBvaW50ZXIgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBkYXJrOnRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCB0ZXh0LXNtICR7dGhpcy5jZWxsQ2xhc3N9YDtcbiAgICAgIGlmICh0aGlzLmlzTWluVmlldykge1xuICAgICAgICBlbC5kYXRhc2V0LmRhdGUgPSBkYXRlO1xuICAgICAgfVxuICAgICAgLy8gcmVzZXQgdGV4dCBvbiBldmVyeSByZW5kZXIgdG8gY2xlYXIgdGhlIGN1c3RvbSBjb250ZW50IHNldFxuICAgICAgLy8gYnkgYmVmb3JlU2hvdyBob29rIGF0IHByZXZpb3VzIHJlbmRlclxuICAgICAgZWwudGV4dENvbnRlbnQgPSB0aGlzLm1vbnRoTmFtZXNbaW5kZXhdO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHlyT3V0T2ZSYW5nZVxuICAgICAgICB8fCBpc01pblllYXIgJiYgaW5kZXggPCB0aGlzLm1pbk1vbnRoXG4gICAgICAgIHx8IGlzTWF4WWVhciAmJiBpbmRleCA+IHRoaXMubWF4TW9udGhcbiAgICAgICkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IFtyYW5nZVN0YXJ0LCByYW5nZUVuZF0gPSByYW5nZTtcbiAgICAgICAgaWYgKGluZGV4ID4gcmFuZ2VTdGFydCAmJiBpbmRleCA8IHJhbmdlRW5kKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkLmluY2x1ZGVzKGluZGV4KSkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtZ3JheS05MDAnLCAnaG92ZXI6YmctZ3JheS0xMDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ2Rhcms6aG92ZXI6YmctZ3JheS02MDAnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5mb2N1c2VkKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmVmb3JlU2hvdykge1xuICAgICAgICB0aGlzLnBlcmZvcm1CZWZvcmVIb29rKGVsLCBpbmRleCwgZGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZXMgb2Ygc2VsZWN0ZWQgYW5kIGZvY3VzZWQgaXRlbXNcbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRbdGhpcy55ZWFyXSB8fCBbXTtcbiAgICBjb25zdCBbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdID0gY29tcHV0ZU1vbnRoUmFuZ2UodGhpcy5yYW5nZSwgdGhpcy55ZWFyKSB8fCBbXTtcbiAgICB0aGlzLmdyaWRcbiAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCcucmFuZ2UsIC5yYW5nZS1zdGFydCwgLnJhbmdlLWVuZCwgLnNlbGVjdGVkLCAuZm9jdXNlZCcpXG4gICAgICAuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UnLCAncmFuZ2Utc3RhcnQnLCAncmFuZ2UtZW5kJywgJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ3RleHQtd2hpdGUnLCAnZm9jdXNlZCcpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWdyYXktOTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJyk7XG4gICAgICB9KTtcbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICBpZiAoaW5kZXggPiByYW5nZVN0YXJ0ICYmIGluZGV4IDwgcmFuZ2VFbmQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PT0gcmFuZ2VTdGFydCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcpO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09PSByYW5nZUVuZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZC5pbmNsdWRlcyhpbmRleCkpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyYXktOTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMuZm9jdXNlZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZSBvZiBmb2N1c2VkIGl0ZW1cbiAgcmVmcmVzaEZvY3VzKCkge1xuICAgIHRoaXMuZ3JpZC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9jdXNlZCcpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmb2N1c2VkJyk7XG4gICAgfSk7XG4gICAgdGhpcy5ncmlkLmNoaWxkcmVuW3RoaXMuZm9jdXNlZF0uY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICB9XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9waWNrZXIvdmlld3MvWWVhcnNWaWV3LmpzXG5cblxuXG5cblxuZnVuY3Rpb24gdG9UaXRsZUNhc2Uod29yZCkge1xuICByZXR1cm4gWy4uLndvcmRdLnJlZHVjZSgoc3RyLCBjaCwgaXgpID0+IHN0ciArPSBpeCA/IGNoIDogY2gudG9VcHBlckNhc2UoKSwgJycpO1xufVxuXG4vLyBDbGFzcyByZXByZXNlbnRpbmcgdGhlIHllYXJzIGFuZCBkZWNhZGVzIHZpZXcgZWxlbWVudHNcbmNsYXNzIFllYXJzVmlldyBleHRlbmRzIFZpZXcge1xuICBjb25zdHJ1Y3RvcihwaWNrZXIsIGNvbmZpZykge1xuICAgIHN1cGVyKHBpY2tlciwgY29uZmlnKTtcbiAgfVxuXG4gIGluaXQob3B0aW9ucywgb25Db25zdHJ1Y3Rpb24gPSB0cnVlKSB7XG4gICAgaWYgKG9uQ29uc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLm5hdlN0ZXAgPSB0aGlzLnN0ZXAgKiAxMDtcbiAgICAgIHRoaXMuYmVmb3JlU2hvd09wdGlvbiA9IGBiZWZvcmVTaG93JHt0b1RpdGxlQ2FzZSh0aGlzLmNlbGxDbGFzcyl9YDtcbiAgICAgIHRoaXMuZ3JpZCA9IHRoaXMuZWxlbWVudDtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMubmFtZSwgJ2RhdGVwaWNrZXItZ3JpZCcsICd3LTY0JywgJ2dyaWQnLCAnZ3JpZC1jb2xzLTQnKTtcbiAgICAgIHRoaXMuZ3JpZC5hcHBlbmRDaGlsZChwYXJzZUhUTUwoKDAsdXRpbHMvKiBjcmVhdGVUYWdSZXBlYXQgKi8uZW0pKCdzcGFuJywgMTIpKSk7XG4gICAgfVxuICAgIHN1cGVyLmluaXQob3B0aW9ucyk7XG4gIH1cblxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoKDAsdXRpbHMvKiBoYXNQcm9wZXJ0eSAqLy5sJCkob3B0aW9ucywgJ21pbkRhdGUnKSkge1xuICAgICAgaWYgKG9wdGlvbnMubWluRGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWluWWVhciA9IHRoaXMubWluRGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWluWWVhciA9ICgwLGxpYl9kYXRlLyogc3RhcnRPZlllYXJQZXJpb2QgKi8uYWspKG9wdGlvbnMubWluRGF0ZSwgdGhpcy5zdGVwKTtcbiAgICAgICAgdGhpcy5taW5EYXRlID0gKDAsbGliX2RhdGUvKiBkYXRlVmFsdWUgKi8uYnkpKHRoaXMubWluWWVhciwgMCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoMCx1dGlscy8qIGhhc1Byb3BlcnR5ICovLmwkKShvcHRpb25zLCAnbWF4RGF0ZScpKSB7XG4gICAgICBpZiAob3B0aW9ucy5tYXhEYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5tYXhZZWFyID0gdGhpcy5tYXhEYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXhZZWFyID0gKDAsbGliX2RhdGUvKiBzdGFydE9mWWVhclBlcmlvZCAqLy5haykob3B0aW9ucy5tYXhEYXRlLCB0aGlzLnN0ZXApO1xuICAgICAgICB0aGlzLm1heERhdGUgPSAoMCxsaWJfZGF0ZS8qIGRhdGVWYWx1ZSAqLy5ieSkodGhpcy5tYXhZZWFyLCAxMSwgMzEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9uc1t0aGlzLmJlZm9yZVNob3dPcHRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGJlZm9yZVNob3cgPSBvcHRpb25zW3RoaXMuYmVmb3JlU2hvd09wdGlvbl07XG4gICAgICB0aGlzLmJlZm9yZVNob3cgPSB0eXBlb2YgYmVmb3JlU2hvdyA9PT0gJ2Z1bmN0aW9uJyA/IGJlZm9yZVNob3cgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIHZpZXcncyBzZXR0aW5ncyB0byByZWZsZWN0IHRoZSB2aWV3RGF0ZSBzZXQgb24gdGhlIHBpY2tlclxuICB1cGRhdGVGb2N1cygpIHtcbiAgICBjb25zdCB2aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMucGlja2VyLnZpZXdEYXRlKTtcbiAgICBjb25zdCBmaXJzdCA9ICgwLGxpYl9kYXRlLyogc3RhcnRPZlllYXJQZXJpb2QgKi8uYWspKHZpZXdEYXRlLCB0aGlzLm5hdlN0ZXApO1xuICAgIGNvbnN0IGxhc3QgPSBmaXJzdCArIDkgKiB0aGlzLnN0ZXA7XG5cbiAgICB0aGlzLmZpcnN0ID0gZmlyc3Q7XG4gICAgdGhpcy5sYXN0ID0gbGFzdDtcbiAgICB0aGlzLnN0YXJ0ID0gZmlyc3QgLSB0aGlzLnN0ZXA7XG4gICAgdGhpcy5mb2N1c2VkID0gKDAsbGliX2RhdGUvKiBzdGFydE9mWWVhclBlcmlvZCAqLy5haykodmlld0RhdGUsIHRoaXMuc3RlcCk7XG4gIH1cblxuICAvLyBVcGRhdGUgdmlldydzIHNldHRpbmdzIHRvIHJlZmxlY3QgdGhlIHNlbGVjdGVkIGRhdGVzXG4gIHVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7ZGF0ZXMsIHJhbmdlcGlja2VyfSA9IHRoaXMucGlja2VyLmRhdGVwaWNrZXI7XG4gICAgdGhpcy5zZWxlY3RlZCA9IGRhdGVzLnJlZHVjZSgoeWVhcnMsIHRpbWVWYWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuICgwLHV0aWxzLyogcHVzaFVuaXF1ZSAqLy4kQykoeWVhcnMsICgwLGxpYl9kYXRlLyogc3RhcnRPZlllYXJQZXJpb2QgKi8uYWspKHRpbWVWYWx1ZSwgdGhpcy5zdGVwKSk7XG4gICAgfSwgW10pO1xuICAgIGlmIChyYW5nZXBpY2tlciAmJiByYW5nZXBpY2tlci5kYXRlcykge1xuICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlcGlja2VyLmRhdGVzLm1hcCh0aW1lVmFsdWUgPT4ge1xuICAgICAgICBpZiAodGltZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gKDAsbGliX2RhdGUvKiBzdGFydE9mWWVhclBlcmlvZCAqLy5haykodGltZVZhbHVlLCB0aGlzLnN0ZXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIGVudGlyZSB2aWV3IFVJXG4gIHJlbmRlcigpIHtcbiAgICAvLyByZWZyZXNoIGRpc2FibGVkIHllYXJzIG9uIGV2ZXJ5IHJlbmRlciBpbiBvcmRlciB0byBjbGVhciB0aGUgb25lcyBhZGRlZFxuICAgIC8vIGJ5IGJlZm9yZVNob3cgaG9vayBhdCBwcmV2aW91cyByZW5kZXJcbiAgICB0aGlzLmRpc2FibGVkID0gW107XG5cbiAgICB0aGlzLnBpY2tlci5zZXRWaWV3U3dpdGNoTGFiZWwoYCR7dGhpcy5maXJzdH0tJHt0aGlzLmxhc3R9YCk7XG4gICAgdGhpcy5waWNrZXIuc2V0UHJldkJ0bkRpc2FibGVkKHRoaXMuZmlyc3QgPD0gdGhpcy5taW5ZZWFyKTtcbiAgICB0aGlzLnBpY2tlci5zZXROZXh0QnRuRGlzYWJsZWQodGhpcy5sYXN0ID49IHRoaXMubWF4WWVhcik7XG5cbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5zdGFydCArIChpbmRleCAqIHRoaXMuc3RlcCk7XG4gICAgICBjb25zdCBkYXRlID0gKDAsbGliX2RhdGUvKiBkYXRlVmFsdWUgKi8uYnkpKGN1cnJlbnQsIDAsIDEpO1xuXG4gICAgICBlbC5jbGFzc05hbWUgPSBgZGF0ZXBpY2tlci1jZWxsIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1wb2ludGVyIHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSAke3RoaXMuY2VsbENsYXNzfWA7XG4gICAgICBpZiAodGhpcy5pc01pblZpZXcpIHtcbiAgICAgICAgZWwuZGF0YXNldC5kYXRlID0gZGF0ZTtcbiAgICAgIH1cbiAgICAgIGVsLnRleHRDb250ZW50ID0gZWwuZGF0YXNldC55ZWFyID0gY3VycmVudDtcblxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3ByZXYnKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDExKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ25leHQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50IDwgdGhpcy5taW5ZZWFyIHx8IGN1cnJlbnQgPiB0aGlzLm1heFllYXIpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJhbmdlKSB7XG4gICAgICAgIGNvbnN0IFtyYW5nZVN0YXJ0LCByYW5nZUVuZF0gPSB0aGlzLnJhbmdlO1xuICAgICAgICBpZiAoY3VycmVudCA+IHJhbmdlU3RhcnQgJiYgY3VycmVudCA8IHJhbmdlRW5kKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VTdGFydCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLXN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlRW5kKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZm9jdXNlZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJlZm9yZVNob3cpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtQmVmb3JlSG9vayhlbCwgY3VycmVudCwgZGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZXMgb2Ygc2VsZWN0ZWQgYW5kIGZvY3VzZWQgaXRlbXNcbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCBbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdID0gdGhpcy5yYW5nZSB8fCBbXTtcbiAgICB0aGlzLmdyaWRcbiAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCcucmFuZ2UsIC5yYW5nZS1zdGFydCwgLnJhbmdlLWVuZCwgLnNlbGVjdGVkLCAuZm9jdXNlZCcpXG4gICAgICAuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UnLCAncmFuZ2Utc3RhcnQnLCAncmFuZ2UtZW5kJywgJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZm9jdXNlZCcpO1xuICAgICAgfSk7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmdyaWQuY2hpbGRyZW4pLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gTnVtYmVyKGVsLnRleHRDb250ZW50KTtcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcbiAgICAgIGlmIChjdXJyZW50ID4gcmFuZ2VTdGFydCAmJiBjdXJyZW50IDwgcmFuZ2VFbmQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLXN0YXJ0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtZ3JheS05MDAnLCAnaG92ZXI6YmctZ3JheS0xMDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ2Rhcms6aG92ZXI6YmctZ3JheS02MDAnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2Ugb2YgZm9jdXNlZCBpdGVtXG4gIHJlZnJlc2hGb2N1cygpIHtcbiAgICBjb25zdCBpbmRleCA9IE1hdGgucm91bmQoKHRoaXMuZm9jdXNlZCAtIHRoaXMuc3RhcnQpIC8gdGhpcy5zdGVwKTtcbiAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmZvY3VzZWQnKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXNlZCcpO1xuICAgIH0pO1xuICAgIHRoaXMuZ3JpZC5jaGlsZHJlbltpbmRleF0uY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL2V2ZW50cy9mdW5jdGlvbnMuanNcblxuXG5cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQoZGF0ZXBpY2tlciwgdHlwZSkge1xuICBjb25zdCBkZXRhaWwgPSB7XG4gICAgZGF0ZTogZGF0ZXBpY2tlci5nZXREYXRlKCksXG4gICAgdmlld0RhdGU6IG5ldyBEYXRlKGRhdGVwaWNrZXIucGlja2VyLnZpZXdEYXRlKSxcbiAgICB2aWV3SWQ6IGRhdGVwaWNrZXIucGlja2VyLmN1cnJlbnRWaWV3LmlkLFxuICAgIGRhdGVwaWNrZXIsXG4gIH07XG4gIGRhdGVwaWNrZXIuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCh0eXBlLCB7ZGV0YWlsfSkpO1xufVxuXG4vLyBkaXJlY3Rpb246IC0xICh0byBwcmV2aW91cyksIDEgKHRvIG5leHQpXG5mdW5jdGlvbiBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCBkaXJlY3Rpb24pIHtcbiAgY29uc3Qge21pbkRhdGUsIG1heERhdGV9ID0gZGF0ZXBpY2tlci5jb25maWc7XG4gIGNvbnN0IHtjdXJyZW50Vmlldywgdmlld0RhdGV9ID0gZGF0ZXBpY2tlci5waWNrZXI7XG4gIGxldCBuZXdWaWV3RGF0ZTtcbiAgc3dpdGNoIChjdXJyZW50Vmlldy5pZCkge1xuICAgIGNhc2UgMDpcbiAgICAgIG5ld1ZpZXdEYXRlID0gKDAsbGliX2RhdGUvKiBhZGRNb250aHMgKi8uekkpKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgbmV3Vmlld0RhdGUgPSAoMCxsaWJfZGF0ZS8qIGFkZFllYXJzICovLkJjKSh2aWV3RGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBuZXdWaWV3RGF0ZSA9ICgwLGxpYl9kYXRlLyogYWRkWWVhcnMgKi8uQmMpKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiBjdXJyZW50Vmlldy5uYXZTdGVwKTtcbiAgfVxuICBuZXdWaWV3RGF0ZSA9ICgwLHV0aWxzLyogbGltaXRUb1JhbmdlICovLmpHKShuZXdWaWV3RGF0ZSwgbWluRGF0ZSwgbWF4RGF0ZSk7XG4gIGRhdGVwaWNrZXIucGlja2VyLmNoYW5nZUZvY3VzKG5ld1ZpZXdEYXRlKS5yZW5kZXIoKTtcbn1cblxuZnVuY3Rpb24gc3dpdGNoVmlldyhkYXRlcGlja2VyKSB7XG4gIGNvbnN0IHZpZXdJZCA9IGRhdGVwaWNrZXIucGlja2VyLmN1cnJlbnRWaWV3LmlkO1xuICBpZiAodmlld0lkID09PSBkYXRlcGlja2VyLmNvbmZpZy5tYXhWaWV3KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRhdGVwaWNrZXIucGlja2VyLmNoYW5nZVZpZXcodmlld0lkICsgMSkucmVuZGVyKCk7XG59XG5cbmZ1bmN0aW9uIHVuZm9jdXMoZGF0ZXBpY2tlcikge1xuICBpZiAoZGF0ZXBpY2tlci5jb25maWcudXBkYXRlT25CbHVyKSB7XG4gICAgZGF0ZXBpY2tlci51cGRhdGUoe2F1dG9oaWRlOiB0cnVlfSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0ZXBpY2tlci5yZWZyZXNoKCdpbnB1dCcpO1xuICAgIGRhdGVwaWNrZXIuaGlkZSgpO1xuICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL2V2ZW50cy9waWNrZXJMaXN0ZW5lcnMuanNcblxuXG5cblxuZnVuY3Rpb24gZ29Ub1NlbGVjdGVkTW9udGhPclllYXIoZGF0ZXBpY2tlciwgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyO1xuICBjb25zdCB2aWV3RGF0ZSA9IG5ldyBEYXRlKHBpY2tlci52aWV3RGF0ZSk7XG4gIGNvbnN0IHZpZXdJZCA9IHBpY2tlci5jdXJyZW50Vmlldy5pZDtcbiAgY29uc3QgbmV3RGF0ZSA9IHZpZXdJZCA9PT0gMVxuICAgID8gKDAsbGliX2RhdGUvKiBhZGRNb250aHMgKi8uekkpKHZpZXdEYXRlLCBzZWxlY3Rpb24gLSB2aWV3RGF0ZS5nZXRNb250aCgpKVxuICAgIDogKDAsbGliX2RhdGUvKiBhZGRZZWFycyAqLy5CYykodmlld0RhdGUsIHNlbGVjdGlvbiAtIHZpZXdEYXRlLmdldEZ1bGxZZWFyKCkpO1xuXG4gIHBpY2tlci5jaGFuZ2VGb2N1cyhuZXdEYXRlKS5jaGFuZ2VWaWV3KHZpZXdJZCAtIDEpLnJlbmRlcigpO1xufVxuXG5mdW5jdGlvbiBvbkNsaWNrVG9kYXlCdG4oZGF0ZXBpY2tlcikge1xuICBjb25zdCBwaWNrZXIgPSBkYXRlcGlja2VyLnBpY2tlcjtcbiAgY29uc3QgY3VycmVudERhdGUgPSAoMCxsaWJfZGF0ZS8qIHRvZGF5ICovLkxnKSgpO1xuICBpZiAoZGF0ZXBpY2tlci5jb25maWcudG9kYXlCdG5Nb2RlID09PSAxKSB7XG4gICAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLmF1dG9oaWRlKSB7XG4gICAgICBkYXRlcGlja2VyLnNldERhdGUoY3VycmVudERhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRlcGlja2VyLnNldERhdGUoY3VycmVudERhdGUsIHtyZW5kZXI6IGZhbHNlfSk7XG4gICAgcGlja2VyLnVwZGF0ZSgpO1xuICB9XG4gIGlmIChwaWNrZXIudmlld0RhdGUgIT09IGN1cnJlbnREYXRlKSB7XG4gICAgcGlja2VyLmNoYW5nZUZvY3VzKGN1cnJlbnREYXRlKTtcbiAgfVxuICBwaWNrZXIuY2hhbmdlVmlldygwKS5yZW5kZXIoKTtcbn1cblxuZnVuY3Rpb24gb25DbGlja0NsZWFyQnRuKGRhdGVwaWNrZXIpIHtcbiAgZGF0ZXBpY2tlci5zZXREYXRlKHtjbGVhcjogdHJ1ZX0pO1xufVxuXG5mdW5jdGlvbiBvbkNsaWNrVmlld1N3aXRjaChkYXRlcGlja2VyKSB7XG4gIHN3aXRjaFZpZXcoZGF0ZXBpY2tlcik7XG59XG5cbmZ1bmN0aW9uIG9uQ2xpY2tQcmV2QnRuKGRhdGVwaWNrZXIpIHtcbiAgZ29Ub1ByZXZPck5leHQoZGF0ZXBpY2tlciwgLTEpO1xufVxuXG5mdW5jdGlvbiBvbkNsaWNrTmV4dEJ0bihkYXRlcGlja2VyKSB7XG4gIGdvVG9QcmV2T3JOZXh0KGRhdGVwaWNrZXIsIDEpO1xufVxuXG4vLyBGb3IgdGhlIHBpY2tlcidzIG1haW4gYmxvY2sgdG8gZGVsZWdldGUgdGhlIGV2ZW50cyBmcm9tIGBkYXRlcGlja2VyLWNlbGxgc1xuZnVuY3Rpb24gb25DbGlja1ZpZXcoZGF0ZXBpY2tlciwgZXYpIHtcbiAgY29uc3QgdGFyZ2V0ID0gKDAsbGliX2V2ZW50LyogZmluZEVsZW1lbnRJbkV2ZW50UGF0aCAqLy5IZSkoZXYsICcuZGF0ZXBpY2tlci1jZWxsJyk7XG4gIGlmICghdGFyZ2V0IHx8IHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2Rpc2FibGVkJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7aWQsIGlzTWluVmlld30gPSBkYXRlcGlja2VyLnBpY2tlci5jdXJyZW50VmlldztcbiAgaWYgKGlzTWluVmlldykge1xuICAgIGRhdGVwaWNrZXIuc2V0RGF0ZShOdW1iZXIodGFyZ2V0LmRhdGFzZXQuZGF0ZSkpO1xuICB9IGVsc2UgaWYgKGlkID09PSAxKSB7XG4gICAgZ29Ub1NlbGVjdGVkTW9udGhPclllYXIoZGF0ZXBpY2tlciwgTnVtYmVyKHRhcmdldC5kYXRhc2V0Lm1vbnRoKSk7XG4gIH0gZWxzZSB7XG4gICAgZ29Ub1NlbGVjdGVkTW9udGhPclllYXIoZGF0ZXBpY2tlciwgTnVtYmVyKHRhcmdldC5kYXRhc2V0LnllYXIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNsaWNrUGlja2VyKGRhdGVwaWNrZXIpIHtcbiAgaWYgKCFkYXRlcGlja2VyLmlubGluZSAmJiAhZGF0ZXBpY2tlci5jb25maWcuZGlzYWJsZVRvdWNoS2V5Ym9hcmQpIHtcbiAgICBkYXRlcGlja2VyLmlucHV0RmllbGQuZm9jdXMoKTtcbiAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9waWNrZXIvUGlja2VyLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gcHJvY2Vzc1BpY2tlck9wdGlvbnMocGlja2VyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy50aXRsZSkge1xuICAgICAgcGlja2VyLmNvbnRyb2xzLnRpdGxlLnRleHRDb250ZW50ID0gb3B0aW9ucy50aXRsZTtcbiAgICAgIHNob3dFbGVtZW50KHBpY2tlci5jb250cm9scy50aXRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpY2tlci5jb250cm9scy50aXRsZS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgaGlkZUVsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRpdGxlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJldkFycm93KSB7XG4gICAgY29uc3QgcHJldkJ0biA9IHBpY2tlci5jb250cm9scy5wcmV2QnRuO1xuICAgIGVtcHR5Q2hpbGROb2RlcyhwcmV2QnRuKTtcbiAgICBvcHRpb25zLnByZXZBcnJvdy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBwcmV2QnRuLmFwcGVuZENoaWxkKG5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9KTtcbiAgfVxuICBpZiAob3B0aW9ucy5uZXh0QXJyb3cpIHtcbiAgICBjb25zdCBuZXh0QnRuID0gcGlja2VyLmNvbnRyb2xzLm5leHRCdG47XG4gICAgZW1wdHlDaGlsZE5vZGVzKG5leHRCdG4pO1xuICAgIG9wdGlvbnMubmV4dEFycm93LmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5leHRCdG4uYXBwZW5kQ2hpbGQobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIH0pO1xuICB9XG4gIGlmIChvcHRpb25zLmxvY2FsZSkge1xuICAgIHBpY2tlci5jb250cm9scy50b2RheUJ0bi50ZXh0Q29udGVudCA9IG9wdGlvbnMubG9jYWxlLnRvZGF5O1xuICAgIHBpY2tlci5jb250cm9scy5jbGVhckJ0bi50ZXh0Q29udGVudCA9IG9wdGlvbnMubG9jYWxlLmNsZWFyO1xuICB9XG4gIGlmIChvcHRpb25zLnRvZGF5QnRuICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy50b2RheUJ0bikge1xuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRvZGF5QnRuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZUVsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRvZGF5QnRuKTtcbiAgICB9XG4gIH1cbiAgaWYgKCgwLHV0aWxzLyogaGFzUHJvcGVydHkgKi8ubCQpKG9wdGlvbnMsICdtaW5EYXRlJykgfHwgKDAsdXRpbHMvKiBoYXNQcm9wZXJ0eSAqLy5sJCkob3B0aW9ucywgJ21heERhdGUnKSkge1xuICAgIGNvbnN0IHttaW5EYXRlLCBtYXhEYXRlfSA9IHBpY2tlci5kYXRlcGlja2VyLmNvbmZpZztcbiAgICBwaWNrZXIuY29udHJvbHMudG9kYXlCdG4uZGlzYWJsZWQgPSAhKDAsdXRpbHMvKiBpc0luUmFuZ2UgKi8ubWgpKCgwLGxpYl9kYXRlLyogdG9kYXkgKi8uTGcpKCksIG1pbkRhdGUsIG1heERhdGUpO1xuICB9XG4gIGlmIChvcHRpb25zLmNsZWFyQnRuICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5jbGVhckJ0bikge1xuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLmNsZWFyQnRuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZUVsZW1lbnQocGlja2VyLmNvbnRyb2xzLmNsZWFyQnRuKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQ29tcHV0ZSB2aWV3IGRhdGUgdG8gcmVzZXQsIHdoaWNoIHdpbGwgYmUuLi5cbi8vIC0gdGhlIGxhc3QgaXRlbSBvZiB0aGUgc2VsZWN0ZWQgZGF0ZXMgb3IgZGVmYXVsdFZpZXdEYXRlIGlmIG5vIHNlbGVjdGlvblxuLy8gLSBsaW1pdHRlZCB0byBtaW5EYXRlIG9yIG1heERhdGUgaWYgaXQgZXhjZWVkcyB0aGUgcmFuZ2VcbmZ1bmN0aW9uIGNvbXB1dGVSZXNldFZpZXdEYXRlKGRhdGVwaWNrZXIpIHtcbiAgY29uc3Qge2RhdGVzLCBjb25maWd9ID0gZGF0ZXBpY2tlcjtcbiAgY29uc3Qgdmlld0RhdGUgPSBkYXRlcy5sZW5ndGggPiAwID8gKDAsdXRpbHMvKiBsYXN0SXRlbU9mICovLkptKShkYXRlcykgOiBjb25maWcuZGVmYXVsdFZpZXdEYXRlO1xuICByZXR1cm4gKDAsdXRpbHMvKiBsaW1pdFRvUmFuZ2UgKi8uakcpKHZpZXdEYXRlLCBjb25maWcubWluRGF0ZSwgY29uZmlnLm1heERhdGUpO1xufVxuXG4vLyBDaGFuZ2UgY3VycmVudCB2aWV3J3MgdmlldyBkYXRlXG5mdW5jdGlvbiBzZXRWaWV3RGF0ZShwaWNrZXIsIG5ld0RhdGUpIHtcbiAgY29uc3Qgb2xkVmlld0RhdGUgPSBuZXcgRGF0ZShwaWNrZXIudmlld0RhdGUpO1xuICBjb25zdCBuZXdWaWV3RGF0ZSA9IG5ldyBEYXRlKG5ld0RhdGUpO1xuICBjb25zdCB7aWQsIHllYXIsIGZpcnN0LCBsYXN0fSA9IHBpY2tlci5jdXJyZW50VmlldztcbiAgY29uc3Qgdmlld1llYXIgPSBuZXdWaWV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gIHBpY2tlci52aWV3RGF0ZSA9IG5ld0RhdGU7XG4gIGlmICh2aWV3WWVhciAhPT0gb2xkVmlld0RhdGUuZ2V0RnVsbFllYXIoKSkge1xuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQocGlja2VyLmRhdGVwaWNrZXIsICdjaGFuZ2VZZWFyJyk7XG4gIH1cbiAgaWYgKG5ld1ZpZXdEYXRlLmdldE1vbnRoKCkgIT09IG9sZFZpZXdEYXRlLmdldE1vbnRoKCkpIHtcbiAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHBpY2tlci5kYXRlcGlja2VyLCAnY2hhbmdlTW9udGgnKTtcbiAgfVxuXG4gIC8vIHJldHVybiB3aGV0aGVyIHRoZSBuZXcgZGF0ZSBpcyBpbiBkaWZmZXJlbnQgcGVyaW9kIG9uIHRpbWUgZnJvbSB0aGUgb25lXG4gIC8vIGRpc3BsYXllZCBpbiB0aGUgY3VycmVudCB2aWV3XG4gIC8vIHdoZW4gdHJ1ZSwgdGhlIHZpZXcgbmVlZHMgdG8gYmUgcmUtcmVuZGVyZWQgb24gdGhlIG5leHQgVUkgcmVmcmVzaC5cbiAgc3dpdGNoIChpZCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBuZXdEYXRlIDwgZmlyc3QgfHwgbmV3RGF0ZSA+IGxhc3Q7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHZpZXdZZWFyICE9PSB5ZWFyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmlld1llYXIgPCBmaXJzdCB8fCB2aWV3WWVhciA+IGxhc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGV4dERpcmVjdGlvbihlbCkge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpcmVjdGlvbjtcbn1cblxuLy8gQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBwaWNrZXIgVUlcbmNsYXNzIFBpY2tlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGVwaWNrZXIpIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIgPSBkYXRlcGlja2VyO1xuXG4gICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZXNfcGlja2VyVGVtcGxhdGUucmVwbGFjZSgvJWJ1dHRvbkNsYXNzJS9nLCBkYXRlcGlja2VyLmNvbmZpZy5idXR0b25DbGFzcyk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudCA9IHBhcnNlSFRNTCh0ZW1wbGF0ZSkuZmlyc3RDaGlsZDtcbiAgICBjb25zdCBbaGVhZGVyLCBtYWluLCBmb290ZXJdID0gZWxlbWVudC5maXJzdENoaWxkLmNoaWxkcmVuO1xuICAgIGNvbnN0IHRpdGxlID0gaGVhZGVyLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIGNvbnN0IFtwcmV2QnRuLCB2aWV3U3dpdGNoLCBuZXh0QnRuXSA9IGhlYWRlci5sYXN0RWxlbWVudENoaWxkLmNoaWxkcmVuO1xuICAgIGNvbnN0IFt0b2RheUJ0biwgY2xlYXJCdG5dID0gZm9vdGVyLmZpcnN0Q2hpbGQuY2hpbGRyZW47XG4gICAgY29uc3QgY29udHJvbHMgPSB7XG4gICAgICB0aXRsZSxcbiAgICAgIHByZXZCdG4sXG4gICAgICB2aWV3U3dpdGNoLFxuICAgICAgbmV4dEJ0bixcbiAgICAgIHRvZGF5QnRuLFxuICAgICAgY2xlYXJCdG4sXG4gICAgfTtcbiAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcblxuICAgIGNvbnN0IGVsZW1lbnRDbGFzcyA9IGRhdGVwaWNrZXIuaW5saW5lID8gJ2lubGluZScgOiAnZHJvcGRvd24nO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChgZGF0ZXBpY2tlci0ke2VsZW1lbnRDbGFzc31gKTtcbiAgICBlbGVtZW50Q2xhc3MgPT09ICdkcm9wZG93bicgPyBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2Ryb3Bkb3duJywgJ2Fic29sdXRlJywgJ3RvcC0wJywgJ2xlZnQtMCcsICd6LTUwJywgJ3B0LTInKSA6IG51bGw7XG5cbiAgICBwcm9jZXNzUGlja2VyT3B0aW9ucyh0aGlzLCBkYXRlcGlja2VyLmNvbmZpZyk7XG4gICAgdGhpcy52aWV3RGF0ZSA9IGNvbXB1dGVSZXNldFZpZXdEYXRlKGRhdGVwaWNrZXIpO1xuXG4gICAgLy8gc2V0IHVwIGV2ZW50IGxpc3RlbmVyc1xuICAgICgwLGxpYl9ldmVudC8qIHJlZ2lzdGVyTGlzdGVuZXJzICovLmNGKShkYXRlcGlja2VyLCBbXG4gICAgICBbZWxlbWVudCwgJ2NsaWNrJywgb25DbGlja1BpY2tlci5iaW5kKG51bGwsIGRhdGVwaWNrZXIpLCB7Y2FwdHVyZTogdHJ1ZX1dLFxuICAgICAgW21haW4sICdjbGljaycsIG9uQ2xpY2tWaWV3LmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLFxuICAgICAgW2NvbnRyb2xzLnZpZXdTd2l0Y2gsICdjbGljaycsIG9uQ2xpY2tWaWV3U3dpdGNoLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLFxuICAgICAgW2NvbnRyb2xzLnByZXZCdG4sICdjbGljaycsIG9uQ2xpY2tQcmV2QnRuLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLFxuICAgICAgW2NvbnRyb2xzLm5leHRCdG4sICdjbGljaycsIG9uQ2xpY2tOZXh0QnRuLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLFxuICAgICAgW2NvbnRyb2xzLnRvZGF5QnRuLCAnY2xpY2snLCBvbkNsaWNrVG9kYXlCdG4uYmluZChudWxsLCBkYXRlcGlja2VyKV0sXG4gICAgICBbY29udHJvbHMuY2xlYXJCdG4sICdjbGljaycsIG9uQ2xpY2tDbGVhckJ0bi5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcbiAgICBdKTtcblxuICAgIC8vIHNldCB1cCB2aWV3c1xuICAgIHRoaXMudmlld3MgPSBbXG4gICAgICBuZXcgRGF5c1ZpZXcodGhpcyksXG4gICAgICBuZXcgTW9udGhzVmlldyh0aGlzKSxcbiAgICAgIG5ldyBZZWFyc1ZpZXcodGhpcywge2lkOiAyLCBuYW1lOiAneWVhcnMnLCBjZWxsQ2xhc3M6ICd5ZWFyJywgc3RlcDogMX0pLFxuICAgICAgbmV3IFllYXJzVmlldyh0aGlzLCB7aWQ6IDMsIG5hbWU6ICdkZWNhZGVzJywgY2VsbENsYXNzOiAnZGVjYWRlJywgc3RlcDogMTB9KSxcbiAgICBdO1xuICAgIHRoaXMuY3VycmVudFZpZXcgPSB0aGlzLnZpZXdzW2RhdGVwaWNrZXIuY29uZmlnLnN0YXJ0Vmlld107XG5cbiAgICB0aGlzLmN1cnJlbnRWaWV3LnJlbmRlcigpO1xuICAgIHRoaXMubWFpbi5hcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRWaWV3LmVsZW1lbnQpO1xuICAgIGRhdGVwaWNrZXIuY29uZmlnLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICB9XG5cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcHJvY2Vzc1BpY2tlck9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy52aWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICB2aWV3LmluaXQob3B0aW9ucywgZmFsc2UpO1xuICAgIH0pO1xuICAgIHRoaXMuY3VycmVudFZpZXcucmVuZGVyKCk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLmNvbmZpZy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnLCAnYmxvY2snKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuXG4gICAgY29uc3QgZGF0ZXBpY2tlciA9IHRoaXMuZGF0ZXBpY2tlcjtcbiAgICBpZiAoIWRhdGVwaWNrZXIuaW5saW5lKSB7XG4gICAgICAvLyBlbnN1cmUgcGlja2VyJ3MgZGlyZWN0aW9uIG1hdGNoZXMgaW5wdXQnc1xuICAgICAgY29uc3QgaW5wdXREaXJlY3Rpb24gPSBnZXRUZXh0RGlyZWN0aW9uKGRhdGVwaWNrZXIuaW5wdXRGaWVsZCk7XG4gICAgICBpZiAoaW5wdXREaXJlY3Rpb24gIT09IGdldFRleHREaXJlY3Rpb24oZGF0ZXBpY2tlci5jb25maWcuY29udGFpbmVyKSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuZGlyID0gaW5wdXREaXJlY3Rpb247XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWxlbWVudC5kaXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGlyJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGxhY2UoKTtcbiAgICAgIGlmIChkYXRlcGlja2VyLmNvbmZpZy5kaXNhYmxlVG91Y2hLZXlib2FyZCkge1xuICAgICAgICBkYXRlcGlja2VyLmlucHV0RmllbGQuYmx1cigpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KGRhdGVwaWNrZXIsICdzaG93Jyk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kYXRlcGlja2VyLmV4aXRFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnLCAnYmxvY2snKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJywgJ2Jsb2NrJywgJ2hpZGRlbicpO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdHJpZ2dlckRhdGVwaWNrZXJFdmVudCh0aGlzLmRhdGVwaWNrZXIsICdoaWRlJyk7XG4gIH1cblxuICBwbGFjZSgpIHtcbiAgICBjb25zdCB7Y2xhc3NMaXN0LCBzdHlsZX0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgY29uc3Qge2NvbmZpZywgaW5wdXRGaWVsZH0gPSB0aGlzLmRhdGVwaWNrZXI7XG4gICAgY29uc3QgY29udGFpbmVyID0gY29uZmlnLmNvbnRhaW5lcjtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogY2FsZW5kYXJXaWR0aCxcbiAgICAgIGhlaWdodDogY2FsZW5kYXJIZWlnaHQsXG4gICAgfSA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0OiBjb250YWluZXJMZWZ0LFxuICAgICAgdG9wOiBjb250YWluZXJUb3AsXG4gICAgICB3aWR0aDogY29udGFpbmVyV2lkdGgsXG4gICAgfSA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0OiBpbnB1dExlZnQsXG4gICAgICB0b3A6IGlucHV0VG9wLFxuICAgICAgd2lkdGg6IGlucHV0V2lkdGgsXG4gICAgICBoZWlnaHQ6IGlucHV0SGVpZ2h0XG4gICAgfSA9IGlucHV0RmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHt4OiBvcmllbnRYLCB5OiBvcmllbnRZfSA9IGNvbmZpZy5vcmllbnRhdGlvbjtcbiAgICBsZXQgc2Nyb2xsVG9wO1xuICAgIGxldCBsZWZ0O1xuICAgIGxldCB0b3A7XG5cbiAgICBpZiAoY29udGFpbmVyID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICBzY3JvbGxUb3AgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgIGxlZnQgPSBpbnB1dExlZnQgKyB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgIHRvcCA9IGlucHV0VG9wICsgc2Nyb2xsVG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGxUb3AgPSBjb250YWluZXIuc2Nyb2xsVG9wO1xuICAgICAgbGVmdCA9IGlucHV0TGVmdCAtIGNvbnRhaW5lckxlZnQ7XG4gICAgICB0b3AgPSBpbnB1dFRvcCAtIGNvbnRhaW5lclRvcCArIHNjcm9sbFRvcDtcbiAgICB9XG5cbiAgICBpZiAob3JpZW50WCA9PT0gJ2F1dG8nKSB7XG4gICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgLy8gYWxpZ24gdG8gdGhlIGxlZnQgYW5kIG1vdmUgaW50byB2aXNpYmxlIGFyZWEgaWYgaW5wdXQncyBsZWZ0IGVkZ2UgPCB3aW5kb3cnc1xuICAgICAgICBvcmllbnRYID0gJ2xlZnQnO1xuICAgICAgICBsZWZ0ID0gMTA7XG4gICAgICB9IGVsc2UgaWYgKGxlZnQgKyBjYWxlbmRhcldpZHRoID4gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgLy8gYWxpZ24gdG8gdGhlIHJpZ2h0IGlmIGNhbmxlbmRhcidzIHJpZ2h0IGVkZ2UgPiBjb250YWluZXInc1xuICAgICAgICBvcmllbnRYID0gJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9yaWVudFggPSBnZXRUZXh0RGlyZWN0aW9uKGlucHV0RmllbGQpID09PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcmllbnRYID09PSAncmlnaHQnKSB7XG4gICAgICBsZWZ0IC09IGNhbGVuZGFyV2lkdGggLSBpbnB1dFdpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcmllbnRZID09PSAnYXV0bycpIHtcbiAgICAgIG9yaWVudFkgPSB0b3AgLSBjYWxlbmRhckhlaWdodCA8IHNjcm9sbFRvcCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgfVxuICAgIGlmIChvcmllbnRZID09PSAndG9wJykge1xuICAgICAgdG9wIC09IGNhbGVuZGFySGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgKz0gaW5wdXRIZWlnaHQ7XG4gICAgfVxuXG4gICAgY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdkYXRlcGlja2VyLW9yaWVudC10b3AnLFxuICAgICAgJ2RhdGVwaWNrZXItb3JpZW50LWJvdHRvbScsXG4gICAgICAnZGF0ZXBpY2tlci1vcmllbnQtcmlnaHQnLFxuICAgICAgJ2RhdGVwaWNrZXItb3JpZW50LWxlZnQnXG4gICAgKTtcbiAgICBjbGFzc0xpc3QuYWRkKGBkYXRlcGlja2VyLW9yaWVudC0ke29yaWVudFl9YCwgYGRhdGVwaWNrZXItb3JpZW50LSR7b3JpZW50WH1gKTtcblxuICAgIHN0eWxlLnRvcCA9IHRvcCA/IGAke3RvcH1weGAgOiB0b3A7XG4gICAgc3R5bGUubGVmdCA9IGxlZnQgPyBgJHtsZWZ0fXB4YCA6IGxlZnQ7XG4gIH1cblxuICBzZXRWaWV3U3dpdGNoTGFiZWwobGFiZWxUZXh0KSB7XG4gICAgdGhpcy5jb250cm9scy52aWV3U3dpdGNoLnRleHRDb250ZW50ID0gbGFiZWxUZXh0O1xuICB9XG5cbiAgc2V0UHJldkJ0bkRpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgdGhpcy5jb250cm9scy5wcmV2QnRuLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gIH1cblxuICBzZXROZXh0QnRuRGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmNvbnRyb2xzLm5leHRCdG4uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgfVxuXG4gIGNoYW5nZVZpZXcodmlld0lkKSB7XG4gICAgY29uc3Qgb2xkVmlldyA9IHRoaXMuY3VycmVudFZpZXc7XG4gICAgY29uc3QgbmV3VmlldyA9ICB0aGlzLnZpZXdzW3ZpZXdJZF07XG4gICAgaWYgKG5ld1ZpZXcuaWQgIT09IG9sZFZpZXcuaWQpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcgPSBuZXdWaWV3O1xuICAgICAgdGhpcy5fcmVuZGVyTWV0aG9kID0gJ3JlbmRlcic7XG4gICAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHRoaXMuZGF0ZXBpY2tlciwgJ2NoYW5nZVZpZXcnKTtcbiAgICAgIHRoaXMubWFpbi5yZXBsYWNlQ2hpbGQobmV3Vmlldy5lbGVtZW50LCBvbGRWaWV3LmVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIENoYW5nZSB0aGUgZm9jdXNlZCBkYXRlICh2aWV3IGRhdGUpXG4gIGNoYW5nZUZvY3VzKG5ld1ZpZXdEYXRlKSB7XG4gICAgdGhpcy5fcmVuZGVyTWV0aG9kID0gc2V0Vmlld0RhdGUodGhpcywgbmV3Vmlld0RhdGUpID8gJ3JlbmRlcicgOiAncmVmcmVzaEZvY3VzJztcbiAgICB0aGlzLnZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgIHZpZXcudXBkYXRlRm9jdXMoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEFwcGx5IHRoZSBjaGFuZ2Ugb2YgdGhlIHNlbGVjdGVkIGRhdGVzXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBuZXdWaWV3RGF0ZSA9IGNvbXB1dGVSZXNldFZpZXdEYXRlKHRoaXMuZGF0ZXBpY2tlcik7XG4gICAgdGhpcy5fcmVuZGVyTWV0aG9kID0gc2V0Vmlld0RhdGUodGhpcywgbmV3Vmlld0RhdGUpID8gJ3JlbmRlcicgOiAncmVmcmVzaCc7XG4gICAgdGhpcy52aWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICB2aWV3LnVwZGF0ZUZvY3VzKCk7XG4gICAgICB2aWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gUmVmcmVzaCB0aGUgcGlja2VyIFVJXG4gIHJlbmRlcihxdWlja1JlbmRlciA9IHRydWUpIHtcbiAgICBjb25zdCByZW5kZXJNZXRob2QgPSAocXVpY2tSZW5kZXIgJiYgdGhpcy5fcmVuZGVyTWV0aG9kKSB8fCAncmVuZGVyJztcbiAgICBkZWxldGUgdGhpcy5fcmVuZGVyTWV0aG9kO1xuXG4gICAgdGhpcy5jdXJyZW50Vmlld1tyZW5kZXJNZXRob2RdKCk7XG4gIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvZXZlbnRzL2lucHV0RmllbGRMaXN0ZW5lcnMuanNcblxuXG5cblxuLy8gRmluZCB0aGUgY2xvc2VzdCBkYXRlIHRoYXQgZG9lc24ndCBtZWV0IHRoZSBjb25kaXRpb24gZm9yIHVuYXZhaWxhYmxlIGRhdGVcbi8vIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vIGF2YWlsYWJsZSBkYXRlIGlzIGZvdW5kXG4vLyBhZGRGbjogZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBuZXh0IGRhdGVcbi8vICAgLSBhcmdzOiB0aW1lIHZhbHVlLCBhbW91bnRcbi8vIGluY3JlYXNlOiBhbW91bnQgdG8gcGFzcyB0byBhZGRGblxuLy8gdGVzdEZuOiBmdW5jdGlvbiB0byB0ZXN0IHRoZSB1bmF2YWlsYWJsaXR5IG9mIHRoZSBkYXRlXG4vLyAgIC0gYXJnczogdGltZSB2YWx1ZTsgcmV0dW46IHRydWUgaWYgdW5hdmFpbGFibGVcbmZ1bmN0aW9uIGZpbmROZXh0QXZhaWxhYmxlT25lKGRhdGUsIGFkZEZuLCBpbmNyZWFzZSwgdGVzdEZuLCBtaW4sIG1heCkge1xuICBpZiAoISgwLHV0aWxzLyogaXNJblJhbmdlICovLm1oKShkYXRlLCBtaW4sIG1heCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRlc3RGbihkYXRlKSkge1xuICAgIGNvbnN0IG5ld0RhdGUgPSBhZGRGbihkYXRlLCBpbmNyZWFzZSk7XG4gICAgcmV0dXJuIGZpbmROZXh0QXZhaWxhYmxlT25lKG5ld0RhdGUsIGFkZEZuLCBpbmNyZWFzZSwgdGVzdEZuLCBtaW4sIG1heCk7XG4gIH1cbiAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIGRpcmVjdGlvbjogLTEgKGxlZnQvdXApLCAxIChyaWdodC9kb3duKVxuLy8gdmVydGljYWw6IHRydWUgZm9yIHVwL2Rvd24sIGZhbHNlIGZvciBsZWZ0L3JpZ2h0XG5mdW5jdGlvbiBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgZGlyZWN0aW9uLCB2ZXJ0aWNhbCkge1xuICBjb25zdCBwaWNrZXIgPSBkYXRlcGlja2VyLnBpY2tlcjtcbiAgY29uc3QgY3VycmVudFZpZXcgPSBwaWNrZXIuY3VycmVudFZpZXc7XG4gIGNvbnN0IHN0ZXAgPSBjdXJyZW50Vmlldy5zdGVwIHx8IDE7XG4gIGxldCB2aWV3RGF0ZSA9IHBpY2tlci52aWV3RGF0ZTtcbiAgbGV0IGFkZEZuO1xuICBsZXQgdGVzdEZuO1xuICBzd2l0Y2ggKGN1cnJlbnRWaWV3LmlkKSB7XG4gICAgY2FzZSAwOlxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIHZpZXdEYXRlID0gKDAsbGliX2RhdGUvKiBhZGREYXlzICovLkU0KSh2aWV3RGF0ZSwgZGlyZWN0aW9uICogNyk7XG4gICAgICB9IGVsc2UgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICB2aWV3RGF0ZSA9ICgwLGxpYl9kYXRlLyogYWRkWWVhcnMgKi8uQmMpKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlld0RhdGUgPSAoMCxsaWJfZGF0ZS8qIGFkZERheXMgKi8uRTQpKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgfVxuICAgICAgYWRkRm4gPSBsaWJfZGF0ZS8qIGFkZERheXMgKi8uRTQ7XG4gICAgICB0ZXN0Rm4gPSAoZGF0ZSkgPT4gY3VycmVudFZpZXcuZGlzYWJsZWQuaW5jbHVkZXMoZGF0ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICB2aWV3RGF0ZSA9ICgwLGxpYl9kYXRlLyogYWRkTW9udGhzICovLnpJKSh2aWV3RGF0ZSwgdmVydGljYWwgPyBkaXJlY3Rpb24gKiA0IDogZGlyZWN0aW9uKTtcbiAgICAgIGFkZEZuID0gbGliX2RhdGUvKiBhZGRNb250aHMgKi8uekk7XG4gICAgICB0ZXN0Rm4gPSAoZGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBkdCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICBjb25zdCB7eWVhciwgZGlzYWJsZWR9ID0gY3VycmVudFZpZXc7XG4gICAgICAgIHJldHVybiBkdC5nZXRGdWxsWWVhcigpID09PSB5ZWFyICYmIGRpc2FibGVkLmluY2x1ZGVzKGR0LmdldE1vbnRoKCkpO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2aWV3RGF0ZSA9ICgwLGxpYl9kYXRlLyogYWRkWWVhcnMgKi8uQmMpKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiAodmVydGljYWwgPyA0IDogMSkgKiBzdGVwKTtcbiAgICAgIGFkZEZuID0gbGliX2RhdGUvKiBhZGRZZWFycyAqLy5CYztcbiAgICAgIHRlc3RGbiA9IGRhdGUgPT4gY3VycmVudFZpZXcuZGlzYWJsZWQuaW5jbHVkZXMoKDAsbGliX2RhdGUvKiBzdGFydE9mWWVhclBlcmlvZCAqLy5haykoZGF0ZSwgc3RlcCkpO1xuICB9XG4gIHZpZXdEYXRlID0gZmluZE5leHRBdmFpbGFibGVPbmUoXG4gICAgdmlld0RhdGUsXG4gICAgYWRkRm4sXG4gICAgZGlyZWN0aW9uIDwgMCA/IC1zdGVwIDogc3RlcCxcbiAgICB0ZXN0Rm4sXG4gICAgY3VycmVudFZpZXcubWluRGF0ZSxcbiAgICBjdXJyZW50Vmlldy5tYXhEYXRlXG4gICk7XG4gIGlmICh2aWV3RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGlja2VyLmNoYW5nZUZvY3VzKHZpZXdEYXRlKS5yZW5kZXIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbktleWRvd24oZGF0ZXBpY2tlciwgZXYpIHtcbiAgaWYgKGV2LmtleSA9PT0gJ1RhYicpIHtcbiAgICB1bmZvY3VzKGRhdGVwaWNrZXIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyO1xuICBjb25zdCB7aWQsIGlzTWluVmlld30gPSBwaWNrZXIuY3VycmVudFZpZXc7XG4gIGlmICghcGlja2VyLmFjdGl2ZSkge1xuICAgIHN3aXRjaCAoZXYua2V5KSB7XG4gICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgcGlja2VyLnNob3coKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgIGRhdGVwaWNrZXIudXBkYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRlcGlja2VyLmVkaXRNb2RlKSB7XG4gICAgc3dpdGNoIChldi5rZXkpIHtcbiAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgIHBpY2tlci5oaWRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICBkYXRlcGlja2VyLmV4aXRFZGl0TW9kZSh7dXBkYXRlOiB0cnVlLCBhdXRvaGlkZTogZGF0ZXBpY2tlci5jb25maWcuYXV0b2hpZGV9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAoZXYua2V5KSB7XG4gICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICBwaWNrZXIuaGlkZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgIGlmIChldi5jdHJsS2V5IHx8IGV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCAtMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYuc2hpZnRLZXkpIHtcbiAgICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW92ZUJ5QXJyb3dLZXkoZGF0ZXBpY2tlciwgZXYsIC0xLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICAgIGdvVG9QcmV2T3JOZXh0KGRhdGVwaWNrZXIsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vdmVCeUFycm93S2V5KGRhdGVwaWNrZXIsIGV2LCAxLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICAgIHN3aXRjaFZpZXcoZGF0ZXBpY2tlcik7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYuc2hpZnRLZXkpIHtcbiAgICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW92ZUJ5QXJyb3dLZXkoZGF0ZXBpY2tlciwgZXYsIC0xLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgIGlmIChldi5zaGlmdEtleSAmJiAhZXYuY3RybEtleSAmJiAhZXYubWV0YUtleSkge1xuICAgICAgICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgMSwgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICBpZiAoaXNNaW5WaWV3KSB7XG4gICAgICAgICAgZGF0ZXBpY2tlci5zZXREYXRlKHBpY2tlci52aWV3RGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGlja2VyLmNoYW5nZVZpZXcoaWQgLSAxKS5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0JhY2tzcGFjZSc6XG4gICAgICBjYXNlICdEZWxldGUnOlxuICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGV2LmtleS5sZW5ndGggPT09IDEgJiYgIWV2LmN0cmxLZXkgJiYgIWV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG5mdW5jdGlvbiBvbkZvY3VzKGRhdGVwaWNrZXIpIHtcbiAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLnNob3dPbkZvY3VzICYmICFkYXRlcGlja2VyLl9zaG93aW5nKSB7XG4gICAgZGF0ZXBpY2tlci5zaG93KCk7XG4gIH1cbn1cblxuLy8gZm9yIHRoZSBwcmV2ZW50aW9uIGZvciBlbnRlcmluZyBlZGl0IG1vZGUgd2hpbGUgZ2V0dGluZyBmb2N1cyBvbiBjbGlja1xuZnVuY3Rpb24gb25Nb3VzZWRvd24oZGF0ZXBpY2tlciwgZXYpIHtcbiAgY29uc3QgZWwgPSBldi50YXJnZXQ7XG4gIGlmIChkYXRlcGlja2VyLnBpY2tlci5hY3RpdmUgfHwgZGF0ZXBpY2tlci5jb25maWcuc2hvd09uQ2xpY2spIHtcbiAgICBlbC5fYWN0aXZlID0gZWwgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgZWwuX2NsaWNraW5nID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkZWxldGUgZWwuX2FjdGl2ZTtcbiAgICAgIGRlbGV0ZSBlbC5fY2xpY2tpbmc7XG4gICAgfSwgMjAwMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25DbGlja0lucHV0KGRhdGVwaWNrZXIsIGV2KSB7XG4gIGNvbnN0IGVsID0gZXYudGFyZ2V0O1xuICBpZiAoIWVsLl9jbGlja2luZykge1xuICAgIHJldHVybjtcbiAgfVxuICBjbGVhclRpbWVvdXQoZWwuX2NsaWNraW5nKTtcbiAgZGVsZXRlIGVsLl9jbGlja2luZztcblxuICBpZiAoZWwuX2FjdGl2ZSkge1xuICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICB9XG4gIGRlbGV0ZSBlbC5fYWN0aXZlO1xuXG4gIGlmIChkYXRlcGlja2VyLmNvbmZpZy5zaG93T25DbGljaykge1xuICAgIGRhdGVwaWNrZXIuc2hvdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uUGFzdGUoZGF0ZXBpY2tlciwgZXYpIHtcbiAgaWYgKGV2LmNsaXBib2FyZERhdGEudHlwZXMuaW5jbHVkZXMoJ3RleHQvcGxhaW4nKSkge1xuICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL2V2ZW50cy9vdGhlckxpc3RlbmVycy5qc1xuXG5cblxuLy8gZm9yIHRoZSBgZG9jdW1lbnRgIHRvIGRlbGVnYXRlIHRoZSBldmVudHMgZnJvbSBvdXRzaWRlIHRoZSBwaWNrZXIvaW5wdXQgZmllbGRcbmZ1bmN0aW9uIG9uQ2xpY2tPdXRzaWRlKGRhdGVwaWNrZXIsIGV2KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBkYXRlcGlja2VyLmVsZW1lbnQ7XG4gIGlmIChlbGVtZW50ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBpY2tlckVsZW0gPSBkYXRlcGlja2VyLnBpY2tlci5lbGVtZW50O1xuICBpZiAoKDAsbGliX2V2ZW50LyogZmluZEVsZW1lbnRJbkV2ZW50UGF0aCAqLy5IZSkoZXYsIGVsID0+IGVsID09PSBlbGVtZW50IHx8IGVsID09PSBwaWNrZXJFbGVtKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB1bmZvY3VzKGRhdGVwaWNrZXIpO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9EYXRlcGlja2VyLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBzdHJpbmdpZnlEYXRlcyhkYXRlcywgY29uZmlnKSB7XG4gIHJldHVybiBkYXRlc1xuICAgIC5tYXAoZHQgPT4gKDAsZGF0ZV9mb3JtYXQvKiBmb3JtYXREYXRlICovLnA2KShkdCwgY29uZmlnLmZvcm1hdCwgY29uZmlnLmxvY2FsZSkpXG4gICAgLmpvaW4oY29uZmlnLmRhdGVEZWxpbWl0ZXIpO1xufVxuXG4vLyBwYXJzZSBpbnB1dCBkYXRlcyBhbmQgY3JlYXRlIGFuIGFycmF5IG9mIHRpbWUgdmFsdWVzIGZvciBzZWxlY3Rpb25cbi8vIHJldHVybnMgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyB2YWxpZCBkYXRlcyBpbiBpbnB1dERhdGVzXG4vLyB3aGVuIG9yaWdEYXRlcyAoY3VycmVudCBzZWxlY3Rpb24pIGlzIHBhc3NlZCwgdGhlIGZ1bmN0aW9uIHdvcmtzIHRvIG1peFxuLy8gdGhlIGlucHV0IGRhdGVzIGludG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5mdW5jdGlvbiBwcm9jZXNzSW5wdXREYXRlcyhkYXRlcGlja2VyLCBpbnB1dERhdGVzLCBjbGVhciA9IGZhbHNlKSB7XG4gIGNvbnN0IHtjb25maWcsIGRhdGVzOiBvcmlnRGF0ZXMsIHJhbmdlcGlja2VyfSA9IGRhdGVwaWNrZXI7XG4gIGlmIChpbnB1dERhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGVtcHR5IGlucHV0IGlzIGNvbnNpZGVyZWQgdmFsaWQgdW5sZXNzIG9yaWdpRGF0ZXMgaXMgcGFzc2VkXG4gICAgcmV0dXJuIGNsZWFyID8gW10gOiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCByYW5nZUVuZCA9IHJhbmdlcGlja2VyICYmIGRhdGVwaWNrZXIgPT09IHJhbmdlcGlja2VyLmRhdGVwaWNrZXJzWzFdO1xuICBsZXQgbmV3RGF0ZXMgPSBpbnB1dERhdGVzLnJlZHVjZSgoZGF0ZXMsIGR0KSA9PiB7XG4gICAgbGV0IGRhdGUgPSAoMCxkYXRlX2Zvcm1hdC8qIHBhcnNlRGF0ZSAqLy5zRykoZHQsIGNvbmZpZy5mb3JtYXQsIGNvbmZpZy5sb2NhbGUpO1xuICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkYXRlcztcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5waWNrTGV2ZWwgPiAwKSB7XG4gICAgICAvLyBhZGp1c3QgdG8gMXN0IG9mIHRoZSBtb250aC9KYW4gMXN0IG9mIHRoZSB5ZWFyXG4gICAgICAvLyBvciB0byB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbmgvRGVjIDMxc3Qgb2YgdGhlIHllYXIgaWYgdGhlIGRhdGVwaWNrZXJcbiAgICAgIC8vIGlzIHRoZSByYW5nZS1lbmQgcGlja2VyIG9mIGEgcmFuZ2VwaWNrZXJcbiAgICAgIGNvbnN0IGR0ID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICBpZiAoY29uZmlnLnBpY2tMZXZlbCA9PT0gMSkge1xuICAgICAgICBkYXRlID0gcmFuZ2VFbmRcbiAgICAgICAgICA/IGR0LnNldE1vbnRoKGR0LmdldE1vbnRoKCkgKyAxLCAwKVxuICAgICAgICAgIDogZHQuc2V0RGF0ZSgxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUgPSByYW5nZUVuZFxuICAgICAgICAgID8gZHQuc2V0RnVsbFllYXIoZHQuZ2V0RnVsbFllYXIoKSArIDEsIDAsIDApXG4gICAgICAgICAgOiBkdC5zZXRNb250aCgwLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFxuICAgICAgKDAsdXRpbHMvKiBpc0luUmFuZ2UgKi8ubWgpKGRhdGUsIGNvbmZpZy5taW5EYXRlLCBjb25maWcubWF4RGF0ZSlcbiAgICAgICYmICFkYXRlcy5pbmNsdWRlcyhkYXRlKVxuICAgICAgJiYgIWNvbmZpZy5kYXRlc0Rpc2FibGVkLmluY2x1ZGVzKGRhdGUpXG4gICAgICAmJiAhY29uZmlnLmRheXNPZldlZWtEaXNhYmxlZC5pbmNsdWRlcyhuZXcgRGF0ZShkYXRlKS5nZXREYXkoKSlcbiAgICApIHtcbiAgICAgIGRhdGVzLnB1c2goZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlcztcbiAgfSwgW10pO1xuICBpZiAobmV3RGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjb25maWcubXVsdGlkYXRlICYmICFjbGVhcikge1xuICAgIC8vIGdldCB0aGUgc3lubWV0cmljIGRpZmZlcmVuY2UgYmV0d2VlbiBvcmlnRGF0ZXMgYW5kIG5ld0RhdGVzXG4gICAgbmV3RGF0ZXMgPSBuZXdEYXRlcy5yZWR1Y2UoKGRhdGVzLCBkYXRlKSA9PiB7XG4gICAgICBpZiAoIW9yaWdEYXRlcy5pbmNsdWRlcyhkYXRlKSkge1xuICAgICAgICBkYXRlcy5wdXNoKGRhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGVzO1xuICAgIH0sIG9yaWdEYXRlcy5maWx0ZXIoZGF0ZSA9PiAhbmV3RGF0ZXMuaW5jbHVkZXMoZGF0ZSkpKTtcbiAgfVxuICAvLyBkbyBsZW5ndGggY2hlY2sgYWx3YXlzIGJlY2F1c2UgdXNlciBjYW4gaW5wdXQgbXVsdGlwbGUgZGF0ZXMgcmVnYXJkbGVzcyBvZiB0aGUgbW9kZVxuICByZXR1cm4gY29uZmlnLm1heE51bWJlck9mRGF0ZXMgJiYgbmV3RGF0ZXMubGVuZ3RoID4gY29uZmlnLm1heE51bWJlck9mRGF0ZXNcbiAgICA/IG5ld0RhdGVzLnNsaWNlKGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzICogLTEpXG4gICAgOiBuZXdEYXRlcztcbn1cblxuLy8gcmVmcmVzaCB0aGUgVUkgZWxlbWVudHNcbi8vIG1vZGVzOiAxOiBpbnB1dCBvbmx5LCAyLCBwaWNrZXIgb25seSwgMyBib3RoXG5mdW5jdGlvbiByZWZyZXNoVUkoZGF0ZXBpY2tlciwgbW9kZSA9IDMsIHF1aWNrUmVuZGVyID0gdHJ1ZSkge1xuICBjb25zdCB7Y29uZmlnLCBwaWNrZXIsIGlucHV0RmllbGR9ID0gZGF0ZXBpY2tlcjtcbiAgaWYgKG1vZGUgJiAyKSB7XG4gICAgY29uc3QgbmV3VmlldyA9IHBpY2tlci5hY3RpdmUgPyBjb25maWcucGlja0xldmVsIDogY29uZmlnLnN0YXJ0VmlldztcbiAgICBwaWNrZXIudXBkYXRlKCkuY2hhbmdlVmlldyhuZXdWaWV3KS5yZW5kZXIocXVpY2tSZW5kZXIpO1xuICB9XG4gIGlmIChtb2RlICYgMSAmJiBpbnB1dEZpZWxkKSB7XG4gICAgaW5wdXRGaWVsZC52YWx1ZSA9IHN0cmluZ2lmeURhdGVzKGRhdGVwaWNrZXIuZGF0ZXMsIGNvbmZpZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0RGF0ZShkYXRlcGlja2VyLCBpbnB1dERhdGVzLCBvcHRpb25zKSB7XG4gIGxldCB7Y2xlYXIsIHJlbmRlciwgYXV0b2hpZGV9ID0gb3B0aW9ucztcbiAgaWYgKHJlbmRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmVuZGVyID0gdHJ1ZTtcbiAgfVxuICBpZiAoIXJlbmRlcikge1xuICAgIGF1dG9oaWRlID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoYXV0b2hpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGF1dG9oaWRlID0gZGF0ZXBpY2tlci5jb25maWcuYXV0b2hpZGU7XG4gIH1cblxuICBjb25zdCBuZXdEYXRlcyA9IHByb2Nlc3NJbnB1dERhdGVzKGRhdGVwaWNrZXIsIGlucHV0RGF0ZXMsIGNsZWFyKTtcbiAgaWYgKCFuZXdEYXRlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobmV3RGF0ZXMudG9TdHJpbmcoKSAhPT0gZGF0ZXBpY2tlci5kYXRlcy50b1N0cmluZygpKSB7XG4gICAgZGF0ZXBpY2tlci5kYXRlcyA9IG5ld0RhdGVzO1xuICAgIHJlZnJlc2hVSShkYXRlcGlja2VyLCByZW5kZXIgPyAzIDogMSk7XG4gICAgdHJpZ2dlckRhdGVwaWNrZXJFdmVudChkYXRlcGlja2VyLCAnY2hhbmdlRGF0ZScpO1xuICB9IGVsc2Uge1xuICAgIHJlZnJlc2hVSShkYXRlcGlja2VyLCAxKTtcbiAgfVxuICBpZiAoYXV0b2hpZGUpIHtcbiAgICBkYXRlcGlja2VyLmhpZGUoKTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGRhdGUgcGlja2VyXG4gKi9cbmNsYXNzIERhdGVwaWNrZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgZGF0ZSBwaWNrZXJcbiAgICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBhIGRhdGUgcGlja2VyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIC0gY29uZmlnIG9wdGlvbnNcbiAgICogQHBhcmFtICB7RGF0ZVJhbmdlUGlja2VyfSBbcmFuZ2VwaWNrZXJdIC0gRGF0ZVJhbmdlUGlja2VyIGluc3RhbmNlIHRoZVxuICAgKiBkYXRlIHBpY2tlciBiZWxvbmdzIHRvLiBVc2UgdGhpcyBvbmx5IHdoZW4gY3JlYXRpbmcgZGF0ZSBwaWNrZXIgYXMgYSBwYXJ0XG4gICAqIG9mIGRhdGUgcmFuZ2UgcGlja2VyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zID0ge30sIHJhbmdlcGlja2VyID0gdW5kZWZpbmVkKSB7XG4gICAgZWxlbWVudC5kYXRlcGlja2VyID0gdGhpcztcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgLy8gc2V0IHVwIGNvbmZpZ1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBidXR0b25DbGFzczogKG9wdGlvbnMuYnV0dG9uQ2xhc3MgJiYgU3RyaW5nKG9wdGlvbnMuYnV0dG9uQ2xhc3MpKSB8fCAnYnV0dG9uJyxcbiAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgICAgIGRlZmF1bHRWaWV3RGF0ZTogKDAsbGliX2RhdGUvKiB0b2RheSAqLy5MZykoKSxcbiAgICAgIG1heERhdGU6IHVuZGVmaW5lZCxcbiAgICAgIG1pbkRhdGU6IHVuZGVmaW5lZCxcbiAgICB9LCBwcm9jZXNzT3B0aW9ucyhvcHRpb25zX2RlZmF1bHRPcHRpb25zLCB0aGlzKSk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIHByb2Nlc3NPcHRpb25zKG9wdGlvbnMsIHRoaXMpKTtcblxuICAgIC8vIGNvbmZpZ3VyZSBieSB0eXBlXG4gICAgY29uc3QgaW5saW5lID0gdGhpcy5pbmxpbmUgPSBlbGVtZW50LnRhZ05hbWUgIT09ICdJTlBVVCc7XG4gICAgbGV0IGlucHV0RmllbGQ7XG4gICAgbGV0IGluaXRpYWxEYXRlcztcblxuICAgIGlmIChpbmxpbmUpIHtcbiAgICAgIGNvbmZpZy5jb250YWluZXIgPSBlbGVtZW50O1xuICAgICAgaW5pdGlhbERhdGVzID0gKDAsdXRpbHMvKiBzdHJpbmdUb0FycmF5ICovLlc3KShlbGVtZW50LmRhdGFzZXQuZGF0ZSwgY29uZmlnLmRhdGVEZWxpbWl0ZXIpO1xuICAgICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC5kYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5jb250YWluZXIpIDogbnVsbDtcbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIH1cbiAgICAgIGlucHV0RmllbGQgPSB0aGlzLmlucHV0RmllbGQgPSBlbGVtZW50O1xuICAgICAgaW5wdXRGaWVsZC5jbGFzc0xpc3QuYWRkKCdkYXRlcGlja2VyLWlucHV0Jyk7XG4gICAgICBpbml0aWFsRGF0ZXMgPSAoMCx1dGlscy8qIHN0cmluZ1RvQXJyYXkgKi8uVzcpKGlucHV0RmllbGQudmFsdWUsIGNvbmZpZy5kYXRlRGVsaW1pdGVyKTtcbiAgICB9XG4gICAgaWYgKHJhbmdlcGlja2VyKSB7XG4gICAgICAvLyBjaGVjayB2YWxpZGlyeVxuICAgICAgY29uc3QgaW5kZXggPSByYW5nZXBpY2tlci5pbnB1dHMuaW5kZXhPZihpbnB1dEZpZWxkKTtcbiAgICAgIGNvbnN0IGRhdGVwaWNrZXJzID0gcmFuZ2VwaWNrZXIuZGF0ZXBpY2tlcnM7XG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gMSB8fCAhQXJyYXkuaXNBcnJheShkYXRlcGlja2VycykpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcmFuZ2VwaWNrZXIgb2JqZWN0LicpO1xuICAgICAgfVxuICAgICAgLy8gYXR0YWNoIGl0YWVsZiB0byB0aGUgcmFuZ2VwaWNrZXIgaGVyZSBzbyB0aGF0IHByb2Nlc3NJbnB1dERhdGVzKCkgY2FuXG4gICAgICAvLyBkZXRlcm1pbmUgaWYgdGhpcyBpcyB0aGUgcmFuZ2UtZW5kIHBpY2tlciBvZiB0aGUgcmFuZ2VwaWNrZXIgd2hpbGVcbiAgICAgIC8vIHNldHRpbmcgaW5pdGFsIHZhbHVlcyB3aGVuIHBpY2tMZXZlbCA+IDBcbiAgICAgIGRhdGVwaWNrZXJzW2luZGV4XSA9IHRoaXM7XG4gICAgICAvLyBhZGQgZ2V0dGVyIGZvciByYW5nZXBpY2tlclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyYW5nZXBpY2tlcicsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiByYW5nZXBpY2tlcjtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNldCBpbml0aWFsIGRhdGVzXG4gICAgdGhpcy5kYXRlcyA9IFtdO1xuICAgIC8vIHByb2Nlc3MgaW5pdGlhbCB2YWx1ZVxuICAgIGNvbnN0IGlucHV0RGF0ZVZhbHVlcyA9IHByb2Nlc3NJbnB1dERhdGVzKHRoaXMsIGluaXRpYWxEYXRlcyk7XG4gICAgaWYgKGlucHV0RGF0ZVZhbHVlcyAmJiBpbnB1dERhdGVWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5kYXRlcyA9IGlucHV0RGF0ZVZhbHVlcztcbiAgICB9XG4gICAgaWYgKGlucHV0RmllbGQpIHtcbiAgICAgIGlucHV0RmllbGQudmFsdWUgPSBzdHJpbmdpZnlEYXRlcyh0aGlzLmRhdGVzLCBjb25maWcpO1xuICAgIH1cblxuICAgIGNvbnN0IHBpY2tlciA9IHRoaXMucGlja2VyID0gbmV3IFBpY2tlcih0aGlzKTtcblxuICAgIGlmIChpbmxpbmUpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzIGluIG90aGVyIG1vZGVzXG4gICAgICBjb25zdCBvbk1vdXNlZG93bkRvY3VtZW50ID0gb25DbGlja091dHNpZGUuYmluZChudWxsLCB0aGlzKTtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFtcbiAgICAgICAgW2lucHV0RmllbGQsICdrZXlkb3duJywgb25LZXlkb3duLmJpbmQobnVsbCwgdGhpcyldLFxuICAgICAgICBbaW5wdXRGaWVsZCwgJ2ZvY3VzJywgb25Gb2N1cy5iaW5kKG51bGwsIHRoaXMpXSxcbiAgICAgICAgW2lucHV0RmllbGQsICdtb3VzZWRvd24nLCBvbk1vdXNlZG93bi5iaW5kKG51bGwsIHRoaXMpXSxcbiAgICAgICAgW2lucHV0RmllbGQsICdjbGljaycsIG9uQ2xpY2tJbnB1dC5iaW5kKG51bGwsIHRoaXMpXSxcbiAgICAgICAgW2lucHV0RmllbGQsICdwYXN0ZScsIG9uUGFzdGUuYmluZChudWxsLCB0aGlzKV0sXG4gICAgICAgIFtkb2N1bWVudCwgJ21vdXNlZG93bicsIG9uTW91c2Vkb3duRG9jdW1lbnRdLFxuICAgICAgICBbZG9jdW1lbnQsICd0b3VjaHN0YXJ0Jywgb25Nb3VzZWRvd25Eb2N1bWVudF0sXG4gICAgICAgIFt3aW5kb3csICdyZXNpemUnLCBwaWNrZXIucGxhY2UuYmluZChwaWNrZXIpXVxuICAgICAgXTtcbiAgICAgICgwLGxpYl9ldmVudC8qIHJlZ2lzdGVyTGlzdGVuZXJzICovLmNGKSh0aGlzLCBsaXN0ZW5lcnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXQgRGF0ZSBvYmplY3Qgb3IgdGltZSB2YWx1ZSBpbiBnaXZlbiBmb3JtYXQgYW5kIGxhbmd1YWdlXG4gICAqIEBwYXJhbSAge0RhdGV8TnVtYmVyfSBkYXRlIC0gZGF0ZSBvciB0aW1lIHZhbHVlIHRvIGZvcm1hdFxuICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBmb3JtYXQgLSBmb3JtYXQgc3RyaW5nIG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zXG4gICAqIHRvRGlzcGxheSgpIGN1c3RvbSBmb3JtYXR0ZXIsIHdob3NlIHNpZ25hdHVyZSBpc1xuICAgKiAtIGFyZ3M6XG4gICAqICAgLSBkYXRlOiB7RGF0ZX0gLSBEYXRlIGluc3RhbmNlIG9mIHRoZSBkYXRlIHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gICAqICAgLSBmb3JtYXQ6IHtPYmplY3R9IC0gdGhlIGZvcm1hdCBvYmplY3QgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICogICAtIGxvY2FsZToge09iamVjdH0gLSBsb2NhbGUgZm9yIHRoZSBsYW5ndWFnZSBzcGVjaWZpZWQgYnkgYGxhbmdgXG4gICAqIC0gcmV0dXJuOlxuICAgKiAgICAge1N0cmluZ30gZm9ybWF0dGVkIGRhdGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbbGFuZz1lbl0gLSBsYW5ndWFnZSBjb2RlIGZvciB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCBkYXRlXG4gICAqL1xuICBzdGF0aWMgZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIGxhbmcpIHtcbiAgICByZXR1cm4gKDAsZGF0ZV9mb3JtYXQvKiBmb3JtYXREYXRlICovLnA2KShkYXRlLCBmb3JtYXQsIGxhbmcgJiYgbG9jYWxlc1tsYW5nXSB8fCBsb2NhbGVzLmVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBkYXRlIHN0cmluZ1xuICAgKiBAcGFyYW0gIHtTdHJpbmd8RGF0ZXxOdW1iZXJ9IGRhdGVTdHIgLSBkYXRlIHN0cmluZywgRGF0ZSBvYmplY3Qgb3IgdGltZVxuICAgKiB2YWx1ZSB0byBwYXJzZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBmb3JtYXQgLSBmb3JtYXQgc3RyaW5nIG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zXG4gICAqIHRvVmFsdWUoKSBjdXN0b20gcGFyc2VyLCB3aG9zZSBzaWduYXR1cmUgaXNcbiAgICogLSBhcmdzOlxuICAgKiAgIC0gZGF0ZVN0cjoge1N0cmluZ3xEYXRlfE51bWJlcn0gLSB0aGUgZGF0ZVN0ciBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICAgKiAgIC0gZm9ybWF0OiB7T2JqZWN0fSAtIHRoZSBmb3JtYXQgb2JqZWN0IHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gICAqICAgLSBsb2NhbGU6IHtPYmplY3R9IC0gbG9jYWxlIGZvciB0aGUgbGFuZ3VhZ2Ugc3BlY2lmaWVkIGJ5IGBsYW5nYFxuICAgKiAtIHJldHVybjpcbiAgICogICAgIHtEYXRlfE51bWJlcn0gcGFyc2VkIGRhdGUgb3IgaXRzIHRpbWUgdmFsdWVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbbGFuZz1lbl0gLSBsYW5ndWFnZSBjb2RlIGZvciB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRpbWUgdmFsdWUgb2YgcGFyc2VkIGRhdGVcbiAgICovXG4gIHN0YXRpYyBwYXJzZURhdGUoZGF0ZVN0ciwgZm9ybWF0LCBsYW5nKSB7XG4gICAgcmV0dXJuICgwLGRhdGVfZm9ybWF0LyogcGFyc2VEYXRlICovLnNHKShkYXRlU3RyLCBmb3JtYXQsIGxhbmcgJiYgbG9jYWxlc1tsYW5nXSB8fCBsb2NhbGVzLmVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fSAtIEluc3RhbGxlZCBsb2NhbGVzIGluIGBbbGFuZ3VhZ2VDb2RlXTogbG9jYWxlT2JqZWN0YCBmb3JtYXRcbiAgICogZW5gOl9FbmdsaXNoIChVUylfIGlzIHByZS1pbnN0YWxsZWQuXG4gICAqL1xuICBzdGF0aWMgZ2V0IGxvY2FsZXMoKSB7XG4gICAgcmV0dXJuIGxvY2FsZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59IC0gV2hldGhlciB0aGUgcGlja2VyIGVsZW1lbnQgaXMgc2hvd24uIGB0cnVlYCB3aG5lIHNob3duXG4gICAqL1xuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiAhISh0aGlzLnBpY2tlciAmJiB0aGlzLnBpY2tlci5hY3RpdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH0gLSBET00gb2JqZWN0IG9mIHBpY2tlciBlbGVtZW50XG4gICAqL1xuICBnZXQgcGlja2VyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5waWNrZXIgPyB0aGlzLnBpY2tlci5lbGVtZW50IDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBuZXcgdmFsdWVzIHRvIHRoZSBjb25maWcgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZyBvcHRpb25zIHRvIHVwZGF0ZVxuICAgKi9cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcy5waWNrZXI7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IHByb2Nlc3NPcHRpb25zKG9wdGlvbnMsIHRoaXMpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZywgbmV3T3B0aW9ucyk7XG4gICAgcGlja2VyLnNldE9wdGlvbnMobmV3T3B0aW9ucyk7XG5cbiAgICByZWZyZXNoVUkodGhpcywgMyk7XG4gIH1cblxuICAvKipcbiAgICogU2hvdyB0aGUgcGlja2VyIGVsZW1lbnRcbiAgICovXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuaW5wdXRGaWVsZCkge1xuICAgICAgaWYgKHRoaXMuaW5wdXRGaWVsZC5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pbnB1dEZpZWxkICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3Nob3dpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuZm9jdXMoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Nob3dpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucGlja2VyLnNob3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBwaWNrZXIgZWxlbWVudFxuICAgKiBOb3QgYXZhaWxhYmxlIG9uIGlubGluZSBwaWNrZXJcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGlja2VyLmhpZGUoKTtcbiAgICB0aGlzLnBpY2tlci51cGRhdGUoKS5jaGFuZ2VWaWV3KHRoaXMuY29uZmlnLnN0YXJ0VmlldykucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgRGF0ZXBpY2tlciBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEZXRlcGlja2VyfSAtIHRoZSBpbnN0YW5jZSBkZXN0cm95ZWRcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5oaWRlKCk7XG4gICAgKDAsbGliX2V2ZW50LyogdW5yZWdpc3Rlckxpc3RlbmVycyAqLy51VikodGhpcyk7XG4gICAgdGhpcy5waWNrZXIuZGV0YWNoKCk7XG4gICAgaWYgKCF0aGlzLmlubGluZSkge1xuICAgICAgdGhpcy5pbnB1dEZpZWxkLmNsYXNzTGlzdC5yZW1vdmUoJ2RhdGVwaWNrZXItaW5wdXQnKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRlcGlja2VyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2VsZWN0ZWQgZGF0ZShzKVxuICAgKlxuICAgKiBUaGUgbWV0aG9kIHJldHVybnMgYSBEYXRlIG9iamVjdCBvZiBzZWxlY3RlZCBkYXRlIGJ5IGRlZmF1bHQsIGFuZCByZXR1cm5zXG4gICAqIGFuIGFycmF5IG9mIHNlbGVjdGVkIGRhdGVzIGluIG11bHRpZGF0ZSBtb2RlLiBJZiBmb3JtYXQgc3RyaW5nIGlzIHBhc3NlZCxcbiAgICogaXQgcmV0dXJucyBkYXRlIHN0cmluZyhzKSBmb3JtYXR0ZWQgaW4gZ2l2ZW4gZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtmb3JtYXRdIC0gRm9ybWF0IHN0cmluZyB0byBzdHJpbmdpZnkgdGhlIGRhdGUocylcbiAgICogQHJldHVybiB7RGF0ZXxTdHJpbmd8RGF0ZVtdfFN0cmluZ1tdfSAtIHNlbGVjdGVkIGRhdGUocyksIG9yIGlmIG5vbmUgaXNcbiAgICogc2VsZWN0ZWQsIGVtcHR5IGFycmF5IGluIG11bHRpZGF0ZSBtb2RlIGFuZCB1bnRpdGxlZCBpbiBzaWdsZWRhdGUgbW9kZVxuICAgKi9cbiAgZ2V0RGF0ZShmb3JtYXQgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IGZvcm1hdFxuICAgICAgPyBkYXRlID0+ICgwLGRhdGVfZm9ybWF0LyogZm9ybWF0RGF0ZSAqLy5wNikoZGF0ZSwgZm9ybWF0LCB0aGlzLmNvbmZpZy5sb2NhbGUpXG4gICAgICA6IGRhdGUgPT4gbmV3IERhdGUoZGF0ZSk7XG5cbiAgICBpZiAodGhpcy5jb25maWcubXVsdGlkYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRlcy5tYXAoY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5kYXRlc1swXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RlZCBkYXRlKHMpXG4gICAqXG4gICAqIEluIG11bHRpZGF0ZSBtb2RlLCB5b3UgY2FuIHBhc3MgbXVsdGlwbGUgZGF0ZXMgYXMgYSBzZXJpZXMgb2YgYXJndW1lbnRzXG4gICAqIG9yIGFuIGFycmF5LiAoU2luY2UgZWFjaCBkYXRlIGlzIHBhcnNlZCBpbmRpdmlkdWFsbHksIHRoZSB0eXBlIG9mIHRoZVxuICAgKiBkYXRlcyBkb2Vzbid0IGhhdmUgdG8gYmUgdGhlIHNhbWUuKVxuICAgKiBUaGUgZ2l2ZW4gZGF0ZXMgYXJlIHVzZWQgdG8gdG9nZ2xlIHRoZSBzZWxlY3Qgc3RhdHVzIG9mIGVhY2ggZGF0ZS4gVGhlXG4gICAqIG51bWJlciBvZiBzZWxlY3RlZCBkYXRlcyBpcyBrZXB0IGZyb20gZXhjZWVkaW5nIHRoZSBsZW5ndGggc2V0IHRvXG4gICAqIG1heE51bWJlck9mRGF0ZXMuXG4gICAqXG4gICAqIFdpdGggY2xlYXI6IHRydWUgb3B0aW9uLCB0aGUgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGNsZWFyIHRoZSBzZWxlY3Rpb25cbiAgICogYW5kIHRvIHJlcGxhY2UgdGhlIHNlbGVjdGlvbiBpbnN0ZWFkIG9mIHRvZ2dsaW5nIGluIG11bHRpZGF0ZSBtb2RlLlxuICAgKiBJZiB0aGUgb3B0aW9uIGlzIHBhc3NlZCB3aXRoIG5vIGRhdGUgYXJndW1lbnRzIG9yIGFuIGVtcHR5IGRhdGVzIGFycmF5LFxuICAgKiBpdCB3b3JrcyBhcyBcImNsZWFyXCIgKGNsZWFyIHRoZSBzZWxlY3Rpb24gdGhlbiBzZXQgbm90aGluZyksIGFuZCBpZiB0aGVcbiAgICogb3B0aW9uIGlzIHBhc3NlZCB3aXRoIG5ldyBkYXRlcyB0byBzZWxlY3QsIGl0IHdvcmtzIGFzIFwicmVwbGFjZVwiIChjbGVhclxuICAgKiB0aGUgc2VsZWN0aW9uIHRoZW4gc2V0IHRoZSBnaXZlbiBkYXRlcylcbiAgICpcbiAgICogV2hlbiByZW5kZXI6IGZhbHNlIG9wdGlvbiBpcyB1c2VkLCB0aGUgbWV0aG9kIG9taXRzIHJlLXJlbmRlcmluZyB0aGVcbiAgICogcGlja2VyIGVsZW1lbnQuIEluIHRoaXMgY2FzZSwgeW91IG5lZWQgdG8gY2FsbCByZWZyZXNoKCkgbWV0aG9kIGxhdGVyIGluXG4gICAqIG9yZGVyIGZvciB0aGUgcGlja2VyIGVsZW1lbnQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlcy4gVGhlIGlucHV0IGZpZWxkIGlzXG4gICAqIHJlZnJlc2hlZCBhbHdheXMgcmVnYXJkbGVzcyBvZiB0aGlzIG9wdGlvbi5cbiAgICpcbiAgICogV2hlbiBpbnZhbGlkICh1bnBhcnNhYmxlLCByZXBlYXRlZCwgZGlzYWJsZWQgb3Igb3V0LW9mLXJhbmdlKSBkYXRlcyBhcmVcbiAgICogcGFzc2VkLCB0aGUgbWV0aG9kIGlnbm9yZXMgdGhlbSBhbmQgYXBwbGllcyBvbmx5IHZhbGlkIG9uZXMuIEluIHRoZSBjYXNlXG4gICAqIHRoYXQgYWxsIHRoZSBnaXZlbiBkYXRlcyBhcmUgaW52YWxpZCwgd2hpY2ggaXMgZGlzdGluZ3Vpc2hlZCBmcm9tIHBhc3NpbmdcbiAgICogbm8gZGF0ZXMsIHRoZSBtZXRob2QgY29uc2lkZXJzIGl0IGFzIGFuIGVycm9yIGFuZCBsZWF2ZXMgdGhlIHNlbGVjdGlvblxuICAgKiB1bnRvdWNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uKERhdGV8TnVtYmVyfFN0cmluZyl8QXJyYXl9IFtkYXRlc10gLSBEYXRlIHN0cmluZ3MsIERhdGVcbiAgICogb2JqZWN0cywgdGltZSB2YWx1ZXMgb3IgbWl4IG9mIHRob3NlIGZvciBuZXcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXG4gICAqIC0gY2xlYXI6IHtib29sZWFufSAtIFdoZXRoZXIgdG8gY2xlYXIgdGhlIGV4aXN0aW5nIHNlbGVjdGlvblxuICAgKiAgICAgZGVmdWFsdDogZmFsc2VcbiAgICogLSByZW5kZXI6IHtib29sZWFufSAtIFdoZXRoZXIgdG8gcmUtcmVuZGVyIHRoZSBwaWNrZXIgZWxlbWVudFxuICAgKiAgICAgZGVmYXVsdDogdHJ1ZVxuICAgKiAtIGF1dG9oaWRlOiB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRvIGhpZGUgdGhlIHBpY2tlciBlbGVtZW50IGFmdGVyIHJlLXJlbmRlclxuICAgKiAgICAgSWdub3JlZCB3aGVuIHVzZWQgd2l0aCByZW5kZXI6IGZhbHNlXG4gICAqICAgICBkZWZhdWx0OiBjb25maWcuYXV0b2hpZGVcbiAgICovXG4gIHNldERhdGUoLi4uYXJncykge1xuICAgIGNvbnN0IGRhdGVzID0gWy4uLmFyZ3NdO1xuICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICBjb25zdCBsYXN0QXJnID0gKDAsdXRpbHMvKiBsYXN0SXRlbU9mICovLkptKShhcmdzKTtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbGFzdEFyZyA9PT0gJ29iamVjdCdcbiAgICAgICYmICFBcnJheS5pc0FycmF5KGxhc3RBcmcpXG4gICAgICAmJiAhKGxhc3RBcmcgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgJiYgbGFzdEFyZ1xuICAgICkge1xuICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCBkYXRlcy5wb3AoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXREYXRlcyA9IEFycmF5LmlzQXJyYXkoZGF0ZXNbMF0pID8gZGF0ZXNbMF0gOiBkYXRlcztcbiAgICBzZXREYXRlKHRoaXMsIGlucHV0RGF0ZXMsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2VsZWN0ZWQgZGF0ZShzKSB3aXRoIGlucHV0IGZpZWxkJ3MgdmFsdWVcbiAgICogTm90IGF2YWlsYWJsZSBvbiBpbmxpbmUgcGlja2VyXG4gICAqXG4gICAqIFRoZSBpbnB1dCBmaWVsZCB3aWxsIGJlIHJlZnJlc2hlZCB3aXRoIHByb3Blcmx5IGZvcm1hdHRlZCBkYXRlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXG4gICAqIC0gYXV0b2hpZGU6IHtib29sZWFufSAtIHdoZXRoZXIgdG8gaGlkZSB0aGUgcGlja2VyIGVsZW1lbnQgYWZ0ZXIgcmVmcmVzaFxuICAgKiAgICAgZGVmYXVsdDogZmFsc2VcbiAgICovXG4gIHVwZGF0ZShvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHtjbGVhcjogdHJ1ZSwgYXV0b2hpZGU6ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5hdXRvaGlkZSl9O1xuICAgIGNvbnN0IGlucHV0RGF0ZXMgPSAoMCx1dGlscy8qIHN0cmluZ1RvQXJyYXkgKi8uVzcpKHRoaXMuaW5wdXRGaWVsZC52YWx1ZSwgdGhpcy5jb25maWcuZGF0ZURlbGltaXRlcik7XG4gICAgc2V0RGF0ZSh0aGlzLCBpbnB1dERhdGVzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBwaWNrZXIgZWxlbWVudCBhbmQgdGhlIGFzc29jaWF0ZWQgaW5wdXQgZmllbGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0YXJnZXRdIC0gdGFyZ2V0IGl0ZW0gd2hlbiByZWZyZXNoaW5nIG9uZSBpdGVtIG9ubHlcbiAgICogJ3BpY2tlcicgb3IgJ2lucHV0J1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZVJlbmRlcl0gLSB3aGV0aGVyIHRvIHJlLXJlbmRlciB0aGUgcGlja2VyIGVsZW1lbnRcbiAgICogcmVnYXJkbGVzcyBvZiBpdHMgc3RhdGUgaW5zdGVhZCBvZiBvcHRpbWl6ZWQgcmVmcmVzaFxuICAgKi9cbiAgcmVmcmVzaCh0YXJnZXQgPSB1bmRlZmluZWQsIGZvcmNlUmVuZGVyID0gZmFsc2UpIHtcbiAgICBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBmb3JjZVJlbmRlciA9IHRhcmdldDtcbiAgICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQgbW9kZTtcbiAgICBpZiAodGFyZ2V0ID09PSAncGlja2VyJykge1xuICAgICAgbW9kZSA9IDI7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgPT09ICdpbnB1dCcpIHtcbiAgICAgIG1vZGUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlID0gMztcbiAgICB9XG4gICAgcmVmcmVzaFVJKHRoaXMsIG1vZGUsICFmb3JjZVJlbmRlcik7XG4gIH1cblxuICAvKipcbiAgICogRW50ZXIgZWRpdCBtb2RlXG4gICAqIE5vdCBhdmFpbGFibGUgb24gaW5saW5lIHBpY2tlciBvciB3aGVuIHRoZSBwaWNrZXIgZWxlbWVudCBpcyBoaWRkZW5cbiAgICovXG4gIGVudGVyRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuaW5saW5lIHx8ICF0aGlzLnBpY2tlci5hY3RpdmUgfHwgdGhpcy5lZGl0TW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NMaXN0LmFkZCgnaW4tZWRpdCcsICdib3JkZXItYmx1ZS03MDAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGl0IGZyb20gZWRpdCBtb2RlXG4gICAqIE5vdCBhdmFpbGFibGUgb24gaW5saW5lIHBpY2tlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAtIGZ1bmN0aW9uIG9wdGlvbnNcbiAgICogLSB1cGRhdGU6IHtib29sZWFufSAtIHdoZXRoZXIgdG8gY2FsbCB1cGRhdGUoKSBhZnRlciBleGl0aW5nXG4gICAqICAgICBJZiBmYWxzZSwgaW5wdXQgZmllbGQgaXMgcmV2ZXJ0IHRvIHRoZSBleGlzdGluZyBzZWxlY3Rpb25cbiAgICogICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAqL1xuICBleGl0RWRpdE1vZGUob3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLmlubGluZSB8fCAhdGhpcy5lZGl0TW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7dXBkYXRlOiBmYWxzZX0sIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSB0aGlzLmVkaXRNb2RlO1xuICAgIHRoaXMuaW5wdXRGaWVsZC5jbGFzc0xpc3QucmVtb3ZlKCdpbi1lZGl0JywgJ2JvcmRlci1ibHVlLTcwMCcpO1xuICAgIGlmIChvcHRzLnVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGUob3B0cyk7XG4gICAgfVxuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk2Mzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkNMXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyByZUZvcm1hdFRva2VuczsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJwNlwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gZm9ybWF0RGF0ZTsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJzR1wiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gcGFyc2VEYXRlOyB9XG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCByZU5vbkRhdGVQYXJ0cyAqL1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kYXRlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNSk7XG5cblxuXG4vLyBwYXR0ZXJuIGZvciBmb3JtYXQgcGFydHNcbmNvbnN0IHJlRm9ybWF0VG9rZW5zID0gL2RkP3xERD98bW0/fE1NP3x5eT8oPzp5eSk/Lztcbi8vIHBhdHRlcm4gZm9yIG5vbiBkYXRlIHBhcnRzXG5jb25zdCByZU5vbkRhdGVQYXJ0cyA9IC9bXFxzIS0vOi1AWy1gey1+5bm05pyI5pelXSsvO1xuLy8gY2FjaGUgZm9yIHBlcnNlZCBmb3JtYXRzXG5sZXQga25vd25Gb3JtYXRzID0ge307XG4vLyBwYXJzZSBmdW50aW9ucyBmb3IgZGF0ZSBwYXJ0c1xuY29uc3QgcGFyc2VGbnMgPSB7XG4gIHkoZGF0ZSwgeWVhcikge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKS5zZXRGdWxsWWVhcihwYXJzZUludCh5ZWFyLCAxMCkpO1xuICB9LFxuICBtKGRhdGUsIG1vbnRoLCBsb2NhbGUpIHtcbiAgICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgbGV0IG1vbnRoSW5kZXggPSBwYXJzZUludChtb250aCwgMTApIC0gMTtcblxuICAgIGlmIChpc05hTihtb250aEluZGV4KSkge1xuICAgICAgaWYgKCFtb250aCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtb250aE5hbWUgPSBtb250aC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgY29tcGFyZU5hbWVzID0gbmFtZSA9PiBuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChtb250aE5hbWUpO1xuICAgICAgLy8gY29tcGFyZSB3aXRoIGJvdGggc2hvcnQgYW5kIGZ1bGwgbmFtZXMgYmVjYXVzZSBzb21lIGxvY2FsZXMgaGF2ZSBwZXJpb2RzXG4gICAgICAvLyBpbiB0aGUgc2hvcnQgbmFtZXMgKG5vdCBlcXVhbCB0byB0aGUgZmlyc3QgWCBsZXR0ZXJzIG9mIHRoZSBmdWxsIG5hbWVzKVxuICAgICAgbW9udGhJbmRleCA9IGxvY2FsZS5tb250aHNTaG9ydC5maW5kSW5kZXgoY29tcGFyZU5hbWVzKTtcbiAgICAgIGlmIChtb250aEluZGV4IDwgMCkge1xuICAgICAgICBtb250aEluZGV4ID0gbG9jYWxlLm1vbnRocy5maW5kSW5kZXgoY29tcGFyZU5hbWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb250aEluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld0RhdGUuc2V0TW9udGgobW9udGhJbmRleCk7XG4gICAgcmV0dXJuIG5ld0RhdGUuZ2V0TW9udGgoKSAhPT0gbm9ybWFsaXplTW9udGgobW9udGhJbmRleClcbiAgICAgID8gbmV3RGF0ZS5zZXREYXRlKDApXG4gICAgICA6IG5ld0RhdGUuZ2V0VGltZSgpO1xuICB9LFxuICBkKGRhdGUsIGRheSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKS5zZXREYXRlKHBhcnNlSW50KGRheSwgMTApKTtcbiAgfSxcbn07XG4vLyBmb3JtYXQgZnVuY3Rpb25zIGZvciBkYXRlIHBhcnRzXG5jb25zdCBmb3JtYXRGbnMgPSB7XG4gIGQoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldERhdGUoKTtcbiAgfSxcbiAgZGQoZGF0ZSkge1xuICAgIHJldHVybiBwYWRaZXJvKGRhdGUuZ2V0RGF0ZSgpLCAyKTtcbiAgfSxcbiAgRChkYXRlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLmRheXNTaG9ydFtkYXRlLmdldERheSgpXTtcbiAgfSxcbiAgREQoZGF0ZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5kYXlzW2RhdGUuZ2V0RGF5KCldO1xuICB9LFxuICBtKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgfSxcbiAgbW0oZGF0ZSkge1xuICAgIHJldHVybiBwYWRaZXJvKGRhdGUuZ2V0TW9udGgoKSArIDEsIDIpO1xuICB9LFxuICBNKGRhdGUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRbZGF0ZS5nZXRNb250aCgpXTtcbiAgfSxcbiAgTU0oZGF0ZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgfSxcbiAgeShkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfSxcbiAgeXkoZGF0ZSkge1xuICAgIHJldHVybiBwYWRaZXJvKGRhdGUuZ2V0RnVsbFllYXIoKSwgMikuc2xpY2UoLTIpO1xuICB9LFxuICB5eXl5KGRhdGUpIHtcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldEZ1bGxZZWFyKCksIDQpO1xuICB9LFxufTtcblxuLy8gZ2V0IG1vbnRoIGluZGV4IGluIG5vcm1hbCByYW5nZSAoMCAtIDExKSBmcm9tIGFueSBudW1iZXJcbmZ1bmN0aW9uIG5vcm1hbGl6ZU1vbnRoKG1vbnRoSW5kZXgpIHtcbiAgcmV0dXJuIG1vbnRoSW5kZXggPiAtMSA/IG1vbnRoSW5kZXggJSAxMiA6IG5vcm1hbGl6ZU1vbnRoKG1vbnRoSW5kZXggKyAxMik7XG59XG5cbmZ1bmN0aW9uIHBhZFplcm8obnVtLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG51bS50b1N0cmluZygpLnBhZFN0YXJ0KGxlbmd0aCwgJzAnKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0KSB7XG4gIGlmICh0eXBlb2YgZm9ybWF0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuICB9XG4gIGlmIChmb3JtYXQgaW4ga25vd25Gb3JtYXRzKSB7XG4gICAgcmV0dXJuIGtub3duRm9ybWF0c1tmb3JtYXRdO1xuICB9XG5cbiAgLy8gc3ByaXQgdGhlIGZvcm1hdCBzdHJpbmcgaW50byBwYXJ0cyBhbmQgc2VwcmF0b3JzXG4gIGNvbnN0IHNlcGFyYXRvcnMgPSBmb3JtYXQuc3BsaXQocmVGb3JtYXRUb2tlbnMpO1xuICBjb25zdCBwYXJ0cyA9IGZvcm1hdC5tYXRjaChuZXcgUmVnRXhwKHJlRm9ybWF0VG9rZW5zLCAnZycpKTtcbiAgaWYgKHNlcGFyYXRvcnMubGVuZ3RoID09PSAwIHx8ICFwYXJ0cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuICB9XG5cbiAgLy8gY29sbGVjdCBmb3JtYXQgZnVuY3Rpb25zIHVzZWQgaW4gdGhlIGZvcm1hdFxuICBjb25zdCBwYXJ0Rm9ybWF0dGVycyA9IHBhcnRzLm1hcCh0b2tlbiA9PiBmb3JtYXRGbnNbdG9rZW5dKTtcblxuICAvLyBjb2xsZWN0IHBhcnNlIGZ1bmN0aW9uIGtleXMgdXNlZCBpbiB0aGUgZm9ybWF0XG4gIC8vIGl0ZXJhdGUgb3ZlciBwYXJzZUZucycga2V5cyBpbiBvcmRlciB0byBrZWVwIHRoZSBvcmRlciBvZiB0aGUga2V5cy5cbiAgY29uc3QgcGFydFBhcnNlcktleXMgPSBPYmplY3Qua2V5cyhwYXJzZUZucykucmVkdWNlKChrZXlzLCBrZXkpID0+IHtcbiAgICBjb25zdCB0b2tlbiA9IHBhcnRzLmZpbmQocGFydCA9PiBwYXJ0WzBdICE9PSAnRCcgJiYgcGFydFswXS50b0xvd2VyQ2FzZSgpID09PSBrZXkpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIGtub3duRm9ybWF0c1tmb3JtYXRdID0ge1xuICAgIHBhcnNlcihkYXRlU3RyLCBsb2NhbGUpIHtcbiAgICAgIGNvbnN0IGRhdGVQYXJ0cyA9IGRhdGVTdHIuc3BsaXQocmVOb25EYXRlUGFydHMpLnJlZHVjZSgoZHRQYXJ0cywgcGFydCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKHBhcnQubGVuZ3RoID4gMCAmJiBwYXJ0c1tpbmRleF0pIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnRzW2luZGV4XVswXTtcbiAgICAgICAgICBpZiAodG9rZW4gPT09ICdNJykge1xuICAgICAgICAgICAgZHRQYXJ0cy5tID0gcGFydDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuICE9PSAnRCcpIHtcbiAgICAgICAgICAgIGR0UGFydHNbdG9rZW5dID0gcGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR0UGFydHM7XG4gICAgICB9LCB7fSk7XG5cbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXJ0UGFyc2Vya2V5cyBzbyB0aGF0IHRoZSBwYXJzaW5nIGlzIG1hZGUgaW4gdGhlIG9kZXJcbiAgICAgIC8vIG9mIHllYXIsIG1vbnRoIGFuZCBkYXkgdG8gcHJldmVudCB0aGUgZGF5IHBhcnNlciBmcm9tIGNvcnJlY3RpbmcgbGFzdFxuICAgICAgLy8gZGF5IG9mIG1vbnRoIHdyb25nbHlcbiAgICAgIHJldHVybiBwYXJ0UGFyc2VyS2V5cy5yZWR1Y2UoKG9yaWdEYXRlLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbmV3RGF0ZSA9IHBhcnNlRm5zW2tleV0ob3JpZ0RhdGUsIGRhdGVQYXJ0c1trZXldLCBsb2NhbGUpO1xuICAgICAgICAvLyBpbmdub3JlIHRoZSBwYXJ0IGZhaWxlZCB0byBwYXJzZVxuICAgICAgICByZXR1cm4gaXNOYU4obmV3RGF0ZSkgPyBvcmlnRGF0ZSA6IG5ld0RhdGU7XG4gICAgICB9LCAoMCxfZGF0ZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLnRvZGF5ICovIC5MZykoKSk7XG4gICAgfSxcbiAgICBmb3JtYXR0ZXIoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICBsZXQgZGF0ZVN0ciA9IHBhcnRGb3JtYXR0ZXJzLnJlZHVjZSgoc3RyLCBmbiwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHN0ciArPSBgJHtzZXBhcmF0b3JzW2luZGV4XX0ke2ZuKGRhdGUsIGxvY2FsZSl9YDtcbiAgICAgIH0sICcnKTtcbiAgICAgIC8vIHNlcGFyYXRvcnMnIGxlbmd0aCBpcyBhbHdheXMgcGFydHMnIGxlbmd0aCArIDEsXG4gICAgICByZXR1cm4gZGF0ZVN0ciArPSAoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5sYXN0SXRlbU9mICovIC5KbSkoc2VwYXJhdG9ycyk7XG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGVTdHIsIGZvcm1hdCwgbG9jYWxlKSB7XG4gIGlmIChkYXRlU3RyIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2YgZGF0ZVN0ciA9PT0gJ251bWJlcicpIHtcbiAgICBjb25zdCBkYXRlID0gKDAsX2RhdGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5zdHJpcFRpbWUgKi8gLnhSKShkYXRlU3RyKTtcbiAgICByZXR1cm4gaXNOYU4oZGF0ZSkgPyB1bmRlZmluZWQgOiBkYXRlO1xuICB9XG4gIGlmICghZGF0ZVN0cikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGRhdGVTdHIgPT09ICd0b2RheScpIHtcbiAgICByZXR1cm4gKDAsX2RhdGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC50b2RheSAqLyAuTGcpKCk7XG4gIH1cblxuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC50b1ZhbHVlKSB7XG4gICAgY29uc3QgZGF0ZSA9IGZvcm1hdC50b1ZhbHVlKGRhdGVTdHIsIGZvcm1hdCwgbG9jYWxlKTtcbiAgICByZXR1cm4gaXNOYU4oZGF0ZSkgPyB1bmRlZmluZWQgOiAoMCxfZGF0ZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLnN0cmlwVGltZSAqLyAueFIpKGRhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlRm9ybWF0U3RyaW5nKGZvcm1hdCkucGFyc2VyKGRhdGVTdHIsIGxvY2FsZSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBsb2NhbGUpIHtcbiAgaWYgKGlzTmFOKGRhdGUpIHx8ICghZGF0ZSAmJiBkYXRlICE9PSAwKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0IGRhdGVPYmogPSB0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcicgPyBuZXcgRGF0ZShkYXRlKSA6IGRhdGU7XG5cbiAgaWYgKGZvcm1hdC50b0Rpc3BsYXkpIHtcbiAgICByZXR1cm4gZm9ybWF0LnRvRGlzcGxheShkYXRlT2JqLCBmb3JtYXQsIGxvY2FsZSk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0KS5mb3JtYXR0ZXIoZGF0ZU9iaiwgbG9jYWxlKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTYwOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiQmNcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGFkZFllYXJzOyB9LFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkU0XCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBhZGREYXlzOyB9LFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkxnXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyB0b2RheTsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJRa1wiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gZ2V0V2VlazsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJha1wiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gc3RhcnRPZlllYXJQZXJpb2Q7IH0sXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiYnlcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGRhdGVWYWx1ZTsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJmclwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gZGF5T2ZUaGVXZWVrT2Y7IH0sXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiamhcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGFkZFdlZWtzOyB9LFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInhSXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBzdHJpcFRpbWU7IH0sXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwieklcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGFkZE1vbnRoczsgfVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG5mdW5jdGlvbiBzdHJpcFRpbWUodGltZVZhbHVlKSB7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lVmFsdWUpLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufVxuXG5mdW5jdGlvbiB0b2RheSgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59XG5cbi8vIEdldCB0aGUgdGltZSB2YWx1ZSBvZiB0aGUgc3RhcnQgb2YgZ2l2ZW4gZGF0ZSBvciB5ZWFyLCBtb250aCBhbmQgZGF5XG5mdW5jdGlvbiBkYXRlVmFsdWUoLi4uYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHRvZGF5KCk7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHN0cmlwVGltZShhcmdzWzBdKTtcbiAgfVxuXG4gIC8vIHVzZSBzZXRGdWxsWWVhcigpIHRvIGtlZXAgMi1kaWdpdCB5ZWFyIGZyb20gYmVpbmcgbWFwcGVkIHRvIDE5MDAtMTk5OVxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoMCk7XG4gIG5ld0RhdGUuc2V0RnVsbFllYXIoLi4uYXJncyk7XG4gIHJldHVybiBuZXdEYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufVxuXG5mdW5jdGlvbiBhZGREYXlzKGRhdGUsIGFtb3VudCkge1xuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIHJldHVybiBuZXdEYXRlLnNldERhdGUobmV3RGF0ZS5nZXREYXRlKCkgKyBhbW91bnQpO1xufVxuXG5mdW5jdGlvbiBhZGRXZWVrcyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuIGFkZERheXMoZGF0ZSwgYW1vdW50ICogNyk7XG59XG5cbmZ1bmN0aW9uIGFkZE1vbnRocyhkYXRlLCBhbW91bnQpIHtcbiAgLy8gSWYgdGhlIGRheSBvZiB0aGUgZGF0ZSBpcyBub3QgaW4gdGhlIG5ldyBtb250aCwgdGhlIGxhc3QgZGF5IG9mIHRoZSBuZXdcbiAgLy8gbW9udGggd2lsbCBiZSByZXR1cm5lZC4gZS5nLiBKYW4gMzEgKyAxIG1vbnRoIOKGkiBGZWIgMjggKG5vdCBNYXIgMDMpXG4gIGNvbnN0IG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgY29uc3QgbW9udGhzVG9TZXQgPSBuZXdEYXRlLmdldE1vbnRoKCkgKyBhbW91bnQ7XG4gIGxldCBleHBlY3RlZE1vbnRoID0gbW9udGhzVG9TZXQgJSAxMjtcbiAgaWYgKGV4cGVjdGVkTW9udGggPCAwKSB7XG4gICAgZXhwZWN0ZWRNb250aCArPSAxMjtcbiAgfVxuXG4gIGNvbnN0IHRpbWUgPSBuZXdEYXRlLnNldE1vbnRoKG1vbnRoc1RvU2V0KTtcbiAgcmV0dXJuIG5ld0RhdGUuZ2V0TW9udGgoKSAhPT0gZXhwZWN0ZWRNb250aCA/IG5ld0RhdGUuc2V0RGF0ZSgwKSA6IHRpbWU7XG59XG5cbmZ1bmN0aW9uIGFkZFllYXJzKGRhdGUsIGFtb3VudCkge1xuICAvLyBJZiB0aGUgZGF0ZSBpcyBGZWIgMjkgYW5kIHRoZSBuZXcgeWVhciBpcyBub3QgYSBsZWFwIHllYXIsIEZlYiAyOCBvZiB0aGVcbiAgLy8gbmV3IHllYXIgd2lsbCBiZSByZXR1cm5lZC5cbiAgY29uc3QgbmV3RGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICBjb25zdCBleHBlY3RlZE1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpO1xuICBjb25zdCB0aW1lID0gbmV3RGF0ZS5zZXRGdWxsWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkgKyBhbW91bnQpO1xuICByZXR1cm4gZXhwZWN0ZWRNb250aCA9PT0gMSAmJiBuZXdEYXRlLmdldE1vbnRoKCkgPT09IDIgPyBuZXdEYXRlLnNldERhdGUoMCkgOiB0aW1lO1xufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHR3ZW4gMiBkYXlzIG9mIHRoZSB3ZWVrXG5mdW5jdGlvbiBkYXlEaWZmKGRheSwgZnJvbSkge1xuICByZXR1cm4gKGRheSAtIGZyb20gKyA3KSAlIDc7XG59XG5cbi8vIEdldCB0aGUgZGF0ZSBvZiB0aGUgc3BlY2lmaWVkIGRheSBvZiB0aGUgd2VlayBvZiBnaXZlbiBiYXNlIGRhdGVcbmZ1bmN0aW9uIGRheU9mVGhlV2Vla09mKGJhc2VEYXRlLCBkYXlPZldlZWssIHdlZWtTdGFydCA9IDApIHtcbiAgY29uc3QgYmFzZURheSA9IG5ldyBEYXRlKGJhc2VEYXRlKS5nZXREYXkoKTtcbiAgcmV0dXJuIGFkZERheXMoYmFzZURhdGUsIGRheURpZmYoZGF5T2ZXZWVrLCB3ZWVrU3RhcnQpIC0gZGF5RGlmZihiYXNlRGF5LCB3ZWVrU3RhcnQpKTtcbn1cblxuLy8gR2V0IHRoZSBJU08gd2VlayBvZiBhIGRhdGVcbmZ1bmN0aW9uIGdldFdlZWsoZGF0ZSkge1xuICAvLyBzdGFydCBvZiBJU08gd2VlayBpcyBNb25kYXlcbiAgY29uc3QgdGh1T2ZUaGVXZWVrID0gZGF5T2ZUaGVXZWVrT2YoZGF0ZSwgNCwgMSk7XG4gIC8vIDFzdCB3ZWVrID09IHRoZSB3ZWVrIHdoZXJlIHRoZSA0dGggb2YgSmFudWFyeSBpcyBpblxuICBjb25zdCBmaXJzdFRodSA9IGRheU9mVGhlV2Vla09mKG5ldyBEYXRlKHRodU9mVGhlV2Vlaykuc2V0TW9udGgoMCwgNCksIDQsIDEpO1xuICByZXR1cm4gTWF0aC5yb3VuZCgodGh1T2ZUaGVXZWVrIC0gZmlyc3RUaHUpIC8gNjA0ODAwMDAwKSArIDE7XG59XG5cbi8vIEdldCB0aGUgc3RhcnQgeWVhciBvZiB0aGUgcGVyaW9kIG9mIHllYXJzIHRoYXQgaW5jbHVkZXMgZ2l2ZW4gZGF0ZVxuLy8geWVhcnM6IGxlbmd0aCBvZiB0aGUgeWVhciBwZXJpb2RcbmZ1bmN0aW9uIHN0YXJ0T2ZZZWFyUGVyaW9kKGRhdGUsIHllYXJzKSB7XG4gIC8qIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWWVhcl96ZXJvI0lTT184NjAxICovXG4gIGNvbnN0IHllYXIgPSBuZXcgRGF0ZShkYXRlKS5nZXRGdWxsWWVhcigpO1xuICByZXR1cm4gTWF0aC5mbG9vcih5ZWFyIC8geWVhcnMpICogeWVhcnM7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY5ODpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkhlXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBmaW5kRWxlbWVudEluRXZlbnRQYXRoOyB9LFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImNGXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyByZWdpc3Rlckxpc3RlbmVyczsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJ1VlwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gdW5yZWdpc3Rlckxpc3RlbmVyczsgfVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG5jb25zdCBsaXN0ZW5lclJlZ2lzdHJ5ID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHthZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyfSA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZTtcblxuLy8gUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIHRvIGEga2V5IG9iamVjdFxuLy8gbGlzdGVuZXJzOiBhcnJheSBvZiBsaXN0ZW5lciBkZWZpbml0aW9ucztcbi8vICAgLSBlYWNoIGRlZmluaXRpb24gbXVzdCBiZSBhIGZsYXQgYXJyYXkgb2YgZXZlbnQgdGFyZ2V0IGFuZCB0aGUgYXJndW1lbnRzXG4vLyAgICAgdXNlZCB0byBjYWxsIGFkZEV2ZW50TGlzdGVuZXIoKSBvbiB0aGUgdGFyZ2V0XG5mdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycyhrZXlPYmosIGxpc3RlbmVycykge1xuICBsZXQgcmVnaXN0ZXJlZCA9IGxpc3RlbmVyUmVnaXN0cnkuZ2V0KGtleU9iaik7XG4gIGlmICghcmVnaXN0ZXJlZCkge1xuICAgIHJlZ2lzdGVyZWQgPSBbXTtcbiAgICBsaXN0ZW5lclJlZ2lzdHJ5LnNldChrZXlPYmosIHJlZ2lzdGVyZWQpO1xuICB9XG4gIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgIGFkZEV2ZW50TGlzdGVuZXIuY2FsbCguLi5saXN0ZW5lcik7XG4gICAgcmVnaXN0ZXJlZC5wdXNoKGxpc3RlbmVyKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoa2V5T2JqKSB7XG4gIGxldCBsaXN0ZW5lcnMgPSBsaXN0ZW5lclJlZ2lzdHJ5LmdldChrZXlPYmopO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyLmNhbGwoLi4ubGlzdGVuZXIpO1xuICB9KTtcbiAgbGlzdGVuZXJSZWdpc3RyeS5kZWxldGUoa2V5T2JqKTtcbn1cblxuLy8gRXZlbnQuY29tcG9zZWRQYXRoKCkgcG9seWZpbGwgZm9yIEVkZ2Vcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2tsZWluZnJldW5kL2U5Nzg3ZDczNzc2YzBlMzc1MGRjZmNkYzg5ZjEwMGVjXG5pZiAoIUV2ZW50LnByb3RvdHlwZS5jb21wb3NlZFBhdGgpIHtcbiAgY29uc3QgZ2V0Q29tcG9zZWRQYXRoID0gKG5vZGUsIHBhdGggPSBbXSkgPT4ge1xuICAgIHBhdGgucHVzaChub2RlKTtcblxuICAgIGxldCBwYXJlbnQ7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ob3N0KSB7IC8vIFNoYWRvd1Jvb3RcbiAgICAgIHBhcmVudCA9IG5vZGUuaG9zdDtcbiAgICB9IGVsc2UgaWYgKG5vZGUuZGVmYXVsdFZpZXcpIHsgIC8vIERvY3VtZW50XG4gICAgICBwYXJlbnQgPSBub2RlLmRlZmF1bHRWaWV3O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50ID8gZ2V0Q29tcG9zZWRQYXRoKHBhcmVudCwgcGF0aCkgOiBwYXRoO1xuICB9O1xuXG4gIEV2ZW50LnByb3RvdHlwZS5jb21wb3NlZFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldENvbXBvc2VkUGF0aCh0aGlzLnRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRGcm9tUGF0aChwYXRoLCBjcml0ZXJpYSwgY3VycmVudFRhcmdldCwgaW5kZXggPSAwKSB7XG4gIGNvbnN0IGVsID0gcGF0aFtpbmRleF07XG4gIGlmIChjcml0ZXJpYShlbCkpIHtcbiAgICByZXR1cm4gZWw7XG4gIH0gZWxzZSBpZiAoZWwgPT09IGN1cnJlbnRUYXJnZXQgfHwgIWVsLnBhcmVudEVsZW1lbnQpIHtcbiAgICAvLyBzdG9wIHdoZW4gcmVhY2hpbmcgY3VycmVudFRhcmdldCBvciA8aHRtbD5cbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIGZpbmRGcm9tUGF0aChwYXRoLCBjcml0ZXJpYSwgY3VycmVudFRhcmdldCwgaW5kZXggKyAxKTtcbn1cblxuLy8gU2VhcmNoIGZvciB0aGUgYWN0dWFsIHRhcmdldCBvZiBhIGRlbGVnYXRlZCBldmVudFxuZnVuY3Rpb24gZmluZEVsZW1lbnRJbkV2ZW50UGF0aChldiwgc2VsZWN0b3IpIHtcbiAgY29uc3QgY3JpdGVyaWEgPSB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RvciA6IGVsID0+IGVsLm1hdGNoZXMoc2VsZWN0b3IpO1xuICByZXR1cm4gZmluZEZyb21QYXRoKGV2LmNvbXBvc2VkUGF0aCgpLCBjcml0ZXJpYSwgZXYuY3VycmVudFRhcmdldCk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEwNTpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIiRDXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBwdXNoVW5pcXVlOyB9LFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIkptXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBsYXN0SXRlbU9mOyB9LFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIlc3XCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBzdHJpbmdUb0FycmF5OyB9LFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImVtXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjcmVhdGVUYWdSZXBlYXQ7IH0sXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiakdcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGxpbWl0VG9SYW5nZTsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJsJFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gaGFzUHJvcGVydHk7IH0sXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwibWhcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGlzSW5SYW5nZTsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJ6aFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gb3B0aW1pemVUZW1wbGF0ZUhUTUw7IH1cbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuZnVuY3Rpb24gaGFzUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZnVuY3Rpb24gbGFzdEl0ZW1PZihhcnIpIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5cbi8vIHB1c2ggb25seSB0aGUgaXRlbXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheVxuZnVuY3Rpb24gcHVzaFVuaXF1ZShhcnIsIC4uLml0ZW1zKSB7XG4gIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpZiAoYXJyLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFyci5wdXNoKGl0ZW0pO1xuICB9KTtcbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHIsIHNlcGFyYXRvcikge1xuICAvLyBjb252ZXJ0IGVtcHR5IHN0cmluZyB0byBhbiBlbXB0eSBhcnJheVxuICByZXR1cm4gc3RyID8gc3RyLnNwbGl0KHNlcGFyYXRvcikgOiBbXTtcbn1cblxuZnVuY3Rpb24gaXNJblJhbmdlKHRlc3RWYWwsIG1pbiwgbWF4KSB7XG4gIGNvbnN0IG1pbk9LID0gbWluID09PSB1bmRlZmluZWQgfHwgdGVzdFZhbCA+PSBtaW47XG4gIGNvbnN0IG1heE9LID0gbWF4ID09PSB1bmRlZmluZWQgfHwgdGVzdFZhbCA8PSBtYXg7XG4gIHJldHVybiBtaW5PSyAmJiBtYXhPSztcbn1cblxuZnVuY3Rpb24gbGltaXRUb1JhbmdlKHZhbCwgbWluLCBtYXgpIHtcbiAgaWYgKHZhbCA8IG1pbikge1xuICAgIHJldHVybiBtaW47XG4gIH1cbiAgaWYgKHZhbCA+IG1heCkge1xuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGFnUmVwZWF0KHRhZ05hbWUsIHJlcGVhdCwgYXR0cmlidXRlcyA9IHt9LCBpbmRleCA9IDAsIGh0bWwgPSAnJykge1xuICBjb25zdCBvcGVuVGFnU3JjID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykucmVkdWNlKChzcmMsIGF0dHIpID0+IHtcbiAgICBsZXQgdmFsID0gYXR0cmlidXRlc1thdHRyXTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsID0gdmFsKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3NyY30gJHthdHRyfT1cIiR7dmFsfVwiYDtcbiAgfSwgdGFnTmFtZSk7XG4gIGh0bWwgKz0gYDwke29wZW5UYWdTcmN9PjwvJHt0YWdOYW1lfT5gO1xuXG4gIGNvbnN0IG5leHQgPSBpbmRleCArIDE7XG4gIHJldHVybiBuZXh0IDwgcmVwZWF0XG4gICAgPyBjcmVhdGVUYWdSZXBlYXQodGFnTmFtZSwgcmVwZWF0LCBhdHRyaWJ1dGVzLCBuZXh0LCBodG1sKVxuICAgIDogaHRtbDtcbn1cblxuLy8gUmVtb3ZlIHRoZSBzcGFjaW5nIHN1cnJvdW5kaW5nIHRhZ3MgZm9yIEhUTUwgcGFyc2VyIG5vdCB0byBjcmVhdGUgdGV4dCBub2Rlc1xuLy8gYmVmb3JlL2FmdGVyIGVsZW1lbnRzXG5mdW5jdGlvbiBvcHRpbWl6ZVRlbXBsYXRlSFRNTChodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoLz5cXHMrL2csICc+JykucmVwbGFjZSgvXFxzKzwvLCAnPCcpO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NDc6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIF9fd2VicGFja191bnVzZWRfZXhwb3J0X187XG5cbl9fd2VicGFja191bnVzZWRfZXhwb3J0X18gPSAoeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFdmVudHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRzKGV2ZW50VHlwZSwgZXZlbnRGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKGV2ZW50RnVuY3Rpb25zID09PSB2b2lkIDApIHsgZXZlbnRGdW5jdGlvbnMgPSBbXTsgfVxuICAgICAgICB0aGlzLl9ldmVudFR5cGUgPSBldmVudFR5cGU7XG4gICAgICAgIHRoaXMuX2V2ZW50RnVuY3Rpb25zID0gZXZlbnRGdW5jdGlvbnM7XG4gICAgfVxuICAgIEV2ZW50cy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZXZlbnRGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoX3RoaXMuX2V2ZW50VHlwZSwgZXZlbnRGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50cztcbn0oKSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEV2ZW50cztcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4hZnVuY3Rpb24oKSB7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImluaXREYXRlcGlja2Vyc1wiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gaW5pdERhdGVwaWNrZXJzOyB9XG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBmbG93Yml0ZV9kYXRlcGlja2VyX0RhdGVwaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzcwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBmbG93Yml0ZV9kYXRlcGlja2VyX0RhdGVSYW5nZVBpY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0Nyk7XG5cblxuXG52YXIgZ2V0RGF0ZXBpY2tlck9wdGlvbnMgPSBmdW5jdGlvbiBnZXREYXRlcGlja2VyT3B0aW9ucyhkYXRlcGlja2VyRWwpIHtcbiAgdmFyIGJ1dHRvbnMgPSBkYXRlcGlja2VyRWwuaGFzQXR0cmlidXRlKCdkYXRlcGlja2VyLWJ1dHRvbnMnKTtcbiAgdmFyIGF1dG9oaWRlID0gZGF0ZXBpY2tlckVsLmhhc0F0dHJpYnV0ZSgnZGF0ZXBpY2tlci1hdXRvaGlkZScpO1xuICB2YXIgZm9ybWF0ID0gZGF0ZXBpY2tlckVsLmhhc0F0dHJpYnV0ZSgnZGF0ZXBpY2tlci1mb3JtYXQnKTtcbiAgdmFyIG9yaWVudGF0aW9uID0gZGF0ZXBpY2tlckVsLmhhc0F0dHJpYnV0ZSgnZGF0ZXBpY2tlci1vcmllbnRhdGlvbicpO1xuICB2YXIgdGl0bGUgPSBkYXRlcGlja2VyRWwuaGFzQXR0cmlidXRlKCdkYXRlcGlja2VyLXRpdGxlJyk7XG4gIHZhciBvcHRpb25zID0ge307XG4gIGlmIChidXR0b25zKSB7XG4gICAgb3B0aW9ucy50b2RheUJ0biA9IHRydWU7XG4gICAgb3B0aW9ucy5jbGVhckJ0biA9IHRydWU7XG4gIH1cbiAgaWYgKGF1dG9oaWRlKSB7XG4gICAgb3B0aW9ucy5hdXRvaGlkZSA9IHRydWU7XG4gIH1cbiAgaWYgKGZvcm1hdCkge1xuICAgIG9wdGlvbnMuZm9ybWF0ID0gZGF0ZXBpY2tlckVsLmdldEF0dHJpYnV0ZSgnZGF0ZXBpY2tlci1mb3JtYXQnKTtcbiAgfVxuICBpZiAob3JpZW50YXRpb24pIHtcbiAgICBvcHRpb25zLm9yaWVudGF0aW9uID0gZGF0ZXBpY2tlckVsLmdldEF0dHJpYnV0ZSgnZGF0ZXBpY2tlci1vcmllbnRhdGlvbicpO1xuICB9XG4gIGlmICh0aXRsZSkge1xuICAgIG9wdGlvbnMudGl0bGUgPSBkYXRlcGlja2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRlcGlja2VyLXRpdGxlJyk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuZnVuY3Rpb24gaW5pdERhdGVwaWNrZXJzKCkge1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0ZXBpY2tlcl0nKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRlcGlja2VyRWwpIHtcbiAgICBuZXcgZmxvd2JpdGVfZGF0ZXBpY2tlcl9EYXRlcGlja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiBbXCJkZWZhdWx0XCJdICovIC5aKGRhdGVwaWNrZXJFbCwgZ2V0RGF0ZXBpY2tlck9wdGlvbnMoZGF0ZXBpY2tlckVsKSk7XG4gIH0pO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaW5saW5lLWRhdGVwaWNrZXJdJykuZm9yRWFjaChmdW5jdGlvbiAoZGF0ZXBpY2tlckVsKSB7XG4gICAgbmV3IGZsb3diaXRlX2RhdGVwaWNrZXJfRGF0ZXBpY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogW1wiZGVmYXVsdFwiXSAqLyAuWihkYXRlcGlja2VyRWwsIGdldERhdGVwaWNrZXJPcHRpb25zKGRhdGVwaWNrZXJFbCkpO1xuICB9KTtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGUtcmFuZ2VwaWNrZXJdJykuZm9yRWFjaChmdW5jdGlvbiAoZGF0ZXBpY2tlckVsKSB7XG4gICAgbmV3IGZsb3diaXRlX2RhdGVwaWNrZXJfRGF0ZVJhbmdlUGlja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiBbXCJkZWZhdWx0XCJdICovIC5aKGRhdGVwaWNrZXJFbCwgZ2V0RGF0ZXBpY2tlck9wdGlvbnMoZGF0ZXBpY2tlckVsKSk7XG4gIH0pO1xufVxudmFyIGV2ZW50cyA9IG5ldyBfZG9tX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSgnRE9NQ29udGVudExvYWRlZCcsIFtpbml0RGF0ZXBpY2tlcnNdKTtcbmV2ZW50cy5pbml0KCk7XG59KCk7XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlcGlja2VyLmpzLm1hcCIsIi8qIVxuKiBUYWlsd2luZCBFbGVtZW50cyAxLjAuMC1iZXRhM1xuKiBcbiogVGFpbHdpbmQgRWxlbWVudHMgaXMgYW4gb3Blbi1zb3VyY2UgVUkga2l0IG9mIGFkdmFuY2VkIGNvbXBvbmVudHMgZm9yIFRhaWx3aW5kQ1NTLlxuKiBDb3B5cmlnaHQgwqkgMjAyMyBNREJvb3RzdHJhcC5jb21cbiogXG4qIFVubGVzcyBhIGN1c3RvbSwgaW5kaXZpZHVhbGx5IGFzc2lnbmVkIGxpY2Vuc2UgaGFzIGJlZW4gZ3JhbnRlZCwgdGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgQWZmZXJvIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4qIEluIGFkZGl0aW9uLCBhIGN1c3RvbSBsaWNlbnNlIG1heSBiZSBhdmFpbGFibGUgdXBvbiByZXF1ZXN0LCBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGF0IGxpY2Vuc2UuIFBsZWFzZSBjb250YWN0IHRhaWx3aW5kQG1kYm9vdHN0cmFwLmNvbSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBvYnRhaW5pbmcgYSBjdXN0b20gbGljZW5zZS5cbiogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgQWZmZXJvIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiogXG4qL1xudmFyIE5jID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIFJjID0gKHMsIHQsIGUpID0+IHQgaW4gcyA/IE5jKHMsIHQsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IGUgfSkgOiBzW3RdID0gZTtcbnZhciBBdCA9IChzLCB0LCBlKSA9PiAoUmMocywgdHlwZW9mIHQgIT0gXCJzeW1ib2xcIiA/IHQgKyBcIlwiIDogdCwgZSksIGUpO1xuY29uc3QgWnMgPSAoKCkgPT4ge1xuICBjb25zdCBzID0ge307XG4gIGxldCB0ID0gMTtcbiAgcmV0dXJuIHtcbiAgICBzZXQoZSwgaSwgbikge1xuICAgICAgdHlwZW9mIGVbaV0gPiBcInVcIiAmJiAoZVtpXSA9IHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICBpZDogdFxuICAgICAgfSwgdCsrKSwgc1tlW2ldLmlkXSA9IG47XG4gICAgfSxcbiAgICBnZXQoZSwgaSkge1xuICAgICAgaWYgKCFlIHx8IHR5cGVvZiBlW2ldID4gXCJ1XCIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgbiA9IGVbaV07XG4gICAgICByZXR1cm4gbi5rZXkgPT09IGkgPyBzW24uaWRdIDogbnVsbDtcbiAgICB9LFxuICAgIGRlbGV0ZShlLCBpKSB7XG4gICAgICBpZiAodHlwZW9mIGVbaV0gPiBcInVcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbiA9IGVbaV07XG4gICAgICBuLmtleSA9PT0gaSAmJiAoZGVsZXRlIHNbbi5pZF0sIGRlbGV0ZSBlW2ldKTtcbiAgICB9XG4gIH07XG59KSgpLCBJID0ge1xuICBzZXREYXRhKHMsIHQsIGUpIHtcbiAgICBacy5zZXQocywgdCwgZSk7XG4gIH0sXG4gIGdldERhdGEocywgdCkge1xuICAgIHJldHVybiBacy5nZXQocywgdCk7XG4gIH0sXG4gIHJlbW92ZURhdGEocywgdCkge1xuICAgIFpzLmRlbGV0ZShzLCB0KTtcbiAgfVxufSwgUGMgPSAxZTYsIEJjID0gMWUzLCBRbiA9IFwidHJhbnNpdGlvbmVuZFwiLCBIYyA9IChzKSA9PiBzID09IG51bGwgPyBgJHtzfWAgOiB7fS50b1N0cmluZy5jYWxsKHMpLm1hdGNoKC9cXHMoW2Etel0rKS9pKVsxXS50b0xvd2VyQ2FzZSgpLCBidCA9IChzKSA9PiB7XG4gIGRvXG4gICAgcyArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBQYyk7XG4gIHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzKSk7XG4gIHJldHVybiBzO1xufSwgUWEgPSAocykgPT4ge1xuICBsZXQgdCA9IHMuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS10YXJnZXRcIik7XG4gIGlmICghdCB8fCB0ID09PSBcIiNcIikge1xuICAgIGxldCBlID0gcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgIGlmICghZSB8fCAhZS5pbmNsdWRlcyhcIiNcIikgJiYgIWUuc3RhcnRzV2l0aChcIi5cIikpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBlLmluY2x1ZGVzKFwiI1wiKSAmJiAhZS5zdGFydHNXaXRoKFwiI1wiKSAmJiAoZSA9IGAjJHtlLnNwbGl0KFwiI1wiKVsxXX1gKSwgdCA9IGUgJiYgZSAhPT0gXCIjXCIgPyBlLnRyaW0oKSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIHQ7XG59LCBmbyA9IChzKSA9PiB7XG4gIGNvbnN0IHQgPSBRYShzKTtcbiAgcmV0dXJuIHQgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KSA/IHQgOiBudWxsO1xufSwgUXQgPSAocykgPT4ge1xuICBjb25zdCB0ID0gUWEocyk7XG4gIHJldHVybiB0ID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KSA6IG51bGw7XG59LCBXYyA9IChzKSA9PiB7XG4gIGlmICghcylcbiAgICByZXR1cm4gMDtcbiAgbGV0IHsgdHJhbnNpdGlvbkR1cmF0aW9uOiB0LCB0cmFuc2l0aW9uRGVsYXk6IGUgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHMpO1xuICBjb25zdCBpID0gTnVtYmVyLnBhcnNlRmxvYXQodCksIG4gPSBOdW1iZXIucGFyc2VGbG9hdChlKTtcbiAgcmV0dXJuICFpICYmICFuID8gMCA6ICh0ID0gdC5zcGxpdChcIixcIilbMF0sIGUgPSBlLnNwbGl0KFwiLFwiKVswXSwgKE51bWJlci5wYXJzZUZsb2F0KHQpICsgTnVtYmVyLnBhcnNlRmxvYXQoZSkpICogQmMpO1xufSwgSmEgPSAocykgPT4ge1xuICBzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFFuKSk7XG59LCBWZSA9IChzKSA9PiAhcyB8fCB0eXBlb2YgcyAhPSBcIm9iamVjdFwiID8gITEgOiAodHlwZW9mIHMuanF1ZXJ5IDwgXCJ1XCIgJiYgKHMgPSBzWzBdKSwgdHlwZW9mIHMubm9kZVR5cGUgPCBcInVcIiksIEp0ID0gKHMpID0+IFZlKHMpID8gcy5qcXVlcnkgPyBzWzBdIDogcyA6IHR5cGVvZiBzID09IFwic3RyaW5nXCIgJiYgcy5sZW5ndGggPiAwID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzKSA6IG51bGwsIEwgPSAocywgdCwgZSkgPT4ge1xuICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgY29uc3QgbiA9IGVbaV0sIG8gPSB0W2ldLCByID0gbyAmJiBWZShvKSA/IFwiZWxlbWVudFwiIDogSGMobyk7XG4gICAgaWYgKCFuZXcgUmVnRXhwKG4pLnRlc3QocikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAke3MudG9VcHBlckNhc2UoKX06IE9wdGlvbiBcIiR7aX1cIiBwcm92aWRlZCB0eXBlIFwiJHtyfVwiIGJ1dCBleHBlY3RlZCB0eXBlIFwiJHtufVwiLmBcbiAgICAgICk7XG4gIH0pO1xufSwgTHQgPSAocykgPT4ge1xuICBpZiAoIXMgfHwgcy5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gITE7XG4gIGlmIChzLnN0eWxlICYmIHMucGFyZW50Tm9kZSAmJiBzLnBhcmVudE5vZGUuc3R5bGUpIHtcbiAgICBjb25zdCB0ID0gZ2V0Q29tcHV0ZWRTdHlsZShzKSwgZSA9IGdldENvbXB1dGVkU3R5bGUocy5wYXJlbnROb2RlKTtcbiAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShzKS5nZXRQcm9wZXJ0eVZhbHVlKFwidmlzaWJpbGl0eVwiKSA9PT0gXCJ2aXNpYmxlXCIgfHwgdC5kaXNwbGF5ICE9PSBcIm5vbmVcIiAmJiBlLmRpc3BsYXkgIT09IFwibm9uZVwiICYmIHQudmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIjtcbiAgfVxuICByZXR1cm4gITE7XG59LCBtZSA9IChzKSA9PiAhcyB8fCBzLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSB8fCBzLmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpID8gITAgOiB0eXBlb2Ygcy5kaXNhYmxlZCA8IFwidVwiID8gcy5kaXNhYmxlZCA6IHMuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgJiYgcy5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSAhPT0gXCJmYWxzZVwiLCB0bCA9IChzKSA9PiB7XG4gIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaFNoYWRvdylcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHR5cGVvZiBzLmdldFJvb3ROb2RlID09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHQgPSBzLmdldFJvb3ROb2RlKCk7XG4gICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gdCA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gcyA6IHMucGFyZW50Tm9kZSA/IHRsKHMucGFyZW50Tm9kZSkgOiBudWxsO1xufSwgTXMgPSAoKSA9PiBmdW5jdGlvbigpIHtcbn0sIEdlID0gKHMpID0+IHtcbiAgcy5vZmZzZXRIZWlnaHQ7XG59LCBlbCA9ICgpID0+IHtcbiAgY29uc3QgeyBqUXVlcnk6IHMgfSA9IHdpbmRvdztcbiAgcmV0dXJuIHMgJiYgIWRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKFwiZGF0YS10ZS1uby1qcXVlcnlcIikgPyBzIDogbnVsbDtcbn0sIFFzID0gW10sIGlsID0gKHMpID0+IHtcbiAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIgPyAoUXMubGVuZ3RoIHx8IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcbiAgICBRcy5mb3JFYWNoKCh0KSA9PiB0KCkpO1xuICB9KSwgUXMucHVzaChzKSkgOiBzKCk7XG59LCBGID0gKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9PT0gXCJydGxcIiwgVmMgPSAocykgPT4gQXJyYXkuZnJvbShzKSwgRCA9IChzKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHMpLCBmZSA9IChzKSA9PiB7XG4gIHR5cGVvZiBzID09IFwiZnVuY3Rpb25cIiAmJiBzKCk7XG59LCBzbCA9IChzLCB0LCBlID0gITApID0+IHtcbiAgaWYgKCFlKSB7XG4gICAgZmUocyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGkgPSA1LCBuID0gV2ModCkgKyBpO1xuICBsZXQgbyA9ICExO1xuICBjb25zdCByID0gKHsgdGFyZ2V0OiBhIH0pID0+IHtcbiAgICBhID09PSB0ICYmIChvID0gITAsIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihRbiwgciksIGZlKHMpKTtcbiAgfTtcbiAgdC5hZGRFdmVudExpc3RlbmVyKFFuLCByKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgbyB8fCBKYSh0KTtcbiAgfSwgbik7XG59LCBubCA9IChzLCB0LCBlLCBpKSA9PiB7XG4gIGxldCBuID0gcy5pbmRleE9mKHQpO1xuICBpZiAobiA9PT0gLTEpXG4gICAgcmV0dXJuIHNbIWUgJiYgaSA/IHMubGVuZ3RoIC0gMSA6IDBdO1xuICBjb25zdCBvID0gcy5sZW5ndGg7XG4gIHJldHVybiBuICs9IGUgPyAxIDogLTEsIGkgJiYgKG4gPSAobiArIG8pICUgbyksIHNbTWF0aC5tYXgoMCwgTWF0aC5taW4obiwgbyAtIDEpKV07XG59LCBGYyA9IC9bXi5dKig/PVxcLi4qKVxcLnwuKi8sIFljID0gL1xcLi4qLywgamMgPSAvOjpcXGQrJC8sIEpzID0ge307XG5sZXQgWW8gPSAxO1xuY29uc3QgS2MgPSB7XG4gIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxufSwgemMgPSAvXihtb3VzZWVudGVyfG1vdXNlbGVhdmUpL2ksIG9sID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImNsaWNrXCIsXG4gIFwiZGJsY2xpY2tcIixcbiAgXCJtb3VzZXVwXCIsXG4gIFwibW91c2Vkb3duXCIsXG4gIFwiY29udGV4dG1lbnVcIixcbiAgXCJtb3VzZXdoZWVsXCIsXG4gIFwiRE9NTW91c2VTY3JvbGxcIixcbiAgXCJtb3VzZW92ZXJcIixcbiAgXCJtb3VzZW91dFwiLFxuICBcIm1vdXNlbW92ZVwiLFxuICBcInNlbGVjdHN0YXJ0XCIsXG4gIFwic2VsZWN0ZW5kXCIsXG4gIFwia2V5ZG93blwiLFxuICBcImtleXByZXNzXCIsXG4gIFwia2V5dXBcIixcbiAgXCJvcmllbnRhdGlvbmNoYW5nZVwiLFxuICBcInRvdWNoc3RhcnRcIixcbiAgXCJ0b3VjaG1vdmVcIixcbiAgXCJ0b3VjaGVuZFwiLFxuICBcInRvdWNoY2FuY2VsXCIsXG4gIFwicG9pbnRlcmRvd25cIixcbiAgXCJwb2ludGVybW92ZVwiLFxuICBcInBvaW50ZXJ1cFwiLFxuICBcInBvaW50ZXJsZWF2ZVwiLFxuICBcInBvaW50ZXJjYW5jZWxcIixcbiAgXCJnZXN0dXJlc3RhcnRcIixcbiAgXCJnZXN0dXJlY2hhbmdlXCIsXG4gIFwiZ2VzdHVyZWVuZFwiLFxuICBcImZvY3VzXCIsXG4gIFwiYmx1clwiLFxuICBcImNoYW5nZVwiLFxuICBcInJlc2V0XCIsXG4gIFwic2VsZWN0XCIsXG4gIFwic3VibWl0XCIsXG4gIFwiZm9jdXNpblwiLFxuICBcImZvY3Vzb3V0XCIsXG4gIFwibG9hZFwiLFxuICBcInVubG9hZFwiLFxuICBcImJlZm9yZXVubG9hZFwiLFxuICBcInJlc2l6ZVwiLFxuICBcIm1vdmVcIixcbiAgXCJET01Db250ZW50TG9hZGVkXCIsXG4gIFwicmVhZHlzdGF0ZWNoYW5nZVwiLFxuICBcImVycm9yXCIsXG4gIFwiYWJvcnRcIixcbiAgXCJzY3JvbGxcIlxuXSk7XG5mdW5jdGlvbiBybChzLCB0KSB7XG4gIHJldHVybiB0ICYmIGAke3R9Ojoke1lvKyt9YCB8fCBzLnVpZEV2ZW50IHx8IFlvKys7XG59XG5mdW5jdGlvbiBhbChzKSB7XG4gIGNvbnN0IHQgPSBybChzKTtcbiAgcmV0dXJuIHMudWlkRXZlbnQgPSB0LCBKc1t0XSA9IEpzW3RdIHx8IHt9LCBKc1t0XTtcbn1cbmZ1bmN0aW9uIFVjKHMsIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGUoaSkge1xuICAgIHJldHVybiBpLmRlbGVnYXRlVGFyZ2V0ID0gcywgZS5vbmVPZmYgJiYgaC5vZmYocywgaS50eXBlLCB0KSwgdC5hcHBseShzLCBbaV0pO1xuICB9O1xufVxuZnVuY3Rpb24gWGMocywgdCwgZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaShuKSB7XG4gICAgY29uc3QgbyA9IHMucXVlcnlTZWxlY3RvckFsbCh0KTtcbiAgICBmb3IgKGxldCB7IHRhcmdldDogciB9ID0gbjsgciAmJiByICE9PSB0aGlzOyByID0gci5wYXJlbnROb2RlKVxuICAgICAgZm9yIChsZXQgYSA9IG8ubGVuZ3RoOyBhLS07IFwiXCIpXG4gICAgICAgIGlmIChvW2FdID09PSByKVxuICAgICAgICAgIHJldHVybiBuLmRlbGVnYXRlVGFyZ2V0ID0gciwgaS5vbmVPZmYgJiYgaC5vZmYocywgbi50eXBlLCBlKSwgZS5hcHBseShyLCBbbl0pO1xuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuZnVuY3Rpb24gbGwocywgdCwgZSA9IG51bGwpIHtcbiAgY29uc3QgaSA9IE9iamVjdC5rZXlzKHMpO1xuICBmb3IgKGxldCBuID0gMCwgbyA9IGkubGVuZ3RoOyBuIDwgbzsgbisrKSB7XG4gICAgY29uc3QgciA9IHNbaVtuXV07XG4gICAgaWYgKHIub3JpZ2luYWxIYW5kbGVyID09PSB0ICYmIHIuZGVsZWdhdGlvblNlbGVjdG9yID09PSBlKVxuICAgICAgcmV0dXJuIHI7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbChzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiLCBuID0gaSA/IGUgOiB0O1xuICBsZXQgbyA9IGhsKHMpO1xuICByZXR1cm4gb2wuaGFzKG8pIHx8IChvID0gcyksIFtpLCBuLCBvXTtcbn1cbmZ1bmN0aW9uIGpvKHMsIHQsIGUsIGksIG4pIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgfHwgIXMpXG4gICAgcmV0dXJuO1xuICBpZiAoZSB8fCAoZSA9IGksIGkgPSBudWxsKSwgemMudGVzdCh0KSkge1xuICAgIGNvbnN0IG0gPSAoZykgPT4gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCF2LnJlbGF0ZWRUYXJnZXQgfHwgdi5yZWxhdGVkVGFyZ2V0ICE9PSB2LmRlbGVnYXRlVGFyZ2V0ICYmICF2LmRlbGVnYXRlVGFyZ2V0LmNvbnRhaW5zKHYucmVsYXRlZFRhcmdldCkpXG4gICAgICAgIHJldHVybiBnLmNhbGwodGhpcywgdik7XG4gICAgfTtcbiAgICBpID8gaSA9IG0oaSkgOiBlID0gbShlKTtcbiAgfVxuICBjb25zdCBbbywgciwgYV0gPSBjbChcbiAgICB0LFxuICAgIGUsXG4gICAgaVxuICApLCBsID0gYWwocyksIHAgPSBsW2FdIHx8IChsW2FdID0ge30pLCB1ID0gbGwoXG4gICAgcCxcbiAgICByLFxuICAgIG8gPyBlIDogbnVsbFxuICApO1xuICBpZiAodSkge1xuICAgIHUub25lT2ZmID0gdS5vbmVPZmYgJiYgbjtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZiA9IHJsKFxuICAgIHIsXG4gICAgdC5yZXBsYWNlKEZjLCBcIlwiKVxuICApLCBfID0gbyA/IFhjKHMsIGUsIGkpIDogVWMocywgZSk7XG4gIF8uZGVsZWdhdGlvblNlbGVjdG9yID0gbyA/IGUgOiBudWxsLCBfLm9yaWdpbmFsSGFuZGxlciA9IHIsIF8ub25lT2ZmID0gbiwgXy51aWRFdmVudCA9IGYsIHBbZl0gPSBfLCBzLmFkZEV2ZW50TGlzdGVuZXIoYSwgXywgbyk7XG59XG5mdW5jdGlvbiBKbihzLCB0LCBlLCBpLCBuKSB7XG4gIGNvbnN0IG8gPSBsbCh0W2VdLCBpLCBuKTtcbiAgbyAmJiAocy5yZW1vdmVFdmVudExpc3RlbmVyKGUsIG8sICEhbiksIGRlbGV0ZSB0W2VdW28udWlkRXZlbnRdKTtcbn1cbmZ1bmN0aW9uIEdjKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IHRbZV0gfHwge307XG4gIE9iamVjdC5rZXlzKG4pLmZvckVhY2goKG8pID0+IHtcbiAgICBpZiAoby5pbmNsdWRlcyhpKSkge1xuICAgICAgY29uc3QgciA9IG5bb107XG4gICAgICBKbihcbiAgICAgICAgcyxcbiAgICAgICAgdCxcbiAgICAgICAgZSxcbiAgICAgICAgci5vcmlnaW5hbEhhbmRsZXIsXG4gICAgICAgIHIuZGVsZWdhdGlvblNlbGVjdG9yXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBobChzKSB7XG4gIHJldHVybiBzID0gcy5yZXBsYWNlKFljLCBcIlwiKSwgS2Nbc10gfHwgcztcbn1cbmNvbnN0IGggPSB7XG4gIG9uKHMsIHQsIGUsIGkpIHtcbiAgICBqbyhzLCB0LCBlLCBpLCAhMSk7XG4gIH0sXG4gIG9uZShzLCB0LCBlLCBpKSB7XG4gICAgam8ocywgdCwgZSwgaSwgITApO1xuICB9LFxuICBvZmYocywgdCwgZSwgaSkge1xuICAgIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFtuLCBvLCByXSA9IGNsKFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICBpXG4gICAgKSwgYSA9IHIgIT09IHQsIGwgPSBhbChzKSwgcCA9IHQuc3RhcnRzV2l0aChcIi5cIik7XG4gICAgaWYgKHR5cGVvZiBvIDwgXCJ1XCIpIHtcbiAgICAgIGlmICghbCB8fCAhbFtyXSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgSm4oXG4gICAgICAgIHMsXG4gICAgICAgIGwsXG4gICAgICAgIHIsXG4gICAgICAgIG8sXG4gICAgICAgIG4gPyBlIDogbnVsbFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcCAmJiBPYmplY3Qua2V5cyhsKS5mb3JFYWNoKChmKSA9PiB7XG4gICAgICBHYyhcbiAgICAgICAgcyxcbiAgICAgICAgbCxcbiAgICAgICAgZixcbiAgICAgICAgdC5zbGljZSgxKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjb25zdCB1ID0gbFtyXSB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyh1KS5mb3JFYWNoKChmKSA9PiB7XG4gICAgICBjb25zdCBfID0gZi5yZXBsYWNlKGpjLCBcIlwiKTtcbiAgICAgIGlmICghYSB8fCB0LmluY2x1ZGVzKF8pKSB7XG4gICAgICAgIGNvbnN0IG0gPSB1W2ZdO1xuICAgICAgICBKbihcbiAgICAgICAgICBzLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgcixcbiAgICAgICAgICBtLm9yaWdpbmFsSGFuZGxlcixcbiAgICAgICAgICBtLmRlbGVnYXRpb25TZWxlY3RvclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICB0cmlnZ2VyKHMsIHQsIGUpIHtcbiAgICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIiB8fCAhcylcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGkgPSBlbCgpLCBuID0gaGwodCksIG8gPSB0ICE9PSBuLCByID0gb2wuaGFzKG4pO1xuICAgIGxldCBhLCBsID0gITAsIHAgPSAhMCwgdSA9ICExLCBmID0gbnVsbDtcbiAgICByZXR1cm4gbyAmJiBpICYmIChhID0gaS5FdmVudCh0LCBlKSwgaShzKS50cmlnZ2VyKGEpLCBsID0gIWEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSwgcCA9ICFhLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCksIHUgPSBhLmlzRGVmYXVsdFByZXZlbnRlZCgpKSwgciA/IChmID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpLCBmLmluaXRFdmVudChuLCBsLCAhMCkpIDogZiA9IG5ldyBDdXN0b21FdmVudCh0LCB7XG4gICAgICBidWJibGVzOiBsLFxuICAgICAgY2FuY2VsYWJsZTogITBcbiAgICB9KSwgdHlwZW9mIGUgPCBcInVcIiAmJiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChfKSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGVbX107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLCB1ICYmIGYucHJldmVudERlZmF1bHQoKSwgcCAmJiBzLmRpc3BhdGNoRXZlbnQoZiksIGYuZGVmYXVsdFByZXZlbnRlZCAmJiB0eXBlb2YgYSA8IFwidVwiICYmIGEucHJldmVudERlZmF1bHQoKSwgZjtcbiAgfVxufSwgb2UgPSB7XG4gIG9uKHMsIHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gdC5zcGxpdChcIiBcIik7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBuLmxlbmd0aDsgbysrKVxuICAgICAgaC5vbihzLCBuW29dLCBlLCBpKTtcbiAgfSxcbiAgb2ZmKHMsIHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gdC5zcGxpdChcIiBcIik7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBuLmxlbmd0aDsgbysrKVxuICAgICAgaC5vZmYocywgbltvXSwgZSwgaSk7XG4gIH1cbn0sIHFjID0gXCI1LjEuM1wiO1xuY2xhc3MgRXQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdCA9IEp0KHQpLCB0ICYmICh0aGlzLl9lbGVtZW50ID0gdCwgSS5zZXREYXRhKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKSwgaC5vZmYodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0aGlzW3RdID0gbnVsbDtcbiAgICB9KTtcbiAgfVxuICBfcXVldWVDYWxsYmFjayh0LCBlLCBpID0gITApIHtcbiAgICBzbCh0LCBlLCBpKTtcbiAgfVxuICAvKiogU3RhdGljICovXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YShKdCh0KSwgdGhpcy5EQVRBX0tFWSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIHFjO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnWW91IGhhdmUgdG8gaW1wbGVtZW50IHRoZSBzdGF0aWMgbWV0aG9kIFwiTkFNRVwiLCBmb3IgZWFjaCBjb21wb25lbnQhJ1xuICAgICk7XG4gIH1cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gYHRlLiR7dGhpcy5OQU1FfWA7XG4gIH1cbiAgc3RhdGljIGdldCBFVkVOVF9LRVkoKSB7XG4gICAgcmV0dXJuIGAuJHt0aGlzLkRBVEFfS0VZfWA7XG4gIH1cbn1cbmNvbnN0IFpjID0gXCJidXR0b25cIiwgUWMgPSBcImFjdGl2ZVwiO1xuY2xhc3MgZGwgZXh0ZW5kcyBFdCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBaYztcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLXByZXNzZWRcIixcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShRYylcbiAgICApO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IGRsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICB0ID09PSBcInRvZ2dsZVwiICYmIGVbdF0oKTtcbiAgICB9KTtcbiAgfVxufVxudmFyIFEgPSBcInRvcFwiLCBodCA9IFwiYm90dG9tXCIsIGR0ID0gXCJyaWdodFwiLCBKID0gXCJsZWZ0XCIsIElpID0gXCJhdXRvXCIsIHFlID0gW1EsIGh0LCBkdCwgSl0sIHZlID0gXCJzdGFydFwiLCBGZSA9IFwiZW5kXCIsIHVsID0gXCJjbGlwcGluZ1BhcmVudHNcIiwgbW8gPSBcInZpZXdwb3J0XCIsIEllID0gXCJwb3BwZXJcIiwgcGwgPSBcInJlZmVyZW5jZVwiLCB0byA9IC8qIEBfX1BVUkVfXyAqLyBxZS5yZWR1Y2UoZnVuY3Rpb24ocywgdCkge1xuICByZXR1cm4gcy5jb25jYXQoW3QgKyBcIi1cIiArIHZlLCB0ICsgXCItXCIgKyBGZV0pO1xufSwgW10pLCBnbyA9IC8qIEBfX1BVUkVfXyAqLyBbXS5jb25jYXQocWUsIFtJaV0pLnJlZHVjZShmdW5jdGlvbihzLCB0KSB7XG4gIHJldHVybiBzLmNvbmNhdChbdCwgdCArIFwiLVwiICsgdmUsIHQgKyBcIi1cIiArIEZlXSk7XG59LCBbXSksIF9sID0gXCJiZWZvcmVSZWFkXCIsIGZsID0gXCJyZWFkXCIsIG1sID0gXCJhZnRlclJlYWRcIiwgZ2wgPSBcImJlZm9yZU1haW5cIiwgYmwgPSBcIm1haW5cIiwgdmwgPSBcImFmdGVyTWFpblwiLCBUbCA9IFwiYmVmb3JlV3JpdGVcIiwgRWwgPSBcIndyaXRlXCIsIENsID0gXCJhZnRlcldyaXRlXCIsIE5zID0gW19sLCBmbCwgbWwsIGdsLCBibCwgdmwsIFRsLCBFbCwgQ2xdO1xuZnVuY3Rpb24gTnQocykge1xuICByZXR1cm4gcyA/IChzLm5vZGVOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufVxuZnVuY3Rpb24gdXQocykge1xuICBpZiAocyA9PSBudWxsKVxuICAgIHJldHVybiB3aW5kb3c7XG4gIGlmIChzLnRvU3RyaW5nKCkgIT09IFwiW29iamVjdCBXaW5kb3ddXCIpIHtcbiAgICB2YXIgdCA9IHMub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gdCAmJiB0LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIFRlKHMpIHtcbiAgdmFyIHQgPSB1dChzKS5FbGVtZW50O1xuICByZXR1cm4gcyBpbnN0YW5jZW9mIHQgfHwgcyBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBjdChzKSB7XG4gIHZhciB0ID0gdXQocykuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBzIGluc3RhbmNlb2YgdCB8fCBzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBibyhzKSB7XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA+IFwidVwiKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIHQgPSB1dChzKS5TaGFkb3dSb290O1xuICByZXR1cm4gcyBpbnN0YW5jZW9mIHQgfHwgcyBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBKYyhzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZTtcbiAgT2JqZWN0LmtleXModC5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgdmFyIGkgPSB0LnN0eWxlc1tlXSB8fCB7fSwgbiA9IHQuYXR0cmlidXRlc1tlXSB8fCB7fSwgbyA9IHQuZWxlbWVudHNbZV07XG4gICAgIWN0KG8pIHx8ICFOdChvKSB8fCAoT2JqZWN0LmFzc2lnbihvLnN0eWxlLCBpKSwgT2JqZWN0LmtleXMobikuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgYSA9IG5bcl07XG4gICAgICBhID09PSAhMSA/IG8ucmVtb3ZlQXR0cmlidXRlKHIpIDogby5zZXRBdHRyaWJ1dGUociwgYSA9PT0gITAgPyBcIlwiIDogYSk7XG4gICAgfSkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRoKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHQub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6IFwiMFwiLFxuICAgICAgdG9wOiBcIjBcIixcbiAgICAgIG1hcmdpbjogXCIwXCJcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHQuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBlLnBvcHBlciksIHQuc3R5bGVzID0gZSwgdC5lbGVtZW50cy5hcnJvdyAmJiBPYmplY3QuYXNzaWduKHQuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGUuYXJyb3cpLCBmdW5jdGlvbigpIHtcbiAgICBPYmplY3Qua2V5cyh0LmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBuID0gdC5lbGVtZW50c1tpXSwgbyA9IHQuYXR0cmlidXRlc1tpXSB8fCB7fSwgciA9IE9iamVjdC5rZXlzKHQuc3R5bGVzLmhhc093blByb3BlcnR5KGkpID8gdC5zdHlsZXNbaV0gOiBlW2ldKSwgYSA9IHIucmVkdWNlKGZ1bmN0aW9uKGwsIHApIHtcbiAgICAgICAgcmV0dXJuIGxbcF0gPSBcIlwiLCBsO1xuICAgICAgfSwge30pO1xuICAgICAgIWN0KG4pIHx8ICFOdChuKSB8fCAoT2JqZWN0LmFzc2lnbihuLnN0eWxlLCBhKSwgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbihsKSB7XG4gICAgICAgIG4ucmVtb3ZlQXR0cmlidXRlKGwpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9O1xufVxuY29uc3Qgdm8gPSB7XG4gIG5hbWU6IFwiYXBwbHlTdHlsZXNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIndyaXRlXCIsXG4gIGZuOiBKYyxcbiAgZWZmZWN0OiB0aCxcbiAgcmVxdWlyZXM6IFtcImNvbXB1dGVTdHlsZXNcIl1cbn07XG5mdW5jdGlvbiB2dChzKSB7XG4gIHJldHVybiBzLnNwbGl0KFwiLVwiKVswXTtcbn1cbnZhciBnZSA9IE1hdGgubWF4LCBScyA9IE1hdGgubWluLCBZZSA9IE1hdGgucm91bmQ7XG5mdW5jdGlvbiBlbygpIHtcbiAgdmFyIHMgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgcmV0dXJuIHMgIT0gbnVsbCAmJiBzLmJyYW5kcyAmJiBBcnJheS5pc0FycmF5KHMuYnJhbmRzKSA/IHMuYnJhbmRzLm1hcChmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuYnJhbmQgKyBcIi9cIiArIHQudmVyc2lvbjtcbiAgfSkuam9pbihcIiBcIikgOiBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuZnVuY3Rpb24gQWwoKSB7XG4gIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChlbygpKTtcbn1cbmZ1bmN0aW9uIGplKHMsIHQsIGUpIHtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gITEpLCBlID09PSB2b2lkIDAgJiYgKGUgPSAhMSk7XG4gIHZhciBpID0gcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbiA9IDEsIG8gPSAxO1xuICB0ICYmIGN0KHMpICYmIChuID0gcy5vZmZzZXRXaWR0aCA+IDAgJiYgWWUoaS53aWR0aCkgLyBzLm9mZnNldFdpZHRoIHx8IDEsIG8gPSBzLm9mZnNldEhlaWdodCA+IDAgJiYgWWUoaS5oZWlnaHQpIC8gcy5vZmZzZXRIZWlnaHQgfHwgMSk7XG4gIHZhciByID0gVGUocykgPyB1dChzKSA6IHdpbmRvdywgYSA9IHIudmlzdWFsVmlld3BvcnQsIGwgPSAhQWwoKSAmJiBlLCBwID0gKGkubGVmdCArIChsICYmIGEgPyBhLm9mZnNldExlZnQgOiAwKSkgLyBuLCB1ID0gKGkudG9wICsgKGwgJiYgYSA/IGEub2Zmc2V0VG9wIDogMCkpIC8gbywgZiA9IGkud2lkdGggLyBuLCBfID0gaS5oZWlnaHQgLyBvO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBmLFxuICAgIGhlaWdodDogXyxcbiAgICB0b3A6IHUsXG4gICAgcmlnaHQ6IHAgKyBmLFxuICAgIGJvdHRvbTogdSArIF8sXG4gICAgbGVmdDogcCxcbiAgICB4OiBwLFxuICAgIHk6IHVcbiAgfTtcbn1cbmZ1bmN0aW9uIFRvKHMpIHtcbiAgdmFyIHQgPSBqZShzKSwgZSA9IHMub2Zmc2V0V2lkdGgsIGkgPSBzLm9mZnNldEhlaWdodDtcbiAgcmV0dXJuIE1hdGguYWJzKHQud2lkdGggLSBlKSA8PSAxICYmIChlID0gdC53aWR0aCksIE1hdGguYWJzKHQuaGVpZ2h0IC0gaSkgPD0gMSAmJiAoaSA9IHQuaGVpZ2h0KSwge1xuICAgIHg6IHMub2Zmc2V0TGVmdCxcbiAgICB5OiBzLm9mZnNldFRvcCxcbiAgICB3aWR0aDogZSxcbiAgICBoZWlnaHQ6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIHlsKHMsIHQpIHtcbiAgdmFyIGUgPSB0LmdldFJvb3ROb2RlICYmIHQuZ2V0Um9vdE5vZGUoKTtcbiAgaWYgKHMuY29udGFpbnModCkpXG4gICAgcmV0dXJuICEwO1xuICBpZiAoZSAmJiBibyhlKSkge1xuICAgIHZhciBpID0gdDtcbiAgICBkbyB7XG4gICAgICBpZiAoaSAmJiBzLmlzU2FtZU5vZGUoaSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGkgPSBpLnBhcmVudE5vZGUgfHwgaS5ob3N0O1xuICAgIH0gd2hpbGUgKGkpO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIFR0KHMpIHtcbiAgcmV0dXJuIHV0KHMpLmdldENvbXB1dGVkU3R5bGUocyk7XG59XG5mdW5jdGlvbiBlaChzKSB7XG4gIHJldHVybiBbXCJ0YWJsZVwiLCBcInRkXCIsIFwidGhcIl0uaW5kZXhPZihOdChzKSkgPj0gMDtcbn1cbmZ1bmN0aW9uIHRlKHMpIHtcbiAgcmV0dXJuICgoVGUocykgPyBzLm93bmVyRG9jdW1lbnQgOiAoXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgcy5kb2N1bWVudFxuICApKSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIEhzKHMpIHtcbiAgcmV0dXJuIE50KHMpID09PSBcImh0bWxcIiA/IHMgOiAoXG4gICAgLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgcy5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBzLnBhcmVudE5vZGUgfHwgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICAoYm8ocykgPyBzLmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIHRlKHMpXG4gICk7XG59XG5mdW5jdGlvbiBLbyhzKSB7XG4gIHJldHVybiAhY3QocykgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgVHQocykucG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IG51bGwgOiBzLm9mZnNldFBhcmVudDtcbn1cbmZ1bmN0aW9uIGloKHMpIHtcbiAgdmFyIHQgPSAvZmlyZWZveC9pLnRlc3QoZW8oKSksIGUgPSAvVHJpZGVudC9pLnRlc3QoZW8oKSk7XG4gIGlmIChlICYmIGN0KHMpKSB7XG4gICAgdmFyIGkgPSBUdChzKTtcbiAgICBpZiAoaS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG4gPSBIcyhzKTtcbiAgZm9yIChibyhuKSAmJiAobiA9IG4uaG9zdCk7IGN0KG4pICYmIFtcImh0bWxcIiwgXCJib2R5XCJdLmluZGV4T2YoTnQobikpIDwgMDsgKSB7XG4gICAgdmFyIG8gPSBUdChuKTtcbiAgICBpZiAoby50cmFuc2Zvcm0gIT09IFwibm9uZVwiIHx8IG8ucGVyc3BlY3RpdmUgIT09IFwibm9uZVwiIHx8IG8uY29udGFpbiA9PT0gXCJwYWludFwiIHx8IFtcInRyYW5zZm9ybVwiLCBcInBlcnNwZWN0aXZlXCJdLmluZGV4T2Yoby53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgdCAmJiBvLndpbGxDaGFuZ2UgPT09IFwiZmlsdGVyXCIgfHwgdCAmJiBvLmZpbHRlciAmJiBvLmZpbHRlciAhPT0gXCJub25lXCIpXG4gICAgICByZXR1cm4gbjtcbiAgICBuID0gbi5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gRGkocykge1xuICBmb3IgKHZhciB0ID0gdXQocyksIGUgPSBLbyhzKTsgZSAmJiBlaChlKSAmJiBUdChlKS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIjsgKVxuICAgIGUgPSBLbyhlKTtcbiAgcmV0dXJuIGUgJiYgKE50KGUpID09PSBcImh0bWxcIiB8fCBOdChlKSA9PT0gXCJib2R5XCIgJiYgVHQoZSkucG9zaXRpb24gPT09IFwic3RhdGljXCIpID8gdCA6IGUgfHwgaWgocykgfHwgdDtcbn1cbmZ1bmN0aW9uIEVvKHMpIHtcbiAgcmV0dXJuIFtcInRvcFwiLCBcImJvdHRvbVwiXS5pbmRleE9mKHMpID49IDAgPyBcInhcIiA6IFwieVwiO1xufVxuZnVuY3Rpb24gRWkocywgdCwgZSkge1xuICByZXR1cm4gZ2UocywgUnModCwgZSkpO1xufVxuZnVuY3Rpb24gc2gocywgdCwgZSkge1xuICB2YXIgaSA9IEVpKHMsIHQsIGUpO1xuICByZXR1cm4gaSA+IGUgPyBlIDogaTtcbn1cbmZ1bmN0aW9uIHdsKCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufVxuZnVuY3Rpb24geGwocykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgd2woKSwgcyk7XG59XG5mdW5jdGlvbiBrbChzLCB0KSB7XG4gIHJldHVybiB0LnJlZHVjZShmdW5jdGlvbihlLCBpKSB7XG4gICAgcmV0dXJuIGVbaV0gPSBzLCBlO1xuICB9LCB7fSk7XG59XG52YXIgbmggPSBmdW5jdGlvbih0LCBlKSB7XG4gIHJldHVybiB0ID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdChPYmplY3QuYXNzaWduKHt9LCBlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBlLnBsYWNlbWVudFxuICB9KSkgOiB0LCB4bCh0eXBlb2YgdCAhPSBcIm51bWJlclwiID8gdCA6IGtsKHQsIHFlKSk7XG59O1xuZnVuY3Rpb24gb2gocykge1xuICB2YXIgdCwgZSA9IHMuc3RhdGUsIGkgPSBzLm5hbWUsIG4gPSBzLm9wdGlvbnMsIG8gPSBlLmVsZW1lbnRzLmFycm93LCByID0gZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsIGEgPSB2dChlLnBsYWNlbWVudCksIGwgPSBFbyhhKSwgcCA9IFtKLCBkdF0uaW5kZXhPZihhKSA+PSAwLCB1ID0gcCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG4gIGlmICghKCFvIHx8ICFyKSkge1xuICAgIHZhciBmID0gbmgobi5wYWRkaW5nLCBlKSwgXyA9IFRvKG8pLCBtID0gbCA9PT0gXCJ5XCIgPyBRIDogSiwgZyA9IGwgPT09IFwieVwiID8gaHQgOiBkdCwgdiA9IGUucmVjdHMucmVmZXJlbmNlW3VdICsgZS5yZWN0cy5yZWZlcmVuY2VbbF0gLSByW2xdIC0gZS5yZWN0cy5wb3BwZXJbdV0sIGIgPSByW2xdIC0gZS5yZWN0cy5yZWZlcmVuY2VbbF0sIEMgPSBEaShvKSwgeSA9IEMgPyBsID09PSBcInlcIiA/IEMuY2xpZW50SGVpZ2h0IHx8IDAgOiBDLmNsaWVudFdpZHRoIHx8IDAgOiAwLCBFID0gdiAvIDIgLSBiIC8gMiwgVCA9IGZbbV0sIEEgPSB5IC0gX1t1XSAtIGZbZ10sIHcgPSB5IC8gMiAtIF9bdV0gLyAyICsgRSwgUyA9IEVpKFQsIHcsIEEpLCBrID0gbDtcbiAgICBlLm1vZGlmaWVyc0RhdGFbaV0gPSAodCA9IHt9LCB0W2tdID0gUywgdC5jZW50ZXJPZmZzZXQgPSBTIC0gdywgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJoKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5vcHRpb25zLCBpID0gZS5lbGVtZW50LCBuID0gaSA9PT0gdm9pZCAwID8gXCJbZGF0YS1wb3BwZXItYXJyb3ddXCIgOiBpO1xuICBpZiAobiAhPSBudWxsICYmICEodHlwZW9mIG4gPT0gXCJzdHJpbmdcIiAmJiAobiA9IHQuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IobiksICFuKSkpIHtcbiAgICBpZiAoe30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChjdChuKSB8fCBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50IChub3QgYW4gU1ZHRWxlbWVudCkuJywgXCJUbyB1c2UgYW4gU1ZHIGFycm93LCB3cmFwIGl0IGluIGFuIEhUTUxFbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGFzXCIsIFwidGhlIGFycm93LlwiXS5qb2luKFwiIFwiKSkpLCAheWwodC5lbGVtZW50cy5wb3BwZXIsIG4pKSB7XG4gICAgICAoe30pLk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgbW9kaWZpZXJcXCdzIGBlbGVtZW50YCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIHBvcHBlcicsIFwiZWxlbWVudC5cIl0uam9pbihcIiBcIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0LmVsZW1lbnRzLmFycm93ID0gbjtcbiAgfVxufVxuY29uc3QgT2wgPSB7XG4gIG5hbWU6IFwiYXJyb3dcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IG9oLFxuICBlZmZlY3Q6IHJoLFxuICByZXF1aXJlczogW1wicG9wcGVyT2Zmc2V0c1wiXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wicHJldmVudE92ZXJmbG93XCJdXG59O1xuZnVuY3Rpb24gS2Uocykge1xuICByZXR1cm4gcy5zcGxpdChcIi1cIilbMV07XG59XG52YXIgYWggPSB7XG4gIHRvcDogXCJhdXRvXCIsXG4gIHJpZ2h0OiBcImF1dG9cIixcbiAgYm90dG9tOiBcImF1dG9cIixcbiAgbGVmdDogXCJhdXRvXCJcbn07XG5mdW5jdGlvbiBsaChzLCB0KSB7XG4gIHZhciBlID0gcy54LCBpID0gcy55LCBuID0gdC5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogWWUoZSAqIG4pIC8gbiB8fCAwLFxuICAgIHk6IFllKGkgKiBuKSAvIG4gfHwgMFxuICB9O1xufVxuZnVuY3Rpb24gem8ocykge1xuICB2YXIgdCwgZSA9IHMucG9wcGVyLCBpID0gcy5wb3BwZXJSZWN0LCBuID0gcy5wbGFjZW1lbnQsIG8gPSBzLnZhcmlhdGlvbiwgciA9IHMub2Zmc2V0cywgYSA9IHMucG9zaXRpb24sIGwgPSBzLmdwdUFjY2VsZXJhdGlvbiwgcCA9IHMuYWRhcHRpdmUsIHUgPSBzLnJvdW5kT2Zmc2V0cywgZiA9IHMuaXNGaXhlZCwgXyA9IHIueCwgbSA9IF8gPT09IHZvaWQgMCA/IDAgOiBfLCBnID0gci55LCB2ID0gZyA9PT0gdm9pZCAwID8gMCA6IGcsIGIgPSB0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIgPyB1KHtcbiAgICB4OiBtLFxuICAgIHk6IHZcbiAgfSkgOiB7XG4gICAgeDogbSxcbiAgICB5OiB2XG4gIH07XG4gIG0gPSBiLngsIHYgPSBiLnk7XG4gIHZhciBDID0gci5oYXNPd25Qcm9wZXJ0eShcInhcIiksIHkgPSByLmhhc093blByb3BlcnR5KFwieVwiKSwgRSA9IEosIFQgPSBRLCBBID0gd2luZG93O1xuICBpZiAocCkge1xuICAgIHZhciB3ID0gRGkoZSksIFMgPSBcImNsaWVudEhlaWdodFwiLCBrID0gXCJjbGllbnRXaWR0aFwiO1xuICAgIGlmICh3ID09PSB1dChlKSAmJiAodyA9IHRlKGUpLCBUdCh3KS5wb3NpdGlvbiAhPT0gXCJzdGF0aWNcIiAmJiBhID09PSBcImFic29sdXRlXCIgJiYgKFMgPSBcInNjcm9sbEhlaWdodFwiLCBrID0gXCJzY3JvbGxXaWR0aFwiKSksIHcgPSB3LCBuID09PSBRIHx8IChuID09PSBKIHx8IG4gPT09IGR0KSAmJiBvID09PSBGZSkge1xuICAgICAgVCA9IGh0O1xuICAgICAgdmFyIHggPSBmICYmIHcgPT09IEEgJiYgQS52aXN1YWxWaWV3cG9ydCA/IEEudmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogKFxuICAgICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgd1tTXVxuICAgICAgKTtcbiAgICAgIHYgLT0geCAtIGkuaGVpZ2h0LCB2ICo9IGwgPyAxIDogLTE7XG4gICAgfVxuICAgIGlmIChuID09PSBKIHx8IChuID09PSBRIHx8IG4gPT09IGh0KSAmJiBvID09PSBGZSkge1xuICAgICAgRSA9IGR0O1xuICAgICAgdmFyICQgPSBmICYmIHcgPT09IEEgJiYgQS52aXN1YWxWaWV3cG9ydCA/IEEudmlzdWFsVmlld3BvcnQud2lkdGggOiAoXG4gICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICB3W2tdXG4gICAgICApO1xuICAgICAgbSAtPSAkIC0gaS53aWR0aCwgbSAqPSBsID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuICB2YXIgTyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBhXG4gIH0sIHAgJiYgYWgpLCBNID0gdSA9PT0gITAgPyBsaCh7XG4gICAgeDogbSxcbiAgICB5OiB2XG4gIH0sIHV0KGUpKSA6IHtcbiAgICB4OiBtLFxuICAgIHk6IHZcbiAgfTtcbiAgaWYgKG0gPSBNLngsIHYgPSBNLnksIGwpIHtcbiAgICB2YXIgUDtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgTywgKFAgPSB7fSwgUFtUXSA9IHkgPyBcIjBcIiA6IFwiXCIsIFBbRV0gPSBDID8gXCIwXCIgOiBcIlwiLCBQLnRyYW5zZm9ybSA9IChBLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgbSArIFwicHgsIFwiICsgdiArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgbSArIFwicHgsIFwiICsgdiArIFwicHgsIDApXCIsIFApKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgTywgKHQgPSB7fSwgdFtUXSA9IHkgPyB2ICsgXCJweFwiIDogXCJcIiwgdFtFXSA9IEMgPyBtICsgXCJweFwiIDogXCJcIiwgdC50cmFuc2Zvcm0gPSBcIlwiLCB0KSk7XG59XG5mdW5jdGlvbiBjaChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IGUuZ3B1QWNjZWxlcmF0aW9uLCBuID0gaSA9PT0gdm9pZCAwID8gITAgOiBpLCBvID0gZS5hZGFwdGl2ZSwgciA9IG8gPT09IHZvaWQgMCA/ICEwIDogbywgYSA9IGUucm91bmRPZmZzZXRzLCBsID0gYSA9PT0gdm9pZCAwID8gITAgOiBhO1xuICBpZiAoe30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHAgPSBUdCh0LmVsZW1lbnRzLnBvcHBlcikudHJhbnNpdGlvblByb3BlcnR5IHx8IFwiXCI7XG4gICAgciAmJiBbXCJ0cmFuc2Zvcm1cIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl0uc29tZShmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gcC5pbmRleE9mKGYpID49IDA7XG4gICAgfSkgJiYgY29uc29sZS53YXJuKFtcIlBvcHBlcjogRGV0ZWN0ZWQgQ1NTIHRyYW5zaXRpb25zIG9uIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nXCIsICdDU1MgcHJvcGVydGllczogXCJ0cmFuc2Zvcm1cIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIi4nLCBgXG5cbmAsICdEaXNhYmxlIHRoZSBcImNvbXB1dGVTdHlsZXNcIiBtb2RpZmllclxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCBcImZvciBzbW9vdGggdHJhbnNpdGlvbnMsIG9yIHJlbW92ZSB0aGVzZSBwcm9wZXJ0aWVzIGZyb20gdGhlIENTU1wiLCBcInRyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZ1wiLCBcIm9wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS5cIiwgYFxuXG5gLCBcIldlIHJlY29tbWVuZCB1c2luZyB0aGUgcG9wcGVyIGVsZW1lbnQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBpbm5lclwiLCBcImVsZW1lbnQgdGhhdCBjYW4gaGF2ZSBhbnkgQ1NTIHByb3BlcnR5IHRyYW5zaXRpb25lZCBmb3IgYW5pbWF0aW9ucy5cIl0uam9pbihcIiBcIikpO1xuICB9XG4gIHZhciB1ID0ge1xuICAgIHBsYWNlbWVudDogdnQodC5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogS2UodC5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogdC5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogdC5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBuLFxuICAgIGlzRml4ZWQ6IHQub3B0aW9ucy5zdHJhdGVneSA9PT0gXCJmaXhlZFwiXG4gIH07XG4gIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwgJiYgKHQuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuc3R5bGVzLnBvcHBlciwgem8oT2JqZWN0LmFzc2lnbih7fSwgdSwge1xuICAgIG9mZnNldHM6IHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgIHBvc2l0aW9uOiB0Lm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgYWRhcHRpdmU6IHIsXG4gICAgcm91bmRPZmZzZXRzOiBsXG4gIH0pKSkpLCB0Lm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCAmJiAodC5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCB0LnN0eWxlcy5hcnJvdywgem8oT2JqZWN0LmFzc2lnbih7fSwgdSwge1xuICAgIG9mZnNldHM6IHQubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIGFkYXB0aXZlOiAhMSxcbiAgICByb3VuZE9mZnNldHM6IGxcbiAgfSkpKSksIHQuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0LmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgXCJkYXRhLXBvcHBlci1wbGFjZW1lbnRcIjogdC5wbGFjZW1lbnRcbiAgfSk7XG59XG5jb25zdCBDbyA9IHtcbiAgbmFtZTogXCJjb21wdXRlU3R5bGVzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJiZWZvcmVXcml0ZVwiLFxuICBmbjogY2gsXG4gIGRhdGE6IHt9XG59O1xudmFyIGppID0ge1xuICBwYXNzaXZlOiAhMFxufTtcbmZ1bmN0aW9uIGhoKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5pbnN0YW5jZSwgaSA9IHMub3B0aW9ucywgbiA9IGkuc2Nyb2xsLCBvID0gbiA9PT0gdm9pZCAwID8gITAgOiBuLCByID0gaS5yZXNpemUsIGEgPSByID09PSB2b2lkIDAgPyAhMCA6IHIsIGwgPSB1dCh0LmVsZW1lbnRzLnBvcHBlciksIHAgPSBbXS5jb25jYXQodC5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgdC5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG4gIHJldHVybiBvICYmIHAuZm9yRWFjaChmdW5jdGlvbih1KSB7XG4gICAgdS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGUudXBkYXRlLCBqaSk7XG4gIH0pLCBhICYmIGwuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBlLnVwZGF0ZSwgamkpLCBmdW5jdGlvbigpIHtcbiAgICBvICYmIHAuZm9yRWFjaChmdW5jdGlvbih1KSB7XG4gICAgICB1LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgZS51cGRhdGUsIGppKTtcbiAgICB9KSwgYSAmJiBsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZS51cGRhdGUsIGppKTtcbiAgfTtcbn1cbmNvbnN0IEFvID0ge1xuICBuYW1lOiBcImV2ZW50TGlzdGVuZXJzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJ3cml0ZVwiLFxuICBmbjogZnVuY3Rpb24oKSB7XG4gIH0sXG4gIGVmZmVjdDogaGgsXG4gIGRhdGE6IHt9XG59O1xudmFyIGRoID0ge1xuICBsZWZ0OiBcInJpZ2h0XCIsXG4gIHJpZ2h0OiBcImxlZnRcIixcbiAgYm90dG9tOiBcInRvcFwiLFxuICB0b3A6IFwiYm90dG9tXCJcbn07XG5mdW5jdGlvbiBicyhzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGRoW3RdO1xuICB9KTtcbn1cbnZhciB1aCA9IHtcbiAgc3RhcnQ6IFwiZW5kXCIsXG4gIGVuZDogXCJzdGFydFwiXG59O1xuZnVuY3Rpb24gVW8ocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB1aFt0XTtcbiAgfSk7XG59XG5mdW5jdGlvbiB5byhzKSB7XG4gIHZhciB0ID0gdXQocyksIGUgPSB0LnBhZ2VYT2Zmc2V0LCBpID0gdC5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlLFxuICAgIHNjcm9sbFRvcDogaVxuICB9O1xufVxuZnVuY3Rpb24gd28ocykge1xuICByZXR1cm4gamUodGUocykpLmxlZnQgKyB5byhzKS5zY3JvbGxMZWZ0O1xufVxuZnVuY3Rpb24gcGgocywgdCkge1xuICB2YXIgZSA9IHV0KHMpLCBpID0gdGUocyksIG4gPSBlLnZpc3VhbFZpZXdwb3J0LCBvID0gaS5jbGllbnRXaWR0aCwgciA9IGkuY2xpZW50SGVpZ2h0LCBhID0gMCwgbCA9IDA7XG4gIGlmIChuKSB7XG4gICAgbyA9IG4ud2lkdGgsIHIgPSBuLmhlaWdodDtcbiAgICB2YXIgcCA9IEFsKCk7XG4gICAgKHAgfHwgIXAgJiYgdCA9PT0gXCJmaXhlZFwiKSAmJiAoYSA9IG4ub2Zmc2V0TGVmdCwgbCA9IG4ub2Zmc2V0VG9wKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiBvLFxuICAgIGhlaWdodDogcixcbiAgICB4OiBhICsgd28ocyksXG4gICAgeTogbFxuICB9O1xufVxuZnVuY3Rpb24gX2gocykge1xuICB2YXIgdCwgZSA9IHRlKHMpLCBpID0geW8ocyksIG4gPSAodCA9IHMub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHQuYm9keSwgbyA9IGdlKGUuc2Nyb2xsV2lkdGgsIGUuY2xpZW50V2lkdGgsIG4gPyBuLnNjcm9sbFdpZHRoIDogMCwgbiA/IG4uY2xpZW50V2lkdGggOiAwKSwgciA9IGdlKGUuc2Nyb2xsSGVpZ2h0LCBlLmNsaWVudEhlaWdodCwgbiA/IG4uc2Nyb2xsSGVpZ2h0IDogMCwgbiA/IG4uY2xpZW50SGVpZ2h0IDogMCksIGEgPSAtaS5zY3JvbGxMZWZ0ICsgd28ocyksIGwgPSAtaS5zY3JvbGxUb3A7XG4gIHJldHVybiBUdChuIHx8IGUpLmRpcmVjdGlvbiA9PT0gXCJydGxcIiAmJiAoYSArPSBnZShlLmNsaWVudFdpZHRoLCBuID8gbi5jbGllbnRXaWR0aCA6IDApIC0gbyksIHtcbiAgICB3aWR0aDogbyxcbiAgICBoZWlnaHQ6IHIsXG4gICAgeDogYSxcbiAgICB5OiBsXG4gIH07XG59XG5mdW5jdGlvbiB4byhzKSB7XG4gIHZhciB0ID0gVHQocyksIGUgPSB0Lm92ZXJmbG93LCBpID0gdC5vdmVyZmxvd1gsIG4gPSB0Lm92ZXJmbG93WTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChlICsgbiArIGkpO1xufVxuZnVuY3Rpb24gU2wocykge1xuICByZXR1cm4gW1wiaHRtbFwiLCBcImJvZHlcIiwgXCIjZG9jdW1lbnRcIl0uaW5kZXhPZihOdChzKSkgPj0gMCA/IHMub3duZXJEb2N1bWVudC5ib2R5IDogY3QocykgJiYgeG8ocykgPyBzIDogU2woSHMocykpO1xufVxuZnVuY3Rpb24gQ2kocywgdCkge1xuICB2YXIgZTtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gW10pO1xuICB2YXIgaSA9IFNsKHMpLCBuID0gaSA9PT0gKChlID0gcy5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogZS5ib2R5KSwgbyA9IHV0KGkpLCByID0gbiA/IFtvXS5jb25jYXQoby52aXN1YWxWaWV3cG9ydCB8fCBbXSwgeG8oaSkgPyBpIDogW10pIDogaSwgYSA9IHQuY29uY2F0KHIpO1xuICByZXR1cm4gbiA/IGEgOiAoXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gICAgYS5jb25jYXQoQ2koSHMocikpKVxuICApO1xufVxuZnVuY3Rpb24gaW8ocykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcywge1xuICAgIGxlZnQ6IHMueCxcbiAgICB0b3A6IHMueSxcbiAgICByaWdodDogcy54ICsgcy53aWR0aCxcbiAgICBib3R0b206IHMueSArIHMuaGVpZ2h0XG4gIH0pO1xufVxuZnVuY3Rpb24gZmgocywgdCkge1xuICB2YXIgZSA9IGplKHMsICExLCB0ID09PSBcImZpeGVkXCIpO1xuICByZXR1cm4gZS50b3AgPSBlLnRvcCArIHMuY2xpZW50VG9wLCBlLmxlZnQgPSBlLmxlZnQgKyBzLmNsaWVudExlZnQsIGUuYm90dG9tID0gZS50b3AgKyBzLmNsaWVudEhlaWdodCwgZS5yaWdodCA9IGUubGVmdCArIHMuY2xpZW50V2lkdGgsIGUud2lkdGggPSBzLmNsaWVudFdpZHRoLCBlLmhlaWdodCA9IHMuY2xpZW50SGVpZ2h0LCBlLnggPSBlLmxlZnQsIGUueSA9IGUudG9wLCBlO1xufVxuZnVuY3Rpb24gWG8ocywgdCwgZSkge1xuICByZXR1cm4gdCA9PT0gbW8gPyBpbyhwaChzLCBlKSkgOiBUZSh0KSA/IGZoKHQsIGUpIDogaW8oX2godGUocykpKTtcbn1cbmZ1bmN0aW9uIG1oKHMpIHtcbiAgdmFyIHQgPSBDaShIcyhzKSksIGUgPSBbXCJhYnNvbHV0ZVwiLCBcImZpeGVkXCJdLmluZGV4T2YoVHQocykucG9zaXRpb24pID49IDAsIGkgPSBlICYmIGN0KHMpID8gRGkocykgOiBzO1xuICByZXR1cm4gVGUoaSkgPyB0LmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIFRlKG4pICYmIHlsKG4sIGkpICYmIE50KG4pICE9PSBcImJvZHlcIjtcbiAgfSkgOiBbXTtcbn1cbmZ1bmN0aW9uIGdoKHMsIHQsIGUsIGkpIHtcbiAgdmFyIG4gPSB0ID09PSBcImNsaXBwaW5nUGFyZW50c1wiID8gbWgocykgOiBbXS5jb25jYXQodCksIG8gPSBbXS5jb25jYXQobiwgW2VdKSwgciA9IG9bMF0sIGEgPSBvLnJlZHVjZShmdW5jdGlvbihsLCBwKSB7XG4gICAgdmFyIHUgPSBYbyhzLCBwLCBpKTtcbiAgICByZXR1cm4gbC50b3AgPSBnZSh1LnRvcCwgbC50b3ApLCBsLnJpZ2h0ID0gUnModS5yaWdodCwgbC5yaWdodCksIGwuYm90dG9tID0gUnModS5ib3R0b20sIGwuYm90dG9tKSwgbC5sZWZ0ID0gZ2UodS5sZWZ0LCBsLmxlZnQpLCBsO1xuICB9LCBYbyhzLCByLCBpKSk7XG4gIHJldHVybiBhLndpZHRoID0gYS5yaWdodCAtIGEubGVmdCwgYS5oZWlnaHQgPSBhLmJvdHRvbSAtIGEudG9wLCBhLnggPSBhLmxlZnQsIGEueSA9IGEudG9wLCBhO1xufVxuZnVuY3Rpb24gSWwocykge1xuICB2YXIgdCA9IHMucmVmZXJlbmNlLCBlID0gcy5lbGVtZW50LCBpID0gcy5wbGFjZW1lbnQsIG4gPSBpID8gdnQoaSkgOiBudWxsLCBvID0gaSA/IEtlKGkpIDogbnVsbCwgciA9IHQueCArIHQud2lkdGggLyAyIC0gZS53aWR0aCAvIDIsIGEgPSB0LnkgKyB0LmhlaWdodCAvIDIgLSBlLmhlaWdodCAvIDIsIGw7XG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgUTpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHIsXG4gICAgICAgIHk6IHQueSAtIGUuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBodDpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHIsXG4gICAgICAgIHk6IHQueSArIHQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBkdDpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHQueCArIHQud2lkdGgsXG4gICAgICAgIHk6IGFcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEo6XG4gICAgICBsID0ge1xuICAgICAgICB4OiB0LnggLSBlLndpZHRoLFxuICAgICAgICB5OiBhXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHQueCxcbiAgICAgICAgeTogdC55XG4gICAgICB9O1xuICB9XG4gIHZhciBwID0gbiA/IEVvKG4pIDogbnVsbDtcbiAgaWYgKHAgIT0gbnVsbCkge1xuICAgIHZhciB1ID0gcCA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICAgIHN3aXRjaCAobykge1xuICAgICAgY2FzZSB2ZTpcbiAgICAgICAgbFtwXSA9IGxbcF0gLSAodFt1XSAvIDIgLSBlW3VdIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGZTpcbiAgICAgICAgbFtwXSA9IGxbcF0gKyAodFt1XSAvIDIgLSBlW3VdIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbDtcbn1cbmZ1bmN0aW9uIHplKHMsIHQpIHtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0ge30pO1xuICB2YXIgZSA9IHQsIGkgPSBlLnBsYWNlbWVudCwgbiA9IGkgPT09IHZvaWQgMCA/IHMucGxhY2VtZW50IDogaSwgbyA9IGUuc3RyYXRlZ3ksIHIgPSBvID09PSB2b2lkIDAgPyBzLnN0cmF0ZWd5IDogbywgYSA9IGUuYm91bmRhcnksIGwgPSBhID09PSB2b2lkIDAgPyB1bCA6IGEsIHAgPSBlLnJvb3RCb3VuZGFyeSwgdSA9IHAgPT09IHZvaWQgMCA/IG1vIDogcCwgZiA9IGUuZWxlbWVudENvbnRleHQsIF8gPSBmID09PSB2b2lkIDAgPyBJZSA6IGYsIG0gPSBlLmFsdEJvdW5kYXJ5LCBnID0gbSA9PT0gdm9pZCAwID8gITEgOiBtLCB2ID0gZS5wYWRkaW5nLCBiID0gdiA9PT0gdm9pZCAwID8gMCA6IHYsIEMgPSB4bCh0eXBlb2YgYiAhPSBcIm51bWJlclwiID8gYiA6IGtsKGIsIHFlKSksIHkgPSBfID09PSBJZSA/IHBsIDogSWUsIEUgPSBzLnJlY3RzLnBvcHBlciwgVCA9IHMuZWxlbWVudHNbZyA/IHkgOiBfXSwgQSA9IGdoKFRlKFQpID8gVCA6IFQuY29udGV4dEVsZW1lbnQgfHwgdGUocy5lbGVtZW50cy5wb3BwZXIpLCBsLCB1LCByKSwgdyA9IGplKHMuZWxlbWVudHMucmVmZXJlbmNlKSwgUyA9IElsKHtcbiAgICByZWZlcmVuY2U6IHcsXG4gICAgZWxlbWVudDogRSxcbiAgICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiLFxuICAgIHBsYWNlbWVudDogblxuICB9KSwgayA9IGlvKE9iamVjdC5hc3NpZ24oe30sIEUsIFMpKSwgeCA9IF8gPT09IEllID8gayA6IHcsICQgPSB7XG4gICAgdG9wOiBBLnRvcCAtIHgudG9wICsgQy50b3AsXG4gICAgYm90dG9tOiB4LmJvdHRvbSAtIEEuYm90dG9tICsgQy5ib3R0b20sXG4gICAgbGVmdDogQS5sZWZ0IC0geC5sZWZ0ICsgQy5sZWZ0LFxuICAgIHJpZ2h0OiB4LnJpZ2h0IC0gQS5yaWdodCArIEMucmlnaHRcbiAgfSwgTyA9IHMubW9kaWZpZXJzRGF0YS5vZmZzZXQ7XG4gIGlmIChfID09PSBJZSAmJiBPKSB7XG4gICAgdmFyIE0gPSBPW25dO1xuICAgIE9iamVjdC5rZXlzKCQpLmZvckVhY2goZnVuY3Rpb24oUCkge1xuICAgICAgdmFyIHR0ID0gW2R0LCBodF0uaW5kZXhPZihQKSA+PSAwID8gMSA6IC0xLCBldCA9IFtRLCBodF0uaW5kZXhPZihQKSA+PSAwID8gXCJ5XCIgOiBcInhcIjtcbiAgICAgICRbUF0gKz0gTVtldF0gKiB0dDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gJDtcbn1cbmZ1bmN0aW9uIGJoKHMsIHQpIHtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0ge30pO1xuICB2YXIgZSA9IHQsIGkgPSBlLnBsYWNlbWVudCwgbiA9IGUuYm91bmRhcnksIG8gPSBlLnJvb3RCb3VuZGFyeSwgciA9IGUucGFkZGluZywgYSA9IGUuZmxpcFZhcmlhdGlvbnMsIGwgPSBlLmFsbG93ZWRBdXRvUGxhY2VtZW50cywgcCA9IGwgPT09IHZvaWQgMCA/IGdvIDogbCwgdSA9IEtlKGkpLCBmID0gdSA/IGEgPyB0byA6IHRvLmZpbHRlcihmdW5jdGlvbihnKSB7XG4gICAgcmV0dXJuIEtlKGcpID09PSB1O1xuICB9KSA6IHFlLCBfID0gZi5maWx0ZXIoZnVuY3Rpb24oZykge1xuICAgIHJldHVybiBwLmluZGV4T2YoZykgPj0gMDtcbiAgfSk7XG4gIF8ubGVuZ3RoID09PSAwICYmIChfID0gZiwge30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoW1wiUG9wcGVyOiBUaGUgYGFsbG93ZWRBdXRvUGxhY2VtZW50c2Agb3B0aW9uIGRpZCBub3QgYWxsb3cgYW55XCIsIFwicGxhY2VtZW50cy4gRW5zdXJlIHRoZSBgcGxhY2VtZW50YCBvcHRpb24gbWF0Y2hlcyB0aGUgdmFyaWF0aW9uXCIsIFwib2YgdGhlIGFsbG93ZWQgcGxhY2VtZW50cy5cIiwgJ0ZvciBleGFtcGxlLCBcImF1dG9cIiBjYW5ub3QgYmUgdXNlZCB0byBhbGxvdyBcImJvdHRvbS1zdGFydFwiLicsICdVc2UgXCJhdXRvLXN0YXJ0XCIgaW5zdGVhZC4nXS5qb2luKFwiIFwiKSkpO1xuICB2YXIgbSA9IF8ucmVkdWNlKGZ1bmN0aW9uKGcsIHYpIHtcbiAgICByZXR1cm4gZ1t2XSA9IHplKHMsIHtcbiAgICAgIHBsYWNlbWVudDogdixcbiAgICAgIGJvdW5kYXJ5OiBuLFxuICAgICAgcm9vdEJvdW5kYXJ5OiBvLFxuICAgICAgcGFkZGluZzogclxuICAgIH0pW3Z0KHYpXSwgZztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMobSkuc29ydChmdW5jdGlvbihnLCB2KSB7XG4gICAgcmV0dXJuIG1bZ10gLSBtW3ZdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHZoKHMpIHtcbiAgaWYgKHZ0KHMpID09PSBJaSlcbiAgICByZXR1cm4gW107XG4gIHZhciB0ID0gYnMocyk7XG4gIHJldHVybiBbVW8ocyksIHQsIFVvKHQpXTtcbn1cbmZ1bmN0aW9uIFRoKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5vcHRpb25zLCBpID0gcy5uYW1lO1xuICBpZiAoIXQubW9kaWZpZXJzRGF0YVtpXS5fc2tpcCkge1xuICAgIGZvciAodmFyIG4gPSBlLm1haW5BeGlzLCBvID0gbiA9PT0gdm9pZCAwID8gITAgOiBuLCByID0gZS5hbHRBeGlzLCBhID0gciA9PT0gdm9pZCAwID8gITAgOiByLCBsID0gZS5mYWxsYmFja1BsYWNlbWVudHMsIHAgPSBlLnBhZGRpbmcsIHUgPSBlLmJvdW5kYXJ5LCBmID0gZS5yb290Qm91bmRhcnksIF8gPSBlLmFsdEJvdW5kYXJ5LCBtID0gZS5mbGlwVmFyaWF0aW9ucywgZyA9IG0gPT09IHZvaWQgMCA/ICEwIDogbSwgdiA9IGUuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLCBiID0gdC5vcHRpb25zLnBsYWNlbWVudCwgQyA9IHZ0KGIpLCB5ID0gQyA9PT0gYiwgRSA9IGwgfHwgKHkgfHwgIWcgPyBbYnMoYildIDogdmgoYikpLCBUID0gW2JdLmNvbmNhdChFKS5yZWR1Y2UoZnVuY3Rpb24oQWUsIEh0KSB7XG4gICAgICByZXR1cm4gQWUuY29uY2F0KHZ0KEh0KSA9PT0gSWkgPyBiaCh0LCB7XG4gICAgICAgIHBsYWNlbWVudDogSHQsXG4gICAgICAgIGJvdW5kYXJ5OiB1LFxuICAgICAgICByb290Qm91bmRhcnk6IGYsXG4gICAgICAgIHBhZGRpbmc6IHAsXG4gICAgICAgIGZsaXBWYXJpYXRpb25zOiBnLFxuICAgICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IHZcbiAgICAgIH0pIDogSHQpO1xuICAgIH0sIFtdKSwgQSA9IHQucmVjdHMucmVmZXJlbmNlLCB3ID0gdC5yZWN0cy5wb3BwZXIsIFMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBrID0gITAsIHggPSBUWzBdLCAkID0gMDsgJCA8IFQubGVuZ3RoOyAkKyspIHtcbiAgICAgIHZhciBPID0gVFskXSwgTSA9IHZ0KE8pLCBQID0gS2UoTykgPT09IHZlLCB0dCA9IFtRLCBodF0uaW5kZXhPZihNKSA+PSAwLCBldCA9IHR0ID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIiwgVSA9IHplKHQsIHtcbiAgICAgICAgcGxhY2VtZW50OiBPLFxuICAgICAgICBib3VuZGFyeTogdSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiBmLFxuICAgICAgICBhbHRCb3VuZGFyeTogXyxcbiAgICAgICAgcGFkZGluZzogcFxuICAgICAgfSksIG10ID0gdHQgPyBQID8gZHQgOiBKIDogUCA/IGh0IDogUTtcbiAgICAgIEFbZXRdID4gd1tldF0gJiYgKG10ID0gYnMobXQpKTtcbiAgICAgIHZhciBIaSA9IGJzKG10KSwgaWUgPSBbXTtcbiAgICAgIGlmIChvICYmIGllLnB1c2goVVtNXSA8PSAwKSwgYSAmJiBpZS5wdXNoKFVbbXRdIDw9IDAsIFVbSGldIDw9IDApLCBpZS5ldmVyeShmdW5jdGlvbihBZSkge1xuICAgICAgICByZXR1cm4gQWU7XG4gICAgICB9KSkge1xuICAgICAgICB4ID0gTywgayA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFMuc2V0KE8sIGllKTtcbiAgICB9XG4gICAgaWYgKGspXG4gICAgICBmb3IgKHZhciBXaSA9IGcgPyAzIDogMSwgVXMgPSBmdW5jdGlvbihIdCkge1xuICAgICAgICB2YXIgaWkgPSBULmZpbmQoZnVuY3Rpb24oRmkpIHtcbiAgICAgICAgICB2YXIgc2UgPSBTLmdldChGaSk7XG4gICAgICAgICAgaWYgKHNlKVxuICAgICAgICAgICAgcmV0dXJuIHNlLnNsaWNlKDAsIEh0KS5ldmVyeShmdW5jdGlvbihYcykge1xuICAgICAgICAgICAgICByZXR1cm4gWHM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpaSlcbiAgICAgICAgICByZXR1cm4geCA9IGlpLCBcImJyZWFrXCI7XG4gICAgICB9LCBlaSA9IFdpOyBlaSA+IDA7IGVpLS0pIHtcbiAgICAgICAgdmFyIFZpID0gVXMoZWkpO1xuICAgICAgICBpZiAoVmkgPT09IFwiYnJlYWtcIilcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB0LnBsYWNlbWVudCAhPT0geCAmJiAodC5tb2RpZmllcnNEYXRhW2ldLl9za2lwID0gITAsIHQucGxhY2VtZW50ID0geCwgdC5yZXNldCA9ICEwKTtcbiAgfVxufVxuY29uc3QgRGwgPSB7XG4gIG5hbWU6IFwiZmxpcFwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICBmbjogVGgsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcIm9mZnNldFwiXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiAhMVxuICB9XG59O1xuZnVuY3Rpb24gR28ocywgdCwgZSkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9KSwge1xuICAgIHRvcDogcy50b3AgLSB0LmhlaWdodCAtIGUueSxcbiAgICByaWdodDogcy5yaWdodCAtIHQud2lkdGggKyBlLngsXG4gICAgYm90dG9tOiBzLmJvdHRvbSAtIHQuaGVpZ2h0ICsgZS55LFxuICAgIGxlZnQ6IHMubGVmdCAtIHQud2lkdGggLSBlLnhcbiAgfTtcbn1cbmZ1bmN0aW9uIHFvKHMpIHtcbiAgcmV0dXJuIFtRLCBkdCwgaHQsIEpdLnNvbWUoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBzW3RdID49IDA7XG4gIH0pO1xufVxuZnVuY3Rpb24gRWgocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm5hbWUsIGkgPSB0LnJlY3RzLnJlZmVyZW5jZSwgbiA9IHQucmVjdHMucG9wcGVyLCBvID0gdC5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdywgciA9IHplKHQsIHtcbiAgICBlbGVtZW50Q29udGV4dDogXCJyZWZlcmVuY2VcIlxuICB9KSwgYSA9IHplKHQsIHtcbiAgICBhbHRCb3VuZGFyeTogITBcbiAgfSksIGwgPSBHbyhyLCBpKSwgcCA9IEdvKGEsIG4sIG8pLCB1ID0gcW8obCksIGYgPSBxbyhwKTtcbiAgdC5tb2RpZmllcnNEYXRhW2VdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogbCxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiB1LFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGZcbiAgfSwgdC5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICBcImRhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW5cIjogdSxcbiAgICBcImRhdGEtcG9wcGVyLWVzY2FwZWRcIjogZlxuICB9KTtcbn1cbmNvbnN0ICRsID0ge1xuICBuYW1lOiBcImhpZGVcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wicHJldmVudE92ZXJmbG93XCJdLFxuICBmbjogRWhcbn07XG5mdW5jdGlvbiBDaChzLCB0LCBlKSB7XG4gIHZhciBpID0gdnQocyksIG4gPSBbSiwgUV0uaW5kZXhPZihpKSA+PSAwID8gLTEgOiAxLCBvID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZShPYmplY3QuYXNzaWduKHt9LCB0LCB7XG4gICAgcGxhY2VtZW50OiBzXG4gIH0pKSA6IGUsIHIgPSBvWzBdLCBhID0gb1sxXTtcbiAgcmV0dXJuIHIgPSByIHx8IDAsIGEgPSAoYSB8fCAwKSAqIG4sIFtKLCBkdF0uaW5kZXhPZihpKSA+PSAwID8ge1xuICAgIHg6IGEsXG4gICAgeTogclxuICB9IDoge1xuICAgIHg6IHIsXG4gICAgeTogYVxuICB9O1xufVxuZnVuY3Rpb24gQWgocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBzLm5hbWUsIG4gPSBlLm9mZnNldCwgbyA9IG4gPT09IHZvaWQgMCA/IFswLCAwXSA6IG4sIHIgPSBnby5yZWR1Y2UoZnVuY3Rpb24odSwgZikge1xuICAgIHJldHVybiB1W2ZdID0gQ2goZiwgdC5yZWN0cywgbyksIHU7XG4gIH0sIHt9KSwgYSA9IHJbdC5wbGFjZW1lbnRdLCBsID0gYS54LCBwID0gYS55O1xuICB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsICYmICh0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IGwsIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0gcCksIHQubW9kaWZpZXJzRGF0YVtpXSA9IHI7XG59XG5jb25zdCBMbCA9IHtcbiAgbmFtZTogXCJvZmZzZXRcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXG4gIGZuOiBBaFxufTtcbmZ1bmN0aW9uIHloKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5uYW1lO1xuICB0Lm1vZGlmaWVyc0RhdGFbZV0gPSBJbCh7XG4gICAgcmVmZXJlbmNlOiB0LnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiB0LnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiLFxuICAgIHBsYWNlbWVudDogdC5wbGFjZW1lbnRcbiAgfSk7XG59XG5jb25zdCBrbyA9IHtcbiAgbmFtZTogXCJwb3BwZXJPZmZzZXRzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJyZWFkXCIsXG4gIGZuOiB5aCxcbiAgZGF0YToge31cbn07XG5mdW5jdGlvbiB3aChzKSB7XG4gIHJldHVybiBzID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG59XG5mdW5jdGlvbiB4aChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IHMubmFtZSwgbiA9IGUubWFpbkF4aXMsIG8gPSBuID09PSB2b2lkIDAgPyAhMCA6IG4sIHIgPSBlLmFsdEF4aXMsIGEgPSByID09PSB2b2lkIDAgPyAhMSA6IHIsIGwgPSBlLmJvdW5kYXJ5LCBwID0gZS5yb290Qm91bmRhcnksIHUgPSBlLmFsdEJvdW5kYXJ5LCBmID0gZS5wYWRkaW5nLCBfID0gZS50ZXRoZXIsIG0gPSBfID09PSB2b2lkIDAgPyAhMCA6IF8sIGcgPSBlLnRldGhlck9mZnNldCwgdiA9IGcgPT09IHZvaWQgMCA/IDAgOiBnLCBiID0gemUodCwge1xuICAgIGJvdW5kYXJ5OiBsLFxuICAgIHJvb3RCb3VuZGFyeTogcCxcbiAgICBwYWRkaW5nOiBmLFxuICAgIGFsdEJvdW5kYXJ5OiB1XG4gIH0pLCBDID0gdnQodC5wbGFjZW1lbnQpLCB5ID0gS2UodC5wbGFjZW1lbnQpLCBFID0gIXksIFQgPSBFbyhDKSwgQSA9IHdoKFQpLCB3ID0gdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsIFMgPSB0LnJlY3RzLnJlZmVyZW5jZSwgayA9IHQucmVjdHMucG9wcGVyLCB4ID0gdHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiID8gdihPYmplY3QuYXNzaWduKHt9LCB0LnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiB0LnBsYWNlbWVudFxuICB9KSkgOiB2LCAkID0gdHlwZW9mIHggPT0gXCJudW1iZXJcIiA/IHtcbiAgICBtYWluQXhpczogeCxcbiAgICBhbHRBeGlzOiB4XG4gIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICBtYWluQXhpczogMCxcbiAgICBhbHRBeGlzOiAwXG4gIH0sIHgpLCBPID0gdC5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHQubW9kaWZpZXJzRGF0YS5vZmZzZXRbdC5wbGFjZW1lbnRdIDogbnVsbCwgTSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgaWYgKHcpIHtcbiAgICBpZiAobykge1xuICAgICAgdmFyIFAsIHR0ID0gVCA9PT0gXCJ5XCIgPyBRIDogSiwgZXQgPSBUID09PSBcInlcIiA/IGh0IDogZHQsIFUgPSBUID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsIG10ID0gd1tUXSwgSGkgPSBtdCArIGJbdHRdLCBpZSA9IG10IC0gYltldF0sIFdpID0gbSA/IC1rW1VdIC8gMiA6IDAsIFVzID0geSA9PT0gdmUgPyBTW1VdIDoga1tVXSwgZWkgPSB5ID09PSB2ZSA/IC1rW1VdIDogLVNbVV0sIFZpID0gdC5lbGVtZW50cy5hcnJvdywgQWUgPSBtICYmIFZpID8gVG8oVmkpIDoge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LCBIdCA9IHQubW9kaWZpZXJzRGF0YVtcImFycm93I3BlcnNpc3RlbnRcIl0gPyB0Lm1vZGlmaWVyc0RhdGFbXCJhcnJvdyNwZXJzaXN0ZW50XCJdLnBhZGRpbmcgOiB3bCgpLCBpaSA9IEh0W3R0XSwgRmkgPSBIdFtldF0sIHNlID0gRWkoMCwgU1tVXSwgQWVbVV0pLCBYcyA9IEUgPyBTW1VdIC8gMiAtIFdpIC0gc2UgLSBpaSAtICQubWFpbkF4aXMgOiBVcyAtIHNlIC0gaWkgLSAkLm1haW5BeGlzLCBTYyA9IEUgPyAtU1tVXSAvIDIgKyBXaSArIHNlICsgRmkgKyAkLm1haW5BeGlzIDogZWkgKyBzZSArIEZpICsgJC5tYWluQXhpcywgR3MgPSB0LmVsZW1lbnRzLmFycm93ICYmIERpKHQuZWxlbWVudHMuYXJyb3cpLCBJYyA9IEdzID8gVCA9PT0gXCJ5XCIgPyBHcy5jbGllbnRUb3AgfHwgMCA6IEdzLmNsaWVudExlZnQgfHwgMCA6IDAsIE1vID0gKFAgPSBPID09IG51bGwgPyB2b2lkIDAgOiBPW1RdKSAhPSBudWxsID8gUCA6IDAsIERjID0gbXQgKyBYcyAtIE1vIC0gSWMsICRjID0gbXQgKyBTYyAtIE1vLCBObyA9IEVpKG0gPyBScyhIaSwgRGMpIDogSGksIG10LCBtID8gZ2UoaWUsICRjKSA6IGllKTtcbiAgICAgIHdbVF0gPSBObywgTVtUXSA9IE5vIC0gbXQ7XG4gICAgfVxuICAgIGlmIChhKSB7XG4gICAgICB2YXIgUm8sIExjID0gVCA9PT0gXCJ4XCIgPyBRIDogSiwgTWMgPSBUID09PSBcInhcIiA/IGh0IDogZHQsIG5lID0gd1tBXSwgWWkgPSBBID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsIFBvID0gbmUgKyBiW0xjXSwgQm8gPSBuZSAtIGJbTWNdLCBxcyA9IFtRLCBKXS5pbmRleE9mKEMpICE9PSAtMSwgSG8gPSAoUm8gPSBPID09IG51bGwgPyB2b2lkIDAgOiBPW0FdKSAhPSBudWxsID8gUm8gOiAwLCBXbyA9IHFzID8gUG8gOiBuZSAtIFNbWWldIC0ga1tZaV0gLSBIbyArICQuYWx0QXhpcywgVm8gPSBxcyA/IG5lICsgU1tZaV0gKyBrW1lpXSAtIEhvIC0gJC5hbHRBeGlzIDogQm8sIEZvID0gbSAmJiBxcyA/IHNoKFdvLCBuZSwgVm8pIDogRWkobSA/IFdvIDogUG8sIG5lLCBtID8gVm8gOiBCbyk7XG4gICAgICB3W0FdID0gRm8sIE1bQV0gPSBGbyAtIG5lO1xuICAgIH1cbiAgICB0Lm1vZGlmaWVyc0RhdGFbaV0gPSBNO1xuICB9XG59XG5jb25zdCBNbCA9IHtcbiAgbmFtZTogXCJwcmV2ZW50T3ZlcmZsb3dcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IHhoLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJvZmZzZXRcIl1cbn07XG5mdW5jdGlvbiBraChzKSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogcy5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogcy5zY3JvbGxUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIE9oKHMpIHtcbiAgcmV0dXJuIHMgPT09IHV0KHMpIHx8ICFjdChzKSA/IHlvKHMpIDoga2gocyk7XG59XG5mdW5jdGlvbiBTaChzKSB7XG4gIHZhciB0ID0gcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZSA9IFllKHQud2lkdGgpIC8gcy5vZmZzZXRXaWR0aCB8fCAxLCBpID0gWWUodC5oZWlnaHQpIC8gcy5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIGUgIT09IDEgfHwgaSAhPT0gMTtcbn1cbmZ1bmN0aW9uIEloKHMsIHQsIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gITEpO1xuICB2YXIgaSA9IGN0KHQpLCBuID0gY3QodCkgJiYgU2godCksIG8gPSB0ZSh0KSwgciA9IGplKHMsIG4sIGUpLCBhID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH0sIGwgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIHJldHVybiAoaSB8fCAhaSAmJiAhZSkgJiYgKChOdCh0KSAhPT0gXCJib2R5XCIgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gIHhvKG8pKSAmJiAoYSA9IE9oKHQpKSwgY3QodCkgPyAobCA9IGplKHQsICEwKSwgbC54ICs9IHQuY2xpZW50TGVmdCwgbC55ICs9IHQuY2xpZW50VG9wKSA6IG8gJiYgKGwueCA9IHdvKG8pKSksIHtcbiAgICB4OiByLmxlZnQgKyBhLnNjcm9sbExlZnQgLSBsLngsXG4gICAgeTogci50b3AgKyBhLnNjcm9sbFRvcCAtIGwueSxcbiAgICB3aWR0aDogci53aWR0aCxcbiAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBEaChzKSB7XG4gIHZhciB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIGkgPSBbXTtcbiAgcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICB0LnNldChvLm5hbWUsIG8pO1xuICB9KTtcbiAgZnVuY3Rpb24gbihvKSB7XG4gICAgZS5hZGQoby5uYW1lKTtcbiAgICB2YXIgciA9IFtdLmNvbmNhdChvLnJlcXVpcmVzIHx8IFtdLCBvLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHIuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBpZiAoIWUuaGFzKGEpKSB7XG4gICAgICAgIHZhciBsID0gdC5nZXQoYSk7XG4gICAgICAgIGwgJiYgbihsKTtcbiAgICAgIH1cbiAgICB9KSwgaS5wdXNoKG8pO1xuICB9XG4gIHJldHVybiBzLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgIGUuaGFzKG8ubmFtZSkgfHwgbihvKTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiAkaChzKSB7XG4gIHZhciB0ID0gRGgocyk7XG4gIHJldHVybiBOcy5yZWR1Y2UoZnVuY3Rpb24oZSwgaSkge1xuICAgIHJldHVybiBlLmNvbmNhdCh0LmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gbi5waGFzZSA9PT0gaTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIExoKHMpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdCB8fCAodCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGUpIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHQgPSB2b2lkIDAsIGUocygpKTtcbiAgICAgIH0pO1xuICAgIH0pKSwgdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIFd0KHMpIHtcbiAgZm9yICh2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGgsIGUgPSBuZXcgQXJyYXkodCA+IDEgPyB0IC0gMSA6IDApLCBpID0gMTsgaSA8IHQ7IGkrKylcbiAgICBlW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgcmV0dXJuIFtdLmNvbmNhdChlKS5yZWR1Y2UoZnVuY3Rpb24obiwgbykge1xuICAgIHJldHVybiBuLnJlcGxhY2UoLyVzLywgbyk7XG4gIH0sIHMpO1xufVxudmFyIHJlID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHByb3ZpZGVkIGFuIGludmFsaWQgJXMgcHJvcGVydHksIGV4cGVjdGVkICVzIGJ1dCBnb3QgJXMnLCBNaCA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiByZXF1aXJlcyBcIiVzXCIsIGJ1dCBcIiVzXCIgbW9kaWZpZXIgaXMgbm90IGF2YWlsYWJsZScsIFpvID0gW1wibmFtZVwiLCBcImVuYWJsZWRcIiwgXCJwaGFzZVwiLCBcImZuXCIsIFwiZWZmZWN0XCIsIFwicmVxdWlyZXNcIiwgXCJvcHRpb25zXCJdO1xuZnVuY3Rpb24gTmgocykge1xuICBzLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgIFtdLmNvbmNhdChPYmplY3Qua2V5cyh0KSwgWm8pLmZpbHRlcihmdW5jdGlvbihlLCBpLCBuKSB7XG4gICAgICByZXR1cm4gbi5pbmRleE9mKGUpID09PSBpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgdHlwZW9mIHQubmFtZSAhPSBcInN0cmluZ1wiICYmIGNvbnNvbGUuZXJyb3IoV3QocmUsIFN0cmluZyh0Lm5hbWUpLCAnXCJuYW1lXCInLCAnXCJzdHJpbmdcIicsICdcIicgKyBTdHJpbmcodC5uYW1lKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVuYWJsZWRcIjpcbiAgICAgICAgICB0eXBlb2YgdC5lbmFibGVkICE9IFwiYm9vbGVhblwiICYmIGNvbnNvbGUuZXJyb3IoV3QocmUsIHQubmFtZSwgJ1wiZW5hYmxlZFwiJywgJ1wiYm9vbGVhblwiJywgJ1wiJyArIFN0cmluZyh0LmVuYWJsZWQpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicGhhc2VcIjpcbiAgICAgICAgICBOcy5pbmRleE9mKHQucGhhc2UpIDwgMCAmJiBjb25zb2xlLmVycm9yKFd0KHJlLCB0Lm5hbWUsICdcInBoYXNlXCInLCBcImVpdGhlciBcIiArIE5zLmpvaW4oXCIsIFwiKSwgJ1wiJyArIFN0cmluZyh0LnBoYXNlKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZuXCI6XG4gICAgICAgICAgdHlwZW9mIHQuZm4gIT0gXCJmdW5jdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoV3QocmUsIHQubmFtZSwgJ1wiZm5cIicsICdcImZ1bmN0aW9uXCInLCAnXCInICsgU3RyaW5nKHQuZm4pICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZWZmZWN0XCI6XG4gICAgICAgICAgdC5lZmZlY3QgIT0gbnVsbCAmJiB0eXBlb2YgdC5lZmZlY3QgIT0gXCJmdW5jdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoV3QocmUsIHQubmFtZSwgJ1wiZWZmZWN0XCInLCAnXCJmdW5jdGlvblwiJywgJ1wiJyArIFN0cmluZyh0LmZuKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlcXVpcmVzXCI6XG4gICAgICAgICAgdC5yZXF1aXJlcyAhPSBudWxsICYmICFBcnJheS5pc0FycmF5KHQucmVxdWlyZXMpICYmIGNvbnNvbGUuZXJyb3IoV3QocmUsIHQubmFtZSwgJ1wicmVxdWlyZXNcIicsICdcImFycmF5XCInLCAnXCInICsgU3RyaW5nKHQucmVxdWlyZXMpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVxdWlyZXNJZkV4aXN0c1wiOlxuICAgICAgICAgIEFycmF5LmlzQXJyYXkodC5yZXF1aXJlc0lmRXhpc3RzKSB8fCBjb25zb2xlLmVycm9yKFd0KHJlLCB0Lm5hbWUsICdcInJlcXVpcmVzSWZFeGlzdHNcIicsICdcImFycmF5XCInLCAnXCInICsgU3RyaW5nKHQucmVxdWlyZXNJZkV4aXN0cykgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvcHRpb25zXCI6XG4gICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUG9wcGVySlM6IGFuIGludmFsaWQgcHJvcGVydHkgaGFzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIFwiJyArIHQubmFtZSArICdcIiBtb2RpZmllciwgdmFsaWQgcHJvcGVydGllcyBhcmUgJyArIFpvLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1wiJyArIGkgKyAnXCInO1xuICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSArICc7IGJ1dCBcIicgKyBlICsgJ1wiIHdhcyBwcm92aWRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHQucmVxdWlyZXMgJiYgdC5yZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcy5maW5kKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5uYW1lID09PSBpO1xuICAgICAgICB9KSA9PSBudWxsICYmIGNvbnNvbGUuZXJyb3IoV3QoTWgsIFN0cmluZyh0Lm5hbWUpLCBpLCBpKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBSaChzLCB0KSB7XG4gIHZhciBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcmV0dXJuIHMuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgbiA9IHQoaSk7XG4gICAgaWYgKCFlLmhhcyhuKSlcbiAgICAgIHJldHVybiBlLmFkZChuKSwgITA7XG4gIH0pO1xufVxuZnVuY3Rpb24gUGgocykge1xuICB2YXIgdCA9IHMucmVkdWNlKGZ1bmN0aW9uKGUsIGkpIHtcbiAgICB2YXIgbiA9IGVbaS5uYW1lXTtcbiAgICByZXR1cm4gZVtpLm5hbWVdID0gbiA/IE9iamVjdC5hc3NpZ24oe30sIG4sIGksIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG4ub3B0aW9ucywgaS5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIG4uZGF0YSwgaS5kYXRhKVxuICAgIH0pIDogaSwgZTtcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXModCkubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdFtlXTtcbiAgfSk7XG59XG52YXIgUW8gPSBcIlBvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50LlwiLCBCaCA9IFwiUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC5cIiwgSm8gPSB7XG4gIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIlxufTtcbmZ1bmN0aW9uIHRyKCkge1xuICBmb3IgKHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShzKSwgZSA9IDA7IGUgPCBzOyBlKyspXG4gICAgdFtlXSA9IGFyZ3VtZW50c1tlXTtcbiAgcmV0dXJuICF0LnNvbWUoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiAhKGkgJiYgdHlwZW9mIGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09IFwiZnVuY3Rpb25cIik7XG4gIH0pO1xufVxuZnVuY3Rpb24gV3Mocykge1xuICBzID09PSB2b2lkIDAgJiYgKHMgPSB7fSk7XG4gIHZhciB0ID0gcywgZSA9IHQuZGVmYXVsdE1vZGlmaWVycywgaSA9IGUgPT09IHZvaWQgMCA/IFtdIDogZSwgbiA9IHQuZGVmYXVsdE9wdGlvbnMsIG8gPSBuID09PSB2b2lkIDAgPyBKbyA6IG47XG4gIHJldHVybiBmdW5jdGlvbihhLCBsLCBwKSB7XG4gICAgcCA9PT0gdm9pZCAwICYmIChwID0gbyk7XG4gICAgdmFyIHUgPSB7XG4gICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIEpvLCBvKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiBhLFxuICAgICAgICBwb3BwZXI6IGxcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9LCBmID0gW10sIF8gPSAhMSwgbSA9IHtcbiAgICAgIHN0YXRlOiB1LFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24oQykge1xuICAgICAgICB2YXIgeSA9IHR5cGVvZiBDID09IFwiZnVuY3Rpb25cIiA/IEModS5vcHRpb25zKSA6IEM7XG4gICAgICAgIHYoKSwgdS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgbywgdS5vcHRpb25zLCB5KSwgdS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogVGUoYSkgPyBDaShhKSA6IGEuY29udGV4dEVsZW1lbnQgPyBDaShhLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogQ2kobClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEUgPSAkaChQaChbXS5jb25jYXQoaSwgdS5vcHRpb25zLm1vZGlmaWVycykpKTtcbiAgICAgICAgaWYgKHUub3JkZXJlZE1vZGlmaWVycyA9IEUuZmlsdGVyKGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgICByZXR1cm4gTy5lbmFibGVkO1xuICAgICAgICB9KSwge30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdmFyIFQgPSBSaChbXS5jb25jYXQoRSwgdS5vcHRpb25zLm1vZGlmaWVycyksIGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgICAgIHZhciBNID0gTy5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIE07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKE5oKFQpLCB2dCh1Lm9wdGlvbnMucGxhY2VtZW50KSA9PT0gSWkpIHtcbiAgICAgICAgICAgIHZhciBBID0gdS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24oTykge1xuICAgICAgICAgICAgICB2YXIgTSA9IE8ubmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuIE0gPT09IFwiZmxpcFwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBBIHx8IGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXV0b1wiIHBsYWNlbWVudHMgcmVxdWlyZSB0aGUgXCJmbGlwXCIgbW9kaWZpZXIgYmUnLCBcInByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay5cIl0uam9pbihcIiBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdyA9IFR0KGwpLCBTID0gdy5tYXJnaW5Ub3AsIGsgPSB3Lm1hcmdpblJpZ2h0LCB4ID0gdy5tYXJnaW5Cb3R0b20sICQgPSB3Lm1hcmdpbkxlZnQ7XG4gICAgICAgICAgW1MsIGssIHgsICRdLnNvbWUoZnVuY3Rpb24oTykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoTyk7XG4gICAgICAgICAgfSkgJiYgY29uc29sZS53YXJuKFsnUG9wcGVyOiBDU1MgXCJtYXJnaW5cIiBzdHlsZXMgY2Fubm90IGJlIHVzZWQgdG8gYXBwbHkgcGFkZGluZycsIFwiYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuXCIsIFwiVG8gcmVwbGljYXRlIG1hcmdpbiwgdXNlIHRoZSBgb2Zmc2V0YCBtb2RpZmllciwgYXMgd2VsbCBhc1wiLCBcInRoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgXCIsIFwibW9kaWZpZXJzLlwiXS5qb2luKFwiIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGcoKSwgbS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghXykge1xuICAgICAgICAgIHZhciBDID0gdS5lbGVtZW50cywgeSA9IEMucmVmZXJlbmNlLCBFID0gQy5wb3BwZXI7XG4gICAgICAgICAgaWYgKCF0cih5LCBFKSkge1xuICAgICAgICAgICAgKHt9KS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihRbyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHUucmVjdHMgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2U6IEloKHksIERpKEUpLCB1Lm9wdGlvbnMuc3RyYXRlZ3kgPT09IFwiZml4ZWRcIiksXG4gICAgICAgICAgICBwb3BwZXI6IFRvKEUpXG4gICAgICAgICAgfSwgdS5yZXNldCA9ICExLCB1LnBsYWNlbWVudCA9IHUub3B0aW9ucy5wbGFjZW1lbnQsIHUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgICAgIHJldHVybiB1Lm1vZGlmaWVyc0RhdGFbTy5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIE8uZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yICh2YXIgVCA9IDAsIEEgPSAwOyBBIDwgdS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgQSsrKSB7XG4gICAgICAgICAgICBpZiAoe30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChUICs9IDEsIFQgPiAxMDApKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoQmgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1LnJlc2V0ID09PSAhMCkge1xuICAgICAgICAgICAgICB1LnJlc2V0ID0gITEsIEEgPSAtMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdyA9IHUub3JkZXJlZE1vZGlmaWVyc1tBXSwgUyA9IHcuZm4sIGsgPSB3Lm9wdGlvbnMsIHggPSBrID09PSB2b2lkIDAgPyB7fSA6IGssICQgPSB3Lm5hbWU7XG4gICAgICAgICAgICB0eXBlb2YgUyA9PSBcImZ1bmN0aW9uXCIgJiYgKHUgPSBTKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHgsXG4gICAgICAgICAgICAgIG5hbWU6ICQsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBtXG4gICAgICAgICAgICB9KSB8fCB1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBMaChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICBtLmZvcmNlVXBkYXRlKCksIGIodSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdigpLCBfID0gITA7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIXRyKGEsIGwpKVxuICAgICAgcmV0dXJuIHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFFvKSwgbTtcbiAgICBtLnNldE9wdGlvbnMocCkudGhlbihmdW5jdGlvbihiKSB7XG4gICAgICAhXyAmJiBwLm9uRmlyc3RVcGRhdGUgJiYgcC5vbkZpcnN0VXBkYXRlKGIpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICB1Lm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbihiKSB7XG4gICAgICAgIHZhciBDID0gYi5uYW1lLCB5ID0gYi5vcHRpb25zLCBFID0geSA9PT0gdm9pZCAwID8ge30gOiB5LCBUID0gYi5lZmZlY3Q7XG4gICAgICAgIGlmICh0eXBlb2YgVCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgQSA9IFQoe1xuICAgICAgICAgICAgc3RhdGU6IHUsXG4gICAgICAgICAgICBuYW1lOiBDLFxuICAgICAgICAgICAgaW5zdGFuY2U6IG0sXG4gICAgICAgICAgICBvcHRpb25zOiBFXG4gICAgICAgICAgfSksIHcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGYucHVzaChBIHx8IHcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdigpIHtcbiAgICAgIGYuZm9yRWFjaChmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBiKCk7XG4gICAgICB9KSwgZiA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfTtcbn1cbnZhciBIaCA9IC8qIEBfX1BVUkVfXyAqLyBXcygpLCBXaCA9IFtBbywga28sIENvLCB2b10sIFZoID0gLyogQF9fUFVSRV9fICovIFdzKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogV2hcbn0pLCBGaCA9IFtBbywga28sIENvLCB2bywgTGwsIERsLCBNbCwgT2wsICRsXSwgRWUgPSAvKiBAX19QVVJFX18gKi8gV3Moe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBGaFxufSk7XG5jb25zdCBObCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFmdGVyTWFpbjogdmwsXG4gIGFmdGVyUmVhZDogbWwsXG4gIGFmdGVyV3JpdGU6IENsLFxuICBhcHBseVN0eWxlczogdm8sXG4gIGFycm93OiBPbCxcbiAgYXV0bzogSWksXG4gIGJhc2VQbGFjZW1lbnRzOiBxZSxcbiAgYmVmb3JlTWFpbjogZ2wsXG4gIGJlZm9yZVJlYWQ6IF9sLFxuICBiZWZvcmVXcml0ZTogVGwsXG4gIGJvdHRvbTogaHQsXG4gIGNsaXBwaW5nUGFyZW50czogdWwsXG4gIGNvbXB1dGVTdHlsZXM6IENvLFxuICBjcmVhdGVQb3BwZXI6IEVlLFxuICBjcmVhdGVQb3BwZXJCYXNlOiBIaCxcbiAgY3JlYXRlUG9wcGVyTGl0ZTogVmgsXG4gIGRldGVjdE92ZXJmbG93OiB6ZSxcbiAgZW5kOiBGZSxcbiAgZXZlbnRMaXN0ZW5lcnM6IEFvLFxuICBmbGlwOiBEbCxcbiAgaGlkZTogJGwsXG4gIGxlZnQ6IEosXG4gIG1haW46IGJsLFxuICBtb2RpZmllclBoYXNlczogTnMsXG4gIG9mZnNldDogTGwsXG4gIHBsYWNlbWVudHM6IGdvLFxuICBwb3BwZXI6IEllLFxuICBwb3BwZXJHZW5lcmF0b3I6IFdzLFxuICBwb3BwZXJPZmZzZXRzOiBrbyxcbiAgcHJldmVudE92ZXJmbG93OiBNbCxcbiAgcmVhZDogZmwsXG4gIHJlZmVyZW5jZTogcGwsXG4gIHJpZ2h0OiBkdCxcbiAgc3RhcnQ6IHZlLFxuICB0b3A6IFEsXG4gIHZhcmlhdGlvblBsYWNlbWVudHM6IHRvLFxuICB2aWV3cG9ydDogbW8sXG4gIHdyaXRlOiBFbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmZ1bmN0aW9uIHRuKHMpIHtcbiAgcmV0dXJuIHMgPT09IFwidHJ1ZVwiID8gITAgOiBzID09PSBcImZhbHNlXCIgPyAhMSA6IHMgPT09IE51bWJlcihzKS50b1N0cmluZygpID8gTnVtYmVyKHMpIDogcyA9PT0gXCJcIiB8fCBzID09PSBcIm51bGxcIiA/IG51bGwgOiBzO1xufVxuZnVuY3Rpb24gZW4ocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bQS1aXS9nLCAodCkgPT4gYC0ke3QudG9Mb3dlckNhc2UoKX1gKTtcbn1cbmNvbnN0IGMgPSB7XG4gIHNldERhdGFBdHRyaWJ1dGUocywgdCwgZSkge1xuICAgIHMuc2V0QXR0cmlidXRlKGBkYXRhLXRlLSR7ZW4odCl9YCwgZSk7XG4gIH0sXG4gIHJlbW92ZURhdGFBdHRyaWJ1dGUocywgdCkge1xuICAgIHMucmVtb3ZlQXR0cmlidXRlKGBkYXRhLXRlLSR7ZW4odCl9YCk7XG4gIH0sXG4gIGdldERhdGFBdHRyaWJ1dGVzKHMpIHtcbiAgICBpZiAoIXMpXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgdCA9IHt9O1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzLmRhdGFzZXQpLmZpbHRlcigoZSkgPT4gZS5zdGFydHNXaXRoKFwidGVcIikpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGlmIChlLnN0YXJ0c1dpdGgoXCJ0ZUNsYXNzXCIpKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgaSA9IGUucmVwbGFjZSgvXnRlLywgXCJcIik7XG4gICAgICBpID0gaS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIGkuc2xpY2UoMSwgaS5sZW5ndGgpLCB0W2ldID0gdG4ocy5kYXRhc2V0W2VdKTtcbiAgICB9KSwgdDtcbiAgfSxcbiAgZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyhzKSB7XG4gICAgaWYgKCFzKVxuICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICAuLi5zLmRhdGFzZXRcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0KS5maWx0ZXIoKGUpID0+IGUuc3RhcnRzV2l0aChcInRlQ2xhc3NcIikpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGxldCBpID0gZS5yZXBsYWNlKC9edGVDbGFzcy8sIFwiXCIpO1xuICAgICAgaSA9IGkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBpLnNsaWNlKDEsIGkubGVuZ3RoKSwgdFtpXSA9IHRuKHRbZV0pO1xuICAgIH0pLCB0O1xuICB9LFxuICBnZXREYXRhQXR0cmlidXRlKHMsIHQpIHtcbiAgICByZXR1cm4gdG4oXG4gICAgICBzLmdldEF0dHJpYnV0ZShgZGF0YS10ZS0ke2VuKHQpfWApXG4gICAgKTtcbiAgfSxcbiAgb2Zmc2V0KHMpIHtcbiAgICBjb25zdCB0ID0gcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiB0LnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxuICAgICAgbGVmdDogdC5sZWZ0ICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0XG4gICAgfTtcbiAgfSxcbiAgcG9zaXRpb24ocykge1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHMub2Zmc2V0VG9wLFxuICAgICAgbGVmdDogcy5vZmZzZXRMZWZ0XG4gICAgfTtcbiAgfSxcbiAgc3R5bGUocywgdCkge1xuICAgIE9iamVjdC5hc3NpZ24ocy5zdHlsZSwgdCk7XG4gIH0sXG4gIHRvZ2dsZUNsYXNzKHMsIHQpIHtcbiAgICBzICYmIHNuKHQpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHMuY2xhc3NMaXN0LmNvbnRhaW5zKGUpID8gcy5jbGFzc0xpc3QucmVtb3ZlKGUpIDogcy5jbGFzc0xpc3QuYWRkKGUpO1xuICAgIH0pO1xuICB9LFxuICBhZGRDbGFzcyhzLCB0KSB7XG4gICAgc24odCkuZm9yRWFjaChcbiAgICAgIChlKSA9PiAhcy5jbGFzc0xpc3QuY29udGFpbnMoZSkgJiYgcy5jbGFzc0xpc3QuYWRkKGUpXG4gICAgKTtcbiAgfSxcbiAgYWRkU3R5bGUocywgdCkge1xuICAgIE9iamVjdC5rZXlzKHQpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHMuc3R5bGVbZV0gPSB0W2VdO1xuICAgIH0pO1xuICB9LFxuICByZW1vdmVDbGFzcyhzLCB0KSB7XG4gICAgc24odCkuZm9yRWFjaChcbiAgICAgIChlKSA9PiBzLmNsYXNzTGlzdC5jb250YWlucyhlKSAmJiBzLmNsYXNzTGlzdC5yZW1vdmUoZSlcbiAgICApO1xuICB9LFxuICBoYXNDbGFzcyhzLCB0KSB7XG4gICAgcmV0dXJuIHMuY2xhc3NMaXN0LmNvbnRhaW5zKHQpO1xuICB9LFxuICBtYXhPZmZzZXQocykge1xuICAgIGNvbnN0IHQgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHQudG9wICsgTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICB3aW5kb3cuc2Nyb2xsWVxuICAgICAgKSxcbiAgICAgIGxlZnQ6IHQubGVmdCArIE1hdGgubWF4KFxuICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgICB3aW5kb3cuc2Nyb2xsWFxuICAgICAgKVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBzbihzKSB7XG4gIHJldHVybiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gcy5zcGxpdChcIiBcIikgOiBBcnJheS5pc0FycmF5KHMpID8gcyA6ICExO1xufVxuY29uc3QgWWggPSAzLCBkID0ge1xuICBjbG9zZXN0KHMsIHQpIHtcbiAgICByZXR1cm4gcy5jbG9zZXN0KHQpO1xuICB9LFxuICBtYXRjaGVzKHMsIHQpIHtcbiAgICByZXR1cm4gcy5tYXRjaGVzKHQpO1xuICB9LFxuICBmaW5kKHMsIHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KFxuICAgICAgLi4uRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbC5jYWxsKHQsIHMpXG4gICAgKTtcbiAgfSxcbiAgZmluZE9uZShzLCB0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbCh0LCBzKTtcbiAgfSxcbiAgY2hpbGRyZW4ocywgdCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoLi4ucy5jaGlsZHJlbikuZmlsdGVyKChpKSA9PiBpLm1hdGNoZXModCkpO1xuICB9LFxuICBwYXJlbnRzKHMsIHQpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgbGV0IGkgPSBzLnBhcmVudE5vZGU7XG4gICAgZm9yICg7IGkgJiYgaS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgaS5ub2RlVHlwZSAhPT0gWWg7IClcbiAgICAgIHRoaXMubWF0Y2hlcyhpLCB0KSAmJiBlLnB1c2goaSksIGkgPSBpLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIGU7XG4gIH0sXG4gIHByZXYocywgdCkge1xuICAgIGxldCBlID0gcy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGZvciAoOyBlOyApIHtcbiAgICAgIGlmIChlLm1hdGNoZXModCkpXG4gICAgICAgIHJldHVybiBbZV07XG4gICAgICBlID0gZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIG5leHQocywgdCkge1xuICAgIGxldCBlID0gcy5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgZm9yICg7IGU7ICkge1xuICAgICAgaWYgKHRoaXMubWF0Y2hlcyhlLCB0KSlcbiAgICAgICAgcmV0dXJuIFtlXTtcbiAgICAgIGUgPSBlLm5leHRFbGVtZW50U2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBmb2N1c2FibGVDaGlsZHJlbihzKSB7XG4gICAgY29uc3QgdCA9IFtcbiAgICAgIFwiYVwiLFxuICAgICAgXCJidXR0b25cIixcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIFwidGV4dGFyZWFcIixcbiAgICAgIFwic2VsZWN0XCIsXG4gICAgICBcImRldGFpbHNcIixcbiAgICAgIFwiW3RhYmluZGV4XVwiLFxuICAgICAgJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJ1xuICAgIF0ubWFwKChlKSA9PiBgJHtlfTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pYCkuam9pbihcIiwgXCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmQodCwgcykuZmlsdGVyKFxuICAgICAgKGUpID0+ICFtZShlKSAmJiBMdChlKVxuICAgICk7XG4gIH1cbn0sIG5uID0gXCJkcm9wZG93blwiLCBqaCA9IFwidGUuZHJvcGRvd25cIiwgQ2UgPSBgLiR7amh9YCwgT28gPSBcIi5kYXRhLWFwaVwiLCB2cyA9IFwiRXNjYXBlXCIsIGVyID0gXCJTcGFjZVwiLCBpciA9IFwiVGFiXCIsIHNvID0gXCJBcnJvd1VwXCIsIFRzID0gXCJBcnJvd0Rvd25cIiwgS2ggPSAyLCB6aCA9IG5ldyBSZWdFeHAoXG4gIGAke3NvfXwke1RzfXwke3ZzfWBcbiksIFVoID0gYGhpZGUke0NlfWAsIFhoID0gYGhpZGRlbiR7Q2V9YCwgR2ggPSBgc2hvdyR7Q2V9YCwgcWggPSBgc2hvd24ke0NlfWAsIFpoID0gYGNsaWNrJHtDZX0ke09vfWAsIHNyID0gYGtleWRvd24ke0NlfSR7T299YCwgUWggPSBga2V5dXAke0NlfSR7T299YCwgVnQgPSBcInNob3dcIiwgSmggPSBcImRyb3B1cFwiLCB0ZCA9IFwiZHJvcGVuZFwiLCBlZCA9IFwiZHJvcHN0YXJ0XCIsIGlkID0gXCJbZGF0YS10ZS1uYXZiYXItcmVmXVwiLCBLaSA9IFwiW2RhdGEtdGUtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIiwgb24gPSBcIltkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXVwiLCBzZCA9IFwiW2RhdGEtdGUtbmF2YmFyLW5hdi1yZWZdXCIsIG5kID0gXCJbZGF0YS10ZS1kcm9wZG93bi1tZW51LXJlZl0gW2RhdGEtdGUtZHJvcGRvd24taXRlbS1yZWZdOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpXCIsIG9kID0gRigpID8gXCJ0b3AtZW5kXCIgOiBcInRvcC1zdGFydFwiLCByZCA9IEYoKSA/IFwidG9wLXN0YXJ0XCIgOiBcInRvcC1lbmRcIiwgYWQgPSBGKCkgPyBcImJvdHRvbS1lbmRcIiA6IFwiYm90dG9tLXN0YXJ0XCIsIGxkID0gRigpID8gXCJib3R0b20tc3RhcnRcIiA6IFwiYm90dG9tLWVuZFwiLCBjZCA9IEYoKSA/IFwibGVmdC1zdGFydFwiIDogXCJyaWdodC1zdGFydFwiLCBoZCA9IEYoKSA/IFwicmlnaHQtc3RhcnRcIiA6IFwibGVmdC1zdGFydFwiLCBkZCA9IFt7IG9wYWNpdHk6IFwiMFwiIH0sIHsgb3BhY2l0eTogXCIxXCIgfV0sIHVkID0gW3sgb3BhY2l0eTogXCIxXCIgfSwgeyBvcGFjaXR5OiBcIjBcIiB9XSwgemkgPSB7XG4gIGR1cmF0aW9uOiA1NTAsXG4gIGl0ZXJhdGlvbnM6IDEsXG4gIGVhc2luZzogXCJlYXNlXCIsXG4gIGZpbGw6IFwiYm90aFwiXG59LCBwZCA9IHtcbiAgb2Zmc2V0OiBbMCwgMl0sXG4gIGJvdW5kYXJ5OiBcImNsaXBwaW5nUGFyZW50c1wiLFxuICByZWZlcmVuY2U6IFwidG9nZ2xlXCIsXG4gIGRpc3BsYXk6IFwiZHluYW1pY1wiLFxuICBwb3BwZXJDb25maWc6IG51bGwsXG4gIGF1dG9DbG9zZTogITAsXG4gIGRyb3Bkb3duQW5pbWF0aW9uOiBcIm9uXCJcbn0sIF9kID0ge1xuICBvZmZzZXQ6IFwiKGFycmF5fHN0cmluZ3xmdW5jdGlvbilcIixcbiAgYm91bmRhcnk6IFwiKHN0cmluZ3xlbGVtZW50KVwiLFxuICByZWZlcmVuY2U6IFwiKHN0cmluZ3xlbGVtZW50fG9iamVjdClcIixcbiAgZGlzcGxheTogXCJzdHJpbmdcIixcbiAgcG9wcGVyQ29uZmlnOiBcIihudWxsfG9iamVjdHxmdW5jdGlvbilcIixcbiAgYXV0b0Nsb3NlOiBcIihib29sZWFufHN0cmluZylcIixcbiAgZHJvcGRvd25BbmltYXRpb246IFwic3RyaW5nXCJcbn07XG5jbGFzcyBJdCBleHRlbmRzIEV0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpLCB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpLCB0aGlzLl9mYWRlT3V0QW5pbWF0ZSA9IG51bGw7XG4gICAgY29uc3QgaSA9IHdpbmRvdy5tYXRjaE1lZGlhKFxuICAgICAgXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiXG4gICAgKS5tYXRjaGVzO1xuICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPSB0aGlzLl9jb25maWcuZHJvcGRvd25BbmltYXRpb24gPT09IFwib25cIiAmJiAhaSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHBkO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIF9kO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gbm47XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmIChtZSh0aGlzLl9lbGVtZW50KSB8fCB0aGlzLl9pc1Nob3duKHRoaXMuX21lbnUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfTtcbiAgICBpZiAoaC50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIEdoLFxuICAgICAgdFxuICAgICkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gSXQuZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgdGhpcy5faW5OYXZiYXIgPyBjLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgXCJwb3BwZXJcIiwgXCJub25lXCIpIDogdGhpcy5fY3JlYXRlUG9wcGVyKGkpLCBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhaS5jbG9zZXN0KHNkKSAmJiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgobikgPT4gaC5vbihuLCBcIm1vdXNlb3ZlclwiLCBNcykpLCB0aGlzLl9lbGVtZW50LmZvY3VzKCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCAhMCksIHRoaXMuX21lbnUuc2V0QXR0cmlidXRlKGBkYXRhLXRlLWRyb3Bkb3duLSR7VnR9YCwgXCJcIiksIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgJiYgdGhpcy5fbWVudS5hbmltYXRlKGRkLCB6aSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLXRlLWRyb3Bkb3duLSR7VnR9YCwgXCJcIiksIHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBxaCwgdCk7XG4gICAgICB9LFxuICAgICAgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSA/IHppLmR1cmF0aW9uIDogMFxuICAgICk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAobWUodGhpcy5fZWxlbWVudCkgfHwgIXRoaXMuX2lzU2hvd24odGhpcy5fbWVudSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9O1xuICAgIHRoaXMuX2NvbXBsZXRlSGlkZSh0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCksIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8IChoLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBzcixcbiAgICAgIEtpLFxuICAgICAgSXQuZGF0YUFwaUtleWRvd25IYW5kbGVyXG4gICAgKSwgaC5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgc3IsXG4gICAgICBvbixcbiAgICAgIEl0LmRhdGFBcGlLZXlkb3duSGFuZGxlclxuICAgICksIGgub24oZG9jdW1lbnQsIFpoLCBJdC5jbGVhck1lbnVzKSwgaC5vbihkb2N1bWVudCwgUWgsIEl0LmNsZWFyTWVudXMpLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9jb21wbGV0ZUhpZGUodCkge1xuICAgIHRoaXMuX2ZhZGVPdXRBbmltYXRlICYmIHRoaXMuX2ZhZGVPdXRBbmltYXRlLnBsYXlTdGF0ZSA9PT0gXCJydW5uaW5nXCIgfHwgaC50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFVoLFxuICAgICAgdFxuICAgICkuZGVmYXVsdFByZXZlbnRlZCB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKGkpID0+IGgub2ZmKGksIFwibW91c2VvdmVyXCIsIE1zKSksIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgJiYgKHRoaXMuX2ZhZGVPdXRBbmltYXRlID0gdGhpcy5fbWVudS5hbmltYXRlKFxuICAgICAgdWQsXG4gICAgICB6aVxuICAgICkpLCBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgdGhpcy5fbWVudS5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtWdH1gKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtWdH1gKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIiksIGMucmVtb3ZlRGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFhoLCB0KTtcbiAgICAgIH0sXG4gICAgICB0aGlzLl9hbmltYXRpb25DYW5QbGF5ID8gemkuZHVyYXRpb24gOiAwXG4gICAgKSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgaWYgKHQgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIEwobm4sIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0eXBlb2YgdC5yZWZlcmVuY2UgPT0gXCJvYmplY3RcIiAmJiAhVmUodC5yZWZlcmVuY2UpICYmIHR5cGVvZiB0LnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYCR7bm4udG9VcHBlckNhc2UoKX06IE9wdGlvbiBcInJlZmVyZW5jZVwiIHByb3ZpZGVkIHR5cGUgXCJvYmplY3RcIiB3aXRob3V0IGEgcmVxdWlyZWQgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIiBtZXRob2QuYFxuICAgICAgKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBfY3JlYXRlUG9wcGVyKHQpIHtcbiAgICBpZiAodHlwZW9mIE5sID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkJvb3RzdHJhcCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKVwiXG4gICAgICApO1xuICAgIGxldCBlID0gdGhpcy5fZWxlbWVudDtcbiAgICB0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSBcInBhcmVudFwiID8gZSA9IHQgOiBWZSh0aGlzLl9jb25maWcucmVmZXJlbmNlKSA/IGUgPSBKdCh0aGlzLl9jb25maWcucmVmZXJlbmNlKSA6IHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlID09IFwib2JqZWN0XCIgJiYgKGUgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlKTtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCksIG4gPSBpLm1vZGlmaWVycy5maW5kKFxuICAgICAgKG8pID0+IG8ubmFtZSA9PT0gXCJhcHBseVN0eWxlc1wiICYmIG8uZW5hYmxlZCA9PT0gITFcbiAgICApO1xuICAgIHRoaXMuX3BvcHBlciA9IEVlKFxuICAgICAgZSxcbiAgICAgIHRoaXMuX21lbnUsXG4gICAgICBpXG4gICAgKSwgbiAmJiBjLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgXCJwb3BwZXJcIiwgXCJzdGF0aWNcIik7XG4gIH1cbiAgX2lzU2hvd24odCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gdC5kYXRhc2V0W2B0ZURyb3Bkb3duJHtWdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIFZ0LnNsaWNlKDEpfWBdID09PSBcIlwiO1xuICB9XG4gIF9nZXRNZW51RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZC5uZXh0KHRoaXMuX2VsZW1lbnQsIG9uKVswXTtcbiAgfVxuICBfZ2V0UGxhY2VtZW50KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHQuZGF0YXNldC50ZURyb3Bkb3duUG9zaXRpb24gPT09IHRkKVxuICAgICAgcmV0dXJuIGNkO1xuICAgIGlmICh0LmRhdGFzZXQudGVEcm9wZG93blBvc2l0aW9uID09PSBlZClcbiAgICAgIHJldHVybiBoZDtcbiAgICBjb25zdCBlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS10ZS1wb3NpdGlvblwiKS50cmltKCkgPT09IFwiZW5kXCI7XG4gICAgcmV0dXJuIHQuZGF0YXNldC50ZURyb3Bkb3duUG9zaXRpb24gPT09IEpoID8gZSA/IHJkIDogb2QgOiBlID8gbGQgOiBhZDtcbiAgfVxuICBfZGV0ZWN0TmF2YmFyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoaWQpICE9PSBudWxsO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgeyBvZmZzZXQ6IHQgfSA9IHRoaXMuX2NvbmZpZztcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gTnVtYmVyLnBhcnNlSW50KGUsIDEwKSkgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAoZSkgPT4gdChlLCB0aGlzLl9lbGVtZW50KSA6IHQ7XG4gIH1cbiAgX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJwcmV2ZW50T3ZlcmZsb3dcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRpc3BsYXkgPT09IFwic3RhdGljXCIgJiYgKHQubW9kaWZpZXJzID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcImFwcGx5U3R5bGVzXCIsXG4gICAgICAgIGVuYWJsZWQ6ICExXG4gICAgICB9XG4gICAgXSksIHtcbiAgICAgIC4uLnQsXG4gICAgICAuLi50eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKHQpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xuICAgIH07XG4gIH1cbiAgX3NlbGVjdE1lbnVJdGVtKHsga2V5OiB0LCB0YXJnZXQ6IGUgfSkge1xuICAgIGNvbnN0IGkgPSBkLmZpbmQoXG4gICAgICBuZCxcbiAgICAgIHRoaXMuX21lbnVcbiAgICApLmZpbHRlcihMdCk7XG4gICAgaS5sZW5ndGggJiYgbmwoXG4gICAgICBpLFxuICAgICAgZSxcbiAgICAgIHQgPT09IFRzLFxuICAgICAgIWkuaW5jbHVkZXMoZSlcbiAgICApLmZvY3VzKCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gSXQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNsZWFyTWVudXModCkge1xuICAgIGlmICh0ICYmICh0LmJ1dHRvbiA9PT0gS2ggfHwgdC50eXBlID09PSBcImtleXVwXCIgJiYgdC5rZXkgIT09IGlyKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gZC5maW5kKEtpKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGUubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCBvID0gSXQuZ2V0SW5zdGFuY2UoZVtpXSk7XG4gICAgICBpZiAoIW8gfHwgby5fY29uZmlnLmF1dG9DbG9zZSA9PT0gITEgfHwgIW8uX2lzU2hvd24oKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCByID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBvLl9lbGVtZW50XG4gICAgICB9O1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY29uc3QgYSA9IHQuY29tcG9zZWRQYXRoKCksIGwgPSBhLmluY2x1ZGVzKG8uX21lbnUpO1xuICAgICAgICBpZiAoYS5pbmNsdWRlcyhvLl9lbGVtZW50KSB8fCBvLl9jb25maWcuYXV0b0Nsb3NlID09PSBcImluc2lkZVwiICYmICFsIHx8IG8uX2NvbmZpZy5hdXRvQ2xvc2UgPT09IFwib3V0c2lkZVwiICYmIGwgfHwgby5fbWVudS5jb250YWlucyh0LnRhcmdldCkgJiYgKHQudHlwZSA9PT0gXCJrZXl1cFwiICYmIHQua2V5ID09PSBpciB8fCAvaW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxmb3JtL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHQudHlwZSA9PT0gXCJjbGlja1wiICYmIChyLmNsaWNrRXZlbnQgPSB0KTtcbiAgICAgIH1cbiAgICAgIG8uX2NvbXBsZXRlSGlkZShyKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldFBhcmVudEZyb21FbGVtZW50KHQpIHtcbiAgICByZXR1cm4gUXQodCkgfHwgdC5wYXJlbnROb2RlO1xuICB9XG4gIHN0YXRpYyBkYXRhQXBpS2V5ZG93bkhhbmRsZXIodCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpID8gdC5rZXkgPT09IGVyIHx8IHQua2V5ICE9PSB2cyAmJiAodC5rZXkgIT09IFRzICYmIHQua2V5ICE9PSBzbyB8fCB0LnRhcmdldC5jbG9zZXN0KG9uKSkgOiAhemgudGVzdCh0LmtleSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuZGF0YXNldFtgdGVEcm9wZG93biR7VnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBWdC5zbGljZSgxKX1gXSA9PT0gXCJcIjtcbiAgICBpZiAoIWUgJiYgdC5rZXkgPT09IHZzIHx8ICh0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCksIG1lKHRoaXMpKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gdGhpcy5tYXRjaGVzKEtpKSA/IHRoaXMgOiBkLnByZXYodGhpcywgS2kpWzBdLCBuID0gSXQuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKTtcbiAgICBpZiAodC5rZXkgPT09IHZzKSB7XG4gICAgICBuLmhpZGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHQua2V5ID09PSBzbyB8fCB0LmtleSA9PT0gVHMpIHtcbiAgICAgIGUgfHwgbi5zaG93KCksIG4uX3NlbGVjdE1lbnVJdGVtKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoIWUgfHwgdC5rZXkgPT09IGVyKSAmJiBJdC5jbGVhck1lbnVzKCk7XG4gIH1cbn1cbmNvbnN0IHJuID0gXCJjb2xsYXBzZVwiLCBSbCA9IFwidGUuY29sbGFwc2VcIiwgVnMgPSBgLiR7Umx9YCwgbnIgPSB7XG4gIHRvZ2dsZTogITAsXG4gIHBhcmVudDogbnVsbFxufSwgZmQgPSB7XG4gIHRvZ2dsZTogXCJib29sZWFuXCIsXG4gIHBhcmVudDogXCIobnVsbHxlbGVtZW50KVwiXG59LCBtZCA9IGBzaG93JHtWc31gLCBnZCA9IGBzaG93biR7VnN9YCwgYmQgPSBgaGlkZSR7VnN9YCwgdmQgPSBgaGlkZGVuJHtWc31gLCBhbiA9IFwiZGF0YS10ZS1jb2xsYXBzZS1zaG93XCIsIG9yID0gXCJkYXRhLXRlLWNvbGxhcHNlLWNvbGxhcHNlZFwiLCBVaSA9IFwiZGF0YS10ZS1jb2xsYXBzZS1jb2xsYXBzaW5nXCIsIFRkID0gXCJkYXRhLXRlLWNvbGxhcHNlLWhvcml6b250YWxcIiwgTGUgPSBcImRhdGEtdGUtY29sbGFwc2UtaXRlbVwiLCByciA9IGA6c2NvcGUgWyR7TGV9XSBbJHtMZX1dYCwgRWQgPSBcIndpZHRoXCIsIENkID0gXCJoZWlnaHRcIiwgQWQgPSBcIltkYXRhLXRlLWNvbGxhcHNlLWl0ZW1dW2RhdGEtdGUtY29sbGFwc2Utc2hvd10sIFtkYXRhLXRlLWNvbGxhcHNlLWl0ZW1dW2RhdGEtdGUtY29sbGFwc2UtY29sbGFwc2luZ11cIiwgYXIgPSBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsIHlkID0ge1xuICB2aXNpYmxlOiBcIiF2aXNpYmxlXCIsXG4gIGhpZGRlbjogXCJoaWRkZW5cIixcbiAgYmFzZVRyYW5zaXRpb246IFwib3ZlcmZsb3ctaGlkZGVuIGR1cmF0aW9uLVszNTBtc10gZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMS4wKV0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgY29sbGFwc2luZzogXCJoLTAgdHJhbnNpdGlvbi1baGVpZ2h0XSBvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBjb2xsYXBzaW5nSG9yaXpvbnRhbDogXCJ3LTAgaC1hdXRvIHRyYW5zaXRpb24tW3dpZHRoXSBvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiXG59LCB3ZCA9IHtcbiAgdmlzaWJsZTogXCJzdHJpbmdcIixcbiAgaGlkZGVuOiBcInN0cmluZ1wiLFxuICBiYXNlVHJhbnNpdGlvbjogXCJzdHJpbmdcIixcbiAgY29sbGFwc2luZzogXCJzdHJpbmdcIixcbiAgY29sbGFwc2luZ0hvcml6b250YWw6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBxdCBleHRlbmRzIEV0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fdHJpZ2dlckFycmF5ID0gW107XG4gICAgY29uc3QgbiA9IGQuZmluZChhcik7XG4gICAgZm9yIChsZXQgbyA9IDAsIHIgPSBuLmxlbmd0aDsgbyA8IHI7IG8rKykge1xuICAgICAgY29uc3QgYSA9IG5bb10sIGwgPSBmbyhhKSwgcCA9IGQuZmluZChsKS5maWx0ZXIoXG4gICAgICAgICh1KSA9PiB1ID09PSB0aGlzLl9lbGVtZW50XG4gICAgICApO1xuICAgICAgbCAhPT0gbnVsbCAmJiBwLmxlbmd0aCAmJiAodGhpcy5fc2VsZWN0b3IgPSBsLCB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChhKSk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemVDaGlsZHJlbigpLCB0aGlzLl9jb25maWcucGFyZW50IHx8IHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksIHRoaXMuX2lzU2hvd24oKSksIHRoaXMuX2NvbmZpZy50b2dnbGUgJiYgdGhpcy50b2dnbGUoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gbnI7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBybjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2lzU2hvd24oKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdCA9IFtdLCBlO1xuICAgIGlmICh0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICBjb25zdCB1ID0gZC5maW5kKFxuICAgICAgICBycixcbiAgICAgICAgdGhpcy5fY29uZmlnLnBhcmVudFxuICAgICAgKTtcbiAgICAgIHQgPSBkLmZpbmQoXG4gICAgICAgIEFkLFxuICAgICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICApLmZpbHRlcigoZikgPT4gIXUuaW5jbHVkZXMoZikpO1xuICAgIH1cbiAgICBjb25zdCBpID0gZC5maW5kT25lKHRoaXMuX3NlbGVjdG9yKTtcbiAgICBpZiAodC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHUgPSB0LmZpbmQoKGYpID0+IGkgIT09IGYpO1xuICAgICAgaWYgKGUgPSB1ID8gcXQuZ2V0SW5zdGFuY2UodSkgOiBudWxsLCBlICYmIGUuX2lzVHJhbnNpdGlvbmluZylcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIG1kKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHQuZm9yRWFjaCgodSkgPT4ge1xuICAgICAgaSAhPT0gdSAmJiBxdC5nZXRPckNyZWF0ZUluc3RhbmNlKHUsIHsgdG9nZ2xlOiAhMSB9KS5oaWRlKCksIGUgfHwgSS5zZXREYXRhKHUsIFJsLCBudWxsKTtcbiAgICB9KTtcbiAgICBjb25zdCBvID0gdGhpcy5fZ2V0RGltZW5zaW9uKCksIHIgPSBvID09PSBcImhlaWdodFwiID8gdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nIDogdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nSG9yaXpvbnRhbDtcbiAgICBjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMudmlzaWJsZSksIGMucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5oaWRkZW4pLCBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShMZSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFVpLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zdHlsZVtvXSA9IDAsIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksICEwKSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITA7XG4gICAgY29uc3QgYSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCBjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCByKSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShVaSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKExlLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYW4sIFwiXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlW29dID0gXCJcIiwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGdkKTtcbiAgICB9LCBwID0gYHNjcm9sbCR7b1swXS50b1VwcGVyQ2FzZSgpICsgby5zbGljZSgxKX1gO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soYSwgdGhpcy5fZWxlbWVudCwgITApLCB0aGlzLl9lbGVtZW50LnN0eWxlW29dID0gYCR7dGhpcy5fZWxlbWVudFtwXX1weGA7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkgfHwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGJkKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXREaW1lbnNpb24oKSwgaSA9IGUgPT09IFwiaGVpZ2h0XCIgPyB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmcgOiB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmdIb3Jpem9udGFsO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZV0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2VdfXB4YCwgR2UodGhpcy5fZWxlbWVudCksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgaSksIGMucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFVpLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoTGUpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhbik7XG4gICAgY29uc3QgbiA9IHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGg7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBuOyByKyspIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLl90cmlnZ2VyQXJyYXlbcl0sIGwgPSBRdChhKTtcbiAgICAgIGwgJiYgIXRoaXMuX2lzU2hvd24obCkgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFthXSwgITEpO1xuICAgIH1cbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMDtcbiAgICBjb25zdCBvID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIGMucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgaSksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFVpKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoTGUsIFwiXCIpLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdmQpO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtlXSA9IFwiXCIsIHRoaXMuX3F1ZXVlQ2FsbGJhY2sobywgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIF9pc1Nob3duKHQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgcmV0dXJuIHQuaGFzQXR0cmlidXRlKGFuKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ubnIsXG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIHQudG9nZ2xlID0gISF0LnRvZ2dsZSwgdC5wYXJlbnQgPSBKdCh0LnBhcmVudCksIEwocm4sIHQsIGZkKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnlkLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKHJuLCB0LCB3ZCksIHQ7XG4gIH1cbiAgX2dldERpbWVuc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoVGQpID8gRWQgOiBDZDtcbiAgfVxuICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZC5maW5kKFxuICAgICAgcnIsXG4gICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgKTtcbiAgICBkLmZpbmQoYXIsIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcigoZSkgPT4gIXQuaW5jbHVkZXMoZSkpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBRdChlKTtcbiAgICAgIGkgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFtlXSwgdGhpcy5faXNTaG93bihpKSk7XG4gICAgfSk7XG4gIH1cbiAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0LCBlKSB7XG4gICAgdC5sZW5ndGggJiYgdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBlID8gaS5yZW1vdmVBdHRyaWJ1dGUob3IpIDogaS5zZXRBdHRyaWJ1dGUoYCR7b3J9YCwgXCJcIiksIGkuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBlKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSB7fTtcbiAgICAgIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgL3Nob3d8aGlkZS8udGVzdCh0KSAmJiAoZS50b2dnbGUgPSAhMSk7XG4gICAgICBjb25zdCBpID0gcXQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBlKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGxyID0gXCIuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wXCIsIGNyID0gXCIuc3RpY2t5LXRvcFwiO1xuY2xhc3Mga2kge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgfVxuICBnZXRXaWR0aCgpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cuaW5uZXJXaWR0aCAtIHQpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICB0aGlzLl9kaXNhYmxlT3ZlckZsb3coKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJwYWRkaW5nUmlnaHRcIixcbiAgICAgIChlKSA9PiBlICsgdFxuICAgICksIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFxuICAgICAgbHIsXG4gICAgICBcInBhZGRpbmdSaWdodFwiLFxuICAgICAgKGUpID0+IGUgKyB0XG4gICAgKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICBjcixcbiAgICAgIFwibWFyZ2luUmlnaHRcIixcbiAgICAgIChlKSA9PiBlIC0gdFxuICAgICk7XG4gIH1cbiAgX2Rpc2FibGVPdmVyRmxvdygpIHtcbiAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50LCBcIm92ZXJmbG93XCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgfVxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldFdpZHRoKCksIG8gPSAocikgPT4ge1xuICAgICAgaWYgKHIgIT09IHRoaXMuX2VsZW1lbnQgJiYgd2luZG93LmlubmVyV2lkdGggPiByLmNsaWVudFdpZHRoICsgbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUociwgZSk7XG4gICAgICBjb25zdCBhID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocilbZV07XG4gICAgICByLnN0eWxlW2VdID0gYCR7aShcbiAgICAgICAgTnVtYmVyLnBhcnNlRmxvYXQoYSlcbiAgICAgICl9cHhgO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBvKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFwib3ZlcmZsb3dcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgXCJwYWRkaW5nUmlnaHRcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMobHIsIFwicGFkZGluZ1JpZ2h0XCIpLCB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKGNyLCBcIm1hcmdpblJpZ2h0XCIpO1xuICB9XG4gIF9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IHQuc3R5bGVbZV07XG4gICAgaSAmJiBjLnNldERhdGFBdHRyaWJ1dGUodCwgZSwgaSk7XG4gIH1cbiAgX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSkge1xuICAgIGNvbnN0IGkgPSAobikgPT4ge1xuICAgICAgY29uc3QgbyA9IGMuZ2V0RGF0YUF0dHJpYnV0ZShuLCBlKTtcbiAgICAgIHR5cGVvZiBvID4gXCJ1XCIgPyBuLnN0eWxlLnJlbW92ZVByb3BlcnR5KGUpIDogKGMucmVtb3ZlRGF0YUF0dHJpYnV0ZShuLCBlKSwgbi5zdHlsZVtlXSA9IG8pO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBpKTtcbiAgfVxuICBfYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBlKSB7XG4gICAgVmUodCkgPyBlKHQpIDogZC5maW5kKHQsIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goZSk7XG4gIH1cbiAgaXNPdmVyZmxvd2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpID4gMDtcbiAgfVxufVxuY29uc3QgeGQgPSB7XG4gIGlzVmlzaWJsZTogITAsXG4gIC8vIGlmIGZhbHNlLCB3ZSB1c2UgdGhlIGJhY2tkcm9wIGhlbHBlciB3aXRob3V0IGFkZGluZyBhbnkgZWxlbWVudCB0byB0aGUgZG9tXG4gIGlzQW5pbWF0ZWQ6ICExLFxuICByb290RWxlbWVudDogXCJib2R5XCIsXG4gIC8vIGdpdmUgdGhlIGNob2ljZSB0byBwbGFjZSBiYWNrZHJvcCB1bmRlciBkaWZmZXJlbnQgZWxlbWVudHNcbiAgY2xpY2tDYWxsYmFjazogbnVsbCxcbiAgYmFja2Ryb3BDbGFzc2VzOiBudWxsXG59LCBrZCA9IHtcbiAgaXNWaXNpYmxlOiBcImJvb2xlYW5cIixcbiAgaXNBbmltYXRlZDogXCJib29sZWFuXCIsXG4gIHJvb3RFbGVtZW50OiBcIihlbGVtZW50fHN0cmluZylcIixcbiAgY2xpY2tDYWxsYmFjazogXCIoZnVuY3Rpb258bnVsbClcIixcbiAgYmFja2Ryb3BDbGFzc2VzOiBcIihhcnJheXxudWxsKVwiXG59LCBQbCA9IFwiYmFja2Ryb3BcIiwgaHIgPSBgbW91c2Vkb3duLnRlLiR7UGx9YDtcbmNsYXNzIFNvIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyh0KSwgdGhpcy5faXNBcHBlbmRlZCA9ICExLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBzaG93KHQpIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcbiAgICAgIGZlKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hcHBlbmQoKSwgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQgJiYgR2UodGhpcy5fZ2V0RWxlbWVudCgpKTtcbiAgICBjb25zdCBlID0gdGhpcy5fY29uZmlnLmJhY2tkcm9wQ2xhc3NlcyB8fCBbXG4gICAgICBcIm9wYWNpdHktNTBcIixcbiAgICAgIFwidHJhbnNpdGlvbi1hbGxcIixcbiAgICAgIFwiZHVyYXRpb24tMzAwXCIsXG4gICAgICBcImVhc2UtaW4tb3V0XCIsXG4gICAgICBcImZpeGVkXCIsXG4gICAgICBcInRvcC0wXCIsXG4gICAgICBcImxlZnQtMFwiLFxuICAgICAgXCJ6LVsxMDQwXVwiLFxuICAgICAgXCJiZy1ibGFja1wiLFxuICAgICAgXCJ3LXNjcmVlblwiLFxuICAgICAgXCJoLXNjcmVlblwiXG4gICAgXTtcbiAgICBjLnJlbW92ZUNsYXNzKHRoaXMuX2dldEVsZW1lbnQoKSwgXCJvcGFjaXR5LTBcIiksIGMuYWRkQ2xhc3ModGhpcy5fZ2V0RWxlbWVudCgpLCBlKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWJhY2tkcm9wLXNob3dcIiwgXCJcIiksIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgZmUodCk7XG4gICAgfSk7XG4gIH1cbiAgaGlkZSh0KSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICBmZSh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWJhY2tkcm9wLXNob3dcIiksIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0wXCIpLCB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktNTBcIiksIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy5kaXNwb3NlKCksIGZlKHQpO1xuICAgIH0pO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldEVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50KSB7XG4gICAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHQuY2xhc3NOYW1lID0gdGhpcy5fY29uZmlnLmNsYXNzTmFtZSwgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQgJiYgdC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS01MFwiKSwgdGhpcy5fZWxlbWVudCA9IHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ueGQsXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgdC5yb290RWxlbWVudCA9IEp0KHQucm9vdEVsZW1lbnQpLCBMKFBsLCB0LCBrZCksIHQ7XG4gIH1cbiAgX2FwcGVuZCgpIHtcbiAgICB0aGlzLl9pc0FwcGVuZGVkIHx8ICh0aGlzLl9jb25maWcucm9vdEVsZW1lbnQuYXBwZW5kKHRoaXMuX2dldEVsZW1lbnQoKSksIGgub24odGhpcy5fZ2V0RWxlbWVudCgpLCBociwgKCkgPT4ge1xuICAgICAgZmUodGhpcy5fY29uZmlnLmNsaWNrQ2FsbGJhY2spO1xuICAgIH0pLCB0aGlzLl9pc0FwcGVuZGVkID0gITApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5faXNBcHBlbmRlZCAmJiAoaC5vZmYodGhpcy5fZWxlbWVudCwgaHIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZSgpLCB0aGlzLl9pc0FwcGVuZGVkID0gITEpO1xuICB9XG4gIF9lbXVsYXRlQW5pbWF0aW9uKHQpIHtcbiAgICBzbChcbiAgICAgIHQsXG4gICAgICB0aGlzLl9nZXRFbGVtZW50KCksXG4gICAgICB0aGlzLl9jb25maWcuaXNBbmltYXRlZFxuICAgICk7XG4gIH1cbn1cbmNsYXNzICRpIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX3RvZ2dsZXIgPSBpLCB0aGlzLl9ldmVudCA9IGUuZXZlbnQgfHwgXCJibHVyXCIsIHRoaXMuX2NvbmRpdGlvbiA9IGUuY29uZGl0aW9uIHx8ICgoKSA9PiAhMCksIHRoaXMuX3NlbGVjdG9yID0gZS5zZWxlY3RvciB8fCAnYnV0dG9uLCBhLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJywgdGhpcy5fb25seVZpc2libGUgPSBlLm9ubHlWaXNpYmxlIHx8ICExLCB0aGlzLl9mb2N1c2FibGVFbGVtZW50cyA9IFtdLCB0aGlzLl9maXJzdEVsZW1lbnQgPSBudWxsLCB0aGlzLl9sYXN0RWxlbWVudCA9IG51bGwsIHRoaXMuaGFuZGxlciA9IChuKSA9PiB7XG4gICAgICB0aGlzLl9jb25kaXRpb24obikgJiYgIW4uc2hpZnRLZXkgJiYgbi50YXJnZXQgPT09IHRoaXMuX2xhc3RFbGVtZW50ID8gKG4ucHJldmVudERlZmF1bHQoKSwgdGhpcy5fZmlyc3RFbGVtZW50LmZvY3VzKCkpIDogdGhpcy5fY29uZGl0aW9uKG4pICYmIG4uc2hpZnRLZXkgJiYgbi50YXJnZXQgPT09IHRoaXMuX2ZpcnN0RWxlbWVudCAmJiAobi5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9sYXN0RWxlbWVudC5mb2N1cygpKTtcbiAgICB9O1xuICB9XG4gIHRyYXAoKSB7XG4gICAgdGhpcy5fc2V0RWxlbWVudHMoKSwgdGhpcy5faW5pdCgpLCB0aGlzLl9zZXRGb2N1c1RyYXAoKTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9ldmVudCwgdGhpcy5oYW5kbGVyKTtcbiAgICB9KSwgdGhpcy5fdG9nZ2xlciAmJiB0aGlzLl90b2dnbGVyLmZvY3VzKCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX3NldEVsZW1lbnRzKCksIHRoaXMuX3NldEZvY3VzVHJhcCgpO1xuICB9XG4gIF9pbml0KCkge1xuICAgIGNvbnN0IHQgPSAoZSkgPT4ge1xuICAgICAgIXRoaXMuX2ZpcnN0RWxlbWVudCB8fCBlLmtleSAhPT0gXCJUYWJcIiB8fCB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5pbmNsdWRlcyhlLnRhcmdldCkgfHwgKGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5fZmlyc3RFbGVtZW50LmZvY3VzKCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0KSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdCk7XG4gIH1cbiAgX2ZpbHRlclZpc2libGUodCkge1xuICAgIHJldHVybiB0LmZpbHRlcigoZSkgPT4ge1xuICAgICAgaWYgKCFMdChlKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgaSA9IGQucGFyZW50cyhlLCBcIipcIik7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGkubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgY29uc3QgbyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGlbbl0pO1xuICAgICAgICBpZiAobyAmJiAoby5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBvLnZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9KTtcbiAgfVxuICBfc2V0RWxlbWVudHMoKSB7XG4gICAgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMgPSBkLmZvY3VzYWJsZUNoaWxkcmVuKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9vbmx5VmlzaWJsZSAmJiAodGhpcy5fZm9jdXNhYmxlRWxlbWVudHMgPSB0aGlzLl9maWx0ZXJWaXNpYmxlKHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzKSksIHRoaXMuX2ZpcnN0RWxlbWVudCA9IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzWzBdLCB0aGlzLl9sYXN0RWxlbWVudCA9IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzW3RoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIF9zZXRGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgZSA9PT0gdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMSB8fCBlID09PSAwID8gdC5hZGRFdmVudExpc3RlbmVyKHRoaXMuX2V2ZW50LCB0aGlzLmhhbmRsZXIpIDogdC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX2V2ZW50LCB0aGlzLmhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBkciA9IFwib2ZmY2FudmFzXCIsIE9kID0gXCJ0ZS5vZmZjYW52YXNcIiwgWmUgPSBgLiR7T2R9YCwgU2QgPSBcIi5kYXRhLWFwaVwiLCBJZCA9IGBsb2FkJHtaZX0ke1NkfWAsIERkID0gXCJFc2NhcGVcIiwgdXIgPSB7XG4gIGJhY2tkcm9wOiAhMCxcbiAga2V5Ym9hcmQ6ICEwLFxuICBzY3JvbGw6ICExXG59LCAkZCA9IHtcbiAgYmFja2Ryb3A6IFwiYm9vbGVhblwiLFxuICBrZXlib2FyZDogXCJib29sZWFuXCIsXG4gIHNjcm9sbDogXCJib29sZWFuXCJcbn0sIHByID0gXCJzaG93XCIsIExkID0gXCJbZGF0YS10ZS1vZmZjYW52YXMtaW5pdF1bZGF0YS10ZS1vZmZjYW52YXMtc2hvd11cIiwgTWQgPSBgc2hvdyR7WmV9YCwgTmQgPSBgc2hvd24ke1plfWAsIFJkID0gYGhpZGUke1plfWAsIFBkID0gYGhpZGRlbiR7WmV9YCwgQmQgPSBga2V5ZG93bi5kaXNtaXNzJHtaZX1gO1xuY2xhc3Mgbm8gZXh0ZW5kcyBFdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9pc1Nob3duID0gITEsIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCksIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKSwgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGRyO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gdXI7XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyh0KTtcbiAgfVxuICBzaG93KHQpIHtcbiAgICBpZiAodGhpcy5faXNTaG93biB8fCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgTWQsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2hvd24gPSAhMCwgdGhpcy5fZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCIsIHRoaXMuX2JhY2tkcm9wLnNob3coKSwgdGhpcy5fY29uZmlnLnNjcm9sbCB8fCBuZXcga2koKS5oaWRlKCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiLCAhMCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImRpYWxvZ1wiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtb2ZmY2FudmFzLSR7cHJ9YCwgXCJcIik7XG4gICAgY29uc3QgaSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgdGhpcy5fZm9jdXN0cmFwLnRyYXAoKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIE5kLCB7IHJlbGF0ZWRUYXJnZXQ6IHQgfSk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGksIHRoaXMuX2VsZW1lbnQsICEwKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5faXNTaG93biB8fCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgUmQpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZm9jdXN0cmFwLmRpc2FibGUoKSwgdGhpcy5fZWxlbWVudC5ibHVyKCksIHRoaXMuX2lzU2hvd24gPSAhMSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdGUtb2ZmY2FudmFzLSR7cHJ9YCksIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgICBjb25zdCBlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCAhMCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJyb2xlXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiLCB0aGlzLl9jb25maWcuc2Nyb2xsIHx8IG5ldyBraSgpLnJlc2V0KCksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBQZCk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMuX2VsZW1lbnQsICEwKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKSwgdGhpcy5fZm9jdXN0cmFwLmRpc2FibGUoKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoaC5vbihcbiAgICAgIHdpbmRvdyxcbiAgICAgIElkLFxuICAgICAgKCkgPT4gZC5maW5kKExkKS5mb3JFYWNoKFxuICAgICAgICAodCkgPT4gbm8uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0KS5zaG93KClcbiAgICAgIClcbiAgICApLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4udXIsXG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIEwoZHIsIHQsICRkKSwgdDtcbiAgfVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgU28oe1xuICAgICAgaXNWaXNpYmxlOiB0aGlzLl9jb25maWcuYmFja2Ryb3AsXG4gICAgICBpc0FuaW1hdGVkOiAhMCxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICBjbGlja0NhbGxiYWNrOiAoKSA9PiB0aGlzLmhpZGUoKVxuICAgIH0pO1xuICB9XG4gIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgIHJldHVybiBuZXcgJGkodGhpcy5fZWxlbWVudCwge1xuICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgY29uZGl0aW9uOiAodCkgPT4gdC5rZXkgPT09IFwiVGFiXCJcbiAgICB9KTtcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaC5vbih0aGlzLl9lbGVtZW50LCBCZCwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gRGQgJiYgdGhpcy5oaWRlKCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gbm8uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChlW3RdID09PSB2b2lkIDAgfHwgdC5zdGFydHNXaXRoKFwiX1wiKSB8fCB0ID09PSBcImNvbnN0cnVjdG9yXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGxuID0gXCJhbGVydFwiLCBIZCA9IFwidGUuYWxlcnRcIiwgQmwgPSBgLiR7SGR9YCwgV2QgPSBgY2xvc2Uke0JsfWAsIFZkID0gYGNsb3NlZCR7Qmx9YCwgc2kgPSBcImRhdGEtdGUtYWxlcnQtc2hvd1wiLCBGZCA9IHtcbiAgYW5pbWF0aW9uOiBcImJvb2xlYW5cIixcbiAgYXV0b2hpZGU6IFwiYm9vbGVhblwiLFxuICBkZWxheTogXCJudW1iZXJcIlxufSwgX3IgPSB7XG4gIGFuaW1hdGlvbjogITAsXG4gIGF1dG9oaWRlOiAhMCxcbiAgZGVsYXk6IDFlM1xufSwgWWQgPSB7XG4gIGZhZGVJbjogXCJhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF0gcC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIixcbiAgZmFkZU91dDogXCJhbmltYXRlLVtmYWRlLW91dF8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCJcbn0sIGpkID0ge1xuICBmYWRlSW46IFwic3RyaW5nXCIsXG4gIGZhZGVPdXQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBIbCBleHRlbmRzIEV0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIEZkO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gX3I7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBsbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgY2xvc2UoKSB7XG4gICAgaWYgKGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBXZCkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZSA9IDA7XG4gICAgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiAoZSA9IDMwMCwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoc2kpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soXG4gICAgICAgICgpID0+IHRoaXMuX2Rlc3Ryb3lFbGVtZW50KCksXG4gICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb25cbiAgICAgICk7XG4gICAgfSwgZSk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hdXRvaGlkZSAmJiB0aGlzLl9zZXR1cEF1dG9oaWRlKCksICF0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShzaSkgJiYgKGMucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJoaWRkZW5cIiksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJibG9ja1wiKSwgTHQodGhpcy5fZWxlbWVudCkpKSB7XG4gICAgICAgIGNvbnN0IHQgPSAoZSkgPT4ge1xuICAgICAgICAgIGMucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJoaWRkZW5cIiksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJibG9ja1wiKSwgaC5vZmYoZS50YXJnZXQsIFwiYW5pbWF0aW9uZW5kXCIsIHQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShzaSwgXCJcIiksIGgub24odGhpcy5fZWxlbWVudCwgXCJhbmltYXRpb25lbmRcIiwgdCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25maWcuYW5pbWF0aW9uICYmIChjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pKTtcbiAgICB9XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudCAmJiB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShzaSkpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHNpKTtcbiAgICAgIGNvbnN0IHQgPSAoZSkgPT4ge1xuICAgICAgICBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIFwiaGlkZGVuXCIpLCBjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIFwiYmxvY2tcIiksIHRoaXMuX3RpbWVvdXQgIT09IG51bGwgJiYgKGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgdGhpcy5fdGltZW91dCA9IG51bGwpLCBoLm9mZihlLnRhcmdldCwgXCJhbmltYXRpb25lbmRcIiwgdCk7XG4gICAgICB9O1xuICAgICAgaC5vbih0aGlzLl9lbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCB0KSwgYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbiksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KTtcbiAgICB9XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLl9yLFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCA/IHQgOiB7fVxuICAgIH0sIEwobG4sIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uWWQsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwobG4sIHQsIGpkKSwgdDtcbiAgfVxuICBfc2V0dXBBdXRvaGlkZSgpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpO1xuICB9XG4gIF9kZXN0cm95RWxlbWVudCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZSgpLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVmQpLCB0aGlzLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBIbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGVbdF0gPT09IHZvaWQgMCB8fCB0LnN0YXJ0c1dpdGgoXCJfXCIpIHx8IHQgPT09IFwiY29uc3RydWN0b3JcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgY24gPSBcImNhcm91c2VsXCIsIEtkID0gXCJ0ZS5jYXJvdXNlbFwiLCBwdCA9IGAuJHtLZH1gLCBXbCA9IFwiLmRhdGEtYXBpXCIsIHpkID0gXCJBcnJvd0xlZnRcIiwgVWQgPSBcIkFycm93UmlnaHRcIiwgWGQgPSA1MDAsIEdkID0gNDAsIGZyID0ge1xuICBpbnRlcnZhbDogNWUzLFxuICBrZXlib2FyZDogITAsXG4gIHJpZGU6ICExLFxuICBwYXVzZTogXCJob3ZlclwiLFxuICB3cmFwOiAhMCxcbiAgdG91Y2g6ICEwXG59LCBxZCA9IHtcbiAgaW50ZXJ2YWw6IFwiKG51bWJlcnxib29sZWFuKVwiLFxuICBrZXlib2FyZDogXCJib29sZWFuXCIsXG4gIHJpZGU6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBwYXVzZTogXCIoc3RyaW5nfGJvb2xlYW4pXCIsXG4gIHdyYXA6IFwiYm9vbGVhblwiLFxuICB0b3VjaDogXCJib29sZWFuXCJcbn0sIFpkID0ge1xuICBwb2ludGVyOiBcInRvdWNoLXBhbi15XCIsXG4gIGJsb2NrOiBcIiFibG9ja1wiLFxuICB2aXNpYmxlOiBcImRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOm9wYWNpdHktMTAwIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOnotWzFdXCIsXG4gIGludmlzaWJsZTogXCJkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTp6LTAgZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06b3BhY2l0eS0wIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOmR1cmF0aW9uLVs2MDBtc10gZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06ZGVsYXktNjAwXCIsXG4gIHNsaWRlUmlnaHQ6IFwidHJhbnNsYXRlLXgtZnVsbFwiLFxuICBzbGlkZUxlZnQ6IFwiLXRyYW5zbGF0ZS14LWZ1bGxcIlxufSwgUWQgPSB7XG4gIHBvaW50ZXI6IFwic3RyaW5nXCIsXG4gIGJsb2NrOiBcInN0cmluZ1wiLFxuICB2aXNpYmxlOiBcInN0cmluZ1wiLFxuICBpbnZpc2libGU6IFwic3RyaW5nXCIsXG4gIHNsaWRlUmlnaHQ6IFwic3RyaW5nXCIsXG4gIHNsaWRlTGVmdDogXCJzdHJpbmdcIlxufSwgYWUgPSBcIm5leHRcIiwgbGUgPSBcInByZXZcIiwgcGUgPSBcImxlZnRcIiwgdWkgPSBcInJpZ2h0XCIsIEpkID0ge1xuICBbemRdOiB1aSxcbiAgW1VkXTogcGVcbn0sIHR1ID0gYHNsaWRlJHtwdH1gLCBobiA9IGBzbGlkJHtwdH1gLCBldSA9IGBrZXlkb3duJHtwdH1gLCBpdSA9IGBtb3VzZWVudGVyJHtwdH1gLCBzdSA9IGBtb3VzZWxlYXZlJHtwdH1gLCBudSA9IGB0b3VjaHN0YXJ0JHtwdH1gLCBvdSA9IGB0b3VjaG1vdmUke3B0fWAsIHJ1ID0gYHRvdWNoZW5kJHtwdH1gLCBhdSA9IGBwb2ludGVyZG93biR7cHR9YCwgbHUgPSBgcG9pbnRlcnVwJHtwdH1gLCBjdSA9IGBkcmFnc3RhcnQke3B0fWAsIGh1ID0gYGxvYWQke3B0fSR7V2x9YCwgZHUgPSBgY2xpY2ske3B0fSR7V2x9YCwgbXIgPSBcImRhdGEtdGUtY2Fyb3VzZWwtaW5pdFwiLCBjZSA9IFwiZGF0YS10ZS1jYXJvdXNlbC1hY3RpdmVcIiwgdXUgPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1lbmRcIiwgZG4gPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1zdGFydFwiLCBwdSA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pdGVtLW5leHRcIiwgX3UgPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1wcmV2XCIsIGZ1ID0gXCJkYXRhLXRlLWNhcm91c2VsLXBvaW50ZXItZXZlbnRcIiwgbXUgPSBcIltkYXRhLXRlLWNhcm91c2VsLWluaXRdXCIsIFZsID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1hY3RpdmVdXCIsIElvID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1pdGVtXVwiLCB5ZSA9IGAke1ZsfSR7SW99YCwgZ3UgPSBgJHtJb30gaW1nYCwgYnUgPSBcIltkYXRhLXRlLWNhcm91c2VsLWl0ZW0tbmV4dF0sIFtkYXRhLXRlLWNhcm91c2VsLWl0ZW0tcHJldl1cIiwgdnUgPSBcIltkYXRhLXRlLWNhcm91c2VsLWluZGljYXRvcnNdXCIsIFR1ID0gXCJbZGF0YS10ZS10YXJnZXRdXCIsIEV1ID0gXCJbZGF0YS10ZS1zbGlkZV0sIFtkYXRhLXRlLXNsaWRlLXRvXVwiLCBDdSA9IFwidG91Y2hcIiwgQXUgPSBcInBlblwiO1xuY2xhc3MgVXQgZXh0ZW5kcyBFdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5faXRlbXMgPSBudWxsLCB0aGlzLl9pbnRlcnZhbCA9IG51bGwsIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsLCB0aGlzLl9pc1BhdXNlZCA9ICExLCB0aGlzLl9pc1NsaWRpbmcgPSAhMSwgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsLCB0aGlzLnRvdWNoU3RhcnRYID0gMCwgdGhpcy50b3VjaERlbHRhWCA9IDAsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gZC5maW5kT25lKFxuICAgICAgdnUsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fdG91Y2hTdXBwb3J0ZWQgPSBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwLCB0aGlzLl9wb2ludGVyRXZlbnQgPSAhIXdpbmRvdy5Qb2ludGVyRXZlbnQsIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRDbGFzcygpLCB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKSwgdGhpcy5fY29uZmlnLnJpZGUgPT09IFwiY2Fyb3VzZWxcIiAmJiB0aGlzLmN5Y2xlKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIGZyO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gY247XG4gIH1cbiAgLy8gUHVibGljXG4gIG5leHQoKSB7XG4gICAgdGhpcy5fc2xpZGUoYWUpO1xuICB9XG4gIG5leHRXaGVuVmlzaWJsZSgpIHtcbiAgICAhZG9jdW1lbnQuaGlkZGVuICYmIEx0KHRoaXMuX2VsZW1lbnQpICYmIHRoaXMubmV4dCgpO1xuICB9XG4gIHByZXYoKSB7XG4gICAgdGhpcy5fc2xpZGUobGUpO1xuICB9XG4gIHBhdXNlKHQpIHtcbiAgICB0IHx8ICh0aGlzLl9pc1BhdXNlZCA9ICEwKSwgZC5maW5kT25lKGJ1LCB0aGlzLl9lbGVtZW50KSAmJiAoSmEodGhpcy5fZWxlbWVudCksIHRoaXMuY3ljbGUoITApKSwgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgfVxuICBjeWNsZSh0KSB7XG4gICAgdCB8fCAodGhpcy5faXNQYXVzZWQgPSAhMSksIHRoaXMuX2ludGVydmFsICYmIChjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgdGhpcy5faW50ZXJ2YWwgPSBudWxsKSwgdGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCAmJiAhdGhpcy5faXNQYXVzZWQgJiYgKHRoaXMuX3VwZGF0ZUludGVydmFsKCksIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoXG4gICAgICAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID8gdGhpcy5uZXh0V2hlblZpc2libGUgOiB0aGlzLm5leHQpLmJpbmQoXG4gICAgICAgIHRoaXNcbiAgICAgICksXG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICApKTtcbiAgfVxuICB0byh0KSB7XG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IGQuZmluZE9uZShcbiAgICAgIHllLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtcbiAgICBpZiAodCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgfHwgdCA8IDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgaC5vbmUodGhpcy5fZWxlbWVudCwgaG4sICgpID0+IHRoaXMudG8odCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZSA9PT0gdCkge1xuICAgICAgdGhpcy5wYXVzZSgpLCB0aGlzLmN5Y2xlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0ID4gZSA/IGFlIDogbGU7XG4gICAgdGhpcy5fc2xpZGUoaSwgdGhpcy5faXRlbXNbdF0pO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoaC5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgZHUsXG4gICAgICBFdSxcbiAgICAgIFV0LmRhdGFBcGlDbGlja0hhbmRsZXJcbiAgICApLCBoLm9uKHdpbmRvdywgaHUsICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBkLmZpbmQobXUpO1xuICAgICAgZm9yIChsZXQgZSA9IDAsIGkgPSB0Lmxlbmd0aDsgZSA8IGk7IGUrKylcbiAgICAgICAgVXQuY2Fyb3VzZWxJbnRlcmZhY2UoXG4gICAgICAgICAgdFtlXSxcbiAgICAgICAgICBVdC5nZXRJbnN0YW5jZSh0W2VdKVxuICAgICAgICApO1xuICAgIH0pLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZnIsXG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIEwoY24sIHQsIHFkKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlpkLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKGNuLCB0LCBRZCksIHQ7XG4gIH1cbiAgX2VuYWJsZUN5Y2xlKCkge1xuICAgIGlmICh0aGlzLl9jb25maWcucmlkZSkge1xuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICBoLm9uZSh0aGlzLl9lbGVtZW50LCBobiwgKCkgPT4gdGhpcy5jeWNsZSgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jeWNsZSgpO1xuICAgIH1cbiAgfVxuICBfYXBwbHlJbml0aWFsQ2xhc3NlcygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgeWUsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICB0LmNsYXNzTGlzdC5hZGQoXG4gICAgICB0aGlzLl9jbGFzc2VzLmJsb2NrLFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKVxuICAgICksIHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQodCk7XG4gIH1cbiAgX2hhbmRsZVN3aXBlKCkge1xuICAgIGNvbnN0IHQgPSBNYXRoLmFicyh0aGlzLnRvdWNoRGVsdGFYKTtcbiAgICBpZiAodCA8PSBHZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdCAvIHRoaXMudG91Y2hEZWx0YVg7XG4gICAgdGhpcy50b3VjaERlbHRhWCA9IDAsIGUgJiYgdGhpcy5fc2xpZGUoZSA+IDAgPyB1aSA6IHBlKTtcbiAgfVxuICBfc2V0QWN0aXZlRWxlbWVudENsYXNzKCkge1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBkLmZpbmRPbmUoXG4gICAgICB5ZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBjLmFkZENsYXNzKHRoaXMuX2FjdGl2ZUVsZW1lbnQsIFwiaGlkZGVuXCIpO1xuICB9XG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgaC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBldSxcbiAgICAgICh0KSA9PiB0aGlzLl9rZXlkb3duKHQpXG4gICAgKSwgdGhpcy5fY29uZmlnLnBhdXNlID09PSBcImhvdmVyXCIgJiYgKGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgaXUsXG4gICAgICAodCkgPT4gdGhpcy5wYXVzZSh0KVxuICAgICksIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgc3UsXG4gICAgICAodCkgPT4gdGhpcy5fZW5hYmxlQ3ljbGUodClcbiAgICApKSwgdGhpcy5fY29uZmlnLnRvdWNoICYmIHRoaXMuX3RvdWNoU3VwcG9ydGVkICYmIHRoaXMuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3NlcygpO1xuICB9XG4gIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHQgPSAobykgPT4gdGhpcy5fcG9pbnRlckV2ZW50ICYmIChvLnBvaW50ZXJUeXBlID09PSBBdSB8fCBvLnBvaW50ZXJUeXBlID09PSBDdSksIGUgPSAobykgPT4ge1xuICAgICAgdChvKSA/IHRoaXMudG91Y2hTdGFydFggPSBvLmNsaWVudFggOiB0aGlzLl9wb2ludGVyRXZlbnQgfHwgKHRoaXMudG91Y2hTdGFydFggPSBvLnRvdWNoZXNbMF0uY2xpZW50WCk7XG4gICAgfSwgaSA9IChvKSA9PiB7XG4gICAgICB0aGlzLnRvdWNoRGVsdGFYID0gby50b3VjaGVzICYmIG8udG91Y2hlcy5sZW5ndGggPiAxID8gMCA6IG8udG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WDtcbiAgICB9LCBuID0gKG8pID0+IHtcbiAgICAgIHQobykgJiYgKHRoaXMudG91Y2hEZWx0YVggPSBvLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYKSwgdGhpcy5faGFuZGxlU3dpcGUoKSwgdGhpcy5fY29uZmlnLnBhdXNlID09PSBcImhvdmVyXCIgJiYgKHRoaXMucGF1c2UoKSwgdGhpcy50b3VjaFRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMudG91Y2hUaW1lb3V0KSwgdGhpcy50b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAocikgPT4gdGhpcy5fZW5hYmxlQ3ljbGUociksXG4gICAgICAgIFhkICsgdGhpcy5fY29uZmlnLmludGVydmFsXG4gICAgICApKTtcbiAgICB9O1xuICAgIGQuZmluZChndSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChcbiAgICAgIChvKSA9PiB7XG4gICAgICAgIGgub24oXG4gICAgICAgICAgbyxcbiAgICAgICAgICBjdSxcbiAgICAgICAgICAocikgPT4gci5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSwgdGhpcy5fcG9pbnRlckV2ZW50ID8gKGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgYXUsXG4gICAgICAobykgPT4gZShvKVxuICAgICksIGgub24odGhpcy5fZWxlbWVudCwgbHUsIChvKSA9PiBuKG8pKSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMucG9pbnRlciksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGAke2Z1fWAsIFwiXCIpKSA6IChoLm9uKHRoaXMuX2VsZW1lbnQsIG51LCAobykgPT4gZShvKSksIGgub24odGhpcy5fZWxlbWVudCwgb3UsIChvKSA9PiBpKG8pKSwgaC5vbih0aGlzLl9lbGVtZW50LCBydSwgKG8pID0+IG4obykpKTtcbiAgfVxuICBfa2V5ZG93bih0KSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IEpkW3Qua2V5XTtcbiAgICBlICYmICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3NsaWRlKGUpKTtcbiAgfVxuICBfZ2V0SXRlbUluZGV4KHQpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMgPSB0ICYmIHQucGFyZW50Tm9kZSA/IGQuZmluZChJbywgdC5wYXJlbnROb2RlKSA6IFtdLCB0aGlzLl9pdGVtcy5pbmRleE9mKHQpO1xuICB9XG4gIF9nZXRJdGVtQnlPcmRlcih0LCBlKSB7XG4gICAgY29uc3QgaSA9IHQgPT09IGFlO1xuICAgIHJldHVybiBubChcbiAgICAgIHRoaXMuX2l0ZW1zLFxuICAgICAgZSxcbiAgICAgIGksXG4gICAgICB0aGlzLl9jb25maWcud3JhcFxuICAgICk7XG4gIH1cbiAgX3RyaWdnZXJTbGlkZUV2ZW50KHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2V0SXRlbUluZGV4KHQpLCBuID0gdGhpcy5fZ2V0SXRlbUluZGV4KFxuICAgICAgZC5maW5kT25lKHllLCB0aGlzLl9lbGVtZW50KVxuICAgICk7XG4gICAgcmV0dXJuIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0dSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdCxcbiAgICAgIGRpcmVjdGlvbjogZSxcbiAgICAgIGZyb206IG4sXG4gICAgICB0bzogaVxuICAgIH0pO1xuICB9XG4gIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KHQpIHtcbiAgICBpZiAodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXG4gICAgICAgIFZsLFxuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudFxuICAgICAgKTtcbiAgICAgIGUucmVtb3ZlQXR0cmlidXRlKGNlKSwgZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiksIGUuY2xhc3NMaXN0LnJlbW92ZShcIiFvcGFjaXR5LTEwMFwiKTtcbiAgICAgIGNvbnN0IGkgPSBkLmZpbmQoXG4gICAgICAgIFR1LFxuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudFxuICAgICAgKTtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaS5sZW5ndGg7IG4rKylcbiAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChcbiAgICAgICAgICBpW25dLmdldEF0dHJpYnV0ZShcImRhdGEtdGUtc2xpZGUtdG9cIiksXG4gICAgICAgICAgMTBcbiAgICAgICAgKSA9PT0gdGhpcy5fZ2V0SXRlbUluZGV4KHQpKSB7XG4gICAgICAgICAgaVtuXS5zZXRBdHRyaWJ1dGUoYCR7Y2V9YCwgXCJcIiksIGlbbl0uc2V0QXR0cmlidXRlKFwiYXJpYS1jdXJyZW50XCIsIFwidHJ1ZVwiKSwgaVtuXS5jbGFzc0xpc3QuYWRkKFwiIW9wYWNpdHktMTAwXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIF91cGRhdGVJbnRlcnZhbCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCBkLmZpbmRPbmUoeWUsIHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gTnVtYmVyLnBhcnNlSW50KFxuICAgICAgdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWludGVydmFsXCIpLFxuICAgICAgMTBcbiAgICApO1xuICAgIGUgPyAodGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlKSA6IHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsO1xuICB9XG4gIF9zbGlkZSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2RpcmVjdGlvblRvT3JkZXIodCksIG4gPSBkLmZpbmRPbmUoXG4gICAgICB5ZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBvID0gdGhpcy5fZ2V0SXRlbUluZGV4KG4pLCByID0gZSB8fCB0aGlzLl9nZXRJdGVtQnlPcmRlcihpLCBuKSwgYSA9IHRoaXMuX2dldEl0ZW1JbmRleChyKSwgbCA9ICEhdGhpcy5faW50ZXJ2YWwsIHAgPSBpID09PSBhZSwgdSA9IHAgPyBkbiA6IHV1LCBmID0gcCA/IHB1IDogX3UsIF8gPSB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKGkpLCBtID0gdSA9PT0gZG4gPyB0aGlzLl9jbGFzc2VzLnNsaWRlTGVmdCA6IHRoaXMuX2NsYXNzZXMuc2xpZGVSaWdodCwgZyA9IHUgIT09IGRuID8gdGhpcy5fY2xhc3Nlcy5zbGlkZUxlZnQgOiB0aGlzLl9jbGFzc2VzLnNsaWRlUmlnaHQ7XG4gICAgaWYgKHIgJiYgci5oYXNBdHRyaWJ1dGUoY2UpKSB7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSAhMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZyB8fCB0aGlzLl90cmlnZ2VyU2xpZGVFdmVudChyLCBfKS5kZWZhdWx0UHJldmVudGVkIHx8ICFuIHx8ICFyKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2xpZGluZyA9ICEwLCBsICYmIHRoaXMucGF1c2UoKSwgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChyKSwgdGhpcy5fYWN0aXZlRWxlbWVudCA9IHI7XG4gICAgY29uc3QgYiA9ICgpID0+IHtcbiAgICAgIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBobiwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiByLFxuICAgICAgICBkaXJlY3Rpb246IF8sXG4gICAgICAgIGZyb206IG8sXG4gICAgICAgIHRvOiBhXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICh0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShtcikpIHtcbiAgICAgIHIuc2V0QXR0cmlidXRlKGAke2Z9YCwgXCJcIiksIHIuY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLmJsb2NrLCBnKSwgR2UociksIG4uc2V0QXR0cmlidXRlKGAke3V9YCwgXCJcIiksIG4uY2xhc3NMaXN0LmFkZChcbiAgICAgICAgbSxcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnZpc2libGUuc3BsaXQoXCIgXCIpXG4gICAgICApLCBuLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKSksIHIuc2V0QXR0cmlidXRlKGAke3V9YCwgXCJcIiksIHIuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLnZpc2libGUuc3BsaXQoXCIgXCIpKSwgci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICB0aGlzLl9jbGFzc2VzLnNsaWRlUmlnaHQsXG4gICAgICAgIHRoaXMuX2NsYXNzZXMuc2xpZGVMZWZ0XG4gICAgICApO1xuICAgICAgY29uc3QgQyA9ICgpID0+IHtcbiAgICAgICAgci5yZW1vdmVBdHRyaWJ1dGUodSksIHIucmVtb3ZlQXR0cmlidXRlKGYpLCByLnNldEF0dHJpYnV0ZShgJHtjZX1gLCBcIlwiKSwgbi5yZW1vdmVBdHRyaWJ1dGUoY2UpLCBuLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgbSxcbiAgICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmludmlzaWJsZS5zcGxpdChcIiBcIiksXG4gICAgICAgICAgdGhpcy5fY2xhc3Nlcy5ibG9ja1xuICAgICAgICApLCBuLnJlbW92ZUF0dHJpYnV0ZShmKSwgbi5yZW1vdmVBdHRyaWJ1dGUodSksIHRoaXMuX2lzU2xpZGluZyA9ICExLCBzZXRUaW1lb3V0KGIsIDApO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soQywgbiwgITApO1xuICAgIH0gZWxzZVxuICAgICAgbi5yZW1vdmVBdHRyaWJ1dGUoY2UpLCBuLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3Nlcy5ibG9jayksIHIuc2V0QXR0cmlidXRlKGAke2NlfWAsIFwiXCIpLCByLmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5ibG9jayksIHRoaXMuX2lzU2xpZGluZyA9ICExLCBiKCk7XG4gICAgbCAmJiB0aGlzLmN5Y2xlKCk7XG4gIH1cbiAgX2RpcmVjdGlvblRvT3JkZXIodCkge1xuICAgIHJldHVybiBbdWksIHBlXS5pbmNsdWRlcyh0KSA/IEYoKSA/IHQgPT09IHBlID8gbGUgOiBhZSA6IHQgPT09IHBlID8gYWUgOiBsZSA6IHQ7XG4gIH1cbiAgX29yZGVyVG9EaXJlY3Rpb24odCkge1xuICAgIHJldHVybiBbYWUsIGxlXS5pbmNsdWRlcyh0KSA/IEYoKSA/IHQgPT09IGxlID8gcGUgOiB1aSA6IHQgPT09IGxlID8gdWkgOiBwZSA6IHQ7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBjYXJvdXNlbEludGVyZmFjZSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IFV0LmdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSk7XG4gICAgbGV0IHsgX2NvbmZpZzogbiB9ID0gaTtcbiAgICB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIChuID0ge1xuICAgICAgLi4ubixcbiAgICAgIC4uLmVcbiAgICB9KTtcbiAgICBjb25zdCBvID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiBlLnNsaWRlO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICBpLnRvKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHR5cGVvZiBpW29dID4gXCJ1XCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7b31cImApO1xuICAgICAgaVtvXSgpO1xuICAgIH0gZWxzZVxuICAgICAgbi5pbnRlcnZhbCAmJiBuLnJpZGUgPT09ICEwICYmIGkucGF1c2UoKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgVXQuY2Fyb3VzZWxJbnRlcmZhY2UodGhpcywgdCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGRhdGFBcGlDbGlja0hhbmRsZXIodCkge1xuICAgIGNvbnN0IGUgPSBRdCh0aGlzKTtcbiAgICBpZiAoIWUgfHwgIWUuaGFzQXR0cmlidXRlKG1yKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0ge1xuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyhlKSxcbiAgICAgIC4uLmMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcylcbiAgICB9LCBuID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNsaWRlLXRvXCIpO1xuICAgIG4gJiYgKGkuaW50ZXJ2YWwgPSAhMSksIFV0LmNhcm91c2VsSW50ZXJmYWNlKGUsIGkpLCBuICYmIFV0LmdldEluc3RhbmNlKGUpLnRvKG4pLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cbmNvbnN0IHVuID0gXCJtb2RhbFwiLCB5dSA9IFwidGUubW9kYWxcIiwgQ3QgPSBgLiR7eXV9YCwgZ3IgPSBcIkVzY2FwZVwiLCBiciA9IHtcbiAgYmFja2Ryb3A6ICEwLFxuICBrZXlib2FyZDogITAsXG4gIGZvY3VzOiAhMFxufSwgd3UgPSB7XG4gIGJhY2tkcm9wOiBcIihib29sZWFufHN0cmluZylcIixcbiAga2V5Ym9hcmQ6IFwiYm9vbGVhblwiLFxuICBmb2N1czogXCJib29sZWFuXCJcbn0sIHh1ID0ge1xuICBzaG93OiBcInRyYW5zZm9ybS1ub25lXCIsXG4gIHN0YXRpYzogXCJzY2FsZS1bMS4wMl1cIixcbiAgc3RhdGljUHJvcGVydGllczogXCJ0cmFuc2l0aW9uLXNjYWxlIGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dFwiXG59LCBrdSA9IHtcbiAgc2hvdzogXCJzdHJpbmdcIixcbiAgc3RhdGljOiBcInN0cmluZ1wiLFxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInN0cmluZ1wiXG59LCBPdSA9IGBoaWRlJHtDdH1gLCBTdSA9IGBoaWRlUHJldmVudGVkJHtDdH1gLCBJdSA9IGBoaWRkZW4ke0N0fWAsIER1ID0gYHNob3cke0N0fWAsICR1ID0gYHNob3duJHtDdH1gLCB2ciA9IGByZXNpemUke0N0fWAsIFRyID0gYGNsaWNrLmRpc21pc3Mke0N0fWAsIEVyID0gYGtleWRvd24uZGlzbWlzcyR7Q3R9YCwgTHUgPSBgbW91c2V1cC5kaXNtaXNzJHtDdH1gLCBDciA9IGBtb3VzZWRvd24uZGlzbWlzcyR7Q3R9YCwgQXIgPSBcImRhdGEtdGUtbW9kYWwtb3BlblwiLCB5ciA9IFwiZGF0YS10ZS1vcGVuXCIsIG5pID0gXCJbZGF0YS10ZS1tb2RhbC1kaWFsb2ctcmVmXVwiLCBNdSA9IFwiW2RhdGEtdGUtbW9kYWwtYm9keS1yZWZdXCI7XG5jbGFzcyBGbCBleHRlbmRzIEV0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9kaWFsb2cgPSBkLmZpbmRPbmUobmksIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCksIHRoaXMuX2lzU2hvd24gPSAhMSwgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9ICExLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IGtpKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIGJyO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gdW47XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyh0KTtcbiAgfVxuICBzaG93KHQpIHtcbiAgICB0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRHUsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkIHx8ICh0aGlzLl9pc1Nob3duID0gITAsIHRoaXMuX2lzQW5pbWF0ZWQoKSAmJiAodGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITApLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpLCBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShBciwgXCJ0cnVlXCIpLCB0aGlzLl9hZGp1c3REaWFsb2coKSwgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKSwgdGhpcy5fc2V0UmVzaXplRXZlbnQoKSwgaC5vbih0aGlzLl9kaWFsb2csIENyLCAoKSA9PiB7XG4gICAgICBoLm9uZSh0aGlzLl9lbGVtZW50LCBMdSwgKGkpID0+IHtcbiAgICAgICAgaS50YXJnZXQgPT09IHRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMCk7XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy5fc2hvd0VsZW1lbnQodCksIHRoaXMuX3Nob3dCYWNrZHJvcCgpKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIE91KS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2hvd24gPSAhMTtcbiAgICBjb25zdCBlID0gdGhpcy5faXNBbmltYXRlZCgpO1xuICAgIGUgJiYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICEwKSwgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKSwgdGhpcy5fc2V0UmVzaXplRXZlbnQoKSwgdGhpcy5fZm9jdXN0cmFwLmRpc2FibGUoKSwgZC5maW5kT25lKG5pLCB0aGlzLl9lbGVtZW50KS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc2hvdyksIGgub2ZmKHRoaXMuX2VsZW1lbnQsIFRyKSwgaC5vZmYodGhpcy5fZGlhbG9nLCBDciksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIGUpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh5cik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBbd2luZG93LCB0aGlzLl9kaWFsb2ddLmZvckVhY2goXG4gICAgICAodCkgPT4gaC5vZmYodCwgQ3QpXG4gICAgKSwgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgaGFuZGxlVXBkYXRlKCkge1xuICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICByZXR1cm4gbmV3IFNvKHtcbiAgICAgIGlzVmlzaWJsZTogISF0aGlzLl9jb25maWcuYmFja2Ryb3AsXG4gICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWVcbiAgICAgIGlzQW5pbWF0ZWQ6IHRoaXMuX2lzQW5pbWF0ZWQoKVxuICAgIH0pO1xuICB9XG4gIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgIHJldHVybiBuZXcgJGkodGhpcy5fZWxlbWVudCwge1xuICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgY29uZGl0aW9uOiAodCkgPT4gdC5rZXkgPT09IFwiVGFiXCJcbiAgICB9KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmJyLFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCBMKHVuLCB0LCB3dSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi54dSxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTCh1biwgdCwga3UpLCB0O1xuICB9XG4gIF9zaG93RWxlbWVudCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2lzQW5pbWF0ZWQoKSwgaSA9IGQuZmluZE9uZShNdSwgdGhpcy5fZGlhbG9nKTtcbiAgICAoIXRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSB8fCB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSAmJiBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLl9lbGVtZW50KSwgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiLCAhMCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImRpYWxvZ1wiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYCR7eXJ9YCwgXCJ0cnVlXCIpLCB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgY29uc3QgbiA9IGQuZmluZE9uZShuaSwgdGhpcy5fZWxlbWVudCk7XG4gICAgbi5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMuc2hvdyksIG4uY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMFwiKSwgbi5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0xMDBcIiksIGkgJiYgKGkuc2Nyb2xsVG9wID0gMCksIGUgJiYgR2UodGhpcy5fZWxlbWVudCk7XG4gICAgY29uc3QgbyA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5mb2N1cyAmJiB0aGlzLl9mb2N1c3RyYXAudHJhcCgpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsICR1LCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhvLCB0aGlzLl9kaWFsb2csIGUpO1xuICB9XG4gIF9zZXRFc2NhcGVFdmVudCgpIHtcbiAgICB0aGlzLl9pc1Nob3duID8gaC5vbihkb2N1bWVudCwgRXIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdC5rZXkgPT09IGdyID8gKHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5oaWRlKCkpIDogIXRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gZ3IgJiYgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xuICAgIH0pIDogaC5vZmYodGhpcy5fZWxlbWVudCwgRXIpO1xuICB9XG4gIF9zZXRSZXNpemVFdmVudCgpIHtcbiAgICB0aGlzLl9pc1Nob3duID8gaC5vbih3aW5kb3csIHZyLCAoKSA9PiB0aGlzLl9hZGp1c3REaWFsb2coKSkgOiBoLm9mZih3aW5kb3csIHZyKTtcbiAgfVxuICBfaGlkZU1vZGFsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUobmksIHRoaXMuX2VsZW1lbnQpO1xuICAgIHQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc2VzLnNob3cpLCB0LmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTEwMFwiKSwgdC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0wXCIpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH0sIDMwMCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHRoaXMuX2JhY2tkcm9wLmhpZGUoKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUoQXIpLCB0aGlzLl9yZXNldEFkanVzdG1lbnRzKCksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgSXUpO1xuICAgIH0pO1xuICB9XG4gIF9zaG93QmFja2Ryb3AodCkge1xuICAgIGgub24odGhpcy5fZWxlbWVudCwgVHIsIChlKSA9PiB7XG4gICAgICBpZiAodGhpcy5faWdub3JlQmFja2Ryb3BDbGljaykge1xuICAgICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gITE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgJiYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gITAgPyB0aGlzLmhpZGUoKSA6IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gXCJzdGF0aWNcIiAmJiB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkpO1xuICAgIH0pLCB0aGlzLl9iYWNrZHJvcC5zaG93KHQpO1xuICB9XG4gIF9pc0FuaW1hdGVkKCkge1xuICAgIHJldHVybiAhIWQuZmluZE9uZShuaSwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSB7XG4gICAgaWYgKGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBTdSkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGNsYXNzTGlzdDogZSwgc2Nyb2xsSGVpZ2h0OiBpLCBzdHlsZTogbiB9ID0gdGhpcy5fZWxlbWVudCwgbyA9IGkgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICFvICYmIG4ub3ZlcmZsb3dZID09PSBcImhpZGRlblwiIHx8IGUuY29udGFpbnModGhpcy5fY2xhc3Nlcy5zdGF0aWMpIHx8IChvIHx8IChuLm92ZXJmbG93WSA9IFwiaGlkZGVuXCIpLCBlLmFkZCguLi50aGlzLl9jbGFzc2VzLnN0YXRpYy5zcGxpdChcIiBcIikpLCBlLmFkZCguLi50aGlzLl9jbGFzc2VzLnN0YXRpY1Byb3BlcnRpZXMuc3BsaXQoXCIgXCIpKSwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICBlLnJlbW92ZSh0aGlzLl9jbGFzc2VzLnN0YXRpYyksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlLnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLnN0YXRpY1Byb3BlcnRpZXMuc3BsaXQoXCIgXCIpKTtcbiAgICAgIH0sIDMwMCksIG8gfHwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIG4ub3ZlcmZsb3dZID0gXCJcIjtcbiAgICAgIH0sIHRoaXMuX2RpYWxvZyk7XG4gICAgfSwgdGhpcy5fZGlhbG9nKSwgdGhpcy5fZWxlbWVudC5mb2N1cygpKTtcbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgX2FkanVzdERpYWxvZygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCBlID0gdGhpcy5fc2Nyb2xsQmFyLmdldFdpZHRoKCksIGkgPSBlID4gMDtcbiAgICAoIWkgJiYgdCAmJiAhRigpIHx8IGkgJiYgIXQgJiYgRigpKSAmJiAodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IGAke2V9cHhgKSwgKGkgJiYgIXQgJiYgIUYoKSB8fCAhaSAmJiB0ICYmIEYoKSkgJiYgKHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7ZX1weGApO1xuICB9XG4gIF9yZXNldEFkanVzdG1lbnRzKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBcIlwiLCB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiXCI7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpID0gRmwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBOdSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJiYWNrZ3JvdW5kXCIsXG4gIFwiY2l0ZVwiLFxuICBcImhyZWZcIixcbiAgXCJpdGVtdHlwZVwiLFxuICBcImxvbmdkZXNjXCIsXG4gIFwicG9zdGVyXCIsXG4gIFwic3JjXCIsXG4gIFwieGxpbms6aHJlZlwiXG5dKSwgUnUgPSAvXmFyaWEtW1xcdy1dKiQvaSwgUHUgPSAvXig/Oig/Omh0dHBzP3xtYWlsdG98ZnRwfHRlbHxmaWxlfHNtcyk6fFteIyYvOj9dKig/OlsjLz9dfCQpKS9pLCBCdSA9IC9eZGF0YTooPzppbWFnZVxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicCl8dmlkZW9cXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFtcXGQrL2Etel0rPSokL2ksIEh1ID0gKHMsIHQpID0+IHtcbiAgY29uc3QgZSA9IHMubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHQuaW5jbHVkZXMoZSkpXG4gICAgcmV0dXJuIE51LmhhcyhlKSA/ICEhKFB1LnRlc3Qocy5ub2RlVmFsdWUpIHx8IEJ1LnRlc3Qocy5ub2RlVmFsdWUpKSA6ICEwO1xuICBjb25zdCBpID0gdC5maWx0ZXIoXG4gICAgKG4pID0+IG4gaW5zdGFuY2VvZiBSZWdFeHBcbiAgKTtcbiAgZm9yIChsZXQgbiA9IDAsIG8gPSBpLmxlbmd0aDsgbiA8IG87IG4rKylcbiAgICBpZiAoaVtuXS50ZXN0KGUpKVxuICAgICAgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59LCBXdSA9IHtcbiAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cbiAgXCIqXCI6IFtcImNsYXNzXCIsIFwiZGlyXCIsIFwiaWRcIiwgXCJsYW5nXCIsIFwicm9sZVwiLCBSdV0sXG4gIGE6IFtcInRhcmdldFwiLCBcImhyZWZcIiwgXCJ0aXRsZVwiLCBcInJlbFwiXSxcbiAgYXJlYTogW10sXG4gIGI6IFtdLFxuICBicjogW10sXG4gIGNvbDogW10sXG4gIGNvZGU6IFtdLFxuICBkaXY6IFtdLFxuICBlbTogW10sXG4gIGhyOiBbXSxcbiAgaDE6IFtdLFxuICBoMjogW10sXG4gIGgzOiBbXSxcbiAgaDQ6IFtdLFxuICBoNTogW10sXG4gIGg2OiBbXSxcbiAgaTogW10sXG4gIGltZzogW1wic3JjXCIsIFwic3Jjc2V0XCIsIFwiYWx0XCIsIFwidGl0bGVcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSxcbiAgbGk6IFtdLFxuICBvbDogW10sXG4gIHA6IFtdLFxuICBwcmU6IFtdLFxuICBzOiBbXSxcbiAgc21hbGw6IFtdLFxuICBzcGFuOiBbXSxcbiAgc3ViOiBbXSxcbiAgc3VwOiBbXSxcbiAgc3Ryb25nOiBbXSxcbiAgdTogW10sXG4gIHVsOiBbXVxufTtcbmZ1bmN0aW9uIHdyKHMsIHQsIGUpIHtcbiAgaWYgKCFzLmxlbmd0aClcbiAgICByZXR1cm4gcztcbiAgaWYgKGUgJiYgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBlKHMpO1xuICBjb25zdCBuID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcocywgXCJ0ZXh0L2h0bWxcIiksIG8gPSBbXS5jb25jYXQoLi4ubi5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKTtcbiAgZm9yIChsZXQgciA9IDAsIGEgPSBvLmxlbmd0aDsgciA8IGE7IHIrKykge1xuICAgIGNvbnN0IGwgPSBvW3JdLCBwID0gbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghT2JqZWN0LmtleXModCkuaW5jbHVkZXMocCkpIHtcbiAgICAgIGwucmVtb3ZlKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdSA9IFtdLmNvbmNhdCguLi5sLmF0dHJpYnV0ZXMpLCBmID0gW10uY29uY2F0KFxuICAgICAgdFtcIipcIl0gfHwgW10sXG4gICAgICB0W3BdIHx8IFtdXG4gICAgKTtcbiAgICB1LmZvckVhY2goKF8pID0+IHtcbiAgICAgIEh1KF8sIGYpIHx8IGwucmVtb3ZlQXR0cmlidXRlKF8ubm9kZU5hbWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuLmJvZHkuaW5uZXJIVE1MO1xufVxuY29uc3QgeHIgPSBcInRvb2x0aXBcIiwgVnUgPSBcInRlLnRvb2x0aXBcIiwgeXQgPSBgLiR7VnV9YCwgRnUgPSBcInRlLXRvb2x0aXBcIiwgWXUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJzYW5pdGl6ZVwiLCBcImFsbG93TGlzdFwiLCBcInNhbml0aXplRm5cIl0pLCBqdSA9IHtcbiAgYW5pbWF0aW9uOiBcImJvb2xlYW5cIixcbiAgdGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHRpdGxlOiBcIihzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbilcIixcbiAgdHJpZ2dlcjogXCJzdHJpbmdcIixcbiAgZGVsYXk6IFwiKG51bWJlcnxvYmplY3QpXCIsXG4gIGh0bWw6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RvcjogXCIoc3RyaW5nfGJvb2xlYW4pXCIsXG4gIHBsYWNlbWVudDogXCIoc3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBvZmZzZXQ6IFwiKGFycmF5fHN0cmluZ3xmdW5jdGlvbilcIixcbiAgY29udGFpbmVyOiBcIihzdHJpbmd8ZWxlbWVudHxib29sZWFuKVwiLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IFwiYXJyYXlcIixcbiAgYm91bmRhcnk6IFwiKHN0cmluZ3xlbGVtZW50KVwiLFxuICBjdXN0b21DbGFzczogXCIoc3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBzYW5pdGl6ZTogXCJib29sZWFuXCIsXG4gIHNhbml0aXplRm46IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGFsbG93TGlzdDogXCJvYmplY3RcIixcbiAgcG9wcGVyQ29uZmlnOiBcIihudWxsfG9iamVjdHxmdW5jdGlvbilcIlxufSwgS3UgPSB7XG4gIEFVVE86IFwiYXV0b1wiLFxuICBUT1A6IFwidG9wXCIsXG4gIFJJR0hUOiBGKCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgQk9UVE9NOiBcImJvdHRvbVwiLFxuICBMRUZUOiBGKCkgPyBcInJpZ2h0XCIgOiBcImxlZnRcIlxufSwgenUgPSB7XG4gIGFuaW1hdGlvbjogITAsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cIm9wYWNpdHktMCB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0IGFic29sdXRlIHotWzEwODBdIGJsb2NrIG0tMCB0ZXh0LXNtIG5vdC1pdGFsaWMgZm9udC1ub3JtYWwgdGV4dC1sZWZ0IG5vLXVuZGVybGluZSB1bmRlcmxpbmUtb2Zmc2V0LWF1dG8gbm9ybWFsLWNhc2UgbGVhZGluZy02IHRyYWNraW5nLW5vcm1hbCBicmVhay1ub3JtYWwgd2hpdGVzcGFjZS1ub3JtYWxcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgZGF0YS10ZS10b29sdGlwLWlubmVyLXJlZiBjbGFzcz1cInRvb2x0aXAtaW5uZXIgbWF4LXctWzIwMHB4XSB0ZXh0LXNtIHB5LTEuNSBweC00IHRleHQtd2hpdGUgdGV4dC1jZW50ZXIgYmctWyM2ZDZkNmRdIHJvdW5kZWRcIj48L2Rpdj48L2Rpdj4nLFxuICB0cmlnZ2VyOiBcImhvdmVyIGZvY3VzXCIsXG4gIHRpdGxlOiBcIlwiLFxuICBkZWxheTogMCxcbiAgaHRtbDogITEsXG4gIHNlbGVjdG9yOiAhMSxcbiAgcGxhY2VtZW50OiBcInRvcFwiLFxuICBvZmZzZXQ6IFswLCAwXSxcbiAgY29udGFpbmVyOiAhMSxcbiAgZmFsbGJhY2tQbGFjZW1lbnRzOiBbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl0sXG4gIGJvdW5kYXJ5OiBcImNsaXBwaW5nUGFyZW50c1wiLFxuICBjdXN0b21DbGFzczogXCJcIixcbiAgc2FuaXRpemU6ICEwLFxuICBzYW5pdGl6ZUZuOiBudWxsLFxuICBhbGxvd0xpc3Q6IFd1LFxuICBwb3BwZXJDb25maWc6IHsgaGlkZTogITAgfVxufSwgVXUgPSB7XG4gIEhJREU6IGBoaWRlJHt5dH1gLFxuICBISURERU46IGBoaWRkZW4ke3l0fWAsXG4gIFNIT1c6IGBzaG93JHt5dH1gLFxuICBTSE9XTjogYHNob3duJHt5dH1gLFxuICBJTlNFUlRFRDogYGluc2VydGVkJHt5dH1gLFxuICBDTElDSzogYGNsaWNrJHt5dH1gLFxuICBGT0NVU0lOOiBgZm9jdXNpbiR7eXR9YCxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7eXR9YCxcbiAgTU9VU0VFTlRFUjogYG1vdXNlZW50ZXIke3l0fWAsXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHt5dH1gXG59LCBYdSA9IFwiZmFkZVwiLCBHdSA9IFwibW9kYWxcIiwgcG4gPSBcInNob3dcIiwgb2kgPSBcInNob3dcIiwgX24gPSBcIm91dFwiLCBrciA9IFwiLnRvb2x0aXAtaW5uZXJcIiwgT3IgPSBgLiR7R3V9YCwgU3IgPSBcImhpZGUudGUubW9kYWxcIiwgcmkgPSBcImhvdmVyXCIsIGZuID0gXCJmb2N1c1wiLCBxdSA9IFwiY2xpY2tcIiwgWnUgPSBcIm1hbnVhbFwiO1xuY2xhc3MgUWUgZXh0ZW5kcyBFdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBpZiAodHlwZW9mIE5sID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkJvb3RzdHJhcCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpXCJcbiAgICAgICk7XG4gICAgc3VwZXIodCksIHRoaXMuX2lzRW5hYmxlZCA9ICEwLCB0aGlzLl90aW1lb3V0ID0gMCwgdGhpcy5faG92ZXJTdGF0ZSA9IFwiXCIsIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fSwgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLnRpcCA9IG51bGwsIHRoaXMuX3NldExpc3RlbmVycygpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiB6dTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHhyO1xuICB9XG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgcmV0dXJuIFV1O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIGp1O1xuICB9XG4gIC8vIFB1YmxpY1xuICBlbmFibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gITA7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhMTtcbiAgfVxuICB0b2dnbGVFbmFibGVkKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWQ7XG4gIH1cbiAgdG9nZ2xlKHQpIHtcbiAgICBpZiAodGhpcy5faXNFbmFibGVkKVxuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0KTtcbiAgICAgICAgZS5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFlLl9hY3RpdmVUcmlnZ2VyLmNsaWNrLCBlLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkgPyBlLl9lbnRlcihudWxsLCBlKSA6IGUuX2xlYXZlKG51bGwsIGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhwbikpIHtcbiAgICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW50ZXIobnVsbCwgdGhpcyk7XG4gICAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksIGgub2ZmKFxuICAgICAgdGhpcy5fZWxlbWVudC5jbG9zZXN0KE9yKSxcbiAgICAgIFNyLFxuICAgICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlclxuICAgICksIHRoaXMudGlwICYmIHRoaXMudGlwLnJlbW92ZSgpLCB0aGlzLl9kaXNwb3NlUG9wcGVyKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHNcIik7XG4gICAgaWYgKCEodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gaC50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPV1xuICAgICksIGUgPSB0bCh0aGlzLl9lbGVtZW50KSwgaSA9IGUgPT09IG51bGwgPyB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpIDogZS5jb250YWlucyh0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodC5kZWZhdWx0UHJldmVudGVkIHx8ICFpKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY29uc3RydWN0b3IuTkFNRSA9PT0gXCJ0b29sdGlwXCIgJiYgdGhpcy50aXAgJiYgdGhpcy5nZXRUaXRsZSgpICE9PSB0aGlzLnRpcC5xdWVyeVNlbGVjdG9yKGtyKS5pbm5lckhUTUwgJiYgKHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSwgdGhpcy50aXAucmVtb3ZlKCksIHRoaXMudGlwID0gbnVsbCk7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpLCBvID0gYnQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKTtcbiAgICBuLnNldEF0dHJpYnV0ZShcImlkXCIsIG8pLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIiwgbyksIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRpcC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0xMDBcIiksIHRoaXMudGlwLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTBcIik7XG4gICAgfSwgMTAwKTtcbiAgICBjb25zdCByID0gdHlwZW9mIHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQgPT0gXCJmdW5jdGlvblwiID8gdGhpcy5fY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIG4sIHRoaXMuX2VsZW1lbnQpIDogdGhpcy5fY29uZmlnLnBsYWNlbWVudCwgYSA9IHRoaXMuX2dldEF0dGFjaG1lbnQocik7XG4gICAgdGhpcy5fYWRkQXR0YWNobWVudENsYXNzKGEpO1xuICAgIGNvbnN0IHsgY29udGFpbmVyOiBsIH0gPSB0aGlzLl9jb25maWc7XG4gICAgaWYgKEkuc2V0RGF0YShuLCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKSwgdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLnRpcCkgfHwgKGwuYXBwZW5kKG4pLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5JTlNFUlRFRCkpLCB0aGlzLl9wb3BwZXIgPyB0aGlzLl9wb3BwZXIudXBkYXRlKCkgOiB0aGlzLl9wb3BwZXIgPSBFZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBuLFxuICAgICAgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKGEpXG4gICAgKSwgbi5nZXRBdHRyaWJ1dGUoXCJpZFwiKS5pbmNsdWRlcyhcInRvb2x0aXBcIikpXG4gICAgICBzd2l0Y2ggKHIpIHtcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB5LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB4LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICBuLmNsYXNzTGlzdC5hZGQoXCJweC1bMC40cmVtXVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBuLmNsYXNzTGlzdC5hZGQoXCJweS1bMC40cmVtXVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjb25zdCB1ID0gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmN1c3RvbUNsYXNzKTtcbiAgICB1ICYmIG4uY2xhc3NMaXN0LmFkZCguLi51LnNwbGl0KFwiIFwiKSksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChtKSA9PiB7XG4gICAgICBoLm9uKG0sIFwibW91c2VvdmVyXCIsIE1zKTtcbiAgICB9KTtcbiAgICBjb25zdCBmID0gKCkgPT4ge1xuICAgICAgY29uc3QgbSA9IHRoaXMuX2hvdmVyU3RhdGU7XG4gICAgICB0aGlzLl9ob3ZlclN0YXRlID0gbnVsbCwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPV04pLCBtID09PSBfbiAmJiB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKTtcbiAgICB9LCBfID0gdGhpcy50aXAuY2xhc3NMaXN0LmNvbnRhaW5zKFwidHJhbnNpdGlvbi1vcGFjaXR5XCIpO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZiwgdGhpcy50aXAsIF8pO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9wb3BwZXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpLCBlID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpIHx8ICh0aGlzLl9ob3ZlclN0YXRlICE9PSBvaSAmJiB0LnJlbW92ZSgpLCB0aGlzLl9jbGVhblRpcENsYXNzKCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElEREVOKSwgdGhpcy5fZGlzcG9zZVBvcHBlcigpKTtcbiAgICB9O1xuICAgIGlmIChoLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFXG4gICAgKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHQuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMFwiKSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0xMDBcIiksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChvKSA9PiBoLm9mZihvLCBcIm1vdXNlb3ZlclwiLCBNcykpLCB0aGlzLl9hY3RpdmVUcmlnZ2VyW3F1XSA9ICExLCB0aGlzLl9hY3RpdmVUcmlnZ2VyW2ZuXSA9ICExLCB0aGlzLl9hY3RpdmVUcmlnZ2VyW3JpXSA9ICExO1xuICAgIGNvbnN0IG4gPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoXCJvcGFjaXR5LTBcIik7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhlLCB0aGlzLnRpcCwgbiksIHRoaXMuX2hvdmVyU3RhdGUgPSBcIlwiO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9wb3BwZXIgIT09IG51bGwgJiYgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICB9XG4gIC8vIFByb3RlY3RlZFxuICBpc1dpdGhDb250ZW50KCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0VGl0bGUoKTtcbiAgfVxuICBnZXRUaXBFbGVtZW50KCkge1xuICAgIGlmICh0aGlzLnRpcClcbiAgICAgIHJldHVybiB0aGlzLnRpcDtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0LmlubmVySFRNTCA9IHRoaXMuX2NvbmZpZy50ZW1wbGF0ZTtcbiAgICBjb25zdCBlID0gdC5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gdGhpcy5zZXRDb250ZW50KGUpLCBlLmNsYXNzTGlzdC5yZW1vdmUoWHUsIHBuKSwgdGhpcy50aXAgPSBlLCB0aGlzLnRpcDtcbiAgfVxuICBzZXRDb250ZW50KHQpIHtcbiAgICB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5nZXRUaXRsZSgpLCBrcik7XG4gIH1cbiAgX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCBlLCBpKSB7XG4gICAgY29uc3QgbiA9IGQuZmluZE9uZShpLCB0KTtcbiAgICBpZiAoIWUgJiYgbikge1xuICAgICAgbi5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudChuLCBlKTtcbiAgfVxuICBzZXRFbGVtZW50Q29udGVudCh0LCBlKSB7XG4gICAgaWYgKHQgIT09IG51bGwpIHtcbiAgICAgIGlmIChWZShlKSkge1xuICAgICAgICBlID0gSnQoZSksIHRoaXMuX2NvbmZpZy5odG1sID8gZS5wYXJlbnROb2RlICE9PSB0ICYmICh0LmlubmVySFRNTCA9IFwiXCIsIHQuYXBwZW5kKGUpKSA6IHQudGV4dENvbnRlbnQgPSBlLnRleHRDb250ZW50O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25maWcuaHRtbCA/ICh0aGlzLl9jb25maWcuc2FuaXRpemUgJiYgKGUgPSB3cihcbiAgICAgICAgZSxcbiAgICAgICAgdGhpcy5fY29uZmlnLmFsbG93TGlzdCxcbiAgICAgICAgdGhpcy5fY29uZmlnLnNhbml0aXplRm5cbiAgICAgICkpLCB0LmlubmVySFRNTCA9IGUpIDogdC50ZXh0Q29udGVudCA9IGU7XG4gICAgfVxuICB9XG4gIGdldFRpdGxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdGUtb3JpZ2luYWwtdGl0bGVcIikgfHwgdGhpcy5fY29uZmlnLnRpdGxlO1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0KTtcbiAgfVxuICB1cGRhdGVBdHRhY2htZW50KHQpIHtcbiAgICByZXR1cm4gdCA9PT0gXCJyaWdodFwiID8gXCJlbmRcIiA6IHQgPT09IFwibGVmdFwiID8gXCJzdGFydFwiIDogdDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQodCwgZSkge1xuICAgIHJldHVybiBlIHx8IHRoaXMuY29uc3RydWN0b3IuZ2V0T3JDcmVhdGVJbnN0YW5jZShcbiAgICAgIHQuZGVsZWdhdGVUYXJnZXQsXG4gICAgICB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpXG4gICAgKTtcbiAgfVxuICBfZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IHsgb2Zmc2V0OiB0IH0gPSB0aGlzLl9jb25maWc7XG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0LnNwbGl0KFwiLFwiKS5tYXAoKGUpID0+IE51bWJlci5wYXJzZUludChlLCAxMCkpIDogdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gKGUpID0+IHQoZSwgdGhpcy5fZWxlbWVudCkgOiB0O1xuICB9XG4gIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQuY2FsbCh0aGlzLl9lbGVtZW50KSA6IHQ7XG4gIH1cbiAgX2dldFBvcHBlckNvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIHBsYWNlbWVudDogdCxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJmbGlwXCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB0aGlzLl9jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJwcmV2ZW50T3ZlcmZsb3dcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJhcnJvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwib25DaGFuZ2VcIixcbiAgICAgICAgICBlbmFibGVkOiAhMCxcbiAgICAgICAgICBwaGFzZTogXCJhZnRlcldyaXRlXCIsXG4gICAgICAgICAgZm46IChpKSA9PiB0aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoaSlcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG9uRmlyc3RVcGRhdGU6IChpKSA9PiB7XG4gICAgICAgIGkub3B0aW9ucy5wbGFjZW1lbnQgIT09IGkucGxhY2VtZW50ICYmIHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5lLFxuICAgICAgLi4udHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPT0gXCJmdW5jdGlvblwiID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyhlKSA6IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWdcbiAgICB9O1xuICB9XG4gIF9hZGRBdHRhY2htZW50Q2xhc3ModCkge1xuICAgIHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoXG4gICAgICBgJHt0aGlzLl9nZXRCYXNpY0NsYXNzUHJlZml4KCl9LSR7dGhpcy51cGRhdGVBdHRhY2htZW50KHQpfWBcbiAgICApO1xuICB9XG4gIF9nZXRBdHRhY2htZW50KHQpIHtcbiAgICByZXR1cm4gS3VbdC50b1VwcGVyQ2FzZSgpXTtcbiAgfVxuICBfc2V0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2NvbmZpZy50cmlnZ2VyLnNwbGl0KFwiIFwiKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBpZiAoZSA9PT0gXCJjbGlja1wiKVxuICAgICAgICBoLm9uKFxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5DTElDSyxcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXG4gICAgICAgICAgKGkpID0+IHRoaXMudG9nZ2xlKGkpXG4gICAgICAgICk7XG4gICAgICBlbHNlIGlmIChlICE9PSBadSkge1xuICAgICAgICBjb25zdCBpID0gZSA9PT0gcmkgPyB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFRU5URVIgOiB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTSU4sIG4gPSBlID09PSByaSA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VMRUFWRSA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNPVVQ7XG4gICAgICAgIGgub24oXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHRoaXMuX2NvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAobykgPT4gdGhpcy5fZW50ZXIobylcbiAgICAgICAgKSwgaC5vbihcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgIG4sXG4gICAgICAgICAgdGhpcy5fY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIChvKSA9PiB0aGlzLl9sZWF2ZShvKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudCAmJiB0aGlzLmhpZGUoKTtcbiAgICB9LCBoLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudC5jbG9zZXN0KE9yKSxcbiAgICAgIFNyLFxuICAgICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlclxuICAgICksIHRoaXMuX2NvbmZpZy5zZWxlY3RvciA/IHRoaXMuX2NvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuX2NvbmZpZyxcbiAgICAgIHRyaWdnZXI6IFwibWFudWFsXCIsXG4gICAgICBzZWxlY3RvcjogXCJcIlxuICAgIH0gOiB0aGlzLl9maXhUaXRsZSgpO1xuICB9XG4gIF9maXhUaXRsZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKSwgZSA9IHR5cGVvZiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcbiAgICAgIFwiZGF0YS10ZS1vcmlnaW5hbC10aXRsZVwiXG4gICAgKTtcbiAgICAodCB8fCBlICE9PSBcInN0cmluZ1wiKSAmJiAodGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLW9yaWdpbmFsLXRpdGxlXCIsIHQgfHwgXCJcIiksIHQgJiYgIXRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKSAmJiAhdGhpcy5fZWxlbWVudC50ZXh0Q29udGVudCAmJiB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgXCJcIikpO1xuICB9XG4gIF9lbnRlcih0LCBlKSB7XG4gICAgaWYgKGUgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQodCwgZSksIHQgJiYgKGUuX2FjdGl2ZVRyaWdnZXJbdC50eXBlID09PSBcImZvY3VzaW5cIiA/IGZuIDogcmldID0gITApLCBlLmdldFRpcEVsZW1lbnQoKS5jbGFzc0xpc3QuY29udGFpbnMocG4pIHx8IGUuX2hvdmVyU3RhdGUgPT09IG9pKSB7XG4gICAgICBlLl9ob3ZlclN0YXRlID0gb2k7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjbGVhclRpbWVvdXQoZS5fdGltZW91dCksIGUuX2hvdmVyU3RhdGUgPSBvaSwgIWUuX2NvbmZpZy5kZWxheSB8fCAhZS5fY29uZmlnLmRlbGF5LnNob3cpIHtcbiAgICAgIGUuc2hvdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBlLl9ob3ZlclN0YXRlID09PSBvaSAmJiBlLnNob3coKTtcbiAgICB9LCBlLl9jb25maWcuZGVsYXkuc2hvdyk7XG4gIH1cbiAgX2xlYXZlKHQsIGUpIHtcbiAgICBpZiAoZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSwgdCAmJiAoZS5fYWN0aXZlVHJpZ2dlclt0LnR5cGUgPT09IFwiZm9jdXNvdXRcIiA/IGZuIDogcmldID0gZS5fZWxlbWVudC5jb250YWlucyh0LnJlbGF0ZWRUYXJnZXQpKSwgIWUuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgaWYgKGNsZWFyVGltZW91dChlLl90aW1lb3V0KSwgZS5faG92ZXJTdGF0ZSA9IF9uLCAhZS5fY29uZmlnLmRlbGF5IHx8ICFlLl9jb25maWcuZGVsYXkuaGlkZSkge1xuICAgICAgICBlLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlLl9ob3ZlclN0YXRlID09PSBfbiAmJiBlLmhpZGUoKTtcbiAgICAgIH0sIGUuX2NvbmZpZy5kZWxheS5oaWRlKTtcbiAgICB9XG4gIH1cbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgZm9yIChjb25zdCB0IGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpXG4gICAgICBpZiAodGhpcy5fYWN0aXZlVHJpZ2dlclt0XSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgWXUuaGFzKGkpICYmIGRlbGV0ZSBlW2ldO1xuICAgIH0pLCB0ID0ge1xuICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCA/IHQgOiB7fVxuICAgIH0sIHQuY29udGFpbmVyID0gdC5jb250YWluZXIgPT09ICExID8gZG9jdW1lbnQuYm9keSA6IEp0KHQuY29udGFpbmVyKSwgdHlwZW9mIHQuZGVsYXkgPT0gXCJudW1iZXJcIiAmJiAodC5kZWxheSA9IHtcbiAgICAgIHNob3c6IHQuZGVsYXksXG4gICAgICBoaWRlOiB0LmRlbGF5XG4gICAgfSksIHR5cGVvZiB0LnRpdGxlID09IFwibnVtYmVyXCIgJiYgKHQudGl0bGUgPSB0LnRpdGxlLnRvU3RyaW5nKCkpLCB0eXBlb2YgdC5jb250ZW50ID09IFwibnVtYmVyXCIgJiYgKHQuY29udGVudCA9IHQuY29udGVudC50b1N0cmluZygpKSwgTCh4ciwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQuc2FuaXRpemUgJiYgKHQudGVtcGxhdGUgPSB3cihcbiAgICAgIHQudGVtcGxhdGUsXG4gICAgICB0LmFsbG93TGlzdCxcbiAgICAgIHQuc2FuaXRpemVGblxuICAgICkpLCB0O1xuICB9XG4gIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICBjb25zdCB0ID0ge307XG4gICAgZm9yIChjb25zdCBlIGluIHRoaXMuX2NvbmZpZylcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtlXSAhPT0gdGhpcy5fY29uZmlnW2VdICYmICh0W2VdID0gdGhpcy5fY29uZmlnW2VdKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBfY2xlYW5UaXBDbGFzcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIGUgPSBuZXcgUmVnRXhwKFxuICAgICAgYChefFxcXFxzKSR7dGhpcy5fZ2V0QmFzaWNDbGFzc1ByZWZpeCgpfVxcXFxTK2AsXG4gICAgICBcImdcIlxuICAgICksIGkgPSB0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLm1hdGNoKGUpO1xuICAgIGkgIT09IG51bGwgJiYgaS5sZW5ndGggPiAwICYmIGkubWFwKChuKSA9PiBuLnRyaW0oKSkuZm9yRWFjaCgobikgPT4gdC5jbGFzc0xpc3QucmVtb3ZlKG4pKTtcbiAgfVxuICBfZ2V0QmFzaWNDbGFzc1ByZWZpeCgpIHtcbiAgICByZXR1cm4gRnU7XG4gIH1cbiAgX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSh0KSB7XG4gICAgY29uc3QgeyBzdGF0ZTogZSB9ID0gdDtcbiAgICBlICYmICh0aGlzLnRpcCA9IGUuZWxlbWVudHMucG9wcGVyLCB0aGlzLl9jbGVhblRpcENsYXNzKCksIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KGUucGxhY2VtZW50KSkpO1xuICB9XG4gIF9kaXNwb3NlUG9wcGVyKCkge1xuICAgIHRoaXMuX3BvcHBlciAmJiAodGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgdGhpcy5fcG9wcGVyID0gbnVsbCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gUWUuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFF1ID0gXCJwb3BvdmVyXCIsIEp1ID0gXCJ0ZS5wb3BvdmVyXCIsIHd0ID0gYC4ke0p1fWAsIHRwID0gXCJ0ZS1wb3BvdmVyXCIsIGVwID0ge1xuICAuLi5RZS5EZWZhdWx0LFxuICBwbGFjZW1lbnQ6IFwicmlnaHRcIixcbiAgb2Zmc2V0OiBbMCwgOF0sXG4gIHRyaWdnZXI6IFwiY2xpY2tcIixcbiAgY29udGVudDogXCJcIixcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwib3BhY2l0eS0wIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHotWzEwNzBdIGJsb2NrIG1heC13LVsyNjdweF0gYnJlYWstd29yZHMgYmctd2hpdGUgYmctY2xpcC1wYWRkaW5nIGJvcmRlciBib3JkZXItbmV1dHJhbC0xMDAgcm91bmRlZC1sZyBzaGFkb3ctWzBfMHB4XzNweF8wX3JnYmEoMCwwLDAsMC4wNyksMF8ycHhfMnB4XzBfcmdiYSgwLDAsMCwwLjA0KV0gdGV4dC1zbSBub3QtaXRhbGljIGZvbnQtbm9ybWFsIHRleHQtbGVmdCBuby11bmRlcmxpbmUgdW5kZXJsaW5lLW9mZnNldC1hdXRvIG5vcm1hbC1jYXNlIGxlYWRpbmctNiB0cmFja2luZy1ub3JtYWwgYnJlYWstbm9ybWFsIHdoaXRlc3BhY2Utbm9ybWFsIGRhcms6YmctbmV1dHJhbC03MDAgZGFyazpib3JkZXItMCBkYXJrOnRleHQtd2hpdGUgZGF0YS1bcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW5dOmhpZGRlblwiIHJvbGU9XCJ0b29sdGlwXCI+PGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXIgcHktMiBweC00IG1iLTAgYm9yZGVyLWItMiBib3JkZXItbmV1dHJhbC0xMDAgcm91bmRlZC10LWxnIGZvbnQtbWVkaXVtIGVtcHR5OmhpZGRlbiBkYXJrOmJvcmRlci1uZXV0cmFsLTUwMFwiPjwvaDM+PGRpdiBjbGFzcz1cInBvcG92ZXItYm9keSBwLTQgdGV4dC1bIzIxMjUyOV0gZGFyazp0ZXh0LXdoaXRlXCI+PC9kaXY+PC9kaXY+J1xufSwgaXAgPSB7XG4gIC4uLlFlLkRlZmF1bHRUeXBlLFxuICBjb250ZW50OiBcIihzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbilcIlxufSwgc3AgPSB7XG4gIEhJREU6IGBoaWRlJHt3dH1gLFxuICBISURERU46IGBoaWRkZW4ke3d0fWAsXG4gIFNIT1c6IGBzaG93JHt3dH1gLFxuICBTSE9XTjogYHNob3duJHt3dH1gLFxuICBJTlNFUlRFRDogYGluc2VydGVkJHt3dH1gLFxuICBDTElDSzogYGNsaWNrJHt3dH1gLFxuICBGT0NVU0lOOiBgZm9jdXNpbiR7d3R9YCxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7d3R9YCxcbiAgTU9VU0VFTlRFUjogYG1vdXNlZW50ZXIke3d0fWAsXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHt3dH1gXG59LCBucCA9IFwiLnBvcG92ZXItaGVhZGVyXCIsIG9wID0gXCIucG9wb3Zlci1ib2R5XCI7XG5jbGFzcyBZbCBleHRlbmRzIFFlIHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIGVwO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gUXU7XG4gIH1cbiAgc3RhdGljIGdldCBFdmVudCgpIHtcbiAgICByZXR1cm4gc3A7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gaXA7XG4gIH1cbiAgLy8gT3ZlcnJpZGVzXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XG4gIH1cbiAgc2V0Q29udGVudCh0KSB7XG4gICAgdGhpcy5fc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIHRoaXMuZ2V0VGl0bGUoKSwgbnApLCB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5fZ2V0Q29udGVudCgpLCBvcCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmNvbnRlbnQpO1xuICB9XG4gIF9nZXRCYXNpY0NsYXNzUHJlZml4KCkge1xuICAgIHJldHVybiB0cDtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBZbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgbW4gPSBcInNjcm9sbHNweVwiLCBycCA9IFwidGUuc2Nyb2xsc3B5XCIsIERvID0gYC4ke3JwfWAsIElyID0ge1xuICBvZmZzZXQ6IDEwLFxuICBtZXRob2Q6IFwiYXV0b1wiLFxuICB0YXJnZXQ6IFwiXCJcbn0sIGFwID0ge1xuICBvZmZzZXQ6IFwibnVtYmVyXCIsXG4gIG1ldGhvZDogXCJzdHJpbmdcIixcbiAgdGFyZ2V0OiBcIihzdHJpbmd8ZWxlbWVudClcIlxufSwgbHAgPSB7XG4gIGFjdGl2ZTogXCIhdGV4dC1wcmltYXJ5IGRhcms6IXRleHQtcHJpbWFyeS00MDAgZm9udC1zZW1pYm9sZCBib3JkZXItbC1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItcHJpbWFyeSBkYXJrOmJvcmRlci1wcmltYXJ5LTQwMFwiXG59LCBjcCA9IHtcbiAgYWN0aXZlOiBcInN0cmluZ1wiXG59LCBocCA9IGBhY3RpdmF0ZSR7RG99YCwgZHAgPSBgc2Nyb2xsJHtEb31gLCBnbiA9IFwiZGF0YS10ZS1uYXYtbGluay1hY3RpdmVcIiwgamwgPSBcIltkYXRhLXRlLWRyb3Bkb3duLWl0ZW0tcmVmXVwiLCB1cCA9IFwiW2RhdGEtdGUtbmF2LWxpc3QtcmVmXVwiLCBvbyA9IFwiW2RhdGEtdGUtbmF2LWxpbmstcmVmXVwiLCBwcCA9IFwiW2RhdGEtdGUtbmF2LWl0ZW0tcmVmXVwiLCBLbCA9IFwiW2RhdGEtdGUtbGlzdC1ncm91cC1pdGVtLXJlZl1cIiwgYm4gPSBgJHtvb30sICR7S2x9LCAke2psfWAsIF9wID0gXCJbZGF0YS10ZS1kcm9wZG93bi1yZWZdXCIsIGZwID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBtcCA9IFwibWF4T2Zmc2V0XCIsIERyID0gXCJwb3NpdGlvblwiO1xuY2xhc3MgemwgZXh0ZW5kcyBFdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQudGFnTmFtZSA9PT0gXCJCT0RZXCIgPyB3aW5kb3cgOiB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9vZmZzZXRzID0gW10sIHRoaXMuX3RhcmdldHMgPSBbXSwgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbCwgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gMCwgaC5vbih0aGlzLl9zY3JvbGxFbGVtZW50LCBkcCwgKCkgPT4gdGhpcy5fcHJvY2VzcygpKSwgdGhpcy5yZWZyZXNoKCksIHRoaXMuX3Byb2Nlc3MoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gSXI7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBtbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgPyBtcCA6IERyLCBlID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gXCJhdXRvXCIgPyB0IDogdGhpcy5fY29uZmlnLm1ldGhvZCwgaSA9IGUgPT09IERyID8gdGhpcy5fZ2V0U2Nyb2xsVG9wKCkgOiAwO1xuICAgIHRoaXMuX29mZnNldHMgPSBbXSwgdGhpcy5fdGFyZ2V0cyA9IFtdLCB0aGlzLl9zY3JvbGxIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSwgZC5maW5kKFxuICAgICAgYm4sXG4gICAgICB0aGlzLl9jb25maWcudGFyZ2V0XG4gICAgKS5tYXAoKG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBmbyhvKSwgYSA9IHIgPyBkLmZpbmRPbmUocikgOiBudWxsO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgY29uc3QgbCA9IGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChsLndpZHRoIHx8IGwuaGVpZ2h0KVxuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjW2VdKGEpLnRvcCArIGksXG4gICAgICAgICAgICByXG4gICAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbHRlcigobykgPT4gbykuc29ydCgobywgcikgPT4gb1swXSAtIHJbMF0pLmZvckVhY2goKG8pID0+IHtcbiAgICAgIHRoaXMuX29mZnNldHMucHVzaChvWzBdKSwgdGhpcy5fdGFyZ2V0cy5wdXNoKG9bMV0pO1xuICAgIH0pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaC5vZmYodGhpcy5fc2Nyb2xsRWxlbWVudCwgRG8pLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLklyLFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCA/IHQgOiB7fVxuICAgIH0sIHQudGFyZ2V0ID0gSnQodC50YXJnZXQpIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgTChtbiwgdCwgYXApLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ubHAsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwobW4sIHQsIGNwKSwgdDtcbiAgfVxuICBfZ2V0U2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB0aGlzLl9zY3JvbGxFbGVtZW50LnBhZ2VZT2Zmc2V0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cbiAgX2dldFNjcm9sbEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgoXG4gICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgICApO1xuICB9XG4gIF9nZXRPZmZzZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICB9XG4gIF9wcm9jZXNzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXQsIGUgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSwgaSA9IHRoaXMuX2NvbmZpZy5vZmZzZXQgKyBlIC0gdGhpcy5fZ2V0T2Zmc2V0SGVpZ2h0KCk7XG4gICAgaWYgKHRoaXMuX3Njcm9sbEhlaWdodCAhPT0gZSAmJiB0aGlzLnJlZnJlc2goKSwgdCA+PSBpKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5fdGFyZ2V0c1t0aGlzLl90YXJnZXRzLmxlbmd0aCAtIDFdO1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSBuICYmIHRoaXMuX2FjdGl2YXRlKG4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICYmIHQgPCB0aGlzLl9vZmZzZXRzWzBdICYmIHRoaXMuX29mZnNldHNbMF0gPiAwKSB7XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsLCB0aGlzLl9jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBuID0gdGhpcy5fb2Zmc2V0cy5sZW5ndGg7IG4tLTsgKVxuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0aGlzLl90YXJnZXRzW25dICYmIHQgPj0gdGhpcy5fb2Zmc2V0c1tuXSAmJiAodHlwZW9mIHRoaXMuX29mZnNldHNbbiArIDFdID4gXCJ1XCIgfHwgdCA8IHRoaXMuX29mZnNldHNbbiArIDFdKSAmJiB0aGlzLl9hY3RpdmF0ZSh0aGlzLl90YXJnZXRzW25dKTtcbiAgfVxuICBfYWN0aXZhdGUodCkge1xuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHQsIHRoaXMuX2NsZWFyKCk7XG4gICAgY29uc3QgZSA9IGJuLnNwbGl0KFwiLFwiKS5tYXAoXG4gICAgICAobikgPT4gYCR7bn1bZGF0YS10ZS10YXJnZXQ9XCIke3R9XCJdLCR7bn1baHJlZj1cIiR7dH1cIl1gXG4gICAgKSwgaSA9IGQuZmluZE9uZShlLmpvaW4oXCIsXCIpLCB0aGlzLl9jb25maWcudGFyZ2V0KTtcbiAgICBpLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKSwgaS5zZXRBdHRyaWJ1dGUoZ24sIFwiXCIpLCBpLmdldEF0dHJpYnV0ZShqbCkgPyBkLmZpbmRPbmUoXG4gICAgICBmcCxcbiAgICAgIGkuY2xvc2VzdChfcClcbiAgICApLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKSA6IGQucGFyZW50cyhpLCB1cCkuZm9yRWFjaChcbiAgICAgIChuKSA9PiB7XG4gICAgICAgIGQucHJldihcbiAgICAgICAgICBuLFxuICAgICAgICAgIGAke29vfSwgJHtLbH1gXG4gICAgICAgICkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICAgIG8uY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCBvLnNldEF0dHJpYnV0ZShnbiwgXCJcIik7XG4gICAgICAgIH0pLCBkLnByZXYobiwgcHApLmZvckVhY2goXG4gICAgICAgICAgKG8pID0+IHtcbiAgICAgICAgICAgIGQuY2hpbGRyZW4obywgb28pLmZvckVhY2goXG4gICAgICAgICAgICAgIChyKSA9PiByLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSwgaC50cmlnZ2VyKHRoaXMuX3Njcm9sbEVsZW1lbnQsIGhwLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSk7XG4gIH1cbiAgX2NsZWFyKCkge1xuICAgIGQuZmluZChibiwgdGhpcy5fY29uZmlnLnRhcmdldCkuZmlsdGVyKFxuICAgICAgKHQpID0+IHQuY2xhc3NMaXN0LmNvbnRhaW5zKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSlcbiAgICApLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCB0LnJlbW92ZUF0dHJpYnV0ZShnbik7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gemwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0ICRyID0gXCJ0YWJcIiwgZ3AgPSBcInRlLnRhYlwiLCBGcyA9IGAuJHtncH1gLCBicCA9IGBoaWRlJHtGc31gLCB2cCA9IGBoaWRkZW4ke0ZzfWAsIFRwID0gYHNob3cke0ZzfWAsIEVwID0gYHNob3duJHtGc31gLCBDcCA9IFwiZGF0YS10ZS1kcm9wZG93bi1tZW51LXJlZlwiLCBEZSA9IFwiZGF0YS10ZS10YWItYWN0aXZlXCIsIEVzID0gXCJkYXRhLXRlLW5hdi1hY3RpdmVcIiwgQXAgPSBcIltkYXRhLXRlLWRyb3Bkb3duLXJlZl1cIiwgeXAgPSBcIltkYXRhLXRlLW5hdi1yZWZdXCIsIExyID0gYFske0RlfV1gLCB3cCA9IGBbJHtFc31dYCwgTXIgPSBcIjpzY29wZSA+IGxpID4gLmFjdGl2ZVwiLCB4cCA9IFwiW2RhdGEtdGUtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIiwga3AgPSBcIjpzY29wZSA+IFtkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXSBbZGF0YS10ZS1kcm9wZG93bi1zaG93XVwiLCBPcCA9IHtcbiAgc2hvdzogXCJvcGFjaXR5LTEwMFwiLFxuICBoaWRlOiBcIm9wYWNpdHktMFwiXG59LCBTcCA9IHtcbiAgc2hvdzogXCJzdHJpbmdcIixcbiAgaGlkZTogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFVsIGV4dGVuZHMgRXQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGUpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiAkcjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlICYmIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoRXMpID09PSBcIlwiKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0O1xuICAgIGNvbnN0IGUgPSBRdCh0aGlzLl9lbGVtZW50KSwgaSA9IHRoaXMuX2VsZW1lbnQuY2xvc2VzdCh5cCksIG4gPSBkLmZpbmRPbmUoXG4gICAgICB3cCxcbiAgICAgIGlcbiAgICApO1xuICAgIGlmIChpKSB7XG4gICAgICBjb25zdCBsID0gaS5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IGkubm9kZU5hbWUgPT09IFwiT0xcIiA/IE1yIDogTHI7XG4gICAgICB0ID0gZC5maW5kKGwsIGkpLCB0ID0gdFt0Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb25zdCBvID0gdCA/IGgudHJpZ2dlcih0LCBicCwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH0pIDogbnVsbDtcbiAgICBpZiAoaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFRwLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCB8fCBvICE9PSBudWxsICYmIG8uZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9hY3RpdmF0ZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBpLFxuICAgICAgbnVsbCxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBjb25zdCBhID0gKCkgPT4ge1xuICAgICAgaC50cmlnZ2VyKHQsIHZwLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH0pLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRXAsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBlID8gdGhpcy5fYWN0aXZhdGUoXG4gICAgICBlLFxuICAgICAgZS5wYXJlbnROb2RlLFxuICAgICAgYSxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSA6IGEoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uT3AsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwoJHIsIHQsIFNwKSwgdDtcbiAgfVxuICBfYWN0aXZhdGUodCwgZSwgaSwgbiwgbykge1xuICAgIGNvbnN0IGEgPSAoZSAmJiAoZS5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IGUubm9kZU5hbWUgPT09IFwiT0xcIikgPyBkLmZpbmQoTXIsIGUpIDogZC5jaGlsZHJlbihlLCBMcikpWzBdLCBsID0gaSAmJiBhICYmIGEuaGFzQXR0cmlidXRlKERlKSwgcCA9ICgpID0+IHRoaXMuX3RyYW5zaXRpb25Db21wbGV0ZShcbiAgICAgIHQsXG4gICAgICBhLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBvXG4gICAgKTtcbiAgICBhICYmIGwgPyAoYy5yZW1vdmVDbGFzcyhhLCB0aGlzLl9jbGFzc2VzLnNob3cpLCBjLmFkZENsYXNzKGEsIHRoaXMuX2NsYXNzZXMuaGlkZSksIHRoaXMuX3F1ZXVlQ2FsbGJhY2socCwgdCwgITApKSA6IHAoKTtcbiAgfVxuICBfdHJhbnNpdGlvbkNvbXBsZXRlKHQsIGUsIGksIG4sIG8pIHtcbiAgICBpZiAoZSAmJiBuKSB7XG4gICAgICBlLnJlbW92ZUF0dHJpYnV0ZShEZSksIG4ucmVtb3ZlQXR0cmlidXRlKEVzKTtcbiAgICAgIGNvbnN0IGEgPSBkLmZpbmRPbmUoXG4gICAgICAgIGtwLFxuICAgICAgICBlLnBhcmVudE5vZGVcbiAgICAgICk7XG4gICAgICBhICYmIGEucmVtb3ZlQXR0cmlidXRlKERlKSwgZS5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpID09PSBcInRhYlwiICYmIGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMSk7XG4gICAgfVxuICAgIHQuc2V0QXR0cmlidXRlKERlLCBcIlwiKSwgby5zZXRBdHRyaWJ1dGUoRXMsIFwiXCIpLCB0LmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwidGFiXCIgJiYgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEwKSwgR2UodCksIHQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuX2NsYXNzZXMuaGlkZSkgJiYgKGMucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5oaWRlKSwgYy5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnNob3cpKTtcbiAgICBsZXQgciA9IHQucGFyZW50Tm9kZTtcbiAgICBpZiAociAmJiByLm5vZGVOYW1lID09PSBcIkxJXCIgJiYgKHIgPSByLnBhcmVudE5vZGUpLCByICYmIHIuaGFzQXR0cmlidXRlKENwKSkge1xuICAgICAgY29uc3QgYSA9IHQuY2xvc2VzdChBcCk7XG4gICAgICBhICYmIGQuZmluZCh4cCwgYSkuZm9yRWFjaChcbiAgICAgICAgKGwpID0+IGwuc2V0QXR0cmlidXRlKERlLCBcIlwiKVxuICAgICAgKSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICEwKTtcbiAgICB9XG4gICAgaSAmJiBpKCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gVWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IHZuID0gXCJ0b2FzdFwiLCBJcCA9IFwidGUudG9hc3RcIiwgZWUgPSBgLiR7SXB9YCwgRHAgPSBgbW91c2VvdmVyJHtlZX1gLCAkcCA9IGBtb3VzZW91dCR7ZWV9YCwgTHAgPSBgZm9jdXNpbiR7ZWV9YCwgTXAgPSBgZm9jdXNvdXQke2VlfWAsIE5wID0gYGhpZGUke2VlfWAsIFJwID0gYGhpZGRlbiR7ZWV9YCwgUHAgPSBgc2hvdyR7ZWV9YCwgQnAgPSBgc2hvd24ke2VlfWAsIE5yID0gXCJkYXRhLXRlLXRvYXN0LWhpZGVcIiwgVG4gPSBcImRhdGEtdGUtdG9hc3Qtc2hvd1wiLCBYaSA9IFwiZGF0YS10ZS10b2FzdC1zaG93aW5nXCIsIEhwID0ge1xuICBhbmltYXRpb246IFwiYm9vbGVhblwiLFxuICBhdXRvaGlkZTogXCJib29sZWFuXCIsXG4gIGRlbGF5OiBcIm51bWJlclwiXG59LCBSciA9IHtcbiAgYW5pbWF0aW9uOiAhMCxcbiAgYXV0b2hpZGU6ICEwLFxuICBkZWxheTogNWUzXG59LCBXcCA9IHtcbiAgZmFkZUluOiBcImFuaW1hdGUtW2ZhZGUtaW5fMC4zc19ib3RoXSBwLVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLFxuICBmYWRlT3V0OiBcImFuaW1hdGUtW2ZhZGUtb3V0XzAuM3NfYm90aF0gcC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIlxufSwgVnAgPSB7XG4gIGZhZGVJbjogXCJzdHJpbmdcIixcbiAgZmFkZU91dDogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFhsIGV4dGVuZHMgRXQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX3RpbWVvdXQgPSBudWxsLCB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gITEsIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSAhMSwgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBIcDtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFJyO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gdm47XG4gIH1cbiAgLy8gUHVibGljXG4gIHNob3coKSB7XG4gICAgaWYgKGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBQcCkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiAoYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpLCBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSk7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFhpKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEJwKSwgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgICB9O1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKE5yKSwgR2UodGhpcy5fZWxlbWVudCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFRuLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoWGksIFwiXCIpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQuZGF0YXNldC50ZVRvYXN0U2hvdyA9PT0gdm9pZCAwIHx8IGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBOcCkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gKCkgPT4ge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiAoaSA9IDMwMCwgYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbiksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShOciwgXCJcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFhpKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoVG4pLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgUnApO1xuICAgICAgfSwgaSk7XG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShYaSwgXCJcIiksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fZWxlbWVudC5kYXRhc2V0LnRlVG9hc3RTaG93ICE9PSB2b2lkIDAgJiYgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoVG4pLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlJyLFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCA/IHQgOiB7fVxuICAgIH0sIEwodm4sIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uV3AsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwodm4sIHQsIFZwKSwgdDtcbiAgfVxuICBfbWF5YmVTY2hlZHVsZUhpZGUoKSB7XG4gICAgdGhpcy5fY29uZmlnLmF1dG9oaWRlICYmICh0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uIHx8IHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gfHwgKHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSkpKTtcbiAgfVxuICBfb25JbnRlcmFjdGlvbih0LCBlKSB7XG4gICAgc3dpdGNoICh0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJtb3VzZW92ZXJcIjpcbiAgICAgIGNhc2UgXCJtb3VzZW91dFwiOlxuICAgICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZm9jdXNpblwiOlxuICAgICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGUpIHtcbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpID0gdC5yZWxhdGVkVGFyZ2V0O1xuICAgIHRoaXMuX2VsZW1lbnQgPT09IGkgfHwgdGhpcy5fZWxlbWVudC5jb250YWlucyhpKSB8fCB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xuICB9XG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgaC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBEcCxcbiAgICAgICh0KSA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICEwKVxuICAgICksIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgJHAsXG4gICAgICAodCkgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMSlcbiAgICApLCBoLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIExwLFxuICAgICAgKHQpID0+IHRoaXMuX29uSW50ZXJhY3Rpb24odCwgITApXG4gICAgKSwgaC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBNcCxcbiAgICAgICh0KSA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICExKVxuICAgICk7XG4gIH1cbiAgX2NsZWFyVGltZW91dCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IFhsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuKCgpID0+IHtcbiAgdmFyIHMgPSB7IDQ1NDogKGksIG4sIG8pID0+IHtcbiAgICBvLmQobiwgeyBaOiAoKSA9PiBsIH0pO1xuICAgIHZhciByID0gbyg2NDUpLCBhID0gby5uKHIpKCkoZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHBbMV07XG4gICAgfSk7XG4gICAgYS5wdXNoKFtpLmlkLCBcIklOUFVUOi13ZWJraXQtYXV0b2ZpbGwsU0VMRUNUOi13ZWJraXQtYXV0b2ZpbGwsVEVYVEFSRUE6LXdlYmtpdC1hdXRvZmlsbHthbmltYXRpb24tbmFtZTpvbmF1dG9maWxsc3RhcnR9SU5QVVQ6bm90KDotd2Via2l0LWF1dG9maWxsKSxTRUxFQ1Q6bm90KDotd2Via2l0LWF1dG9maWxsKSxURVhUQVJFQTpub3QoOi13ZWJraXQtYXV0b2ZpbGwpe2FuaW1hdGlvbi1uYW1lOm9uYXV0b2ZpbGxjYW5jZWx9QGtleWZyYW1lcyBvbmF1dG9maWxsc3RhcnR7fUBrZXlmcmFtZXMgb25hdXRvZmlsbGNhbmNlbHt9XCIsIFwiXCJdKTtcbiAgICBjb25zdCBsID0gYTtcbiAgfSwgNjQ1OiAoaSkgPT4ge1xuICAgIGkuZXhwb3J0cyA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHZhciBvID0gW107XG4gICAgICByZXR1cm4gby50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocikge1xuICAgICAgICAgIHZhciBhID0gbihyKTtcbiAgICAgICAgICByZXR1cm4gclsyXSA/IFwiQG1lZGlhIFwiLmNvbmNhdChyWzJdLCBcIiB7XCIpLmNvbmNhdChhLCBcIn1cIikgOiBhO1xuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgfSwgby5pID0gZnVuY3Rpb24ociwgYSwgbCkge1xuICAgICAgICB0eXBlb2YgciA9PSBcInN0cmluZ1wiICYmIChyID0gW1tudWxsLCByLCBcIlwiXV0pO1xuICAgICAgICB2YXIgcCA9IHt9O1xuICAgICAgICBpZiAobClcbiAgICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IHRoaXMubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIHZhciBmID0gdGhpc1t1XVswXTtcbiAgICAgICAgICAgIGYgIT0gbnVsbCAmJiAocFtmXSA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF8gPSAwOyBfIDwgci5sZW5ndGg7IF8rKykge1xuICAgICAgICAgIHZhciBtID0gW10uY29uY2F0KHJbX10pO1xuICAgICAgICAgIGwgJiYgcFttWzBdXSB8fCAoYSAmJiAobVsyXSA/IG1bMl0gPSBcIlwiLmNvbmNhdChhLCBcIiBhbmQgXCIpLmNvbmNhdChtWzJdKSA6IG1bMl0gPSBhKSwgby5wdXNoKG0pKTtcbiAgICAgICAgfVxuICAgICAgfSwgbztcbiAgICB9O1xuICB9LCA4MTA6ICgpID0+IHtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA8IFwidVwiKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudChcInRlc3RcIiwgeyBjYW5jZWxhYmxlOiAhMCB9KTtcbiAgICAgICAgICBpZiAoaS5wcmV2ZW50RGVmYXVsdCgpLCBpLmRlZmF1bHRQcmV2ZW50ZWQgIT09ICEwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHByZXZlbnQgZGVmYXVsdFwiKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdmFyIG4gPSBmdW5jdGlvbihyLCBhKSB7XG4gICAgICAgICAgICB2YXIgbCwgcDtcbiAgICAgICAgICAgIHJldHVybiAoYSA9IGEgfHwge30pLmJ1YmJsZXMgPSAhIWEuYnViYmxlcywgYS5jYW5jZWxhYmxlID0gISFhLmNhbmNlbGFibGUsIChsID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKSkuaW5pdEN1c3RvbUV2ZW50KHIsIGEuYnViYmxlcywgYS5jYW5jZWxhYmxlLCBhLmRldGFpbCksIHAgPSBsLnByZXZlbnREZWZhdWx0LCBsLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHAuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0UHJldmVudGVkXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSAhMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG4ucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZSwgd2luZG93LkN1c3RvbUV2ZW50ID0gbjtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gIH0sIDM3OTogKGksIG4sIG8pID0+IHtcbiAgICB2YXIgciwgYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEUgPSB7fTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihUKSB7XG4gICAgICAgIGlmIChFW1RdID09PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgQSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoVCk7XG4gICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBBIGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgQSA9IEEuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgQSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgRVtUXSA9IEE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVbVF07XG4gICAgICB9O1xuICAgIH0oKSwgbCA9IFtdO1xuICAgIGZ1bmN0aW9uIHAoRSkge1xuICAgICAgZm9yICh2YXIgVCA9IC0xLCBBID0gMDsgQSA8IGwubGVuZ3RoOyBBKyspXG4gICAgICAgIGlmIChsW0FdLmlkZW50aWZpZXIgPT09IEUpIHtcbiAgICAgICAgICBUID0gQTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHUoRSwgVCkge1xuICAgICAgZm9yICh2YXIgQSA9IHt9LCB3ID0gW10sIFMgPSAwOyBTIDwgRS5sZW5ndGg7IFMrKykge1xuICAgICAgICB2YXIgayA9IEVbU10sIHggPSBULmJhc2UgPyBrWzBdICsgVC5iYXNlIDoga1swXSwgJCA9IEFbeF0gfHwgMCwgTyA9IFwiXCIuY29uY2F0KHgsIFwiIFwiKS5jb25jYXQoJCk7XG4gICAgICAgIEFbeF0gPSAkICsgMTtcbiAgICAgICAgdmFyIE0gPSBwKE8pLCBQID0geyBjc3M6IGtbMV0sIG1lZGlhOiBrWzJdLCBzb3VyY2VNYXA6IGtbM10gfTtcbiAgICAgICAgTSAhPT0gLTEgPyAobFtNXS5yZWZlcmVuY2VzKyssIGxbTV0udXBkYXRlcihQKSkgOiBsLnB1c2goeyBpZGVudGlmaWVyOiBPLCB1cGRhdGVyOiB5KFAsIFQpLCByZWZlcmVuY2VzOiAxIH0pLCB3LnB1c2goTyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdztcbiAgICB9XG4gICAgZnVuY3Rpb24gZihFKSB7XG4gICAgICB2YXIgVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSwgQSA9IEUuYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgIGlmIChBLm5vbmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgdmFyIHcgPSBvLm5jO1xuICAgICAgICB3ICYmIChBLm5vbmNlID0gdyk7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMoQSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIFQuc2V0QXR0cmlidXRlKGssIEFba10pO1xuICAgICAgfSksIHR5cGVvZiBFLmluc2VydCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIEUuaW5zZXJ0KFQpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBTID0gYShFLmluc2VydCB8fCBcImhlYWRcIik7XG4gICAgICAgIGlmICghUylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgICAgICBTLmFwcGVuZENoaWxkKFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFQ7XG4gICAgfVxuICAgIHZhciBfLCBtID0gKF8gPSBbXSwgZnVuY3Rpb24oRSwgVCkge1xuICAgICAgcmV0dXJuIF9bRV0gPSBULCBfLmZpbHRlcihCb29sZWFuKS5qb2luKGBcbmApO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGcoRSwgVCwgQSwgdykge1xuICAgICAgdmFyIFMgPSBBID8gXCJcIiA6IHcubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQody5tZWRpYSwgXCIge1wiKS5jb25jYXQody5jc3MsIFwifVwiKSA6IHcuY3NzO1xuICAgICAgaWYgKEUuc3R5bGVTaGVldClcbiAgICAgICAgRS5zdHlsZVNoZWV0LmNzc1RleHQgPSBtKFQsIFMpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBrID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoUyksIHggPSBFLmNoaWxkTm9kZXM7XG4gICAgICAgIHhbVF0gJiYgRS5yZW1vdmVDaGlsZCh4W1RdKSwgeC5sZW5ndGggPyBFLmluc2VydEJlZm9yZShrLCB4W1RdKSA6IEUuYXBwZW5kQ2hpbGQoayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHYoRSwgVCwgQSkge1xuICAgICAgdmFyIHcgPSBBLmNzcywgUyA9IEEubWVkaWEsIGsgPSBBLnNvdXJjZU1hcDtcbiAgICAgIGlmIChTID8gRS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBTKSA6IEUucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIiksIGsgJiYgdHlwZW9mIGJ0b2EgPCBcInVcIiAmJiAodyArPSBgXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGAuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGspKSkpLCBcIiAqL1wiKSksIEUuc3R5bGVTaGVldClcbiAgICAgICAgRS5zdHlsZVNoZWV0LmNzc1RleHQgPSB3O1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoOyBFLmZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICBFLnJlbW92ZUNoaWxkKEUuZmlyc3RDaGlsZCk7XG4gICAgICAgIEUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodykpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYiA9IG51bGwsIEMgPSAwO1xuICAgIGZ1bmN0aW9uIHkoRSwgVCkge1xuICAgICAgdmFyIEEsIHcsIFM7XG4gICAgICBpZiAoVC5zaW5nbGV0b24pIHtcbiAgICAgICAgdmFyIGsgPSBDKys7XG4gICAgICAgIEEgPSBiIHx8IChiID0gZihUKSksIHcgPSBnLmJpbmQobnVsbCwgQSwgaywgITEpLCBTID0gZy5iaW5kKG51bGwsIEEsIGssICEwKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBBID0gZihUKSwgdyA9IHYuYmluZChudWxsLCBBLCBUKSwgUyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICBpZiAoeC5wYXJlbnROb2RlID09PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB4LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoeCk7XG4gICAgICAgICAgfSkoQSk7XG4gICAgICAgIH07XG4gICAgICByZXR1cm4gdyhFKSwgZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgIGlmICh4LmNzcyA9PT0gRS5jc3MgJiYgeC5tZWRpYSA9PT0gRS5tZWRpYSAmJiB4LnNvdXJjZU1hcCA9PT0gRS5zb3VyY2VNYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgdyhFID0geCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIFMoKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGkuZXhwb3J0cyA9IGZ1bmN0aW9uKEUsIFQpIHtcbiAgICAgIChUID0gVCB8fCB7fSkuc2luZ2xldG9uIHx8IHR5cGVvZiBULnNpbmdsZXRvbiA9PSBcImJvb2xlYW5cIiB8fCAoVC5zaW5nbGV0b24gPSAociA9PT0gdm9pZCAwICYmIChyID0gISEod2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpKSwgcikpO1xuICAgICAgdmFyIEEgPSB1KEUgPSBFIHx8IFtdLCBUKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih3KSB7XG4gICAgICAgIGlmICh3ID0gdyB8fCBbXSwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHcpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBTID0gMDsgUyA8IEEubGVuZ3RoOyBTKyspIHtcbiAgICAgICAgICAgIHZhciBrID0gcChBW1NdKTtcbiAgICAgICAgICAgIGxba10ucmVmZXJlbmNlcy0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciB4ID0gdSh3LCBUKSwgJCA9IDA7ICQgPCBBLmxlbmd0aDsgJCsrKSB7XG4gICAgICAgICAgICB2YXIgTyA9IHAoQVskXSk7XG4gICAgICAgICAgICBsW09dLnJlZmVyZW5jZXMgPT09IDAgJiYgKGxbT10udXBkYXRlcigpLCBsLnNwbGljZShPLCAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEEgPSB4O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH0gfSwgdCA9IHt9O1xuICBmdW5jdGlvbiBlKGkpIHtcbiAgICB2YXIgbiA9IHRbaV07XG4gICAgaWYgKG4gIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBuLmV4cG9ydHM7XG4gICAgdmFyIG8gPSB0W2ldID0geyBpZDogaSwgZXhwb3J0czoge30gfTtcbiAgICByZXR1cm4gc1tpXShvLCBvLmV4cG9ydHMsIGUpLCBvLmV4cG9ydHM7XG4gIH1cbiAgZS5uID0gKGkpID0+IHtcbiAgICB2YXIgbiA9IGkgJiYgaS5fX2VzTW9kdWxlID8gKCkgPT4gaS5kZWZhdWx0IDogKCkgPT4gaTtcbiAgICByZXR1cm4gZS5kKG4sIHsgYTogbiB9KSwgbjtcbiAgfSwgZS5kID0gKGksIG4pID0+IHtcbiAgICBmb3IgKHZhciBvIGluIG4pXG4gICAgICBlLm8obiwgbykgJiYgIWUubyhpLCBvKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgbywgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBuW29dIH0pO1xuICB9LCBlLm8gPSAoaSwgbikgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksIG4pLCAoKCkgPT4ge1xuICAgIHZhciBpID0gZSgzNzkpLCBuID0gZS5uKGkpLCBvID0gZSg0NTQpO1xuICAgIGZ1bmN0aW9uIHIobCkge1xuICAgICAgaWYgKCFsLmhhc0F0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIikpIHtcbiAgICAgICAgbC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIsIFwiXCIpO1xuICAgICAgICB2YXIgcCA9IG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoXCJvbmF1dG9jb21wbGV0ZVwiLCB7IGJ1YmJsZXM6ICEwLCBjYW5jZWxhYmxlOiAhMCwgZGV0YWlsOiBudWxsIH0pO1xuICAgICAgICBsLmRpc3BhdGNoRXZlbnQocCkgfHwgKGwudmFsdWUgPSBcIlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYShsKSB7XG4gICAgICBsLmhhc0F0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIikgJiYgKGwucmVtb3ZlQXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiKSwgbC5kaXNwYXRjaEV2ZW50KG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoXCJvbmF1dG9jb21wbGV0ZVwiLCB7IGJ1YmJsZXM6ICEwLCBjYW5jZWxhYmxlOiAhMSwgZGV0YWlsOiBudWxsIH0pKSk7XG4gICAgfVxuICAgIG4oKShvLlosIHsgaW5zZXJ0OiBcImhlYWRcIiwgc2luZ2xldG9uOiAhMSB9KSwgby5aLmxvY2FscywgZSg4MTApLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uc3RhcnRcIiwgZnVuY3Rpb24obCkge1xuICAgICAgbC5hbmltYXRpb25OYW1lID09PSBcIm9uYXV0b2ZpbGxzdGFydFwiID8gcihsLnRhcmdldCkgOiBhKGwudGFyZ2V0KTtcbiAgICB9LCAhMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbihsKSB7XG4gICAgICBsLmlucHV0VHlwZSAhPT0gXCJpbnNlcnRSZXBsYWNlbWVudFRleHRcIiAmJiBcImRhdGFcIiBpbiBsID8gYShsLnRhcmdldCkgOiByKGwudGFyZ2V0KTtcbiAgICB9LCAhMCk7XG4gIH0pKCk7XG59KSgpO1xuY29uc3QgRW4gPSBcImlucHV0XCIsIEdpID0gXCJ0ZS5pbnB1dFwiLCBHbCA9IFwiZGF0YS10ZS1pbnB1dC13cmFwcGVyLWluaXRcIiwgcWwgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtcmVmXCIsIFpsID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLWxlYWRpbmctcmVmXCIsIFFsID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLW1pZGRsZS1yZWZcIiwgRnAgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtdHJhaWxpbmctcmVmXCIsIFlwID0gXCJkYXRhLXRlLWlucHV0LWhlbHBlci1yZWZcIiwganAgPSBcImRhdGEtdGUtaW5wdXQtcGxhY2Vob2xkZXItYWN0aXZlXCIsIEZ0ID0gXCJkYXRhLXRlLWlucHV0LXN0YXRlLWFjdGl2ZVwiLCBQciA9IFwiZGF0YS10ZS1pbnB1dC1mb2N1c2VkXCIsIEJyID0gXCJkYXRhLXRlLWlucHV0LWZvcm0tY291bnRlclwiLCBoZSA9IGBbJHtHbH1dIGlucHV0YCwgZGUgPSBgWyR7R2x9XSB0ZXh0YXJlYWAsIHdlID0gYFske3FsfV1gLCBIciA9IGBbJHtabH1dYCwgV3IgPSBgWyR7UWx9XWAsIEtwID0gYFske1lwfV1gLCB6cCA9IHtcbiAgaW5wdXRGb3JtV2hpdGU6ICExXG59LCBVcCA9IHtcbiAgaW5wdXRGb3JtV2hpdGU6IFwiKGJvb2xlYW4pXCJcbn0sIFhwID0ge1xuICBub3RjaDogXCJncm91cCBmbGV4IGFic29sdXRlIGxlZnQtMCB0b3AtMCB3LWZ1bGwgbWF4LXctZnVsbCBoLWZ1bGwgdGV4dC1sZWZ0IHBvaW50ZXItZXZlbnRzLW5vbmVcIixcbiAgbm90Y2hMZWFkaW5nOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBsZWZ0LTAgdG9wLTAgaC1mdWxsIHctMiBib3JkZXItci0wIHJvdW5kZWQtbC1bMC4yNXJlbV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXItMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci1yLTBcIixcbiAgbm90Y2hMZWFkaW5nTm9ybWFsOiBcImJvcmRlci1uZXV0cmFsLTMwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWy0xcHhfMF8wXyMzYjcxY2EsXzBfMXB4XzBfMF8jM2I3MWNhLF8wXy0xcHhfMF8wXyMzYjcxY2FdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCIsXG4gIG5vdGNoTGVhZGluZ1doaXRlOiBcImJvcmRlci1uZXV0cmFsLTIwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWy0xcHhfMF8wXyNmZmZmZmYsXzBfMXB4XzBfMF8jZmZmZmZmLF8wXy0xcHhfMF8wXyNmZmZmZmZdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci13aGl0ZVwiLFxuICBub3RjaE1pZGRsZTogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZ3Jvdy0wIHNocmluay0wIGJhc2lzLWF1dG8gdy1hdXRvIG1heC13LVtjYWxjKDEwMCUtMXJlbSldIGgtZnVsbCBib3JkZXItci0wIGJvcmRlci1sLTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXgtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci14LTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItdCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItc29saWQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItc29saWQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXQtdHJhbnNwYXJlbnQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItdC10cmFuc3BhcmVudFwiLFxuICBub3RjaE1pZGRsZU5vcm1hbDogXCJib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVswXzFweF8wXzBfIzNiNzFjYV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXByaW1hcnlcIixcbiAgbm90Y2hNaWRkbGVXaGl0ZTogXCJib3JkZXItbmV1dHJhbC0yMDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVswXzFweF8wXzBfI2ZmZmZmZl0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXdoaXRlXCIsXG4gIG5vdGNoVHJhaWxpbmc6IFwicG9pbnRlci1ldmVudHMtbm9uZSBib3JkZXIgYm9yZGVyLXNvbGlkIGJveC1ib3JkZXIgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGdyb3cgaC1mdWxsIGJvcmRlci1sLTAgcm91bmRlZC1yLVswLjI1cmVtXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItbC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLWwtMFwiLFxuICBub3RjaFRyYWlsaW5nTm9ybWFsOiBcImJvcmRlci1uZXV0cmFsLTMwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzFweF8wXzBfIzNiNzFjYSxfMF8tMXB4XzBfMF8jM2I3MWNhLF8wXzFweF8wXzBfIzNiNzFjYV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXByaW1hcnlcIixcbiAgbm90Y2hUcmFpbGluZ1doaXRlOiBcImJvcmRlci1uZXV0cmFsLTIwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzFweF8wXzBfI2ZmZmZmZixfMF8tMXB4XzBfMF8jZmZmZmZmLF8wXzFweF8wXzBfI2ZmZmZmZl0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXdoaXRlXCIsXG4gIGNvdW50ZXI6IFwidGV4dC1yaWdodCBsZWFkaW5nLVsxLjZdXCJcbn0sIEdwID0ge1xuICBub3RjaDogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nOiBcInN0cmluZ1wiLFxuICBub3RjaExlYWRpbmdOb3JtYWw6IFwic3RyaW5nXCIsXG4gIG5vdGNoTGVhZGluZ1doaXRlOiBcInN0cmluZ1wiLFxuICBub3RjaE1pZGRsZTogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGVOb3JtYWw6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlV2hpdGU6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmc6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmdOb3JtYWw6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmdXaGl0ZTogXCJzdHJpbmdcIixcbiAgY291bnRlcjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFcge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUsIHQpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2xhYmVsID0gbnVsbCwgdGhpcy5fbGFiZWxXaWR0aCA9IDAsIHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IDAsIHRoaXMuX25vdGNoTGVhZGluZyA9IG51bGwsIHRoaXMuX25vdGNoTWlkZGxlID0gbnVsbCwgdGhpcy5fbm90Y2hUcmFpbGluZyA9IG51bGwsIHRoaXMuX2luaXRpYXRlZCA9ICExLCB0aGlzLl9oZWxwZXIgPSBudWxsLCB0aGlzLl9jb3VudGVyID0gITEsIHRoaXMuX2NvdW50ZXJFbGVtZW50ID0gbnVsbCwgdGhpcy5fbWF4TGVuZ3RoID0gMCwgdGhpcy5fbGVhZGluZ0ljb24gPSBudWxsLCB0aGlzLl9lbGVtZW50ICYmIChJLnNldERhdGEodCwgR2ksIHRoaXMpLCB0aGlzLmluaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEVuO1xuICB9XG4gIGdldCBpbnB1dCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCkgfHwgZC5maW5kT25lKFwidGV4dGFyZWFcIiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgdGhpcy5faW5pdGlhdGVkIHx8ICh0aGlzLl9nZXRMYWJlbERhdGEoKSwgdGhpcy5fYXBwbHlEaXZzKCksIHRoaXMuX2FwcGx5Tm90Y2goKSwgdGhpcy5fYWN0aXZhdGUoKSwgdGhpcy5fZ2V0SGVscGVyKCksIHRoaXMuX2dldENvdW50ZXIoKSwgdGhpcy5fZ2V0RXZlbnRzKCksIHRoaXMuX2luaXRpYXRlZCA9ICEwKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fZ2V0TGFiZWxEYXRhKCksIHRoaXMuX2dldE5vdGNoRGF0YSgpLCB0aGlzLl9hcHBseU5vdGNoKCksIHRoaXMuX2FjdGl2YXRlKCksIHRoaXMuX2dldEhlbHBlcigpLCB0aGlzLl9nZXRDb3VudGVyKCk7XG4gIH1cbiAgZm9yY2VBY3RpdmUoKSB7XG4gICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoRnQsIFwiXCIpLCBkLmZpbmRPbmUod2UsIHRoaXMuaW5wdXQucGFyZW50Tm9kZSkuc2V0QXR0cmlidXRlKFxuICAgICAgRnQsXG4gICAgICBcIlwiXG4gICAgKTtcbiAgfVxuICBmb3JjZUluYWN0aXZlKCkge1xuICAgIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKEZ0KSwgZC5maW5kT25lKFxuICAgICAgd2UsXG4gICAgICB0aGlzLmlucHV0LnBhcmVudE5vZGVcbiAgICApLnJlbW92ZUF0dHJpYnV0ZShGdCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9yZW1vdmVCb3JkZXIoKSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIEdpKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q29uZmlnKHQsIGUpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnpwLFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyhlKSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCBMKEVuLCB0LCBVcCksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5YcCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTChFbiwgdCwgR3ApLCB0O1xuICB9XG4gIF9nZXRMYWJlbERhdGEoKSB7XG4gICAgdGhpcy5fbGFiZWwgPSBkLmZpbmRPbmUoXCJsYWJlbFwiLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fbGFiZWwgPT09IG51bGwgPyB0aGlzLl9zaG93UGxhY2Vob2xkZXIoKSA6ICh0aGlzLl9nZXRMYWJlbFdpZHRoKCksIHRoaXMuX2dldExhYmVsUG9zaXRpb25JbklucHV0R3JvdXAoKSwgdGhpcy5fdG9nZ2xlRGVmYXVsdERhdGVQbGFjZWhvbGRlcigpKTtcbiAgfVxuICBfZ2V0SGVscGVyKCkge1xuICAgIHRoaXMuX2hlbHBlciA9IGQuZmluZE9uZShLcCwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX2dldENvdW50ZXIoKSB7XG4gICAgdGhpcy5fY291bnRlciA9IGMuZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgIHRoaXMuaW5wdXQsXG4gICAgICBcImlucHV0U2hvd2NvdW50ZXJcIlxuICAgICksIHRoaXMuX2NvdW50ZXIgJiYgKHRoaXMuX21heExlbmd0aCA9IHRoaXMuaW5wdXQubWF4TGVuZ3RoLCB0aGlzLl9zaG93Q291bnRlcigpKTtcbiAgfVxuICBfZ2V0RXZlbnRzKCkge1xuICAgIGgub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgIGhlLFxuICAgICAgVy5hY3RpdmF0ZShuZXcgVygpKVxuICAgICksIGgub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIGhlLFxuICAgICAgVy5hY3RpdmF0ZShuZXcgVygpKVxuICAgICksIGgub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiYmx1clwiLFxuICAgICAgaGUsXG4gICAgICBXLmRlYWN0aXZhdGUobmV3IFcoKSlcbiAgICApLCBoLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImZvY3VzXCIsXG4gICAgICBkZSxcbiAgICAgIFcuYWN0aXZhdGUobmV3IFcoKSlcbiAgICApLCBoLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImlucHV0XCIsXG4gICAgICBkZSxcbiAgICAgIFcuYWN0aXZhdGUobmV3IFcoKSlcbiAgICApLCBoLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImJsdXJcIixcbiAgICAgIGRlLFxuICAgICAgVy5kZWFjdGl2YXRlKG5ldyBXKCkpXG4gICAgKSwgaC5vbih3aW5kb3csIFwic2hvd24udGUubW9kYWxcIiwgKHQpID0+IHtcbiAgICAgIGQuZmluZChoZSwgdC50YXJnZXQpLmZvckVhY2goXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IFcuZ2V0SW5zdGFuY2UoZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBpICYmIGkudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICksIGQuZmluZChkZSwgdC50YXJnZXQpLmZvckVhY2goXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IFcuZ2V0SW5zdGFuY2UoZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBpICYmIGkudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSksIGgub24od2luZG93LCBcInNob3duLnRlLmRyb3Bkb3duXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC50YXJnZXQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBcIltkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXVwiXG4gICAgICApO1xuICAgICAgZSAmJiAoZC5maW5kKGhlLCBlKS5mb3JFYWNoKFxuICAgICAgICAoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG4gPSBXLmdldEluc3RhbmNlKGkucGFyZW50Tm9kZSk7XG4gICAgICAgICAgbiAmJiBuLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApLCBkLmZpbmQoZGUsIGUpLmZvckVhY2goXG4gICAgICAgIChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbiA9IFcuZ2V0SW5zdGFuY2UoaS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBuICYmIG4udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgIH0pLCBoLm9uKHdpbmRvdywgXCJzaG93bi50ZS50YWJcIiwgKHQpID0+IHtcbiAgICAgIGxldCBlO1xuICAgICAgdC50YXJnZXQuaHJlZiA/IGUgPSB0LnRhcmdldC5ocmVmLnNwbGl0KFwiI1wiKVsxXSA6IGUgPSBjLmdldERhdGFBdHRyaWJ1dGUodC50YXJnZXQsIFwidGFyZ2V0XCIpLnNwbGl0KFxuICAgICAgICBcIiNcIlxuICAgICAgKVsxXTtcbiAgICAgIGNvbnN0IGkgPSBkLmZpbmRPbmUoYCMke2V9YCk7XG4gICAgICBkLmZpbmQoaGUsIGkpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgY29uc3QgbyA9IFcuZ2V0SW5zdGFuY2Uobi5wYXJlbnROb2RlKTtcbiAgICAgICAgbyAmJiBvLnVwZGF0ZSgpO1xuICAgICAgfSksIGQuZmluZChkZSwgaSkuZm9yRWFjaChcbiAgICAgICAgKG4pID0+IHtcbiAgICAgICAgICBjb25zdCBvID0gVy5nZXRJbnN0YW5jZShuLnBhcmVudE5vZGUpO1xuICAgICAgICAgIG8gJiYgby51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KSwgaC5vbih3aW5kb3csIFwicmVzZXRcIiwgKHQpID0+IHtcbiAgICAgIGQuZmluZChoZSwgdC50YXJnZXQpLmZvckVhY2goXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IFcuZ2V0SW5zdGFuY2UoZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBpICYmIGkuZm9yY2VJbmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICApLCBkLmZpbmQoZGUsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBXLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaSAmJiBpLmZvcmNlSW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KSwgaC5vbih3aW5kb3csIFwib25hdXRvY29tcGxldGVcIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBXLmdldEluc3RhbmNlKHQudGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgIWUgfHwgIXQuY2FuY2VsYWJsZSB8fCBlLmZvcmNlQWN0aXZlKCk7XG4gICAgfSk7XG4gIH1cbiAgX3Nob3dDb3VudGVyKCkge1xuICAgIGlmIChkLmZpbmQoXG4gICAgICBgWyR7QnJ9XWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKS5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NvdW50ZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgYy5hZGRDbGFzcyh0aGlzLl9jb3VudGVyRWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5jb3VudGVyKSwgdGhpcy5fY291bnRlckVsZW1lbnQuc2V0QXR0cmlidXRlKEJyLCBcIlwiKTtcbiAgICBjb25zdCBlID0gdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGg7XG4gICAgdGhpcy5fY291bnRlckVsZW1lbnQuaW5uZXJIVE1MID0gYCR7ZX0gLyAke3RoaXMuX21heExlbmd0aH1gLCB0aGlzLl9oZWxwZXIuYXBwZW5kQ2hpbGQodGhpcy5fY291bnRlckVsZW1lbnQpLCB0aGlzLl9iaW5kQ291bnRlcigpO1xuICB9XG4gIF9iaW5kQ291bnRlcigpIHtcbiAgICBoLm9uKHRoaXMuaW5wdXQsIFwiaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoO1xuICAgICAgdGhpcy5fY291bnRlckVsZW1lbnQuaW5uZXJIVE1MID0gYCR7dH0gLyAke3RoaXMuX21heExlbmd0aH1gO1xuICAgIH0pO1xuICB9XG4gIF90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKHQgPSB0aGlzLmlucHV0KSB7XG4gICAgaWYgKCEodC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09PSBcImRhdGVcIikpXG4gICAgICByZXR1cm47XG4gICAgIShkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0KSAmJiAhdC52YWx1ZSA/IHQuc3R5bGUub3BhY2l0eSA9IDAgOiB0LnN0eWxlLm9wYWNpdHkgPSAxO1xuICB9XG4gIF9zaG93UGxhY2Vob2xkZXIoKSB7XG4gICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoanAsIFwiXCIpO1xuICB9XG4gIF9nZXROb3RjaERhdGEoKSB7XG4gICAgdGhpcy5fbm90Y2hNaWRkbGUgPSBkLmZpbmRPbmUoXG4gICAgICBXcixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBkLmZpbmRPbmUoXG4gICAgICBIcixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICB9XG4gIF9nZXRMYWJlbFdpZHRoKCkge1xuICAgIHRoaXMuX2xhYmVsV2lkdGggPSB0aGlzLl9sYWJlbC5jbGllbnRXaWR0aCAqIDAuOCArIDg7XG4gIH1cbiAgX2dldExhYmVsUG9zaXRpb25JbklucHV0R3JvdXAoKSB7XG4gICAgaWYgKHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IDAsICF0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtdGUtaW5wdXQtZ3JvdXAtcmVmXCIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB0aGlzLmlucHV0LCBlID0gZC5wcmV2KFxuICAgICAgdCxcbiAgICAgIFwiW2RhdGEtdGUtaW5wdXQtZ3JvdXAtdGV4dC1yZWZdXCJcbiAgICApWzBdO1xuICAgIGUgPT09IHZvaWQgMCA/IHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IDAgOiB0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSBlLm9mZnNldFdpZHRoIC0gMTtcbiAgfVxuICBfYXBwbHlEaXZzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuaW5wdXRGb3JtV2hpdGUgPyB0aGlzLl9jbGFzc2VzLm5vdGNoTGVhZGluZ1doaXRlIDogdGhpcy5fY2xhc3Nlcy5ub3RjaExlYWRpbmdOb3JtYWwsIGUgPSB0aGlzLl9jb25maWcuaW5wdXRGb3JtV2hpdGUgPyB0aGlzLl9jbGFzc2VzLm5vdGNoTWlkZGxlV2hpdGUgOiB0aGlzLl9jbGFzc2VzLm5vdGNoTWlkZGxlTm9ybWFsLCBpID0gdGhpcy5fY29uZmlnLmlucHV0Rm9ybVdoaXRlID8gdGhpcy5fY2xhc3Nlcy5ub3RjaFRyYWlsaW5nV2hpdGUgOiB0aGlzLl9jbGFzc2VzLm5vdGNoVHJhaWxpbmdOb3JtYWwsIG4gPSBkLmZpbmQod2UsIHRoaXMuX2VsZW1lbnQpLCBvID0gRChcImRpdlwiKTtcbiAgICBjLmFkZENsYXNzKG8sIHRoaXMuX2NsYXNzZXMubm90Y2gpLCBvLnNldEF0dHJpYnV0ZShxbCwgXCJcIiksIHRoaXMuX25vdGNoTGVhZGluZyA9IEQoXCJkaXZcIiksIGMuYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9ub3RjaExlYWRpbmcsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLm5vdGNoTGVhZGluZ30gJHt0fWBcbiAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcuc2V0QXR0cmlidXRlKFpsLCBcIlwiKSwgdGhpcy5fbm90Y2hNaWRkbGUgPSBEKFwiZGl2XCIpLCBjLmFkZENsYXNzKFxuICAgICAgdGhpcy5fbm90Y2hNaWRkbGUsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLm5vdGNoTWlkZGxlfSAke2V9YFxuICAgICksIHRoaXMuX25vdGNoTWlkZGxlLnNldEF0dHJpYnV0ZShRbCwgXCJcIiksIHRoaXMuX25vdGNoVHJhaWxpbmcgPSBEKFwiZGl2XCIpLCBjLmFkZENsYXNzKFxuICAgICAgdGhpcy5fbm90Y2hUcmFpbGluZyxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubm90Y2hUcmFpbGluZ30gJHtpfWBcbiAgICApLCB0aGlzLl9ub3RjaFRyYWlsaW5nLnNldEF0dHJpYnV0ZShGcCwgXCJcIiksICEobi5sZW5ndGggPj0gMSkgJiYgKG8uYXBwZW5kKHRoaXMuX25vdGNoTGVhZGluZyksIG8uYXBwZW5kKHRoaXMuX25vdGNoTWlkZGxlKSwgby5hcHBlbmQodGhpcy5fbm90Y2hUcmFpbGluZyksIHRoaXMuX2VsZW1lbnQuYXBwZW5kKG8pKTtcbiAgfVxuICBfYXBwbHlOb3RjaCgpIHtcbiAgICB0aGlzLl9ub3RjaE1pZGRsZS5zdHlsZS53aWR0aCA9IGAke3RoaXMuX2xhYmVsV2lkdGh9cHhgLCB0aGlzLl9ub3RjaExlYWRpbmcuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9sYWJlbE1hcmdpbkxlZnQgKyA5fXB4YCwgdGhpcy5fbGFiZWwgIT09IG51bGwgJiYgKHRoaXMuX2xhYmVsLnN0eWxlLm1hcmdpbkxlZnQgPSBgJHt0aGlzLl9sYWJlbE1hcmdpbkxlZnR9cHhgKTtcbiAgfVxuICBfcmVtb3ZlQm9yZGVyKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUod2UsIHRoaXMuX2VsZW1lbnQpO1xuICAgIHQgJiYgdC5yZW1vdmUoKTtcbiAgfVxuICBfYWN0aXZhdGUodCkge1xuICAgIGlsKCgpID0+IHtcbiAgICAgIHRoaXMuX2dldEVsZW1lbnRzKHQpO1xuICAgICAgY29uc3QgZSA9IHQgPyB0LnRhcmdldCA6IHRoaXMuaW5wdXQsIGkgPSBkLmZpbmRPbmUoXG4gICAgICAgIHdlLFxuICAgICAgICB0aGlzLl9lbGVtZW50XG4gICAgICApO1xuICAgICAgdCAmJiB0LnR5cGUgPT09IFwiZm9jdXNcIiAmJiBpLnNldEF0dHJpYnV0ZShQciwgXCJcIiksIGUudmFsdWUgIT09IFwiXCIgJiYgKGUuc2V0QXR0cmlidXRlKEZ0LCBcIlwiKSwgaS5zZXRBdHRyaWJ1dGUoRnQsIFwiXCIpKSwgdGhpcy5fdG9nZ2xlRGVmYXVsdERhdGVQbGFjZWhvbGRlcihlKTtcbiAgICB9KTtcbiAgfVxuICBfZ2V0RWxlbWVudHModCkge1xuICAgIGlmICh0ICYmICh0aGlzLl9lbGVtZW50ID0gdC50YXJnZXQucGFyZW50Tm9kZSwgdGhpcy5fbGFiZWwgPSBkLmZpbmRPbmUoXCJsYWJlbFwiLCB0aGlzLl9lbGVtZW50KSksIHQgJiYgdGhpcy5fbGFiZWwpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9sYWJlbFdpZHRoO1xuICAgICAgdGhpcy5fZ2V0TGFiZWxEYXRhKCksIGUgIT09IHRoaXMuX2xhYmVsV2lkdGggJiYgKHRoaXMuX25vdGNoTWlkZGxlID0gZC5maW5kT25lKFxuICAgICAgICBXcixcbiAgICAgICAgdC50YXJnZXQucGFyZW50Tm9kZVxuICAgICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gZC5maW5kT25lKFxuICAgICAgICBIcixcbiAgICAgICAgdC50YXJnZXQucGFyZW50Tm9kZVxuICAgICAgKSwgdGhpcy5fYXBwbHlOb3RjaCgpKTtcbiAgICB9XG4gIH1cbiAgX2RlYWN0aXZhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0ID8gdC50YXJnZXQgOiB0aGlzLmlucHV0LCBpID0gZC5maW5kT25lKFxuICAgICAgd2UsXG4gICAgICBlLnBhcmVudE5vZGVcbiAgICApO1xuICAgIGkucmVtb3ZlQXR0cmlidXRlKFByKSwgZS52YWx1ZSA9PT0gXCJcIiAmJiAoZS5yZW1vdmVBdHRyaWJ1dGUoRnQpLCBpLnJlbW92ZUF0dHJpYnV0ZShGdCkpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKGUpO1xuICB9XG4gIHN0YXRpYyBhY3RpdmF0ZSh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHQuX2FjdGl2YXRlKGUpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlYWN0aXZhdGUodCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB0Ll9kZWFjdGl2YXRlKGUpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gSS5nZXREYXRhKHRoaXMsIEdpKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgVyh0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBHaSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgVnIgPSBcImFuaW1hdGlvblwiLCBDbiA9IFwidGUuYW5pbWF0aW9uXCIsIHFwID0ge1xuICBhbmltYXRpb246IFwic3RyaW5nXCIsXG4gIGFuaW1hdGlvblN0YXJ0OiBcInN0cmluZ1wiLFxuICBhbmltYXRpb25TaG93T25Mb2FkOiBcImJvb2xlYW5cIixcbiAgb25TdGFydDogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgb25FbmQ6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIG9uSGlkZTogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgb25TaG93OiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBhbmltYXRpb25PblNjcm9sbDogXCIoc3RyaW5nKVwiLFxuICBhbmltYXRpb25XaW5kb3dIZWlnaHQ6IFwibnVtYmVyXCIsXG4gIGFuaW1hdGlvbk9mZnNldDogXCIobnVtYmVyfHN0cmluZylcIixcbiAgYW5pbWF0aW9uRGVsYXk6IFwiKG51bWJlcnxzdHJpbmcpXCIsXG4gIGFuaW1hdGlvblJldmVyc2U6IFwiYm9vbGVhblwiLFxuICBhbmltYXRpb25JbnRlcnZhbDogXCIobnVtYmVyfHN0cmluZylcIixcbiAgYW5pbWF0aW9uUmVwZWF0OiBcIihudW1iZXJ8Ym9vbGVhbilcIixcbiAgYW5pbWF0aW9uUmVzZXQ6IFwiYm9vbGVhblwiXG59LCBacCA9IHtcbiAgYW5pbWF0aW9uOiBcImZhZGVcIixcbiAgYW5pbWF0aW9uU3RhcnQ6IFwib25DbGlja1wiLFxuICBhbmltYXRpb25TaG93T25Mb2FkOiAhMCxcbiAgb25TdGFydDogbnVsbCxcbiAgb25FbmQ6IG51bGwsXG4gIG9uSGlkZTogbnVsbCxcbiAgb25TaG93OiBudWxsLFxuICBhbmltYXRpb25PblNjcm9sbDogXCJvbmNlXCIsXG4gIGFuaW1hdGlvbldpbmRvd0hlaWdodDogMCxcbiAgYW5pbWF0aW9uT2Zmc2V0OiAwLFxuICBhbmltYXRpb25EZWxheTogMCxcbiAgYW5pbWF0aW9uUmV2ZXJzZTogITEsXG4gIGFuaW1hdGlvbkludGVydmFsOiAwLFxuICBhbmltYXRpb25SZXBlYXQ6ICExLFxuICBhbmltYXRpb25SZXNldDogITFcbn07XG5jbGFzcyBKbCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fYW5pbWF0ZUVsZW1lbnQgPSB0aGlzLl9nZXRBbmltYXRlRWxlbWVudCgpLCB0aGlzLl9pc0ZpcnN0U2Nyb2xsID0gITAsIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCA9ICEwLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9lbGVtZW50ICYmIChJLnNldERhdGEodCwgQ24sIHRoaXMpLCB0aGlzLl9pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBWcjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cbiAgc3RhcnRBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgfVxuICBzdG9wQW5pbWF0aW9uKCkge1xuICAgIHRoaXMuX2NsZWFyQW5pbWF0aW9uQ2xhc3MoKTtcbiAgfVxuICBjaGFuZ2VBbmltYXRpb25UeXBlKHQpIHtcbiAgICB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbiA9IHQ7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBoLm9mZih0aGlzLl9lbGVtZW50LCBcIm1vdXNlZG93blwiKSwgaC5vZmYodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIpLCBoLm9mZih3aW5kb3csIFwic2Nyb2xsXCIpLCBoLm9mZih0aGlzLl9lbGVtZW50LCBcIm1vdXNlb3ZlclwiKSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIENuKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX2FuaW1hdGVFbGVtZW50ID0gbnVsbCwgdGhpcy5faXNGaXJzdFNjcm9sbCA9IG51bGwsIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLmFuaW1hdGlvblN0YXJ0KSB7XG4gICAgICBjYXNlIFwib25Ib3ZlclwiOlxuICAgICAgICB0aGlzLl9iaW5kSG92ZXJFdmVudHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib25Mb2FkXCI6XG4gICAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm9uU2Nyb2xsXCI6XG4gICAgICAgIHRoaXMuX2JpbmRTY3JvbGxFdmVudHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib25DbGlja1wiOlxuICAgICAgICB0aGlzLl9iaW5kQ2xpY2tFdmVudHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX2JpbmRUcmlnZ2VyT25FbmRDYWxsYmFjaygpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJlc2V0ICYmIHRoaXMuX2JpbmRSZXNldEFuaW1hdGlvbkFmdGVyRmluaXNoKCk7XG4gIH1cbiAgX2dldEFuaW1hdGVFbGVtZW50KCkge1xuICAgIGNvbnN0IHQgPSBjLmdldERhdGFBdHRyaWJ1dGUoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJhbmltYXRpb24tdGFyZ2V0XCJcbiAgICApO1xuICAgIHJldHVybiB0ID8gZC5maW5kKHQpWzBdIDogdGhpcy5fZWxlbWVudDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9hbmltYXRlRWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5acCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTChWciwgdCwgcXApLCB0O1xuICB9XG4gIF9hbmltYXRlT25TY3JvbGwoKSB7XG4gICAgY29uc3QgdCA9IGMub2Zmc2V0KHRoaXMuX2FuaW1hdGVFbGVtZW50KS50b3AsIGUgPSB0aGlzLl9hbmltYXRlRWxlbWVudC5vZmZzZXRIZWlnaHQsIGkgPSB3aW5kb3cuaW5uZXJIZWlnaHQsIG4gPSB0ICsgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25PZmZzZXQgPD0gaSAmJiB0ICsgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25PZmZzZXQgKyBlID49IDAsIG8gPSB0aGlzLl9hbmltYXRlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID09PSBcInZpc2libGVcIjtcbiAgICBzd2l0Y2ggKCEwKSB7XG4gICAgICBjYXNlIChuICYmIHRoaXMuX2lzRmlyc3RTY3JvbGwpOlxuICAgICAgICB0aGlzLl9pc0ZpcnN0U2Nyb2xsID0gITEsIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAoIW4gJiYgdGhpcy5faXNGaXJzdFNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMSwgdGhpcy5faGlkZUFuaW1hdGVFbGVtZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAobiAmJiAhbyAmJiB0aGlzLl9yZXBlYXRBbmltYXRlT25TY3JvbGwpOlxuICAgICAgICB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9uU2Nyb2xsICE9PSBcInJlcGVhdFwiICYmICh0aGlzLl9yZXBlYXRBbmltYXRlT25TY3JvbGwgPSAhMSksIHRoaXMuX2NhbGxiYWNrKHRoaXMuX29wdGlvbnMub25TaG93KSwgdGhpcy5fc2hvd0FuaW1hdGVFbGVtZW50KCksIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAoIW4gJiYgbyAmJiB0aGlzLl9yZXBlYXRBbmltYXRlT25TY3JvbGwpOlxuICAgICAgICB0aGlzLl9oaWRlQW5pbWF0ZUVsZW1lbnQoKSwgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpLCB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uSGlkZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfYWRkQW5pbWF0ZWRDbGFzcygpIHtcbiAgICBjLmFkZENsYXNzKFxuICAgICAgdGhpcy5fYW5pbWF0ZUVsZW1lbnQsXG4gICAgICBgYW5pbWF0ZS0ke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9ufWBcbiAgICApO1xuICB9XG4gIF9jbGVhckFuaW1hdGlvbkNsYXNzKCkge1xuICAgIHRoaXMuX2FuaW1hdGVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoYGFuaW1hdGUtJHt0aGlzLl9vcHRpb25zLmFuaW1hdGlvbn1gKTtcbiAgfVxuICBfc3RhcnRBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sodGhpcy5fb3B0aW9ucy5vblN0YXJ0KSwgdGhpcy5fYWRkQW5pbWF0ZWRDbGFzcygpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJlcGVhdCAmJiAhdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCAmJiB0aGlzLl9zZXRBbmltYXRpb25SZXBlYXQoKSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXZlcnNlICYmIHRoaXMuX3NldEFuaW1hdGlvblJldmVyc2UoKSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25EZWxheSAmJiB0aGlzLl9zZXRBbmltYXRpb25EZWxheSgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uICYmIHRoaXMuX3NldEFuaW1hdGlvbkR1cmF0aW9uKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uSW50ZXJ2YWwgJiYgdGhpcy5fc2V0QW5pbWF0aW9uSW50ZXJ2YWwoKTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uUmV2ZXJzZSgpIHtcbiAgICBjLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXQgPT09ICEwID8gXCJpbmZpbml0ZVwiIDogXCIyXCIsXG4gICAgICBhbmltYXRpb25EaXJlY3Rpb246IFwiYWx0ZXJuYXRlXCJcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uRHVyYXRpb24oKSB7XG4gICAgYy5zdHlsZSh0aGlzLl9hbmltYXRlRWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uRHVyYXRpb246IGAke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb259bXNgXG4gICAgfSk7XG4gIH1cbiAgX3NldEFuaW1hdGlvbkRlbGF5KCkge1xuICAgIGMuc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHtcbiAgICAgIGFuaW1hdGlvbkRlbGF5OiBgJHt0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkRlbGF5fW1zYFxuICAgIH0pO1xuICB9XG4gIF9zZXRBbmltYXRpb25SZXBlYXQoKSB7XG4gICAgYy5zdHlsZSh0aGlzLl9hbmltYXRlRWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVwZWF0ID09PSAhMCA/IFwiaW5maW5pdGVcIiA6IHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVwZWF0XG4gICAgfSk7XG4gIH1cbiAgX3NldEFuaW1hdGlvbkludGVydmFsKCkge1xuICAgIGgub24odGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkQW5pbWF0ZWRDbGFzcygpO1xuICAgICAgfSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCk7XG4gICAgfSk7XG4gIH1cbiAgX2hpZGVBbmltYXRlRWxlbWVudCgpIHtcbiAgICBjLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfSk7XG4gIH1cbiAgX3Nob3dBbmltYXRlRWxlbWVudCgpIHtcbiAgICBjLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7IHZpc2liaWxpdHk6IFwidmlzaWJsZVwiIH0pO1xuICB9XG4gIF9iaW5kUmVzZXRBbmltYXRpb25BZnRlckZpbmlzaCgpIHtcbiAgICBoLm9uKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRUcmlnZ2VyT25FbmRDYWxsYmFjaygpIHtcbiAgICBoLm9uKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uRW5kKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZFNjcm9sbEV2ZW50cygpIHtcbiAgICB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblNob3dPbkxvYWQgfHwgdGhpcy5fYW5pbWF0ZU9uU2Nyb2xsKCksIGgub24od2luZG93LCBcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRlT25TY3JvbGwoKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZENsaWNrRXZlbnRzKCkge1xuICAgIGgub24odGhpcy5fZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZEhvdmVyRXZlbnRzKCkge1xuICAgIGgub25lKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdmVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgfSksIGgub25lKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYmluZEhvdmVyRXZlbnRzKCk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG4gIF9jYWxsYmFjayh0KSB7XG4gICAgdCBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIHQoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGF1dG9Jbml0KHQpIHtcbiAgICB0Ll9pbml0KCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgbmV3IEpsKHRoaXNbMF0sIHQpLmluaXQoKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgQ24pO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IEFuID0gXCJyaXBwbGVcIiwgcWkgPSBcInRlLnJpcHBsZVwiLCBRcCA9IFwicmdiYSh7e2NvbG9yfX0sIDAuMikgMCwgcmdiYSh7e2NvbG9yfX0sIDAuMykgNDAlLCByZ2JhKHt7Y29sb3J9fSwgMC40KSA1MCUsIHJnYmEoe3tjb2xvcn19LCAwLjUpIDYwJSwgcmdiYSh7e2NvbG9yfX0sIDApIDcwJVwiLCBKcCA9IFtcIltkYXRhLXRlLXJpcHBsZS1pbml0XVwiXSwgWmkgPSBbMCwgMCwgMF0sIHRfID0gW1xuICB7IG5hbWU6IFwicHJpbWFyeVwiLCBncmFkaWVudENvbG9yOiBcIiMzQjcxQ0FcIiB9LFxuICB7IG5hbWU6IFwic2Vjb25kYXJ5XCIsIGdyYWRpZW50Q29sb3I6IFwiIzlGQTZCMlwiIH0sXG4gIHsgbmFtZTogXCJzdWNjZXNzXCIsIGdyYWRpZW50Q29sb3I6IFwiIzE0QTQ0RFwiIH0sXG4gIHsgbmFtZTogXCJkYW5nZXJcIiwgZ3JhZGllbnRDb2xvcjogXCIjREM0QzY0XCIgfSxcbiAgeyBuYW1lOiBcIndhcm5pbmdcIiwgZ3JhZGllbnRDb2xvcjogXCIjRTRBMTFCXCIgfSxcbiAgeyBuYW1lOiBcImluZm9cIiwgZ3JhZGllbnRDb2xvcjogXCIjNTRCNEQzXCIgfSxcbiAgeyBuYW1lOiBcImxpZ2h0XCIsIGdyYWRpZW50Q29sb3I6IFwiI2ZiZmJmYlwiIH0sXG4gIHsgbmFtZTogXCJkYXJrXCIsIGdyYWRpZW50Q29sb3I6IFwiIzI2MjYyNlwiIH1cbl0sIEZyID0gMC41LCBlXyA9IHtcbiAgcmlwcGxlQ2VudGVyZWQ6ICExLFxuICByaXBwbGVDb2xvcjogXCJcIixcbiAgcmlwcGxlQ29sb3JEYXJrOiBcIlwiLFxuICByaXBwbGVEdXJhdGlvbjogXCI1MDBtc1wiLFxuICByaXBwbGVSYWRpdXM6IDAsXG4gIHJpcHBsZVVuYm91bmQ6ICExXG59LCBpXyA9IHtcbiAgcmlwcGxlQ2VudGVyZWQ6IFwiYm9vbGVhblwiLFxuICByaXBwbGVDb2xvcjogXCJzdHJpbmdcIixcbiAgcmlwcGxlQ29sb3JEYXJrOiBcInN0cmluZ1wiLFxuICByaXBwbGVEdXJhdGlvbjogXCJzdHJpbmdcIixcbiAgcmlwcGxlUmFkaXVzOiBcIm51bWJlclwiLFxuICByaXBwbGVVbmJvdW5kOiBcImJvb2xlYW5cIlxufSwgc18gPSB7XG4gIHJpcHBsZTogXCJyZWxhdGl2ZSBvdmVyZmxvdy1oaWRkZW4gaW5saW5lLWJsb2NrIGFsaWduLWJvdHRvbVwiLFxuICByaXBwbGVXYXZlOiBcInJvdW5kZWQtWzUwJV0gb3BhY2l0eS01MCBwb2ludGVyLWV2ZW50cy1ub25lIGFic29sdXRlIHRvdWNoLW5vbmUgc2NhbGUtMCB0cmFuc2l0aW9uLVt0cmFuc2Zvcm0sX29wYWNpdHldIGVhc2UtW2N1YmljLWJlemllcigwLDAsMC4xNSwxKSxfY3ViaWMtYmV6aWVyKDAsMCwwLjE1LDEpXSB6LVs5OTldXCIsXG4gIHVuYm91bmQ6IFwib3ZlcmZsb3ctdmlzaWJsZVwiXG59LCBuXyA9IHtcbiAgcmlwcGxlOiBcInN0cmluZ1wiLFxuICByaXBwbGVXYXZlOiBcInN0cmluZ1wiLFxuICB1bmJvdW5kOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgVWUge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9lbGVtZW50ICYmIChJLnNldERhdGEodCwgcWksIHRoaXMpLCBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKSksIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2NyZWF0ZVJpcHBsZS5iaW5kKHRoaXMpLCB0aGlzLl9yaXBwbGVUaW1lciA9IG51bGwsIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMSwgdGhpcy5faW5pdGlhbENsYXNzZXMgPSBudWxsLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gQW47XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fYWRkQ2xpY2tFdmVudCh0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBxaSksIGgub2ZmKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2F1dG9Jbml0KHQpIHtcbiAgICBKcC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBkLmNsb3Nlc3QodC50YXJnZXQsIGUpICYmICh0aGlzLl9lbGVtZW50ID0gZC5jbG9zZXN0KHQudGFyZ2V0LCBlKSk7XG4gICAgfSksIHRoaXMuX2VsZW1lbnQuc3R5bGUubWluV2lkdGggfHwgKGMuc3R5bGUodGhpcy5fZWxlbWVudCwge1xuICAgICAgXCJtaW4td2lkdGhcIjogZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS53aWR0aFxuICAgIH0pLCB0aGlzLl9pc01pbldpZHRoU2V0ID0gITApLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKCksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKCksIHRoaXMuX2luaXRpYWxDbGFzc2VzID0gWy4uLnRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0XSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnJpcHBsZSksIHRoaXMuX2NyZWF0ZVJpcHBsZSh0KTtcbiAgfVxuICBfYWRkQ2xpY2tFdmVudCh0KSB7XG4gICAgaC5vbih0LCBcIm1vdXNlZG93blwiLCB0aGlzLl9jbGlja0hhbmRsZXIpO1xuICB9XG4gIF9jcmVhdGVSaXBwbGUodCkge1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodGhpcy5fY2xhc3Nlcy5yaXBwbGUpIDwgMCAmJiBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKTtcbiAgICBjb25zdCB7IGxheWVyWDogZSwgbGF5ZXJZOiBpIH0gPSB0LCBuID0gdC5vZmZzZXRYIHx8IGUsIG8gPSB0Lm9mZnNldFkgfHwgaSwgciA9IHRoaXMuX2VsZW1lbnQub2Zmc2V0SGVpZ2h0LCBhID0gdGhpcy5fZWxlbWVudC5vZmZzZXRXaWR0aCwgbCA9IHRoaXMuX2R1cmF0aW9uVG9Nc051bWJlcih0aGlzLl9vcHRpb25zLnJpcHBsZUR1cmF0aW9uKSwgcCA9IHtcbiAgICAgIG9mZnNldFg6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyByIC8gMiA6IG4sXG4gICAgICBvZmZzZXRZOiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYSAvIDIgOiBvLFxuICAgICAgaGVpZ2h0OiByLFxuICAgICAgd2lkdGg6IGFcbiAgICB9LCB1ID0gdGhpcy5fZ2V0RGlhbWV0ZXIocCksIGYgPSB0aGlzLl9vcHRpb25zLnJpcHBsZVJhZGl1cyB8fCB1IC8gMiwgXyA9IHtcbiAgICAgIGRlbGF5OiBsICogRnIsXG4gICAgICBkdXJhdGlvbjogbCAtIGwgKiBGclxuICAgIH0sIG0gPSB7XG4gICAgICBsZWZ0OiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYCR7YSAvIDIgLSBmfXB4YCA6IGAke24gLSBmfXB4YCxcbiAgICAgIHRvcDogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IGAke3IgLyAyIC0gZn1weGAgOiBgJHtvIC0gZn1weGAsXG4gICAgICBoZWlnaHQ6IGAke3RoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzICogMiB8fCB1fXB4YCxcbiAgICAgIHdpZHRoOiBgJHt0aGlzLl9vcHRpb25zLnJpcHBsZVJhZGl1cyAqIDIgfHwgdX1weGAsXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IGAwcywgJHtfLmRlbGF5fW1zYCxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7bH1tcywgJHtfLmR1cmF0aW9ufW1zYFxuICAgIH0sIGcgPSBEKFwiZGl2XCIpO1xuICAgIHRoaXMuX2NyZWF0ZUhUTUxSaXBwbGUoe1xuICAgICAgd3JhcHBlcjogdGhpcy5fZWxlbWVudCxcbiAgICAgIHJpcHBsZTogZyxcbiAgICAgIHN0eWxlczogbVxuICAgIH0pLCB0aGlzLl9yZW1vdmVIVE1MUmlwcGxlKHsgcmlwcGxlOiBnLCBkdXJhdGlvbjogbCB9KTtcbiAgfVxuICBfY3JlYXRlSFRNTFJpcHBsZSh7IHdyYXBwZXI6IHQsIHJpcHBsZTogZSwgc3R5bGVzOiBpIH0pIHtcbiAgICBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKFxuICAgICAgKG4pID0+IGUuc3R5bGVbbl0gPSBpW25dXG4gICAgKSwgYy5hZGRDbGFzcyhlLCB0aGlzLl9jbGFzc2VzLnJpcHBsZVdhdmUpLCBlLnNldEF0dHJpYnV0ZShcImRhdGEtdGUtcmlwcGxlLXJlZlwiLCBcIlwiKSwgdGhpcy5fYWRkQ29sb3IoZSwgdCksIHRoaXMuX3RvZ2dsZVVuYm91bmQodCksIHRoaXMuX2FwcGVuZFJpcHBsZShlLCB0KTtcbiAgfVxuICBfcmVtb3ZlSFRNTFJpcHBsZSh7IHJpcHBsZTogdCwgZHVyYXRpb246IGUgfSkge1xuICAgIHRoaXMuX3JpcHBsZVRpbWVyICYmIChjbGVhclRpbWVvdXQodGhpcy5fcmlwcGxlVGltZXIpLCB0aGlzLl9yaXBwbGVUaW1lciA9IG51bGwpLCB0ICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdC5jbGFzc0xpc3QuYWRkKFwiIW9wYWNpdHktMFwiKTtcbiAgICB9LCAxMCksIHRoaXMuX3JpcHBsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodCAmJiAodC5yZW1vdmUoKSwgdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgICAgZC5maW5kKFwiW2RhdGEtdGUtcmlwcGxlLXJlZl1cIiwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChcbiAgICAgICAgICAobikgPT4ge1xuICAgICAgICAgICAgbi5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICksIHRoaXMuX2lzTWluV2lkdGhTZXQgJiYgKGMuc3R5bGUodGhpcy5fZWxlbWVudCwgeyBcIm1pbi13aWR0aFwiOiBcIlwiIH0pLCB0aGlzLl9pc01pbldpZHRoU2V0ID0gITEpO1xuICAgICAgICBjb25zdCBpID0gdGhpcy5faW5pdGlhbENsYXNzZXMgPyB0aGlzLl9hZGRlZE5ld1JpcHBsZUNsYXNzZXMoXG4gICAgICAgICAgdGhpcy5fY2xhc3Nlcy5yaXBwbGUsXG4gICAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXNcbiAgICAgICAgKSA6IHRoaXMuX2NsYXNzZXMucmlwcGxlLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBpKTtcbiAgICAgIH1cbiAgICB9LCBlKTtcbiAgfVxuICBfYWRkZWROZXdSaXBwbGVDbGFzc2VzKHQsIGUpIHtcbiAgICByZXR1cm4gdC5zcGxpdChcIiBcIikuZmlsdGVyKFxuICAgICAgKGkpID0+IGUuZmluZEluZGV4KChuKSA9PiBpID09PSBuKSA9PT0gLTFcbiAgICApO1xuICB9XG4gIF9kdXJhdGlvblRvTXNOdW1iZXIodCkge1xuICAgIHJldHVybiBOdW1iZXIodC5yZXBsYWNlKFwibXNcIiwgXCJcIikucmVwbGFjZShcInNcIiwgXCIwMDBcIikpO1xuICB9XG4gIF9nZXRDb25maWcodCA9IHt9KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5lXyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTChBbiwgdCwgaV8pLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQgPSB7fSkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5zXyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTChBbiwgdCwgbl8pLCB0O1xuICB9XG4gIF9nZXREaWFtZXRlcih7IG9mZnNldFg6IHQsIG9mZnNldFk6IGUsIGhlaWdodDogaSwgd2lkdGg6IG4gfSkge1xuICAgIGNvbnN0IG8gPSBlIDw9IGkgLyAyLCByID0gdCA8PSBuIC8gMiwgYSA9IChfLCBtKSA9PiBNYXRoLnNxcnQoXyAqKiAyICsgbSAqKiAyKSwgbCA9IGUgPT09IGkgLyAyICYmIHQgPT09IG4gLyAyLCBwID0ge1xuICAgICAgZmlyc3Q6IG8gPT09ICEwICYmIHIgPT09ICExLFxuICAgICAgc2Vjb25kOiBvID09PSAhMCAmJiByID09PSAhMCxcbiAgICAgIHRoaXJkOiBvID09PSAhMSAmJiByID09PSAhMCxcbiAgICAgIGZvdXJ0aDogbyA9PT0gITEgJiYgciA9PT0gITFcbiAgICB9LCB1ID0ge1xuICAgICAgdG9wTGVmdDogYSh0LCBlKSxcbiAgICAgIHRvcFJpZ2h0OiBhKG4gLSB0LCBlKSxcbiAgICAgIGJvdHRvbUxlZnQ6IGEodCwgaSAtIGUpLFxuICAgICAgYm90dG9tUmlnaHQ6IGEobiAtIHQsIGkgLSBlKVxuICAgIH07XG4gICAgbGV0IGYgPSAwO1xuICAgIHJldHVybiBsIHx8IHAuZm91cnRoID8gZiA9IHUudG9wTGVmdCA6IHAudGhpcmQgPyBmID0gdS50b3BSaWdodCA6IHAuc2Vjb25kID8gZiA9IHUuYm90dG9tUmlnaHQgOiBwLmZpcnN0ICYmIChmID0gdS5ib3R0b21MZWZ0KSwgZiAqIDI7XG4gIH1cbiAgX2FwcGVuZFJpcHBsZSh0LCBlKSB7XG4gICAgZS5hcHBlbmRDaGlsZCh0KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjLmFkZENsYXNzKHQsIFwib3BhY2l0eS0wIHNjYWxlLTEwMFwiKTtcbiAgICB9LCA1MCk7XG4gIH1cbiAgX3RvZ2dsZVVuYm91bmQodCkge1xuICAgIHRoaXMuX29wdGlvbnMucmlwcGxlVW5ib3VuZCA9PT0gITAgPyBjLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMudW5ib3VuZCkgOiBjLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMudW5ib3VuZCk7XG4gIH1cbiAgX2FkZENvbG9yKHQpIHtcbiAgICBsZXQgZSA9IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3IgfHwgXCJyZ2IoMCwwLDApXCI7XG4gICAgKGxvY2FsU3RvcmFnZS50aGVtZSA9PT0gXCJkYXJrXCIgfHwgIShcInRoZW1lXCIgaW4gbG9jYWxTdG9yYWdlKSAmJiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcykgJiYgKGUgPSB0aGlzLl9vcHRpb25zLnJpcHBsZUNvbG9yRGFyayB8fCB0aGlzLl9vcHRpb25zLnJpcHBsZUNvbG9yKTtcbiAgICBjb25zdCBpID0gdF8uZmluZChcbiAgICAgIChyKSA9PiByLm5hbWUgPT09IGUudG9Mb3dlckNhc2UoKVxuICAgICksIG4gPSBpID8gdGhpcy5fY29sb3JUb1JHQihpLmdyYWRpZW50Q29sb3IpLmpvaW4oXCIsXCIpIDogdGhpcy5fY29sb3JUb1JHQihlKS5qb2luKFwiLFwiKSwgbyA9IFFwLnNwbGl0KFwie3tjb2xvcn19XCIpLmpvaW4oYCR7bn1gKTtcbiAgICB0LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGByYWRpYWwtZ3JhZGllbnQoY2lyY2xlLCAke299KWA7XG4gIH1cbiAgX2NvbG9yVG9SR0IodCkge1xuICAgIGZ1bmN0aW9uIGUobykge1xuICAgICAgcmV0dXJuIG8ubGVuZ3RoIDwgNyAmJiAobyA9IGAjJHtvWzFdfSR7b1sxXX0ke29bMl19JHtvWzJdfSR7b1szXX0ke29bM119YCksIFtcbiAgICAgICAgcGFyc2VJbnQoby5zdWJzdHIoMSwgMiksIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoby5zdWJzdHIoMywgMiksIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoby5zdWJzdHIoNSwgMiksIDE2KVxuICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaShvKSB7XG4gICAgICBjb25zdCByID0gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpY3R1bVwiKVxuICAgICAgKSwgYSA9IFwicmdiKDEsIDIsIDMpXCI7XG4gICAgICByZXR1cm4gci5zdHlsZS5jb2xvciA9IGEsIHIuc3R5bGUuY29sb3IgIT09IGEgfHwgKHIuc3R5bGUuY29sb3IgPSBvLCByLnN0eWxlLmNvbG9yID09PSBhIHx8IHIuc3R5bGUuY29sb3IgPT09IFwiXCIpID8gWmkgOiAobyA9IGdldENvbXB1dGVkU3R5bGUocikuY29sb3IsIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQociksIG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuKG8pIHtcbiAgICAgIHJldHVybiBvID0gby5tYXRjaCgvWy5cXGRdKy9nKS5tYXAoKHIpID0+ICtOdW1iZXIocikpLCBvLmxlbmd0aCA9IDMsIG87XG4gICAgfVxuICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCkgPT09IFwidHJhbnNwYXJlbnRcIiA/IFppIDogdFswXSA9PT0gXCIjXCIgPyBlKHQpIDogKHQuaW5kZXhPZihcInJnYlwiKSA9PT0gLTEgJiYgKHQgPSBpKHQpKSwgdC5pbmRleE9mKFwicmdiXCIpID09PSAwID8gbih0KSA6IFppKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGF1dG9Jbml0aWFsKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdC5fYXV0b0luaXQoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEkuZ2V0RGF0YSh0aGlzLCBxaSkgPyBudWxsIDogbmV3IFVlKHRoaXMsIHQpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBxaSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuZnVuY3Rpb24gWihzKSB7XG4gIHJldHVybiBzLmdldERhdGUoKTtcbn1cbmZ1bmN0aW9uIENzKHMpIHtcbiAgcmV0dXJuIHMuZ2V0RGF5KCk7XG59XG5mdW5jdGlvbiBZKHMpIHtcbiAgcmV0dXJuIHMuZ2V0TW9udGgoKTtcbn1cbmZ1bmN0aW9uIEIocykge1xuICByZXR1cm4gcy5nZXRGdWxsWWVhcigpO1xufVxuZnVuY3Rpb24gb18ocywgdCwgZSkge1xuICBjb25zdCBpID0gZS5zdGFydERheSwgbiA9IGkgPiAwID8gNyAtIGkgOiAwLCByID0gbmV3IERhdGUocywgdCkuZ2V0RGF5KCkgKyBuO1xuICByZXR1cm4gciA+PSA3ID8gciAtIDcgOiByO1xufVxuZnVuY3Rpb24gcm8ocykge1xuICByZXR1cm4gcl8ocykuZ2V0RGF0ZSgpO1xufVxuZnVuY3Rpb24gcl8ocykge1xuICByZXR1cm4gTXQocy5nZXRGdWxsWWVhcigpLCBzLmdldE1vbnRoKCkgKyAxLCAwKTtcbn1cbmZ1bmN0aW9uIFJlKCkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG59XG5mdW5jdGlvbiBpdChzLCB0KSB7XG4gIHJldHVybiBudChzLCB0ICogMTIpO1xufVxuZnVuY3Rpb24gbnQocywgdCkge1xuICBjb25zdCBlID0gTXQoXG4gICAgcy5nZXRGdWxsWWVhcigpLFxuICAgIHMuZ2V0TW9udGgoKSArIHQsXG4gICAgcy5nZXREYXRlKClcbiAgKSwgaSA9IFoocyksIG4gPSBaKGUpO1xuICByZXR1cm4gaSAhPT0gbiAmJiBlLnNldERhdGUoMCksIGU7XG59XG5mdW5jdGlvbiB4ZShzLCB0KSB7XG4gIHJldHVybiBNdChzLmdldEZ1bGxZZWFyKCksIHMuZ2V0TW9udGgoKSwgcy5nZXREYXRlKCkgKyB0KTtcbn1cbmZ1bmN0aW9uIE10KHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IG5ldyBEYXRlKHMsIHQsIGUpO1xuICByZXR1cm4gcyA+PSAwICYmIHMgPCAxMDAgJiYgaS5zZXRGdWxsWWVhcihpLmdldEZ1bGxZZWFyKCkgLSAxOTAwKSwgaTtcbn1cbmZ1bmN0aW9uIFlyKHMpIHtcbiAgY29uc3QgdCA9IHMuc3BsaXQoXCItXCIpLCBlID0gdFswXSwgaSA9IHRbMV0sIG4gPSB0WzJdO1xuICByZXR1cm4gTXQoZSwgaSwgbik7XG59XG5mdW5jdGlvbiBhXyhzKSB7XG4gIHJldHVybiAhTnVtYmVyLmlzTmFOKHMuZ2V0VGltZSgpKTtcbn1cbmZ1bmN0aW9uIE1lKHMsIHQpIHtcbiAgcmV0dXJuIEIocykgLSBCKHQpIHx8IFkocykgLSBZKHQpIHx8IFoocykgLSBaKHQpO1xufVxuZnVuY3Rpb24gX2UocywgdCkge1xuICByZXR1cm4gcy5zZXRIb3VycygwLCAwLCAwLCAwKSwgdC5zZXRIb3VycygwLCAwLCAwLCAwKSwgcy5nZXRUaW1lKCkgPT09IHQuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gQXMocywgdCkge1xuICBjb25zdCBpID0gQihzKSAtIGNfKCk7XG4gIHJldHVybiBsXyhpLCB0KTtcbn1cbmZ1bmN0aW9uIGxfKHMsIHQpIHtcbiAgcmV0dXJuIChzICUgdCArIHQpICUgdDtcbn1cbmZ1bmN0aW9uIGNfKHMsIHQsIGUpIHtcbiAgbGV0IGkgPSAwO1xuICByZXR1cm4gZSA/IGkgPSBCKGUpIC0gcyArIDEgOiB0ICYmIChpID0gQih0KSksIGk7XG59XG5mdW5jdGlvbiBQcyhzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgci5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgY29uc3QgYSA9IHQgJiYgTWUocywgdCkgPD0gLTEsIGwgPSBlICYmIE1lKHMsIGUpID49IDEsIHAgPSBuICYmIE1lKHMsIHIpIDw9IC0xLCB1ID0gbyAmJiBNZShzLCByKSA+PSAxLCBmID0gaSAmJiBpKHMpID09PSAhMTtcbiAgcmV0dXJuIGEgfHwgbCB8fCBmIHx8IHAgfHwgdTtcbn1cbmZ1bmN0aW9uIHRjKHMsIHQsIGUsIGksIG4sIG8pIHtcbiAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBhID0gaSAmJiBCKGkpLCBsID0gaSAmJiBZKGkpLCBwID0gZSAmJiBCKGUpLCB1ID0gZSAmJiBZKGUpLCBmID0gQihyKSwgXyA9IFkociksIG0gPSBsICYmIGEgJiYgKHQgPiBhIHx8IHQgPT09IGEgJiYgcyA+IGwpLCBnID0gdSAmJiBwICYmICh0IDwgcCB8fCB0ID09PSBwICYmIHMgPCB1KSwgdiA9IG4gJiYgKHQgPCBmIHx8IHQgPT09IGYgJiYgcyA8IF8pLCBiID0gbyAmJiAodCA+IGYgfHwgdCA9PT0gZiAmJiBzID4gXyk7XG4gIHJldHVybiBtIHx8IGcgfHwgdiB8fCBiO1xufVxuZnVuY3Rpb24gYW8ocywgdCwgZSwgaSwgbikge1xuICBjb25zdCBvID0gdCAmJiBCKHQpLCByID0gZSAmJiBCKGUpLCBhID0gQigvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSksIGwgPSByICYmIHMgPiByLCBwID0gbyAmJiBzIDwgbywgdSA9IGkgJiYgcyA8IGEsIGYgPSBuICYmIHMgPiBhO1xuICByZXR1cm4gbCB8fCBwIHx8IHUgfHwgZjtcbn1cbmZ1bmN0aW9uIGhfKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEpIHtcbiAgY29uc3QgbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICByZXR1cm4gbC5zZXRIb3VycygwLCAwLCAwLCAwKSwgKHMgJiYgbyAmJiBNZShvLCBsKSA8IDAgfHwgcykgJiYgKG8gPSBsKSwgbyAmJiBBaShcbiAgICB0LFxuICAgIG8sXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGFcbiAgKTtcbn1cbmZ1bmN0aW9uIGRfKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEpIHtcbiAgY29uc3QgbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICByZXR1cm4gbC5zZXRIb3VycygwLCAwLCAwLCAwKSwgKHMgJiYgbiAmJiBNZShuLCBsKSA8IDAgfHwgcykgJiYgKG4gPSBsKSwgbiAmJiBBaShcbiAgICB0LFxuICAgIG4sXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGFcbiAgKTtcbn1cbmZ1bmN0aW9uIEFpKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEpIHtcbiAgcmV0dXJuIGUgPT09IFwiZGF5c1wiID8gQihzKSA9PT0gQih0KSAmJiBZKHMpID09PSBZKHQpIDogZSA9PT0gXCJtb250aHNcIiA/IEIocykgPT09IEIodCkgOiBlID09PSBcInllYXJzXCIgPyBCKHQpID49IGEgJiYgQih0KSA8PSByIDogITE7XG59XG5jb25zdCB1XyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLW1vZGFsLWNvbnRhaW5lci1yZWZcIiwgcF8gPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1kcm9wZG93bi1jb250YWluZXItcmVmXCIsIF9fID0gXCJkYXRhLXRlLWRyb3Bkb3duLWJhY2tkcm9wLXJlZlwiLCBmXyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWRhdGUtdGV4dC1yZWZcIiwganIgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci12aWV3LXJlZlwiLCBtXyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLXByZXZpb3VzLWJ1dHRvbi1yZWZcIiwgZ18gPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1uZXh0LWJ1dHRvbi1yZWZcIiwgYl8gPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1vay1idXR0b24tcmVmXCIsIHZfID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2FuY2VsLWJ1dHRvbi1yZWZcIiwgVF8gPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1jbGVhci1idXR0b24tcmVmXCIsIEVfID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItdmlldy1jaGFuZ2UtYnV0dG9uLXJlZlwiO1xuZnVuY3Rpb24gQ18ocywgdCwgZSwgaSwgbiwgbywgciwgYSwgbCwgcCkge1xuICBjb25zdCB1ID0gWShzKSwgZiA9IEIocyksIF8gPSBaKHMpLCBtID0gQ3MocyksIGcgPSBEKFwiZGl2XCIpLCB2ID0gYFxuICAgICAgICAke0tyKFxuICAgIHMsXG4gICAgdSxcbiAgICBmLFxuICAgIHQsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgcFxuICApfVxuICAgIGAsIGIgPSBgXG4gICAgICAke3lfKF8sIG0sIHUsIG4sIHApfVxuICAgICAgJHtLcihcbiAgICBzLFxuICAgIHUsXG4gICAgZixcbiAgICB0LFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIHBcbiAgKX1cbiAgICBgO1xuICByZXR1cm4gbi5pbmxpbmUgPyAoYy5hZGRDbGFzcyhnLCBwLmRhdGVwaWNrZXJEcm9wZG93bkNvbnRhaW5lciksIGcuc2V0QXR0cmlidXRlKHBfLCBsKSwgZy5pbm5lckhUTUwgPSB2KSA6IChjLmFkZENsYXNzKGcsIHAubW9kYWxDb250YWluZXIpLCBnLnNldEF0dHJpYnV0ZSh1XywgbCksIGcuaW5uZXJIVE1MID0gYiksIGc7XG59XG5mdW5jdGlvbiBBXyhzKSB7XG4gIGNvbnN0IHQgPSBEKFwiZGl2XCIpO1xuICByZXR1cm4gYy5hZGRDbGFzcyh0LCBzKSwgdC5zZXRBdHRyaWJ1dGUoX18sIFwiXCIpLCB0O1xufVxuZnVuY3Rpb24geV8ocywgdCwgZSwgaSwgbikge1xuICByZXR1cm4gYFxuICAgICAgPGRpdiBjbGFzcz1cIiR7bi5kYXRlcGlja2VySGVhZGVyfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtuLmRhdGVwaWNrZXJUaXRsZX1cIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyVGl0bGVUZXh0fVwiPiR7aS50aXRsZX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtuLmRhdGVwaWNrZXJEYXRlfVwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtuLmRhdGVwaWNrZXJEYXRlVGV4dH1cIiAke2ZffSA+JHtpLndlZWtkYXlzU2hvcnRbdF19LCAke2kubW9udGhzU2hvcnRbZV19ICR7c308L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbn1cbmZ1bmN0aW9uIEtyKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIHAsIHUpIHtcbiAgbGV0IGY7XG4gIHJldHVybiByLmlubGluZSA/IGYgPSBgXG4gICAgPGRpdiBjbGFzcz1cIiR7dS5kYXRlcGlja2VyTWFpbn1cIj5cbiAgICAgICR7VXIodCwgZSwgciwgdSl9XG4gICAgICA8ZGl2IGNsYXNzPVwiJHt1LmRhdGVwaWNrZXJWaWV3fVwiICR7anJ9IHRhYmluZGV4PVwiMFwiPlxuICAgICAgICAke3pyKFxuICAgIHMsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgbCxcbiAgICBwLFxuICAgIHVcbiAgKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgIDogZiA9IGBcbiAgICA8ZGl2IGNsYXNzPVwiJHt1LmRhdGVwaWNrZXJNYWlufVwiPlxuICAgICAgJHtVcih0LCBlLCByLCB1KX1cbiAgICAgIDxkaXYgY2xhc3M9XCIke3UuZGF0ZXBpY2tlclZpZXd9XCIgJHtqcn0gdGFiaW5kZXg9XCIwXCI+XG4gICAgICAgICR7enIoXG4gICAgcyxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBsLFxuICAgIHAsXG4gICAgdVxuICApfVxuICAgICAgPC9kaXY+XG4gICAgICAke3dfKHIsIHUpfVxuICAgIDwvZGl2PlxuICBgLCBmO1xufVxuZnVuY3Rpb24genIocywgdCwgZSwgaSwgbiwgbywgciwgYSwgbCwgcCkge1xuICBsZXQgdTtcbiAgcmV0dXJuIG8udmlldyA9PT0gXCJkYXlzXCIgPyB1ID0geXMocywgZSwgbywgcCkgOiBvLnZpZXcgPT09IFwibW9udGhzXCIgPyB1ID0gd3MoXG4gICAgdCxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIHBcbiAgKSA6IHUgPSB4cyhcbiAgICBzLFxuICAgIGksXG4gICAgbyxcbiAgICBhLFxuICAgIGwsXG4gICAgcFxuICApLCB1O1xufVxuZnVuY3Rpb24gVXIocywgdCwgZSwgaSkge1xuICByZXR1cm4gYFxuICAgIDxkaXYgY2xhc3M9XCIke2kuZGF0ZXBpY2tlckRhdGVDb250cm9sc31cIj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCIke2kuZGF0ZXBpY2tlclZpZXdDaGFuZ2VCdXR0b259XCIgYXJpYS1sYWJlbD1cIiR7ZS5zd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbH1cIiAke0VffT5cbiAgICAgICAgJHtlLm1vbnRoc0Z1bGxbc119ICR7dH0gJHtEdChcbiAgICBlLFxuICAgIGlcbiAgKX1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7aS5kYXRlcGlja2VyQXJyb3dDb250cm9sc31cIj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7aS5kYXRlcGlja2VyUHJldmlvdXNCdXR0b259XCIgYXJpYS1sYWJlbD1cIiR7ZS5wcmV2TW9udGhMYWJlbH1cIiAke21ffT4ke2UuY2hhbmdlTW9udGhJY29uVGVtcGxhdGV9PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCIke2kuZGF0ZXBpY2tlck5leHRCdXR0b259XCIgYXJpYS1sYWJlbD1cIiR7ZS5uZXh0TW9udGhMYWJlbH1cIiAke2dffT4ke2UuY2hhbmdlTW9udGhJY29uVGVtcGxhdGV9PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICBgO1xufVxuZnVuY3Rpb24gRHQocywgdCkge1xuICByZXR1cm4gYFxuICA8c3BhbiBjbGFzcz1cIiR7dC5kYXRlcGlja2VyVmlld0NoYW5nZUljb259XCI+XG4gICR7cy52aWV3Q2hhbmdlSWNvblRlbXBsYXRlfVxuICA8L3NwYW4+XG4gIGA7XG59XG5mdW5jdGlvbiB3XyhzLCB0KSB7XG4gIGNvbnN0IGUgPSBgPGJ1dHRvbiBjbGFzcz1cIiR7dC5kYXRlcGlja2VyRm9vdGVyQnRufVwiIGFyaWEtbGFiZWw9XCIke3Mub2tCdG5MYWJlbH1cIiAke2JffT4ke3Mub2tCdG5UZXh0fTwvYnV0dG9uPmAsIGkgPSBgPGJ1dHRvbiBjbGFzcz1cIiR7dC5kYXRlcGlja2VyRm9vdGVyQnRufVwiIGFyaWEtbGFiZWw9XCIke3MuY2FuY2VsQnRuTGFiZWx9XCIgJHt2X30+JHtzLmNhbmNlbEJ0blRleHR9PC9idXR0b24+YCwgbiA9IGA8YnV0dG9uIGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJGb290ZXJCdG59ICR7dC5kYXRlcGlja2VyQ2xlYXJCdG59XCIgYXJpYS1sYWJlbD1cIiR7cy5jbGVhckJ0bkxhYmVsfVwiICR7VF99PiR7cy5jbGVhckJ0blRleHR9PC9idXR0b24+YDtcbiAgcmV0dXJuIGBcbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7dC5kYXRlcGlja2VyRm9vdGVyfVwiPlxuICAgICAgICAgIFxuICAgICAgICAke3MucmVtb3ZlQ2xlYXJCdG4gPyBcIlwiIDogbn1cbiAgICAgICAgJHtzLnJlbW92ZUNhbmNlbEJ0biA/IFwiXCIgOiBpfVxuICAgICAgICAke3MucmVtb3ZlT2tCdG4gPyBcIlwiIDogZX1cbiAgICAgICAgPC9kaXY+XG4gICAgICBgO1xufVxuZnVuY3Rpb24geXMocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0geF8ocywgdCwgZSksIHIgPSBgXG4gICAgICA8dHI+XG4gICAgICAgICR7ZS53ZWVrZGF5c05hcnJvdy5tYXAoKGwsIHApID0+IGA8dGggY2xhc3M9XCIke2kuZGF0ZXBpY2tlckRheUhlYWRpbmd9XCIgc2NvcGU9XCJjb2xcIiBhcmlhLWxhYmVsPVwiJHtlLndlZWtkYXlzRnVsbFtwXX1cIj4ke2x9PC90aD5gKS5qb2luKFwiXCIpfVxuICAgICAgPC90cj5cbiAgICBgLCBhID0gbi5tYXAoKGwpID0+IGBcbiAgICAgICAgPHRyPlxuICAgICAgICAgICR7bC5tYXAoKHApID0+IGBcbiAgICAgICAgICAgICAgPHRkXG4gICAgICAgICAgICAgIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJDZWxsfSAke2kuZGF0ZXBpY2tlckNlbGxTbWFsbH1cIlxuICAgICAgICAgICAgICBkYXRhLXRlLWRhdGU9XCIke0IocC5kYXRlKX0tJHtZKFxuICAgIHAuZGF0ZVxuICApfS0ke1oocC5kYXRlKX1cIlxuICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiJHtwLmRhdGV9XCJcbiAgICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD1cIiR7cC5pc1NlbGVjdGVkfVwiXG4gICAgICAgICAgICAgICR7cC5pc1NlbGVjdGVkID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgJHshcC5jdXJyZW50TW9udGggfHwgcC5kaXNhYmxlZCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7cC5pc1RvZGF5ID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XCIgOiBcIlwifVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCIke2kuZGF0ZXBpY2tlckNlbGxDb250ZW50fSAke2kuZGF0ZXBpY2tlckNlbGxDb250ZW50U21hbGx9XCJcbiAgICAgICAgICAgICAgICAgIHN0eWxlPVwiJHtwLmN1cnJlbnRNb250aCA/IFwiZGlzcGxheTogYmxvY2tcIiA6IFwiZGlzcGxheTogbm9uZVwifVwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAke3AuZGF5TnVtYmVyfVxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICBgKS5qb2luKFwiXCIpfVxuICAgICAgICA8L3RyPlxuICAgICAgYCkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGBcbiAgICAgIDx0YWJsZSBjbGFzcz1cIiR7aS5kYXRlcGlja2VyVGFibGV9XCI+XG4gICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAke3J9XG4gICAgICAgIDwvdGhlYWQ+XG4gICAgICAgIDx0Ym9keT5cbiAgICAgICAgICR7YX1cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgYDtcbn1cbmZ1bmN0aW9uIHhfKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IFtdLCBuID0gWShzKSwgbyA9IFkobnQocywgLTEpKSwgciA9IFkobnQocywgMSkpLCBhID0gQihzKSwgbCA9IG9fKGEsIG4sIGUpLCBwID0gcm8ocyksIHUgPSBybyhudChzLCAtMSkpLCBmID0gNztcbiAgbGV0IF8gPSAxLCBtID0gITE7XG4gIGZvciAobGV0IGcgPSAxOyBnIDwgZjsgZysrKSB7XG4gICAgY29uc3QgdiA9IFtdO1xuICAgIGlmIChnID09PSAxKSB7XG4gICAgICBjb25zdCBiID0gdSAtIGwgKyAxO1xuICAgICAgZm9yIChsZXQgeSA9IGI7IHkgPD0gdTsgeSsrKSB7XG4gICAgICAgIGNvbnN0IEUgPSBNdChhLCBvLCB5KTtcbiAgICAgICAgdi5wdXNoKHtcbiAgICAgICAgICBkYXRlOiBFLFxuICAgICAgICAgIGN1cnJlbnRNb250aDogbSxcbiAgICAgICAgICBpc1NlbGVjdGVkOiB0ICYmIF9lKEUsIHQpLFxuICAgICAgICAgIGlzVG9kYXk6IF9lKEUsIFJlKCkpLFxuICAgICAgICAgIGRheU51bWJlcjogWihFKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG0gPSAhMDtcbiAgICAgIGNvbnN0IEMgPSBmIC0gdi5sZW5ndGg7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IEM7IHkrKykge1xuICAgICAgICBjb25zdCBFID0gTXQoYSwgbiwgXyk7XG4gICAgICAgIHYucHVzaCh7XG4gICAgICAgICAgZGF0ZTogRSxcbiAgICAgICAgICBjdXJyZW50TW9udGg6IG0sXG4gICAgICAgICAgaXNTZWxlY3RlZDogdCAmJiBfZShFLCB0KSxcbiAgICAgICAgICBpc1RvZGF5OiBfZShFLCBSZSgpKSxcbiAgICAgICAgICBkYXlOdW1iZXI6IFooRSksXG4gICAgICAgICAgZGlzYWJsZWQ6IFBzKFxuICAgICAgICAgICAgRSxcbiAgICAgICAgICAgIGUubWluLFxuICAgICAgICAgICAgZS5tYXgsXG4gICAgICAgICAgICBlLmZpbHRlcixcbiAgICAgICAgICAgIGUuZGlzYWJsZVBhc3QsXG4gICAgICAgICAgICBlLmRpc2FibGVGdXR1cmVcbiAgICAgICAgICApXG4gICAgICAgIH0pLCBfKys7XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgICBmb3IgKGxldCBiID0gMTsgYiA8IDg7IGIrKykge1xuICAgICAgICBfID4gcCAmJiAoXyA9IDEsIG0gPSAhMSk7XG4gICAgICAgIGNvbnN0IEMgPSBNdChcbiAgICAgICAgICBhLFxuICAgICAgICAgIG0gPyBuIDogcixcbiAgICAgICAgICBfXG4gICAgICAgICk7XG4gICAgICAgIHYucHVzaCh7XG4gICAgICAgICAgZGF0ZTogQyxcbiAgICAgICAgICBjdXJyZW50TW9udGg6IG0sXG4gICAgICAgICAgaXNTZWxlY3RlZDogdCAmJiBfZShDLCB0KSxcbiAgICAgICAgICBpc1RvZGF5OiBfZShDLCBSZSgpKSxcbiAgICAgICAgICBkYXlOdW1iZXI6IFooQyksXG4gICAgICAgICAgZGlzYWJsZWQ6IFBzKFxuICAgICAgICAgICAgQyxcbiAgICAgICAgICAgIGUubWluLFxuICAgICAgICAgICAgZS5tYXgsXG4gICAgICAgICAgICBlLmZpbHRlcixcbiAgICAgICAgICAgIGUuZGlzYWJsZVBhc3QsXG4gICAgICAgICAgICBlLmRpc2FibGVGdXR1cmVcbiAgICAgICAgICApXG4gICAgICAgIH0pLCBfKys7XG4gICAgICB9XG4gICAgaS5wdXNoKHYpO1xuICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gd3MocywgdCwgZSwgaSwgbiwgbykge1xuICBjb25zdCByID0ga18oaSwgbiksIGEgPSBZKFJlKCkpLCBsID0gQihSZSgpKSwgcCA9IGBcbiAgICAgICR7ci5tYXAoKHUpID0+IGBcbiAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAke3UubWFwKChmKSA9PiB7XG4gICAgY29uc3QgXyA9IGkubW9udGhzU2hvcnQuaW5kZXhPZihmKTtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIiR7by5kYXRlcGlja2VyQ2VsbH0gJHtvLmRhdGVwaWNrZXJDZWxsTGFyZ2V9XCJcbiAgICAgICAgICAgICAgICAke3RjKFxuICAgICAgXyxcbiAgICAgIHMsXG4gICAgICBpLm1pbixcbiAgICAgIGkubWF4LFxuICAgICAgaS5kaXNhYmxlUGFzdCxcbiAgICAgIGkuZGlzYWJsZUZ1dHVyZVxuICAgICkgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGRhdGEtdGUtbW9udGg9XCIke199XCIgZGF0YS10ZS15ZWFyPVwiJHtzfVwiIGFyaWEtbGFiZWw9XCIke2Z9LCAke3N9XCJcbiAgICAgICAgICAgICAgICAke18gPT09IGUgJiYgcyA9PT0gdCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICAgJHtfID09PSBhICYmIHMgPT09IGwgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRcIiA6IFwiXCJ9XCIgZGF0YS10ZS1tb250aD1cIiR7X31cIiBkYXRhLXRlLXllYXI9XCIke3N9XCIgYXJpYS1sYWJlbD1cIiR7Zn0sICR7c31cIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGxDb250ZW50fSAke28uZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2V9XCI+JHtmfTwvZGl2PlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgIGA7XG4gIH0pLmpvaW4oXCJcIil9XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgYCkuam9pbihcIlwiKX1cbiAgICBgO1xuICByZXR1cm4gYFxuICAgICAgPHRhYmxlIGNsYXNzPVwiJHtvLmRhdGVwaWNrZXJUYWJsZX1cIj5cbiAgICAgICAgPHRib2R5PlxuICAgICAgICAgJHtwfVxuICAgICAgICA8L3Rib2R5PlxuICAgICAgPC90YWJsZT5cbiAgICBgO1xufVxuZnVuY3Rpb24ga18ocywgdCkge1xuICBjb25zdCBlID0gW107XG4gIGxldCBpID0gW107XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgcy5tb250aHNTaG9ydC5sZW5ndGg7IG4rKylcbiAgICBpZiAoaS5wdXNoKHMubW9udGhzU2hvcnRbbl0pLCBpLmxlbmd0aCA9PT0gdCkge1xuICAgICAgY29uc3QgbyA9IGk7XG4gICAgICBlLnB1c2gobyksIGkgPSBbXTtcbiAgICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24geHMocywgdCwgZSwgaSwgbiwgbykge1xuICBjb25zdCByID0gT18ocywgaSwgbiksIGEgPSBCKFJlKCkpLCBsID0gYFxuICAgICR7ci5tYXAoKHApID0+IGBcbiAgICAgICAgPHRyPlxuICAgICAgICAgICR7cC5tYXAoKHUpID0+IGBcbiAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiJHtvLmRhdGVwaWNrZXJDZWxsfSAke28uZGF0ZXBpY2tlckNlbGxMYXJnZX1cIiAgYXJpYS1sYWJlbD1cIiR7dX1cIiBkYXRhLXRlLXllYXI9XCIke3V9XCJcbiAgICAgICAgICAgICAgJHthbyhcbiAgICB1LFxuICAgIGUubWluLFxuICAgIGUubWF4LFxuICAgIGUuZGlzYWJsZVBhc3QsXG4gICAgZS5kaXNhYmxlRnV0dXJlXG4gICkgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAke3UgPT09IHQgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAke3UgPT09IGEgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtvLmRhdGVwaWNrZXJDZWxsQ29udGVudH0gJHtvLmRhdGVwaWNrZXJDZWxsQ29udGVudExhcmdlfVwiPiR7dX08L2Rpdj5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIGApLmpvaW4oXCJcIil9XG4gICAgICAgIDwvdHI+XG4gICAgICBgKS5qb2luKFwiXCIpfVxuICBgO1xuICByZXR1cm4gYFxuICAgICAgPHRhYmxlIGNsYXNzPVwiJHtvLmRhdGVwaWNrZXJUYWJsZX1cIj5cbiAgICAgICAgPHRib2R5PlxuICAgICAgICAke2x9XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgIGA7XG59XG5mdW5jdGlvbiBPXyhzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBbXSwgbiA9IEIocyksIG8gPSBBcyhzLCB0KSwgciA9IG4gLSBvO1xuICBsZXQgYSA9IFtdO1xuICBmb3IgKGxldCBsID0gMDsgbCA8IHQ7IGwrKylcbiAgICBpZiAoYS5wdXNoKHIgKyBsKSwgYS5sZW5ndGggPT09IGUpIHtcbiAgICAgIGNvbnN0IHAgPSBhO1xuICAgICAgaS5wdXNoKHApLCBhID0gW107XG4gICAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIFNfKHMsIHQpIHtcbiAgcmV0dXJuIGBcbiAgICA8YnV0dG9uIGlkPVwiJHtzfVwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7dH1cIiBkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLWJ1dHRvbi1yZWYgZGF0YS10ZS1kYXRlcGlja2VyLXRvZ2dsZS1yZWY+XG4gICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiPlxuICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNi43NSAyLjI1QS43NS43NSAwIDAxNy41IDN2MS41aDlWM0EuNzUuNzUgMCAwMTE4IDN2MS41aC43NWEzIDMgMCAwMTMgM3YxMS4yNWEzIDMgMCAwMS0zIDNINS4yNWEzIDMgMCAwMS0zLTNWNy41YTMgMyAwIDAxMy0zSDZWM2EuNzUuNzUgMCAwMS43NS0uNzV6bTEzLjUgOWExLjUgMS41IDAgMDAtMS41LTEuNUg1LjI1YTEuNSAxLjUgMCAwMC0xLjUgMS41djcuNWExLjUgMS41IDAgMDAxLjUgMS41aDEzLjVhMS41IDEuNSAwIDAwMS41LTEuNXYtNy41elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgICAgPC9zdmc+ICBcbiAgICA8L2J1dHRvbj5cbiAgYDtcbn1cbmNvbnN0IFBlID0gMzcsIHJ0ID0gMzgsIEJlID0gMzksIHogPSA0MCwgSGUgPSAzNiwgV2UgPSAzNSwgeW4gPSAzMywgd24gPSAzNCwgbHQgPSAxMywga3MgPSAzMiwgTGkgPSAyNywgT2kgPSA5LCBJXyA9IDgsIERfID0gNDYsIGd0ID0gMjQsIFFpID0gNCwgSmkgPSA0LCB4biA9IFwiZGF0ZXBpY2tlclwiLCBPcyA9IFwidGUuZGF0ZXBpY2tlclwiLCBZcyA9IGAuJHtPc31gLCAkXyA9IFwiLmRhdGEtYXBpXCIsIExfID0gYGNsb3NlJHtZc31gLCBNXyA9IGBvcGVuJHtZc31gLCBOXyA9IGBkYXRlQ2hhbmdlJHtZc31gLCB0cyA9IGBjbGljayR7WXN9JHskX31gLCBlYyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLW1vZGFsLWNvbnRhaW5lci1yZWZcIiwgaWMgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1kcm9wZG93bi1jb250YWluZXItcmVmXCIsIGVzID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXRvZ2dsZS1yZWZdXCIsIFJfID0gYFske2VjfV1gLCBQXyA9IGBbJHtpY31dYCwgQl8gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItdmlldy1jaGFuZ2UtYnV0dG9uLXJlZl1cIiwgSF8gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItcHJldmlvdXMtYnV0dG9uLXJlZl1cIiwgV18gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItbmV4dC1idXR0b24tcmVmXVwiLCBWXyA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1vay1idXR0b24tcmVmXVwiLCBGXyA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1jYW5jZWwtYnV0dG9uLXJlZl1cIiwgWV8gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2xlYXItYnV0dG9uLXJlZl1cIiwgal8gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItdmlldy1yZWZdXCIsIEtfID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXRvZ2dsZS1idXR0b24tcmVmXVwiLCB6XyA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1kYXRlLXRleHQtcmVmXVwiLCBVXyA9IFwiW2RhdGEtdGUtZHJvcGRvd24tYmFja2Ryb3AtcmVmXVwiLCBYXyA9IFwiYW5pbWF0ZS1bZmFkZS1pbl8wLjNzX2JvdGhdIHB4LVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLCBHXyA9IFwiYW5pbWF0ZS1bZmFkZS1vdXRfMC4zc19ib3RoXSBweC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIiwgcV8gPSBcImFuaW1hdGUtW2ZhZGUtaW5fMC4xNXNfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIFpfID0gXCJhbmltYXRlLVtmYWRlLW91dF8wLjE1c19ib3RoXSBweC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIiwgUV8gPSBcImZsZXggZmxleC1jb2wgZml4ZWQgdG9wLTEvMiBsZWZ0LTEvMiAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgdy1bMzI4cHhdIGgtWzUxMnB4XSBiZy13aGl0ZSByb3VuZGVkLVswLjZyZW1dIHNoYWRvdy1sZyB6LVsxMDY2XSB4czptYXgtbWQ6bGFuZHNjYXBlOnctWzQ3NXB4XSB4czptYXgtbWQ6bGFuZHNjYXBlOmgtWzM2MHB4XSB4czptYXgtbWQ6bGFuZHNjYXBlOmZsZXgtcm93IGRhcms6YmctemluYy03MDBcIiwgSl8gPSBcInctZnVsbCBoLWZ1bGwgZml4ZWQgdG9wLTAgcmlnaHQtMCBsZWZ0LTAgYm90dG9tLTAgYmctYmxhY2svNDAgei1bMTA2NV1cIiwgdGYgPSBcInJlbGF0aXZlIGgtZnVsbFwiLCBlZiA9IFwieHM6bWF4LW1kOmxhbmRzY2FwZTpoLWZ1bGwgaC1bMTIwcHhdIHB4LTYgYmctcHJpbWFyeSBmbGV4IGZsZXgtY29sIHJvdW5kZWQtdC1sZyBkYXJrOmJnLXppbmMtODAwXCIsIHNmID0gXCJoLTggZmxleCBmbGV4LWNvbCBqdXN0aWZ5LWVuZFwiLCBuZiA9IFwidGV4dC1bMTBweF0gZm9udC1ub3JtYWwgdXBwZXJjYXNlIHRyYWNraW5nLVsxLjdweF0gdGV4dC13aGl0ZVwiLCBvZiA9IFwieHM6bWF4LW1kOmxhbmRzY2FwZTptdC0yNCBoLVs3MnB4XSBmbGV4IGZsZXgtY29sIGp1c3RpZnktZW5kXCIsIHJmID0gXCJ0ZXh0LVszNHB4XSBmb250LW5vcm1hbCB0ZXh0LXdoaXRlXCIsIGFmID0gXCJvdXRsaW5lLW5vbmUgcHgtM1wiLCBsZiA9IFwicHgtMyBwdC0yLjUgcGItMCBmbGV4IGp1c3RpZnktYmV0d2VlbiB0ZXh0LWJsYWNrL1s2NF1cIiwgY2YgPSBcImZsZXggaXRlbXMtY2VudGVyIG91dGxpbmUtbm9uZSBwLTIuNSB0ZXh0LW5ldXRyYWwtNTAwIGZvbnQtbWVkaXVtIHRleHQtWzAuOXJlbV0gcm91bmRlZC14bCBzaGFkb3ctbm9uZSBiZy10cmFuc3BhcmVudCBtLTAgYm9yZGVyLW5vbmUgaG92ZXI6YmctbmV1dHJhbC0yMDAgZm9jdXM6YmctbmV1dHJhbC0yMDAgIGRhcms6dGV4dC13aGl0ZSBkYXJrOmhvdmVyOmJnLXdoaXRlLzEwIGRhcms6Zm9jdXM6Ymctd2hpdGUvMTBcIiwgaGYgPSBcIm10LTIuNVwiLCBkZiA9IFwicC0wIHctMTAgaC0xMCBsZWFkaW5nLTEwIGJvcmRlci1ub25lIG91dGxpbmUtbm9uZSBtLTAgdGV4dC1ncmF5LTYwMCBiZy10cmFuc3BhcmVudCBtci02IGhvdmVyOmJnLW5ldXRyYWwtMjAwIGhvdmVyOnJvdW5kZWQtWzUwJV0gZm9jdXM6YmctbmV1dHJhbC0yMDAgZm9jdXM6cm91bmRlZC1bNTAlXSBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwIFsmPnN2Z106dy00IFsmPnN2Z106aC00IFsmPnN2Z106bXgtYXV0b1wiLCB1ZiA9IFwicC0wIHctMTAgaC0xMCBsZWFkaW5nLTEwIGJvcmRlci1ub25lIG91dGxpbmUtbm9uZSBtLTAgdGV4dC1ncmF5LTYwMCBiZy10cmFuc3BhcmVudCBob3ZlcjpiZy1uZXV0cmFsLTIwMCBob3Zlcjpyb3VuZGVkLVs1MCVdIGZvY3VzOmJnLW5ldXRyYWwtMjAwIGZvY3VzOnJvdW5kZWQtWzUwJV0gZGFyazp0ZXh0LXdoaXRlIGRhcms6aG92ZXI6Ymctd2hpdGUvMTAgZGFyazpmb2N1czpiZy13aGl0ZS8xMCBbJj5zdmddOnctNCBbJj5zdmddOmgtNCBbJj5zdmddOnJvdGF0ZS0xODAgWyY+c3ZnXTpteC1hdXRvXCIsIHBmID0gXCJoLTE0IGZsZXggYWJzb2x1dGUgdy1mdWxsIGJvdHRvbS0wIGp1c3RpZnktZW5kIGl0ZW1zLWNlbnRlciBweC0zXCIsIF9mID0gXCJvdXRsaW5lLW5vbmUgYmctd2hpdGUgdGV4dC1wcmltYXJ5IGJvcmRlci1ub25lIGN1cnNvci1wb2ludGVyIHB5LTAgcHgtMi41IHVwcGVyY2FzZSB0ZXh0LVswLjhyZW1dIGxlYWRpbmctMTAgZm9udC1tZWRpdW0gaC0xMCB0cmFja2luZy1bLjFyZW1dIHJvdW5kZWQtWzEwcHhdIG1iLTIuNSBob3ZlcjpiZy1uZXV0cmFsLTIwMCBmb2N1czpiZy1uZXV0cmFsLTIwMCBkYXJrOmJnLXRyYW5zcGFyZW50IGRhcms6dGV4dC13aGl0ZSBkYXJrOmhvdmVyOmJnLXdoaXRlLzEwIGRhcms6Zm9jdXM6Ymctd2hpdGUvMTBcIiwgZmYgPSBcIm1yLWF1dG9cIiwgbWYgPSBcInctMTAgaC0xMCB0ZXh0LWNlbnRlciB0ZXh0LVsxMnB4XSBmb250LW5vcm1hbCBkYXJrOnRleHQtd2hpdGVcIiwgZ2YgPSBcInRleHQtY2VudGVyIGRhdGEtW3RlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZF06dGV4dC1uZXV0cmFsLTMwMCBkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdOmN1cnNvci1kZWZhdWx0IGRhdGEtW3RlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZF06cG9pbnRlci1ldmVudHMtbm9uZSBkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdOmhvdmVyOmN1cnNvci1kZWZhdWx0IGhvdmVyOmN1cnNvci1wb2ludGVyIGdyb3VwXCIsIGJmID0gXCJ3LTEwIGgtMTAgeHM6bWF4LW1kOmxhbmRzY2FwZTp3LTggeHM6bWF4LW1kOmxhbmRzY2FwZTpoLThcIiwgdmYgPSBcInctWzc2cHhdIGgtWzQycHhdXCIsIFRmID0gXCJteC1hdXRvIGdyb3VwLVs6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZF0pOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdKTpob3Zlcl06YmctbmV1dHJhbC0zMDAgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF1dOmJnLXByaW1hcnkgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF1dOnRleHQtd2hpdGUgZ3JvdXAtWzpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXSlbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZF1dOmJnLW5ldXRyYWwtMTAwIGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZF1dOmRhdGEtW3RlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF06YmctcHJpbWFyeSBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRdXTpib3JkZXItc29saWQgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyLWJsYWNrIGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudF1dOmJvcmRlciBkYXJrOmdyb3VwLVs6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZF0pOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdKTpob3Zlcl06Ymctd2hpdGUvMTAgZGFyazpncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRdXTpib3JkZXItd2hpdGUgZGFyazp0ZXh0LXdoaXRlIGRhcms6Z3JvdXAtWzpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXSlbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZF1dOmJnLXdoaXRlLzEwIGRhcms6Z3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZF1dOnRleHQtbmV1dHJhbC01MDBcIiwgRWYgPSBcInctOSBoLTkgbGVhZGluZy05IHJvdW5kZWQtWzUwJV0gdGV4dC1bMTNweF1cIiwgQ2YgPSBcInctWzcycHhdIGgtMTAgbGVhZGluZy0xMCBweS1bMXB4XSBweC0wLjUgcm91bmRlZC1bOTk5cHhdXCIsIEFmID0gXCJteC1hdXRvIHctWzMwNHB4XVwiLCB5ZiA9IFwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jb250ZW50LWNlbnRlciBbJj5zdmddOnctNSBbJj5zdmddOmgtNSBhYnNvbHV0ZSBvdXRsaW5lLW5vbmUgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcmlnaHQtMC41IHRvcC0xLzIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIGhvdmVyOnRleHQtcHJpbWFyeSBmb2N1czp0ZXh0LXByaW1hcnkgZGFyazpob3Zlcjp0ZXh0LXByaW1hcnktNDAwIGRhcms6Zm9jdXM6dGV4dC1wcmltYXJ5LTQwMCBkYXJrOnRleHQtbmV1dHJhbC0yMDBcIiwgd2YgPSBcImlubGluZS1ibG9jayBwb2ludGVyLWV2ZW50cy1ub25lIG1sLVszcHhdIFsmPnN2Z106dy00IFsmPnN2Z106aC00IFsmPnN2Z106ZmlsbC1uZXV0cmFsLTUwMCBkYXJrOlsmPnN2Z106ZmlsbC13aGl0ZVwiLCB4ZiA9IFwidy1bMzI4cHhdIGgtWzM4MHB4XSBiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdy1bMHB4XzJweF8xNXB4Xy0zcHhfcmdiYSgwLDAsMCwuMDcpLF8wcHhfMTBweF8yMHB4Xy0ycHhfcmdiYSgwLDAsMCwuMDQpXSB6LVsxMDY2XSBkYXJrOmJnLXppbmMtNzAwXCIsIGtmID0ge1xuICB0aXRsZTogXCJTZWxlY3QgZGF0ZVwiLFxuICBjb250YWluZXI6IFwiYm9keVwiLFxuICBkaXNhYmxlUGFzdDogITEsXG4gIGRpc2FibGVGdXR1cmU6ICExLFxuICBtb250aHNGdWxsOiBbXG4gICAgXCJKYW51YXJ5XCIsXG4gICAgXCJGZWJydWFyeVwiLFxuICAgIFwiTWFyY2hcIixcbiAgICBcIkFwcmlsXCIsXG4gICAgXCJNYXlcIixcbiAgICBcIkp1bmVcIixcbiAgICBcIkp1bHlcIixcbiAgICBcIkF1Z3VzdFwiLFxuICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgXCJPY3RvYmVyXCIsXG4gICAgXCJOb3ZlbWJlclwiLFxuICAgIFwiRGVjZW1iZXJcIlxuICBdLFxuICBtb250aHNTaG9ydDogW1xuICAgIFwiSmFuXCIsXG4gICAgXCJGZWJcIixcbiAgICBcIk1hclwiLFxuICAgIFwiQXByXCIsXG4gICAgXCJNYXlcIixcbiAgICBcIkp1blwiLFxuICAgIFwiSnVsXCIsXG4gICAgXCJBdWdcIixcbiAgICBcIlNlcFwiLFxuICAgIFwiT2N0XCIsXG4gICAgXCJOb3ZcIixcbiAgICBcIkRlY1wiXG4gIF0sXG4gIHdlZWtkYXlzRnVsbDogW1xuICAgIFwiU3VuZGF5XCIsXG4gICAgXCJNb25kYXlcIixcbiAgICBcIlR1ZXNkYXlcIixcbiAgICBcIldlZG5lc2RheVwiLFxuICAgIFwiVGh1cnNkYXlcIixcbiAgICBcIkZyaWRheVwiLFxuICAgIFwiU2F0dXJkYXlcIlxuICBdLFxuICB3ZWVrZGF5c1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIHdlZWtkYXlzTmFycm93OiBbXCJTXCIsIFwiTVwiLCBcIlRcIiwgXCJXXCIsIFwiVFwiLCBcIkZcIiwgXCJTXCJdLFxuICBva0J0blRleHQ6IFwiT2tcIixcbiAgY2xlYXJCdG5UZXh0OiBcIkNsZWFyXCIsXG4gIGNhbmNlbEJ0blRleHQ6IFwiQ2FuY2VsXCIsXG4gIG9rQnRuTGFiZWw6IFwiQ29uZmlybSBzZWxlY3Rpb25cIixcbiAgY2xlYXJCdG5MYWJlbDogXCJDbGVhciBzZWxlY3Rpb25cIixcbiAgY2FuY2VsQnRuTGFiZWw6IFwiQ2FuY2VsIHNlbGVjdGlvblwiLFxuICBuZXh0TW9udGhMYWJlbDogXCJOZXh0IG1vbnRoXCIsXG4gIHByZXZNb250aExhYmVsOiBcIlByZXZpb3VzIG1vbnRoXCIsXG4gIG5leHRZZWFyTGFiZWw6IFwiTmV4dCB5ZWFyXCIsXG4gIHByZXZZZWFyTGFiZWw6IFwiUHJldmlvdXMgeWVhclwiLFxuICBjaGFuZ2VNb250aEljb25UZW1wbGF0ZTogYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNiBoLTZcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xNS43NSAxOS41TDguMjUgMTJsNy41LTcuNVwiIC8+XG4gIDwvc3ZnPlxuICBgLFxuICBuZXh0TXVsdGlZZWFyTGFiZWw6IFwiTmV4dCAyNCB5ZWFyc1wiLFxuICBwcmV2TXVsdGlZZWFyTGFiZWw6IFwiUHJldmlvdXMgMjQgeWVhcnNcIixcbiAgc3dpdGNoVG9NdWx0aVllYXJWaWV3TGFiZWw6IFwiQ2hvb3NlIHllYXIgYW5kIG1vbnRoXCIsXG4gIHN3aXRjaFRvTW9udGhWaWV3TGFiZWw6IFwiQ2hvb3NlIGRhdGVcIixcbiAgc3dpdGNoVG9EYXlWaWV3TGFiZWw6IFwiQ2hvb3NlIGRhdGVcIixcbiAgc3RhcnREYXRlOiBudWxsLFxuICBzdGFydERheTogMCxcbiAgZm9ybWF0OiBcImRkL21tL3l5eXlcIixcbiAgdmlldzogXCJkYXlzXCIsXG4gIHZpZXdDaGFuZ2VJY29uVGVtcGxhdGU6IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIwXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTYgaC02XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSA4LjI1bC03LjUgNy41LTcuNS03LjVcIiAvPlxuICA8L3N2Zz5cbiAgYCxcbiAgbWluOiBudWxsLFxuICBtYXg6IG51bGwsXG4gIGZpbHRlcjogbnVsbCxcbiAgaW5saW5lOiAhMSxcbiAgdG9nZ2xlQnV0dG9uOiAhMCxcbiAgZGlzYWJsZVRvZ2dsZUJ1dHRvbjogITEsXG4gIGRpc2FibGVJbnB1dDogITEsXG4gIGFuaW1hdGlvbnM6ICEwLFxuICBjb25maXJtRGF0ZU9uU2VsZWN0OiAhMSxcbiAgcmVtb3ZlT2tCdG46ICExLFxuICByZW1vdmVDYW5jZWxCdG46ICExLFxuICByZW1vdmVDbGVhckJ0bjogITFcbn0sIE9mID0ge1xuICB0aXRsZTogXCJzdHJpbmdcIixcbiAgY29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBkaXNhYmxlUGFzdDogXCJib29sZWFuXCIsXG4gIGRpc2FibGVGdXR1cmU6IFwiYm9vbGVhblwiLFxuICBtb250aHNGdWxsOiBcImFycmF5XCIsXG4gIG1vbnRoc1Nob3J0OiBcImFycmF5XCIsXG4gIHdlZWtkYXlzRnVsbDogXCJhcnJheVwiLFxuICB3ZWVrZGF5c1Nob3J0OiBcImFycmF5XCIsXG4gIHdlZWtkYXlzTmFycm93OiBcImFycmF5XCIsXG4gIG9rQnRuVGV4dDogXCJzdHJpbmdcIixcbiAgY2xlYXJCdG5UZXh0OiBcInN0cmluZ1wiLFxuICBjYW5jZWxCdG5UZXh0OiBcInN0cmluZ1wiLFxuICBva0J0bkxhYmVsOiBcInN0cmluZ1wiLFxuICBjbGVhckJ0bkxhYmVsOiBcInN0cmluZ1wiLFxuICBjYW5jZWxCdG5MYWJlbDogXCJzdHJpbmdcIixcbiAgbmV4dE1vbnRoTGFiZWw6IFwic3RyaW5nXCIsXG4gIHByZXZNb250aExhYmVsOiBcInN0cmluZ1wiLFxuICBuZXh0WWVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBwcmV2WWVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBuZXh0TXVsdGlZZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIHByZXZNdWx0aVllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgY2hhbmdlTW9udGhJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHN3aXRjaFRvTXVsdGlZZWFyVmlld0xhYmVsOiBcInN0cmluZ1wiLFxuICBzd2l0Y2hUb01vbnRoVmlld0xhYmVsOiBcInN0cmluZ1wiLFxuICBzd2l0Y2hUb0RheVZpZXdMYWJlbDogXCJzdHJpbmdcIixcbiAgc3RhcnREYXRlOiBcIihudWxsfHN0cmluZ3xkYXRlKVwiLFxuICBzdGFydERheTogXCJudW1iZXJcIixcbiAgZm9ybWF0OiBcInN0cmluZ1wiLFxuICB2aWV3OiBcInN0cmluZ1wiLFxuICB2aWV3Q2hhbmdlSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBtaW46IFwiKG51bGx8c3RyaW5nfGRhdGUpXCIsXG4gIG1heDogXCIobnVsbHxzdHJpbmd8ZGF0ZSlcIixcbiAgZmlsdGVyOiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBpbmxpbmU6IFwiYm9vbGVhblwiLFxuICB0b2dnbGVCdXR0b246IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlVG9nZ2xlQnV0dG9uOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZUlucHV0OiBcImJvb2xlYW5cIixcbiAgYW5pbWF0aW9uczogXCJib29sZWFuXCIsXG4gIGNvbmZpcm1EYXRlT25TZWxlY3Q6IFwiYm9vbGVhblwiLFxuICByZW1vdmVPa0J0bjogXCJib29sZWFuXCIsXG4gIHJlbW92ZUNhbmNlbEJ0bjogXCJib29sZWFuXCIsXG4gIHJlbW92ZUNsZWFyQnRuOiBcImJvb2xlYW5cIlxufSwgU2YgPSB7XG4gIGZhZGVJbjogWF8sXG4gIGZhZGVPdXQ6IEdfLFxuICBmYWRlSW5TaG9ydDogcV8sXG4gIGZhZGVPdXRTaG9ydDogWl8sXG4gIG1vZGFsQ29udGFpbmVyOiBRXyxcbiAgZGF0ZXBpY2tlckJhY2tkcm9wOiBKXyxcbiAgZGF0ZXBpY2tlck1haW46IHRmLFxuICBkYXRlcGlja2VySGVhZGVyOiBlZixcbiAgZGF0ZXBpY2tlclRpdGxlOiBzZixcbiAgZGF0ZXBpY2tlclRpdGxlVGV4dDogbmYsXG4gIGRhdGVwaWNrZXJEYXRlOiBvZixcbiAgZGF0ZXBpY2tlckRhdGVUZXh0OiByZixcbiAgZGF0ZXBpY2tlclZpZXc6IGFmLFxuICBkYXRlcGlja2VyRGF0ZUNvbnRyb2xzOiBsZixcbiAgZGF0ZXBpY2tlclZpZXdDaGFuZ2VCdXR0b246IGNmLFxuICBkYXRlcGlja2VyVmlld0NoYW5nZUljb246IHdmLFxuICBkYXRlcGlja2VyQXJyb3dDb250cm9sczogaGYsXG4gIGRhdGVwaWNrZXJQcmV2aW91c0J1dHRvbjogZGYsXG4gIGRhdGVwaWNrZXJOZXh0QnV0dG9uOiB1ZixcbiAgZGF0ZXBpY2tlckZvb3RlcjogcGYsXG4gIGRhdGVwaWNrZXJGb290ZXJCdG46IF9mLFxuICBkYXRlcGlja2VyQ2xlYXJCdG46IGZmLFxuICBkYXRlcGlja2VyRGF5SGVhZGluZzogbWYsXG4gIGRhdGVwaWNrZXJDZWxsOiBnZixcbiAgZGF0ZXBpY2tlckNlbGxTbWFsbDogYmYsXG4gIGRhdGVwaWNrZXJDZWxsTGFyZ2U6IHZmLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnQ6IFRmLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnRTbWFsbDogRWYsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudExhcmdlOiBDZixcbiAgZGF0ZXBpY2tlclRhYmxlOiBBZixcbiAgZGF0ZXBpY2tlclRvZ2dsZUJ1dHRvbjogeWYsXG4gIGRhdGVwaWNrZXJEcm9wZG93bkNvbnRhaW5lcjogeGZcbn0sIElmID0ge1xuICBmYWRlSW46IFwic3RyaW5nXCIsXG4gIGZhZGVPdXQ6IFwic3RyaW5nXCIsXG4gIGZhZGVJblNob3J0OiBcInN0cmluZ1wiLFxuICBmYWRlT3V0U2hvcnQ6IFwic3RyaW5nXCIsXG4gIG1vZGFsQ29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQmFja2Ryb3A6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJNYWluOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VySGVhZGVyOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVGl0bGU6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUaXRsZVRleHQ6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEYXRlOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRGF0ZVRleHQ6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJWaWV3OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRGF0ZUNvbnRyb2xzOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVmlld0NoYW5nZUJ1dHRvbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckFycm93Q29udHJvbHM6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJQcmV2aW91c0J1dHRvbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlck5leHRCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJGb290ZXI6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJGb290ZXJCdG46IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDbGVhckJ0bjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRheUhlYWRpbmc6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbFNtYWxsOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbExhcmdlOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudFNtYWxsOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRhYmxlOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVG9nZ2xlQnV0dG9uOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRHJvcGRvd25Db250YWluZXI6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBGMCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5faW5wdXQgPSBkLmZpbmRPbmUoXCJpbnB1dFwiLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2FjdGl2ZURhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgdGhpcy5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuX2hlYWRlckRhdGUgPSBudWxsLCB0aGlzLl9oZWFkZXJZZWFyID0gbnVsbCwgdGhpcy5faGVhZGVyTW9udGggPSBudWxsLCB0aGlzLl92aWV3ID0gdGhpcy5fb3B0aW9ucy52aWV3LCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsLCB0aGlzLl9pc09wZW4gPSAhMSwgdGhpcy5fdG9nZ2xlQnV0dG9uSWQgPSBidChcImRhdGVwaWNrZXItdG9nZ2xlLVwiKSwgdGhpcy5fYW5pbWF0aW9ucyA9ICF3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpLm1hdGNoZXMgJiYgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25zLCB0aGlzLl9zY3JvbGxCYXIgPSBuZXcga2koKSwgdGhpcy5fZWxlbWVudCAmJiBJLnNldERhdGEodCwgT3MsIHRoaXMpLCB0aGlzLl9pbml0KCksIHRoaXMudG9nZ2xlQnV0dG9uICYmIHRoaXMuX29wdGlvbnMuZGlzYWJsZVRvZ2dsZSAmJiAodGhpcy50b2dnbGVCdXR0b24uZGlzYWJsZWQgPSBcInRydWVcIiksIHRoaXMuX29wdGlvbnMuZGlzYWJsZUlucHV0ICYmICh0aGlzLl9pbnB1dC5kaXNhYmxlZCA9IFwidHJ1ZVwiKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4geG47XG4gIH1cbiAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgYFske2VjfT0nJHt0aGlzLl90b2dnbGVCdXR0b25JZH0nXWBcbiAgICApIHx8IGQuZmluZE9uZShcbiAgICAgIGBbJHtpY309JyR7dGhpcy5fdG9nZ2xlQnV0dG9uSWR9J11gXG4gICAgKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuICBnZXQgYWN0aXZlQ2VsbCgpIHtcbiAgICBsZXQgdDtcbiAgICByZXR1cm4gdGhpcy5fdmlldyA9PT0gXCJkYXlzXCIgJiYgKHQgPSB0aGlzLl9nZXRBY3RpdmVEYXlDZWxsKCkpLCB0aGlzLl92aWV3ID09PSBcIm1vbnRoc1wiICYmICh0ID0gdGhpcy5fZ2V0QWN0aXZlTW9udGhDZWxsKCkpLCB0aGlzLl92aWV3ID09PSBcInllYXJzXCIgJiYgKHQgPSB0aGlzLl9nZXRBY3RpdmVZZWFyQ2VsbCgpKSwgdDtcbiAgfVxuICBnZXQgYWN0aXZlRGF5KCkge1xuICAgIHJldHVybiBaKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG4gIGdldCBhY3RpdmVNb250aCgpIHtcbiAgICByZXR1cm4gWSh0aGlzLl9hY3RpdmVEYXRlKTtcbiAgfVxuICBnZXQgYWN0aXZlWWVhcigpIHtcbiAgICByZXR1cm4gQih0aGlzLl9hY3RpdmVEYXRlKTtcbiAgfVxuICBnZXQgZmlyc3RZZWFySW5WaWV3KCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZVllYXIgLSBBcyh0aGlzLl9hY3RpdmVEYXRlLCBndCk7XG4gIH1cbiAgZ2V0IGxhc3RZZWFySW5WaWV3KCkge1xuICAgIHJldHVybiB0aGlzLmZpcnN0WWVhckluVmlldyArIGd0IC0gMTtcbiAgfVxuICBnZXQgdmlld0NoYW5nZUJ1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKEJfLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IHByZXZpb3VzQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoSF8sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgbmV4dEJ1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFdfLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IG9rQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoVl8sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgY2FuY2VsQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoRl8sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgY2xlYXJCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShZXywgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBkYXRlc0NvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKGpfLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IHRvZ2dsZUJ1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKEtfLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICB1cGRhdGUodCA9IHt9KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyh7IC4uLnRoaXMuX29wdGlvbnMsIC4uLnQgfSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgaWYgKHQgPSB7XG4gICAgICAuLi5rZixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTCh4biwgdCwgT2YpLCB0Lm1heCAmJiB0eXBlb2YgdC5tYXggPT0gXCJzdHJpbmdcIiAmJiAodC5tYXggPSBuZXcgRGF0ZSh0Lm1heCkpLCB0Lm1pbiAmJiB0eXBlb2YgdC5taW4gPT0gXCJzdHJpbmdcIiAmJiAodC5taW4gPSBuZXcgRGF0ZSh0Lm1pbikpLCB0LnN0YXJ0RGF5ICYmIHQuc3RhcnREYXkgIT09IDApIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nZXROZXdEYXlzT3JkZXJBcnJheSh0KTtcbiAgICAgIHQud2Vla2RheXNOYXJyb3cgPSBpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlNmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKHhuLCB0LCBJZiksIHQ7XG4gIH1cbiAgX2dldENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKHRoaXMuX29wdGlvbnMuY29udGFpbmVyKTtcbiAgfVxuICBfZ2V0TmV3RGF5c09yZGVyQXJyYXkodCkge1xuICAgIGNvbnN0IGUgPSB0LnN0YXJ0RGF5LCBpID0gdC53ZWVrZGF5c05hcnJvdztcbiAgICByZXR1cm4gaS5zbGljZShlKS5jb25jYXQoaS5zbGljZSgwLCBlKSk7XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgIXRoaXMudG9nZ2xlQnV0dG9uICYmIHRoaXMuX29wdGlvbnMudG9nZ2xlQnV0dG9uICYmICh0aGlzLl9hcHBlbmRUb2dnbGVCdXR0b24oKSwgKHRoaXMuX2lucHV0LnJlYWRPbmx5IHx8IHRoaXMuX2lucHV0LmRpc2FibGVkKSAmJiAodGhpcy50b2dnbGVCdXR0b24uc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiKSksIHRoaXMuX2xpc3RlblRvVXNlcklucHV0KCksIHRoaXMuX2xpc3RlblRvVG9nZ2xlQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9Ub2dnbGVLZXlkb3duKCk7XG4gIH1cbiAgX2FwcGVuZFRvZ2dsZUJ1dHRvbigpIHtcbiAgICBjb25zdCB0ID0gU18oXG4gICAgICB0aGlzLl90b2dnbGVCdXR0b25JZCxcbiAgICAgIHRoaXMuX2NsYXNzZXMuZGF0ZXBpY2tlclRvZ2dsZUJ1dHRvblxuICAgICk7XG4gICAgdGhpcy5fZWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgdCk7XG4gIH1cbiAgb3BlbigpIHtcbiAgICBpZiAodGhpcy5faW5wdXQucmVhZE9ubHkgfHwgdGhpcy5faW5wdXQuZGlzYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBNXyk7XG4gICAgaWYgKHRoaXMuX2lzT3BlbiB8fCB0LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fc2V0SW5pdGlhbERhdGUoKTtcbiAgICBjb25zdCBlID0gQV8odGhpcy5fY2xhc3Nlcy5kYXRlcGlja2VyQmFja2Ryb3ApLCBpID0gQ18oXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fc2VsZWN0ZWREYXRlLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRNb250aCxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBKaSxcbiAgICAgIGd0LFxuICAgICAgUWksXG4gICAgICB0aGlzLl90b2dnbGVCdXR0b25JZCxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMuX29wdGlvbnMuaW5saW5lID8gdGhpcy5fb3BlbkRyb3Bkb3duKGkpIDogKHRoaXMuX29wZW5Nb2RhbChlLCBpKSwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSksIHRoaXMuX2FuaW1hdGlvbnMgJiYgKGMuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSwgYy5hZGRDbGFzcyhlLCB0aGlzLl9jbGFzc2VzLmZhZGVJblNob3J0KSksIHRoaXMuX3NldEZvY3VzVHJhcCh0aGlzLmNvbnRhaW5lciksIHRoaXMuX2xpc3RlblRvRGF0ZVNlbGVjdGlvbigpLCB0aGlzLl9hZGRDb250cm9sc0xpc3RlbmVycygpLCB0aGlzLl91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKSwgdGhpcy5fbGlzdGVuVG9Fc2NhcGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub0tleWJvYXJkTmF2aWdhdGlvbigpLCB0aGlzLl9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyRm9jdXMoKSwgdGhpcy5fbGlzdGVuVG9EYXRlc0NvbnRhaW5lckJsdXIoKSwgdGhpcy5fYXN5bmNGb2N1c0RhdGVzQ29udGFpbmVyKCksIHRoaXMuX3VwZGF0ZVZpZXdDb250cm9sc0FuZEF0dHJpYnV0ZXModGhpcy5fdmlldyksIHRoaXMuX2lzT3BlbiA9ICEwLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2xpc3RlblRvT3V0c2lkZUNsaWNrKCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX29wZW5Ecm9wZG93bih0KSB7XG4gICAgdGhpcy5fcG9wcGVyID0gRWUodGhpcy5faW5wdXQsIHQsIHtcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b20tc3RhcnRcIlxuICAgIH0pLCB0aGlzLl9nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZCh0KTtcbiAgfVxuICBfb3Blbk1vZGFsKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgaS5hcHBlbmRDaGlsZCh0KSwgaS5hcHBlbmRDaGlsZChlKTtcbiAgfVxuICBfc2V0Rm9jdXNUcmFwKHQpIHtcbiAgICB0aGlzLl9mb2N1c1RyYXAgPSBuZXcgJGkodCwge1xuICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgY29uZGl0aW9uOiAoZSkgPT4gZS5rZXkgPT09IFwiVGFiXCJcbiAgICB9KSwgdGhpcy5fZm9jdXNUcmFwLnRyYXAoKTtcbiAgfVxuICBfbGlzdGVuVG9Vc2VySW5wdXQoKSB7XG4gICAgaC5vbih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlVXNlcklucHV0KHQudGFyZ2V0LnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9Ub2dnbGVDbGljaygpIHtcbiAgICBoLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHRzLFxuICAgICAgZXMsXG4gICAgICAodCkgPT4ge1xuICAgICAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMub3BlbigpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2xpc3RlblRvVG9nZ2xlS2V5ZG93bigpIHtcbiAgICBoLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgZXMsXG4gICAgICAodCkgPT4ge1xuICAgICAgICB0LmtleUNvZGUgPT09IGx0ICYmICF0aGlzLl9pc09wZW4gJiYgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9EYXRlU2VsZWN0aW9uKCkge1xuICAgIGgub24odGhpcy5kYXRlc0NvbnRhaW5lciwgXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlRGF0ZVNlbGVjdGlvbih0KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlRGF0ZVNlbGVjdGlvbih0KSB7XG4gICAgY29uc3QgZSA9IHQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkRJVlwiID8gdC50YXJnZXQucGFyZW50Tm9kZS5kYXRhc2V0IDogdC50YXJnZXQuZGF0YXNldCwgaSA9IHQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkRJVlwiID8gdC50YXJnZXQucGFyZW50Tm9kZSA6IHQudGFyZ2V0O1xuICAgIGlmIChlLnRlRGF0ZSAmJiB0aGlzLl9waWNrRGF5KGUudGVEYXRlLCBpKSwgZS50ZU1vbnRoICYmIGUudGVZZWFyKSB7XG4gICAgICBjb25zdCBuID0gcGFyc2VJbnQoZS50ZU1vbnRoLCAxMCksIG8gPSBwYXJzZUludChlLnRlWWVhciwgMTApO1xuICAgICAgdGhpcy5fcGlja01vbnRoKG4sIG8pO1xuICAgIH1cbiAgICBpZiAoZS50ZVllYXIgJiYgIWUudGVNb250aCkge1xuICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGUudGVZZWFyLCAxMCk7XG4gICAgICB0aGlzLl9waWNrWWVhcihuKTtcbiAgICB9XG4gICAgdGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5fdXBkYXRlSGVhZGVyRGF0ZShcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9vcHRpb25zLm1vbnRoc1Nob3J0LFxuICAgICAgdGhpcy5fb3B0aW9ucy53ZWVrZGF5c1Nob3J0XG4gICAgKTtcbiAgfVxuICBfdXBkYXRlSGVhZGVyRGF0ZSh0LCBlLCBpKSB7XG4gICAgY29uc3QgbiA9IGQuZmluZE9uZShcbiAgICAgIHpfLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApLCBvID0gWSh0KSwgciA9IFoodCksIGEgPSBDcyh0KTtcbiAgICBuLmlubmVySFRNTCA9IGAke2lbYV19LCAke2Vbb119ICR7cn1gO1xuICB9XG4gIF9hZGRDb250cm9sc0xpc3RlbmVycygpIHtcbiAgICBoLm9uKHRoaXMubmV4dEJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl92aWV3ID09PSBcImRheXNcIiA/IHRoaXMubmV4dE1vbnRoKCkgOiB0aGlzLl92aWV3ID09PSBcInllYXJzXCIgPyB0aGlzLm5leHRZZWFycygpIDogdGhpcy5uZXh0WWVhcigpLCB0aGlzLl91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKTtcbiAgICB9KSwgaC5vbih0aGlzLnByZXZpb3VzQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiID8gdGhpcy5wcmV2aW91c01vbnRoKCkgOiB0aGlzLl92aWV3ID09PSBcInllYXJzXCIgPyB0aGlzLnByZXZpb3VzWWVhcnMoKSA6IHRoaXMucHJldmlvdXNZZWFyKCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpO1xuICAgIH0pLCBoLm9uKHRoaXMudmlld0NoYW5nZUJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl92aWV3ID09PSBcImRheXNcIiA/IHRoaXMuX2NoYW5nZVZpZXcoXCJ5ZWFyc1wiKSA6ICh0aGlzLl92aWV3ID09PSBcInllYXJzXCIgfHwgdGhpcy5fdmlldyA9PT0gXCJtb250aHNcIikgJiYgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIik7XG4gICAgfSksIHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX2xpc3RlblRvRm9vdGVyQnV0dG9uc0NsaWNrKCk7XG4gIH1cbiAgX2xpc3RlblRvRm9vdGVyQnV0dG9uc0NsaWNrKCkge1xuICAgIGgub24odGhpcy5va0J1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLmhhbmRsZU9rKCkpLCBoLm9uKHRoaXMuY2FuY2VsQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHRoaXMuaGFuZGxlQ2FuY2VsKCkpLCBoLm9uKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5oYW5kbGVDbGVhcigpKTtcbiAgfVxuICBfbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSB7XG4gICAgaC5vbihkb2N1bWVudCwgdHMsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC50YXJnZXQgPT09IHRoaXMuY29udGFpbmVyLCBpID0gdGhpcy5jb250YWluZXIgJiYgdGhpcy5jb250YWluZXIuY29udGFpbnModC50YXJnZXQpO1xuICAgICAgIWUgJiYgIWkgJiYgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0VzY2FwZUNsaWNrKCkge1xuICAgIGgub24oZG9jdW1lbnQsIFwia2V5ZG93blwiLCAodCkgPT4ge1xuICAgICAgdC5rZXlDb2RlID09PSBMaSAmJiB0aGlzLl9pc09wZW4gJiYgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0tleWJvYXJkTmF2aWdhdGlvbigpIHtcbiAgICBoLm9uKHRoaXMuZGF0ZXNDb250YWluZXIsIFwia2V5ZG93blwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlS2V5ZG93bih0KTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9EYXRlc0NvbnRhaW5lckZvY3VzKCkge1xuICAgIGgub24odGhpcy5kYXRlc0NvbnRhaW5lciwgXCJmb2N1c1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwodGhpcy5hY3RpdmVDZWxsKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9EYXRlc0NvbnRhaW5lckJsdXIoKSB7XG4gICAgaC5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImJsdXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUtleWRvd24odCkge1xuICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiICYmIHRoaXMuX2hhbmRsZURheXNWaWV3S2V5ZG93bih0KSwgdGhpcy5fdmlldyA9PT0gXCJtb250aHNcIiAmJiB0aGlzLl9oYW5kbGVNb250aHNWaWV3S2V5ZG93bih0KSwgdGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiICYmIHRoaXMuX2hhbmRsZVllYXJzVmlld0tleWRvd24odCk7XG4gIH1cbiAgX2hhbmRsZURheXNWaWV3S2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZURhdGUsIGkgPSB0aGlzLmFjdGl2ZUNlbGw7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgUGU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB4ZSh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAxIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQmU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB4ZSh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcnQ6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB4ZSh0aGlzLl9hY3RpdmVEYXRlLCAtNyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB6OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0geGUodGhpcy5fYWN0aXZlRGF0ZSwgNyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHhlKFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgMSAtIFoodGhpcy5fYWN0aXZlRGF0ZSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0geGUoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICBybyh0aGlzLl9hY3RpdmVEYXRlKSAtIFoodGhpcy5fYWN0aXZlRGF0ZSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHluOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugd246XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGx0OlxuICAgICAgY2FzZSBrczpcbiAgICAgICAgdGhpcy5fc2VsZWN0RGF0ZSh0aGlzLl9hY3RpdmVEYXRlKSwgdGhpcy5faGFuZGxlRGF0ZVNlbGVjdGlvbih0KSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIEFpKFxuICAgICAgZSxcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl92aWV3LFxuICAgICAgZ3QsXG4gICAgICB0aGlzLl9vcHRpb25zLm1pbixcbiAgICAgIHRoaXMuX29wdGlvbnMubWF4XG4gICAgKSB8fCB0aGlzLl9jaGFuZ2VWaWV3KFwiZGF5c1wiKSwgdGhpcy5fcmVtb3ZlSGlnaGxpZ2h0RnJvbUNlbGwoaSksIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2FzeW5jRm9jdXNEYXRlc0NvbnRhaW5lcigpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZGF0ZXNDb250YWluZXIuZm9jdXMoKTtcbiAgICB9LCAwKTtcbiAgfVxuICBfZm9jdXNBY3RpdmVDZWxsKHQpIHtcbiAgICB0ICYmIHQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZFwiLCBcIlwiKTtcbiAgfVxuICBfcmVtb3ZlSGlnaGxpZ2h0RnJvbUNlbGwodCkge1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXCIpO1xuICB9XG4gIF9nZXRBY3RpdmVEYXlDZWxsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoXCJ0ZFwiLCB0aGlzLmRhdGVzQ29udGFpbmVyKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0KS5maW5kKChpKSA9PiB7XG4gICAgICBjb25zdCBuID0gWXIoaS5kYXRhc2V0LnRlRGF0ZSk7XG4gICAgICByZXR1cm4gX2UobiwgdGhpcy5fYWN0aXZlRGF0ZSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZU1vbnRoc1ZpZXdLZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fYWN0aXZlRGF0ZSwgaSA9IHRoaXMuYWN0aXZlQ2VsbDtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSBQZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IDEgOiAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IC0xIDogMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBydDpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIC00KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHo6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCA0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgLXRoaXMuYWN0aXZlTW9udGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgV2U6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAxMSAtIHRoaXMuYWN0aXZlTW9udGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgeW46XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB3bjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbHQ6XG4gICAgICBjYXNlIGtzOlxuICAgICAgICB0aGlzLl9zZWxlY3RNb250aCh0aGlzLmFjdGl2ZU1vbnRoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBBaShcbiAgICAgIGUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIGd0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heFxuICAgICkgfHwgdGhpcy5fY2hhbmdlVmlldyhcIm1vbnRoc1wiKSwgdGhpcy5fcmVtb3ZlSGlnaGxpZ2h0RnJvbUNlbGwoaSksIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2dldEFjdGl2ZU1vbnRoQ2VsbCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKFwidGRcIiwgdGhpcy5kYXRlc0NvbnRhaW5lcik7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odCkuZmluZCgoaSkgPT4ge1xuICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGkuZGF0YXNldC50ZVllYXIsIDEwKSwgbyA9IHBhcnNlSW50KGkuZGF0YXNldC50ZU1vbnRoLCAxMCk7XG4gICAgICByZXR1cm4gbiA9PT0gdGhpcy5hY3RpdmVZZWFyICYmIG8gPT09IHRoaXMuYWN0aXZlTW9udGg7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVllYXJzVmlld0tleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hY3RpdmVEYXRlLCBpID0gdGhpcy5hY3RpdmVDZWxsLCBuID0gNCwgbyA9IDI0O1xuICAgIHN3aXRjaCAodC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIFBlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gMSA6IC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gLTEgOiAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHJ0OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgLW4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgejpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIG4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSGU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdChcbiAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgICAgIC1Bcyh0aGlzLl9hY3RpdmVEYXRlLCBvKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgV2U6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdChcbiAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgICAgIG8gLSBBcyh0aGlzLl9hY3RpdmVEYXRlLCBvKSAtIDFcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHluOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgLW8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugd246XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCBvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGx0OlxuICAgICAgY2FzZSBrczpcbiAgICAgICAgdGhpcy5fc2VsZWN0WWVhcih0aGlzLmFjdGl2ZVllYXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIEFpKFxuICAgICAgZSxcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl92aWV3LFxuICAgICAgZ3QsXG4gICAgICB0aGlzLl9vcHRpb25zLm1pbixcbiAgICAgIHRoaXMuX29wdGlvbnMubWF4XG4gICAgKSB8fCB0aGlzLl9jaGFuZ2VWaWV3KFwieWVhcnNcIiksIHRoaXMuX3JlbW92ZUhpZ2hsaWdodEZyb21DZWxsKGkpLCB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwodGhpcy5hY3RpdmVDZWxsKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9nZXRBY3RpdmVZZWFyQ2VsbCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKFwidGRcIiwgdGhpcy5kYXRlc0NvbnRhaW5lcik7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odCkuZmluZCgoaSkgPT4gcGFyc2VJbnQoaS5kYXRhc2V0LnRlWWVhciwgMTApID09PSB0aGlzLmFjdGl2ZVllYXIpO1xuICB9XG4gIF9zZXRJbml0aWFsRGF0ZSgpIHtcbiAgICB0aGlzLl9pbnB1dC52YWx1ZSA/IHRoaXMuX2hhbmRsZVVzZXJJbnB1dCh0aGlzLl9pbnB1dC52YWx1ZSkgOiB0aGlzLl9vcHRpb25zLnN0YXJ0RGF0ZSA/IHRoaXMuX2FjdGl2ZURhdGUgPSBuZXcgRGF0ZSh0aGlzLl9vcHRpb25zLnN0YXJ0RGF0ZSkgOiB0aGlzLl9hY3RpdmVEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgY29uc3QgdCA9IGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBMXyk7XG4gICAgIXRoaXMuX2lzT3BlbiB8fCB0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX3JlbW92ZURhdGVwaWNrZXJMaXN0ZW5lcnMoKSwgdGhpcy5fYW5pbWF0aW9ucyAmJiBjLmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpLCB0aGlzLl9vcHRpb25zLmlubGluZSA/IHRoaXMuX2Nsb3NlRHJvcGRvd24oKSA6IHRoaXMuX2Nsb3NlTW9kYWwoKSwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX3ZpZXcgPSB0aGlzLl9vcHRpb25zLnZpZXcsIHRoaXMudG9nZ2xlQnV0dG9uID8gdGhpcy50b2dnbGVCdXR0b24uZm9jdXMoKSA6IHRoaXMuX2lucHV0LmZvY3VzKCkpO1xuICB9XG4gIF9jbG9zZURyb3Bkb3duKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoUF8pLCBlID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKS5tYXRjaGVzICYmICh0ICYmIGUucmVtb3ZlQ2hpbGQodCksIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpKSwgdC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHQgJiYgZS5yZW1vdmVDaGlsZCh0KSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgfSksIHRoaXMuX3JlbW92ZUZvY3VzVHJhcCgpO1xuICB9XG4gIF9jbG9zZU1vZGFsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoVV8pLCBlID0gZC5maW5kT25lKFJfKTtcbiAgICAhZSB8fCAhdCB8fCAodGhpcy5fYW5pbWF0aW9ucyA/IChjLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dFNob3J0KSwgdC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZVBpY2tlcih0LCBlKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgfSkpIDogKHRoaXMuX3JlbW92ZVBpY2tlcih0LCBlKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCkpKTtcbiAgfVxuICBfcmVtb3ZlUGlja2VyKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgaS5yZW1vdmVDaGlsZCh0KSwgaS5yZW1vdmVDaGlsZChlKTtcbiAgfVxuICBfcmVtb3ZlRm9jdXNUcmFwKCkge1xuICAgIHRoaXMuX2ZvY3VzVHJhcCAmJiAodGhpcy5fZm9jdXNUcmFwLmRpc2FibGUoKSwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCk7XG4gIH1cbiAgX3JlbW92ZURhdGVwaWNrZXJMaXN0ZW5lcnMoKSB7XG4gICAgaC5vZmYodGhpcy5uZXh0QnV0dG9uLCBcImNsaWNrXCIpLCBoLm9mZih0aGlzLnByZXZpb3VzQnV0dG9uLCBcImNsaWNrXCIpLCBoLm9mZih0aGlzLnZpZXdDaGFuZ2VCdXR0b24sIFwiY2xpY2tcIiksIGgub2ZmKHRoaXMub2tCdXR0b24sIFwiY2xpY2tcIiksIGgub2ZmKHRoaXMuY2FuY2VsQnV0dG9uLCBcImNsaWNrXCIpLCBoLm9mZih0aGlzLmNsZWFyQnV0dG9uLCBcImNsaWNrXCIpLCBoLm9mZih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImNsaWNrXCIpLCBoLm9mZih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImtleWRvd25cIiksIGgub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiZm9jdXNcIiksIGgub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiYmx1clwiKSwgaC5vZmYoZG9jdW1lbnQsIHRzKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2lzT3BlbiAmJiB0aGlzLmNsb3NlKCksIHRoaXMuX3JlbW92ZUlucHV0QW5kVG9nZ2xlTGlzdGVuZXJzKCk7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIGAjJHt0aGlzLl90b2dnbGVCdXR0b25JZH1gXG4gICAgKTtcbiAgICB0ICYmIHRoaXMuX2VsZW1lbnQucmVtb3ZlQ2hpbGQodCksIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBPcyksIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9pbnB1dCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsLCB0aGlzLl9hY3RpdmVEYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuX2hlYWRlckRhdGUgPSBudWxsLCB0aGlzLl9oZWFkZXJZZWFyID0gbnVsbCwgdGhpcy5faGVhZGVyTW9udGggPSBudWxsLCB0aGlzLl92aWV3ID0gbnVsbCwgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbDtcbiAgfVxuICBfcmVtb3ZlSW5wdXRBbmRUb2dnbGVMaXN0ZW5lcnMoKSB7XG4gICAgaC5vZmYodGhpcy5faW5wdXQsIFwiaW5wdXRcIiksIGgub2ZmKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHRzLFxuICAgICAgZXNcbiAgICApLCBoLm9mZih0aGlzLl9lbGVtZW50LCBcImtleWRvd25cIiwgZXMpO1xuICB9XG4gIGhhbmRsZU9rKCkge1xuICAgIHRoaXMuX2NvbmZpcm1TZWxlY3Rpb24odGhpcy5faGVhZGVyRGF0ZSksIHRoaXMuY2xvc2UoKTtcbiAgfVxuICBfc2VsZWN0RGF0ZSh0LCBlID0gdGhpcy5hY3RpdmVDZWxsKSB7XG4gICAgY29uc3QgeyBtaW46IGksIG1heDogbiwgZmlsdGVyOiBvLCBkaXNhYmxlUGFzdDogciwgZGlzYWJsZUZ1dHVyZTogYSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBQcyh0LCBpLCBuLCBvLCByLCBhKSB8fCAodGhpcy5fcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpLCB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKSwgdGhpcy5fYWRkU2VsZWN0ZWRTdHlsZXMoZSksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IHQsIHRoaXMuX3NlbGVjdGVkWWVhciA9IEIodCksIHRoaXMuX3NlbGVjdGVkTW9udGggPSBZKHQpLCB0aGlzLl9oZWFkZXJEYXRlID0gdCwgKHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMub3B0aW9ucy5jb25maXJtRGF0ZU9uU2VsZWN0KSAmJiAodGhpcy5fY29uZmlybVNlbGVjdGlvbih0KSwgdGhpcy5jbG9zZSgpKSk7XG4gIH1cbiAgX3NlbGVjdFllYXIodCwgZSA9IHRoaXMuYWN0aXZlQ2VsbCkge1xuICAgIHRoaXMuX3JlbW92ZUN1cnJlbnRTZWxlY3Rpb25TdHlsZXMoKSwgdGhpcy5fcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCksIHRoaXMuX2FkZFNlbGVjdGVkU3R5bGVzKGUpLCB0aGlzLl9oZWFkZXJZZWFyID0gdCwgdGhpcy5fYXN5bmNDaGFuZ2VWaWV3KFwibW9udGhzXCIpO1xuICB9XG4gIF9zZWxlY3RNb250aCh0LCBlID0gdGhpcy5hY3RpdmVDZWxsKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpLCB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKSwgdGhpcy5fYWRkU2VsZWN0ZWRTdHlsZXMoZSksIHRoaXMuX2hlYWRlck1vbnRoID0gdCwgdGhpcy5fYXN5bmNDaGFuZ2VWaWV3KFwiZGF5c1wiKTtcbiAgfVxuICBfcmVtb3ZlU2VsZWN0ZWRTdHlsZXModCkge1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiKTtcbiAgfVxuICBfYWRkU2VsZWN0ZWRTdHlsZXModCkge1xuICAgIHQgJiYgdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiLCBcIlwiKTtcbiAgfVxuICBfY29uZmlybVNlbGVjdGlvbih0KSB7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLmZvcm1hdERhdGUodCk7XG4gICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IGUsIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBOXywgeyBkYXRlOiB0IH0pLCBoLnRyaWdnZXIodGhpcy5faW5wdXQsIFwiaW5wdXRcIik7XG4gICAgfVxuICB9XG4gIGhhbmRsZUNhbmNlbCgpIHtcbiAgICB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5jbG9zZSgpO1xuICB9XG4gIGhhbmRsZUNsZWFyKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5faGVhZGVyTW9udGggPSBudWxsLCB0aGlzLl9oZWFkZXJZZWFyID0gbnVsbCwgdGhpcy5fcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpLCB0aGlzLl9pbnB1dC52YWx1ZSA9IFwiXCIsIHRoaXMuX3NldEluaXRpYWxEYXRlKCksIHRoaXMuX2NoYW5nZVZpZXcoXCJkYXlzXCIpLCB0aGlzLl91cGRhdGVIZWFkZXJEYXRlKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnQsXG4gICAgICB0aGlzLl9vcHRpb25zLndlZWtkYXlzU2hvcnRcbiAgICApO1xuICB9XG4gIF9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF1cIixcbiAgICAgIHRoaXMuY29udGFpbmVyXG4gICAgKTtcbiAgICB0ICYmIHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIik7XG4gIH1cbiAgX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgXCJbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZF1cIixcbiAgICAgIHRoaXMuY29udGFpbmVyXG4gICAgKTtcbiAgICB0ICYmIHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZFwiKTtcbiAgfVxuICBmb3JtYXREYXRlKHQpIHtcbiAgICBjb25zdCBlID0gWih0KSwgaSA9IHRoaXMuX2FkZExlYWRpbmdaZXJvKFoodCkpLCBuID0gdGhpcy5fb3B0aW9ucy53ZWVrZGF5c1Nob3J0W0NzKHQpXSwgbyA9IHRoaXMuX29wdGlvbnMud2Vla2RheXNGdWxsW0NzKHQpXSwgciA9IFkodCkgKyAxLCBhID0gdGhpcy5fYWRkTGVhZGluZ1plcm8oWSh0KSArIDEpLCBsID0gdGhpcy5fb3B0aW9ucy5tb250aHNTaG9ydFtZKHQpXSwgcCA9IHRoaXMuX29wdGlvbnMubW9udGhzRnVsbFtZKHQpXSwgdSA9IEIodCkudG9TdHJpbmcoKS5sZW5ndGggPT09IDIgPyBCKHQpIDogQih0KS50b1N0cmluZygpLnNsaWNlKDIsIDQpLCBmID0gQih0KSwgXyA9IHRoaXMuX29wdGlvbnMuZm9ybWF0LnNwbGl0KFxuICAgICAgLyhkezEsNH18bXsxLDR9fHl7NH18eXl8IS4pL2dcbiAgICApO1xuICAgIGxldCBtID0gXCJcIjtcbiAgICByZXR1cm4gXy5mb3JFYWNoKChnKSA9PiB7XG4gICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgY2FzZSBcImRkZGRcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIG8pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGRkXCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCBuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCBpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW1tbVwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgcCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtbW1cIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCBmKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCB1KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG0gKz0gZztcbiAgICB9KSwgbTtcbiAgfVxuICBfYWRkTGVhZGluZ1plcm8odCkge1xuICAgIHJldHVybiBwYXJzZUludCh0LCAxMCkgPCAxMCA/IGAwJHt0fWAgOiB0O1xuICB9XG4gIF9waWNrRGF5KHQsIGUpIHtcbiAgICBjb25zdCBpID0gWXIodCksIHsgbWluOiBuLCBtYXg6IG8sIGZpbHRlcjogciwgZGlzYWJsZVBhc3Q6IGEsIGRpc2FibGVGdXR1cmU6IGwgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgUHMoaSwgbiwgbywgciwgYSwgbCkgfHwgKHRoaXMuX2FjdGl2ZURhdGUgPSBpLCB0aGlzLl9zZWxlY3REYXRlKGksIGUpKTtcbiAgfVxuICBfcGlja1llYXIodCkge1xuICAgIGNvbnN0IHsgbWluOiBlLCBtYXg6IGksIGRpc2FibGVQYXN0OiBuLCBkaXNhYmxlRnV0dXJlOiBvIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGlmIChhbyh0LCBlLCBpLCBuLCBvKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gTXQodCwgdGhpcy5hY3RpdmVNb250aCwgdGhpcy5hY3RpdmVEYXkpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSByLCB0aGlzLl9zZWxlY3RlZERhdGUgPSByLCB0aGlzLl9zZWxlY3RZZWFyKHQpO1xuICB9XG4gIF9waWNrTW9udGgodCwgZSkge1xuICAgIGNvbnN0IHsgbWluOiBpLCBtYXg6IG4sIGRpc2FibGVQYXN0OiBvLCBkaXNhYmxlRnV0dXJlOiByIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGlmICh0Yyh0LCBlLCBpLCBuLCBvLCByKSB8fCBhbyhlLCBpLCBuLCBvLCByKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0gTXQoZSwgdCwgdGhpcy5hY3RpdmVEYXkpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBhLCB0aGlzLl9zZWxlY3RNb250aCh0KTtcbiAgfVxuICBuZXh0TW9udGgoKSB7XG4gICAgY29uc3QgdCA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIDEpLCBlID0geXMoXG4gICAgICB0LFxuICAgICAgdGhpcy5faGVhZGVyRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5fb3B0aW9ucy5tb250aHNGdWxsW3RoaXMuYWN0aXZlTW9udGhdfSAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IER0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgcHJldmlvdXNNb250aCgpIHtcbiAgICBjb25zdCB0ID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgLTEpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0O1xuICAgIGNvbnN0IGUgPSB5cyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9oZWFkZXJEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuX29wdGlvbnMubW9udGhzRnVsbFt0aGlzLmFjdGl2ZU1vbnRoXX0gJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBEdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIG5leHRZZWFyKCkge1xuICAgIGNvbnN0IHQgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAxKTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gRHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgY29uc3QgZSA9IHdzKFxuICAgICAgdGhpcy5hY3RpdmVZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRNb250aCxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBKaSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBwcmV2aW91c1llYXIoKSB7XG4gICAgY29uc3QgdCA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gRHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgY29uc3QgZSA9IHdzKFxuICAgICAgdGhpcy5hY3RpdmVZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRNb250aCxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBKaSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBuZXh0WWVhcnMoKSB7XG4gICAgY29uc3QgdCA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIDI0KTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdDtcbiAgICBjb25zdCBlID0geHMoXG4gICAgICB0LFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIGd0LFxuICAgICAgUWksXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmZpcnN0WWVhckluVmlld30gLSAke3RoaXMubGFzdFllYXJJblZpZXd9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBEdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIHByZXZpb3VzWWVhcnMoKSB7XG4gICAgY29uc3QgdCA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIC0yNCk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQ7XG4gICAgY29uc3QgZSA9IHhzKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBndCxcbiAgICAgIFFpLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5maXJzdFllYXJJblZpZXd9IC0gJHt0aGlzLmxhc3RZZWFySW5WaWV3fWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gRHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBfYXN5bmNDaGFuZ2VWaWV3KHQpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2NoYW5nZVZpZXcodCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX2NoYW5nZVZpZXcodCkge1xuICAgIHRoaXMuX3ZpZXcgPSB0LCB0aGlzLmRhdGVzQ29udGFpbmVyLmJsdXIoKSwgdCA9PT0gXCJkYXlzXCIgJiYgKHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0geXMoXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5faGVhZGVyRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSksIHQgPT09IFwibW9udGhzXCIgJiYgKHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gd3MoXG4gICAgICB0aGlzLmFjdGl2ZVllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIEppLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICkpLCB0ID09PSBcInllYXJzXCIgJiYgKHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0geHMoXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIGd0LFxuICAgICAgUWksXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSksIHRoaXMuZGF0ZXNDb250YWluZXIuZm9jdXMoKSwgdGhpcy5fdXBkYXRlVmlld0NvbnRyb2xzQW5kQXR0cmlidXRlcyh0KSwgdGhpcy5fdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCk7XG4gIH1cbiAgX3VwZGF0ZVZpZXdDb250cm9sc0FuZEF0dHJpYnV0ZXModCkge1xuICAgIHQgPT09IFwiZGF5c1wiICYmICh0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGxbdGhpcy5hY3RpdmVNb250aF19ICR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gRHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3dpdGNoVG9NdWx0aVllYXJWaWV3TGFiZWxcbiAgICApLCB0aGlzLnByZXZpb3VzQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5wcmV2TW9udGhMYWJlbFxuICAgICksIHRoaXMubmV4dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMuX29wdGlvbnMubmV4dE1vbnRoTGFiZWwpKSwgdCA9PT0gXCJtb250aHNcIiAmJiAodGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gRHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3dpdGNoVG9EYXlWaWV3TGFiZWxcbiAgICApLCB0aGlzLnByZXZpb3VzQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5wcmV2WWVhckxhYmVsXG4gICAgKSwgdGhpcy5uZXh0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5fb3B0aW9ucy5uZXh0WWVhckxhYmVsKSksIHQgPT09IFwieWVhcnNcIiAmJiAodGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5maXJzdFllYXJJblZpZXd9IC0gJHt0aGlzLmxhc3RZZWFySW5WaWV3fWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gRHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3dpdGNoVG9Nb250aFZpZXdMYWJlbFxuICAgICksIHRoaXMucHJldmlvdXNCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnByZXZNdWx0aVllYXJMYWJlbFxuICAgICksIHRoaXMubmV4dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMubmV4dE11bHRpWWVhckxhYmVsXG4gICAgKSk7XG4gIH1cbiAgX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpIHtcbiAgICBoXyhcbiAgICAgIHRoaXMuX29wdGlvbnMuZGlzYWJsZUZ1dHVyZSxcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl92aWV3LFxuICAgICAgZ3QsXG4gICAgICB0aGlzLl9vcHRpb25zLm1pbixcbiAgICAgIHRoaXMuX29wdGlvbnMubWF4LFxuICAgICAgdGhpcy5sYXN0WWVhckluVmlldyxcbiAgICAgIHRoaXMuZmlyc3RZZWFySW5WaWV3XG4gICAgKSA/IHRoaXMubmV4dEJ1dHRvbi5kaXNhYmxlZCA9ICEwIDogdGhpcy5uZXh0QnV0dG9uLmRpc2FibGVkID0gITEsIGRfKFxuICAgICAgdGhpcy5fb3B0aW9ucy5kaXNhYmxlUGFzdCxcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl92aWV3LFxuICAgICAgZ3QsXG4gICAgICB0aGlzLl9vcHRpb25zLm1pbixcbiAgICAgIHRoaXMuX29wdGlvbnMubWF4LFxuICAgICAgdGhpcy5sYXN0WWVhckluVmlldyxcbiAgICAgIHRoaXMuZmlyc3RZZWFySW5WaWV3XG4gICAgKSA/IHRoaXMucHJldmlvdXNCdXR0b24uZGlzYWJsZWQgPSAhMCA6IHRoaXMucHJldmlvdXNCdXR0b24uZGlzYWJsZWQgPSAhMTtcbiAgfVxuICBfaGFuZGxlVXNlcklucHV0KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0RGVsaW1ldGVycyh0aGlzLl9vcHRpb25zLmZvcm1hdCksIGkgPSB0aGlzLl9wYXJzZURhdGUodCwgdGhpcy5fb3B0aW9ucy5mb3JtYXQsIGUpO1xuICAgIGFfKGkpID8gKHRoaXMuX2FjdGl2ZURhdGUgPSBpLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBpLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBCKGkpLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gWShpKSwgdGhpcy5faGVhZGVyRGF0ZSA9IGkpIDogKHRoaXMuX2FjdGl2ZURhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgdGhpcy5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlckRhdGUgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsKTtcbiAgfVxuICBfZ2V0RGVsaW1ldGVycyh0KSB7XG4gICAgcmV0dXJuIHQubWF0Y2goL1teKGRteSldezEsfS9nKTtcbiAgfVxuICBfcGFyc2VEYXRlKHQsIGUsIGkpIHtcbiAgICBsZXQgbjtcbiAgICBpWzBdICE9PSBpWzFdID8gbiA9IGlbMF0gKyBpWzFdIDogbiA9IGlbMF07XG4gICAgY29uc3QgbyA9IG5ldyBSZWdFeHAoYFske259XWApLCByID0gdC5zcGxpdChvKSwgYSA9IGUuc3BsaXQobyksIGwgPSBlLmluZGV4T2YoXCJtbW1cIikgIT09IC0xLCBwID0gW107XG4gICAgZm9yIChsZXQgdiA9IDA7IHYgPCBhLmxlbmd0aDsgdisrKVxuICAgICAgYVt2XS5pbmRleE9mKFwieXlcIikgIT09IC0xICYmIChwWzBdID0geyB2YWx1ZTogclt2XSwgZm9ybWF0OiBhW3ZdIH0pLCBhW3ZdLmluZGV4T2YoXCJtXCIpICE9PSAtMSAmJiAocFsxXSA9IHsgdmFsdWU6IHJbdl0sIGZvcm1hdDogYVt2XSB9KSwgYVt2XS5pbmRleE9mKFwiZFwiKSAhPT0gLTEgJiYgYVt2XS5sZW5ndGggPD0gMiAmJiAocFsyXSA9IHsgdmFsdWU6IHJbdl0sIGZvcm1hdDogYVt2XSB9KTtcbiAgICBsZXQgdTtcbiAgICBlLmluZGV4T2YoXCJtbW1tXCIpICE9PSAtMSA/IHUgPSB0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGwgOiB1ID0gdGhpcy5fb3B0aW9ucy5tb250aHNTaG9ydDtcbiAgICBjb25zdCBmID0gTnVtYmVyKHBbMF0udmFsdWUpLCBfID0gbCA/IHRoaXMuZ2V0TW9udGhOdW1iZXJCeU1vbnRoTmFtZShwWzFdLnZhbHVlLCB1KSA6IE51bWJlcihwWzFdLnZhbHVlKSAtIDEsIG0gPSBOdW1iZXIocFsyXS52YWx1ZSk7XG4gICAgcmV0dXJuIE10KGYsIF8sIG0pO1xuICB9XG4gIGdldE1vbnRoTnVtYmVyQnlNb250aE5hbWUodCwgZSkge1xuICAgIHJldHVybiBlLmZpbmRJbmRleCgoaSkgPT4gaSA9PT0gdCk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIE9zKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBEZiA9ICh7XG4gIGZvcm1hdDI0OiBzLFxuICBva0xhYmVsOiB0LFxuICBjYW5jZWxMYWJlbDogZSxcbiAgaGVhZElEOiBpLFxuICBmb290ZXJJRDogbixcbiAgYm9keUlEOiBvLFxuICBwaWNrZXJJRDogcixcbiAgY2xlYXJMYWJlbDogYSxcbiAgaW5saW5lOiBsLFxuICBzaG93Q2xlYXJCdG46IHAsXG4gIGFtTGFiZWw6IHUsXG4gIHBtTGFiZWw6IGZcbn0sIF8pID0+IHtcbiAgY29uc3QgbSA9IGA8ZGl2IGlkPScke3J9JyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJXcmFwcGVyfScgZGF0YS10ZS10aW1lcGlja2VyLXdyYXBwZXI+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJDb250YWluZXJ9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke18udGltZXBpY2tlckVsZW1lbnRzfVwiPlxuICAgICAgICA8ZGl2IGlkPScke2l9JyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJIZWFkfScgc3R5bGU9J3BhZGRpbmctcmlnaHQ6JHtzID8gNTAgOiAxMH1weCc+XG4gICAgICAgIDxkaXYgY2xhc3M9JyR7Xy50aW1lcGlja2VySGVhZENvbnRlbnR9Jz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke18udGltZXBpY2tlckN1cnJlbnRXcmFwcGVyfVwiPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Xy50aW1lcGlja2VyQ3VycmVudEJ1dHRvbldyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke18udGltZXBpY2tlckN1cnJlbnRCdXR0b259JyB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXRpbWVwaWNrZXItYWN0aXZlIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50IGRhdGEtdGUtdGltZXBpY2tlci1ob3VyIGRhdGEtdGUtcmlwcGxlLWluaXQ+MjE8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Xy50aW1lcGlja2VyRG90fScgZGlzYWJsZWQ+OjwvYnV0dG9uPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke18udGltZXBpY2tlckN1cnJlbnRCdXR0b25XcmFwcGVyfVwiPlxuICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Xy50aW1lcGlja2VyQ3VycmVudEJ1dHRvbn0nIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50IGRhdGEtdGUtdGltZXBpY2tlci1taW51dGUgZGF0YS10ZS1yaXBwbGUtaW5pdD4yMTwvYnV0dG9uPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAke3MgPyBcIlwiIDogYDxkaXYgY2xhc3M9XCIke18udGltZXBpY2tlck1vZGVXcmFwcGVyfVwiPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJNb2RlQW19XCIgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS10aW1lcGlja2VyLWFtIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyLW1vZGUgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3V9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJNb2RlUG19XCIgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS10aW1lcGlja2VyLXBtIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyLW1vZGUgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke2Z9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+YH1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgICR7bCA/IFwiXCIgOiBgPGRpdiBpZD0nJHtvfScgY2xhc3M9JyR7Xy50aW1lcGlja2VyQ2xvY2tXcmFwcGVyfScgZGF0YS10ZS10aW1lcGlja2VyLWNsb2NrLXdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPScke18udGltZXBpY2tlckNsb2NrfScgZGF0YS10ZS10aW1lcGlja2VyLWNsb2NrPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nJHtfLnRpbWVwaWNrZXJNaWRkbGVEb3R9JyBkYXRhLXRlLXRpbWVwaWNrZXItbWlkZGxlLWRvdD48L3NwYW4+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9JyR7Xy50aW1lcGlja2VySGFuZFBvaW50ZXJ9JyBkYXRhLXRlLXRpbWVwaWNrZXItaGFuZC1wb2ludGVyPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9JyR7Xy50aW1lcGlja2VyUG9pbnRlckNpcmNsZX0nIGRhdGEtdGUtdGltZXBpY2tlci1jaXJjbGU+PC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAke3MgPyAnPGRpdiBjbGFzcz1cIicgKyBfLnRpbWVwaWNrZXJDbG9ja0lubmVyICsgJ1wiIGRhdGEtdGUtdGltZXBpY2tlci1jbG9jay1pbm5lcj48L2Rpdj4nIDogXCJcIn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PmB9XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD0nJHtufScgY2xhc3M9JyR7Xy50aW1lcGlja2VyRm9vdGVyV3JhcHBlcn0nPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7Xy50aW1lcGlja2VyRm9vdGVyfVwiPlxuICAgICAgICAke3AgPyBgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke18udGltZXBpY2tlckZvb3RlckJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1jbGVhciB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7YX08L2J1dHRvbj5gIDogXCJcIn1cbiAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke18udGltZXBpY2tlckZvb3RlckJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1jYW5jZWwgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke2V9PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJGb290ZXJCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItc3VibWl0IHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt0fTwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+YCwgZyA9IGA8ZGl2IGlkPScke3J9JyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJJbmxpbmVXcmFwcGVyfScgZGF0YS10ZS10aW1lcGlja2VyLXdyYXBwZXI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke18udGltZXBpY2tlcklubGluZUNvbnRhaW5lcn1cIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJJbmxpbmVFbGVtZW50c31cIj5cbiAgICAgICAgICA8ZGl2IGlkPScke2l9JyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJJbmxpbmVIZWFkfSdcbiAgICAgICAgICBzdHlsZT0ncGFkZGluZy1yaWdodDoxMHB4Jz5cbiAgICAgICAgICA8ZGl2IGNsYXNzPScke18udGltZXBpY2tlcklubGluZUhlYWRDb250ZW50fSc+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke18udGltZXBpY2tlckN1cnJlbnRXcmFwcGVyfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJJbmxpbmVIb3VyV3JhcHBlcn1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaW5saW5lLWhvdXItaWNvbnM+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Xy50aW1lcGlja2VySW5saW5lSWNvblVwfVwiIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLXVwIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWlubGluZS1ob3VyPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Xy50aW1lcGlja2VySW5saW5lSWNvblN2Z31cIj5cbiAgICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNSBoLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTQuNSAxNS43NWw3LjUtNy41IDcuNSA3LjVcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPiAgIFxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Xy50aW1lcGlja2VySW5saW5lQ3VycmVudEJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50IGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50LWlubGluZSB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PjIxPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Xy50aW1lcGlja2VySW5saW5lSWNvbkRvd259XCIgZGF0YS10ZS10aW1lcGlja2VyLWljb24taW5saW5lLWhvdXIgZGF0YS10ZS10aW1lcGlja2VyLWljb24tZG93bj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke18udGltZXBpY2tlcklubGluZUljb25Tdmd9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xOS41IDguMjVsLTcuNSA3LjUtNy41LTcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgPC9zdmc+ICBcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Xy50aW1lcGlja2VySW5saW5lRG90fScgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQtaW5saW5lIGRpc2FibGVkPjo8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke18udGltZXBpY2tlckN1cnJlbnRNaW51dGVXcmFwcGVyfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJJbmxpbmVJY29uVXB9XCIgZGF0YS10ZS10aW1lcGlja2VyLWljb24tdXAgZGF0YS10ZS10aW1lcGlja2VyLWljb24taW5saW5lLW1pbnV0ZT5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnfVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNSBoLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk00LjUgMTUuNzVsNy41LTcuNSA3LjUgNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJJbmxpbmVDdXJyZW50QnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLW1pbnV0ZSBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudCBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudC1pbmxpbmUgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4yMTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJJbmxpbmVJY29uRG93bn1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1pbmxpbmUtbWludXRlIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWRvd24+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Xy50aW1lcGlja2VySW5saW5lSWNvblN2Z31cIj5cbiAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSA4LjI1bC03LjUgNy41LTcuNS03LjVcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz4gXG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAke3MgPyBcIlwiIDogYDxkaXYgY2xhc3M9XCIke18udGltZXBpY2tlcklubGluZU1vZGVXcmFwcGVyfVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz1cIiR7Xy50aW1lcGlja2VySW5saW5lTW9kZUFtfVwiIGRhdGEtdGUtdGltZXBpY2tlci1hbSBkYXRhLXRlLXRpbWVwaWNrZXItaG91ci1tb2RlIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt1fTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCIke18udGltZXBpY2tlcklubGluZU1vZGVQbX1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaG91ci1tb2RlIGRhdGEtdGUtdGltZXBpY2tlci1wbSB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7Zn08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Xy50aW1lcGlja2VySW5saW5lU3VibWl0QnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLXN1Ym1pdCB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dH08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+YH1cbiAgICAgICAgICAgICAgJHtzID8gYDxidXR0b24gY2xhc3M9JyR7Xy50aW1lcGlja2VySW5saW5lU3VibWl0QnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLXN1Ym1pdCB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dH08L2J1dHRvbj5gIDogXCJcIn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PmA7XG4gIHJldHVybiBsID8gZyA6IG07XG59LCAkZiA9IChzLCB0LCBlKSA9PiB7XG4gIGNvbnN0IHsgaWNvblNWRzogaSB9ID0gcztcbiAgcmV0dXJuIGBcbiAgPGJ1dHRvbiBpZD1cIiR7dH1cIiB0YWJpbmRleD1cIjBcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke2UudGltZXBpY2tlclRvZ2dsZUJ1dHRvbn1cIiBkYXRhLXRlLXRvZ2dsZT1cInRpbWVwaWNrZXJcIiBkYXRhLXRlLXRpbWVwaWNrZXItdG9nZ2xlLWJ1dHRvbiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbj5cbiAgICAke2l9XG4gIDwvYnV0dG9uPlxuYDtcbn0sIGpzID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItZGlzYWJsZWRcIiwgaXMgPSBcImRhdGEtdGUtdGltZXBpY2tlci1hY3RpdmVcIiwgYmUgPSAocykgPT4ge1xuICBpZiAocyA9PT0gXCJcIilcbiAgICByZXR1cm47XG4gIGxldCB0LCBlLCBpLCBuO1xuICByZXR1cm4gc2MocykgPyAodCA9IHMuZ2V0SG91cnMoKSwgbiA9IHQsIGUgPSBzLmdldE1pbnV0ZXMoKSwgdCAlPSAxMiwgbiA9PT0gMCAmJiB0ID09PSAwICYmIChpID0gXCJBTVwiKSwgdCA9IHQgfHwgMTIsIGkgPT09IHZvaWQgMCAmJiAoaSA9IE51bWJlcihuKSA+PSAxMiA/IFwiUE1cIiA6IFwiQU1cIiksIGUgPSBlIDwgMTAgPyBgMCR7ZX1gIDogZSkgOiAoW3QsIGUsIGldID0gUihzLCAhMSksIG4gPSB0LCB0ICU9IDEyLCBuID09PSAwICYmIHQgPT09IDAgJiYgKGkgPSBcIkFNXCIpLCB0ID0gdCB8fCAxMiwgaSA9PT0gdm9pZCAwICYmIChpID0gTnVtYmVyKG4pID49IDEyID8gXCJQTVwiIDogXCJBTVwiKSksIHtcbiAgICBob3VyczogdCxcbiAgICBtaW51dGVzOiBlLFxuICAgIGFtT3JQbTogaVxuICB9O1xufSwgc2MgPSAocykgPT4gcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocykgPT09IFwiW29iamVjdCBEYXRlXVwiICYmICFOdW1iZXIuaXNOYU4ocyksIFhyID0gKHMpID0+IHtcbiAgaWYgKHMgPT09IFwiXCIpXG4gICAgcmV0dXJuO1xuICBsZXQgdCwgZTtcbiAgcmV0dXJuIHNjKHMpID8gKHQgPSBzLmdldEhvdXJzKCksIGUgPSBzLmdldE1pbnV0ZXMoKSkgOiBbdCwgZV0gPSBSKHMsICExKSwgZSA9IE51bWJlcihlKSA8IDEwID8gYDAke051bWJlcihlKX1gIDogZSwge1xuICAgIGhvdXJzOiB0LFxuICAgIG1pbnV0ZXM6IGVcbiAgfTtcbn0sIExmID0gKHMsIHQsIGUpID0+IGgub24oZG9jdW1lbnQsIHMsIHQsICh7IHRhcmdldDogaSB9KSA9PiB7XG4gIGlmIChpLmhhc0F0dHJpYnV0ZShpcykpXG4gICAgcmV0dXJuO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQpLmZvckVhY2goKG8pID0+IHtcbiAgICBvLmhhc0F0dHJpYnV0ZShpcykgJiYgKGMucmVtb3ZlQ2xhc3MobywgZS5vcGFjaXR5KSwgby5yZW1vdmVBdHRyaWJ1dGUoaXMpKTtcbiAgfSksIGMuYWRkQ2xhc3MoaSwgZS5vcGFjaXR5KSwgaS5zZXRBdHRyaWJ1dGUoaXMsIFwiXCIpO1xufSksIEdyID0gKHsgY2xpZW50WDogcywgY2xpZW50WTogdCwgdG91Y2hlczogZSB9LCBpLCBuID0gITEpID0+IHtcbiAgY29uc3QgeyBsZWZ0OiBvLCB0b3A6IHIgfSA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGxldCBhID0ge307XG4gIHJldHVybiAhbiB8fCAhZSA/IGEgPSB7XG4gICAgeDogcyAtIG8sXG4gICAgeTogdCAtIHJcbiAgfSA6IG4gJiYgT2JqZWN0LmtleXMoZSkubGVuZ3RoID4gMCAmJiAoYSA9IHtcbiAgICB4OiBlWzBdLmNsaWVudFggLSBvLFxuICAgIHk6IGVbMF0uY2xpZW50WSAtIHJcbiAgfSksIGE7XG59LCBzcyA9ICgpID0+IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAyICYmIC9NYWNJbnRlbC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIHx8IC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChcbiAgbmF2aWdhdG9yLnVzZXJBZ2VudFxuKSwgUiA9IChzLCB0ID0gITApID0+IHQgPyBzLnZhbHVlLnJlcGxhY2UoLzovZ2ksIFwiIFwiKS5zcGxpdChcIiBcIikgOiBzLnJlcGxhY2UoLzovZ2ksIFwiIFwiKS5zcGxpdChcIiBcIiksIG5jID0gKHMsIHQpID0+IHtcbiAgY29uc3QgW2UsIGksIG5dID0gUihzLCAhMSksIFtvLCByLCBhXSA9IFIodCwgITEpO1xuICByZXR1cm4gbiA9PT0gXCJQTVwiICYmIGEgPT09IFwiQU1cIiB8fCBuID09PSBhICYmIGUgPiBvIHx8IGkgPiByO1xufSwgb2MgPSAoKSA9PiB7XG4gIGNvbnN0IHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgdCA9IHMuZ2V0SG91cnMoKSwgZSA9IHMuZ2V0TWludXRlcygpO1xuICByZXR1cm4gYCR7dH06JHtlIDwgMTAgPyBgMCR7ZX1gIDogZX1gO1xufSwgWHQgPSAocywgdCwgZSkgPT4ge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHM7XG4gIGxldCBpID0gb2MoKTtcbiAgcmV0dXJuIGUgJiYgKGkgPSBgJHtiZShpKS5ob3Vyc306JHtiZShpKS5taW51dGVzfSAke2JlKGkpLmFtT3JQbX1gKSwgKHMgIT09IFwiXCIgJiYgbmMoaSwgcykgfHwgcyA9PT0gXCJcIikgJiYgKHMgPSBpKSwgcztcbn0sIEd0ID0gKHMsIHQsIGUpID0+IHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBzO1xuICBsZXQgaSA9IG9jKCk7XG4gIHJldHVybiBlICYmIChpID0gYCR7YmUoaSkuaG91cnN9OiR7YmUoaSkubWludXRlc30gJHtiZShpKS5hbU9yUG19YCksIChzICE9PSBcIlwiICYmICFuYyhpLCBzKSB8fCBzID09PSBcIlwiKSAmJiAocyA9IGkpLCBzO1xufSwgTWYgPSAoeyBmb3JtYXQxMjogcywgbWF4VGltZTogdCwgbWluVGltZTogZSwgZGlzYWJsZVBhc3Q6IGksIGRpc2FibGVGdXR1cmU6IG4gfSwgbywgcikgPT4ge1xuICBjb25zdCBhID0gUihvKVsxXTtcbiAgZSA9IFh0KGUsIGksIHMpLCB0ID0gR3QodCwgbiwgcyk7XG4gIGNvbnN0IFtsLCBwLCB1XSA9IFIodCwgITEpLCBbZiwgXywgbV0gPSBSKGUsICExKTtcbiAgaWYgKHUgIT09IHZvaWQgMCB8fCBtICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIFtyLCBhXTtcbiAgaWYgKCEobCAhPT0gXCJcIiAmJiBmID09PSBcIlwiICYmIE51bWJlcihyKSA+IE51bWJlcihsKSkgJiYgIShsID09PSBcIlwiICYmIGYgIT09IFwiXCIgJiYgcCA9PT0gdm9pZCAwICYmIF8gIT09IFwiXCIgJiYgTnVtYmVyKHIpIDwgTnVtYmVyKGYpKSlcbiAgICByZXR1cm4gW3IsIGFdO1xufSwgcXIgPSAocywgdCwgZSwgaSkgPT4ge1xuICBzLmZvckVhY2goKG4pID0+IHtcbiAgICB0ID0gdCA9PT0gXCIxMlwiICYmIGkgPyBcIjBcIiA6IHQsIChuLnRleHRDb250ZW50ID09PSBcIjAwXCIgfHwgTnVtYmVyKG4udGV4dENvbnRlbnQgPT09IFwiMTJcIiAmJiBpID8gXCIwXCIgOiBuLnRleHRDb250ZW50KSA+IHQpICYmIChjLmFkZENsYXNzKG4sIGUudGlwc0Rpc2FibGVkKSwgbi5zZXRBdHRyaWJ1dGUoanMsIFwiXCIpKTtcbiAgfSk7XG59LCBaciA9IChzLCB0LCBlLCBpKSA9PiB7XG4gIHMuZm9yRWFjaCgobikgPT4ge1xuICAgIHQgPSB0ID09PSBcIjEyXCIgJiYgaSA/IFwiMFwiIDogdCwgbi50ZXh0Q29udGVudCAhPT0gXCIwMFwiICYmIE51bWJlcihuLnRleHRDb250ZW50ID09PSBcIjEyXCIgJiYgaSA/IFwiMFwiIDogbi50ZXh0Q29udGVudCkgPCBOdW1iZXIodCkgJiYgKGMuYWRkQ2xhc3MobiwgZS50aXBzRGlzYWJsZWQpLCBuLnNldEF0dHJpYnV0ZShqcywgXCJcIikpO1xuICB9KTtcbn0sIHJjID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgaWYgKHQgPT09IFwiMTJcIiB8fCB0ID09PSBcIjI0XCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBuID0gZSA/IDEyIDogMjQ7XG4gIHJldHVybiBpID09PSBcIm1heFwiID8gKE51bWJlcihzKSA9PT0gbiA/IDAgOiBOdW1iZXIocykpID4gTnVtYmVyKHQpIDogKE51bWJlcihzKSA9PT0gbiA/IDAgOiBOdW1iZXIocykpIDwgTnVtYmVyKHQpO1xufSwgTmYgPSAocywgdCwgZSwgaSwgbiwgbykgPT4ge1xuICBzLmZvckVhY2goKHIpID0+IHtcbiAgICAocmMoaSwgZSwgbywgXCJtYXhcIikgfHwgTnVtYmVyKHIudGV4dENvbnRlbnQpID4gdCAmJiBOdW1iZXIoaSkgPT09IE51bWJlcihlKSkgJiYgKGMuYWRkQ2xhc3Mociwgbi50aXBzRGlzYWJsZWQpLCByLnNldEF0dHJpYnV0ZShqcywgXCJcIikpO1xuICB9KTtcbn0sIFJmID0gKHMsIHQsIGUsIGksIG4sIG8pID0+IHtcbiAgcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgKHJjKGksIGUsIG8sIFwibWluXCIpIHx8IE51bWJlcihyLnRleHRDb250ZW50KSA8IHQgJiYgTnVtYmVyKGkpID09PSBOdW1iZXIoZSkpICYmIChjLmFkZENsYXNzKHIsIG4udGlwc0Rpc2FibGVkKSwgci5zZXRBdHRyaWJ1dGUoanMsIFwiXCIpKTtcbiAgfSk7XG59LCBQZiA9IChzKSA9PiBzLnN0YXJ0c1dpdGgoXCIwXCIpID8gTnVtYmVyKHMuc2xpY2UoMSkpIDogTnVtYmVyKHMpLCB5aSA9IFwidGltZXBpY2tlclwiLCBOID0gYGRhdGEtdGUtJHt5aX1gLCBRciA9IFwiW2RhdGEtdGUtdG9nZ2xlXVwiLCBTcyA9IGB0ZS4ke3lpfWAsIFJ0ID0gYC4ke1NzfWAsIFB0ID0gXCIuZGF0YS1hcGlcIiwgSnIgPSBgY2xpY2ske1J0fSR7UHR9YCwgbnMgPSBga2V5ZG93biR7UnR9JHtQdH1gLCB0YSA9IGBtb3VzZWRvd24ke1J0fSR7UHR9YCwgZWEgPSBgbW91c2V1cCR7UnR9JHtQdH1gLCBpYSA9IGBtb3VzZW1vdmUke1J0fSR7UHR9YCwgc2EgPSBgbW91c2VsZWF2ZSR7UnR9JHtQdH1gLCBuYSA9IGBtb3VzZW92ZXIke1J0fSR7UHR9YCwgb2EgPSBgdG91Y2htb3ZlJHtSdH0ke1B0fWAsIHJhID0gYHRvdWNoZW5kJHtSdH0ke1B0fWAsIGFhID0gYHRvdWNoc3RhcnQke1J0fSR7UHR9YCwgQmYgPSBgWyR7Tn0tYW1dYCwgSGYgPSBgWyR7Tn0tcG1dYCwgV2YgPSBgWyR7Tn0tZm9ybWF0MjRdYCwgb3MgPSBgWyR7Tn0tY3VycmVudF1gLCBycyA9IGBbJHtOfS1ob3VyLW1vZGVdYCwgVmYgPSBgWyR7Tn0tdG9nZ2xlLWJ1dHRvbl1gLCBrbiA9IGAke059LWNhbmNlbGAsIGxhID0gYCR7Tn0tY2xlYXJgLCBPbiA9IGAke059LXN1Ym1pdGAsIEZmID0gYCR7Tn0taWNvbmAsIFNuID0gYCR7Tn0taWNvbi11cGAsIEluID0gYCR7Tn0taWNvbi1kb3duYCwgWWYgPSBgJHtOfS1pY29uLWlubGluZS1ob3VyYCwgamYgPSBgJHtOfS1pY29uLWlubGluZS1taW51dGVgLCBjYSA9IGAke059LWlubGluZS1ob3VyLWljb25zYCwgS2YgPSBgJHtOfS1jdXJyZW50LWlubGluZWAsIHpmID0gXCJyZWFkb25seVwiLCBoYSA9IGAke059LWludmFsaWQtZmVlZGJhY2tgLCBEbiA9IGAke059LWlzLWludmFsaWRgLCBZdCA9IGAke059LWRpc2FibGVkYCwgSCA9IGAke059LWFjdGl2ZWAsIFVmID0gYCR7Tn0taW5wdXRgLCB1ZSA9IGAke059LWNsb2NrYCwgYWkgPSBgJHtOfS1jbG9jay1pbm5lcmAsICRuID0gYCR7Tn0td3JhcHBlcmAsIGRhID0gYCR7Tn0tY2xvY2std3JhcHBlcmAsIGFzID0gYCR7Tn0taG91cmAsIExuID0gYCR7Tn0tbWludXRlYCwgbHMgPSBgJHtOfS10aXBzLWVsZW1lbnRgLCBLID0gYCR7Tn0tdGlwcy1ob3Vyc2AsIFggPSBgJHtOfS10aXBzLW1pbnV0ZXNgLCBhdCA9IGAke059LXRpcHMtaW5uZXJgLCBjcyA9IGAke059LXRpcHMtaW5uZXItZWxlbWVudGAsIHVhID0gYCR7Tn0tbWlkZGxlLWRvdGAsIE1uID0gYCR7Tn0taGFuZC1wb2ludGVyYCwgTm4gPSBgJHtOfS1jaXJjbGVgLCBwYSA9IGAke059LW1vZGFsYCwgWGYgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTIgNnY2aDQuNW00LjUgMGE5IDkgMCAxMS0xOCAwIDkgOSAwIDAxMTggMHpcIiAvPlxuPC9zdmc+YCwgR2YgPSB7XG4gIGFwcGVuZFZhbGlkYXRpb25JbmZvOiAhMCxcbiAgYm9keUlEOiBcIlwiLFxuICBjYW5jZWxMYWJlbDogXCJDYW5jZWxcIixcbiAgY2xlYXJMYWJlbDogXCJDbGVhclwiLFxuICBjbG9zZU1vZGFsT25CYWNrZHJvcENsaWNrOiAhMCxcbiAgY2xvc2VNb2RhbE9uTWludXRlc0NsaWNrOiAhMSxcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgZGVmYXVsdFRpbWU6IFwiXCIsXG4gIGRpc2FibGVkOiAhMSxcbiAgZGlzYWJsZVBhc3Q6ICExLFxuICBkaXNhYmxlRnV0dXJlOiAhMSxcbiAgZW5hYmxlVmFsaWRhdGlvbjogITAsXG4gIGZvY3VzSW5wdXRBZnRlckFwcHJvdmU6ICExLFxuICBmb290ZXJJRDogXCJcIixcbiAgZm9ybWF0MTI6ICEwLFxuICBmb3JtYXQyNDogITEsXG4gIGhlYWRJRDogXCJcIixcbiAgaW5jcmVtZW50OiAhMSxcbiAgaW5saW5lOiAhMSxcbiAgaW52YWxpZExhYmVsOiBcIkludmFsaWQgVGltZSBGb3JtYXRcIixcbiAgbWF4VGltZTogXCJcIixcbiAgbWluVGltZTogXCJcIixcbiAgbW9kYWxJRDogXCJcIixcbiAgb2tMYWJlbDogXCJPa1wiLFxuICBvdmVyZmxvd0hpZGRlbjogITAsXG4gIHBpY2tlcklEOiBcIlwiLFxuICByZWFkT25seTogITEsXG4gIHNob3dDbGVhckJ0bjogITAsXG4gIHN3aXRjaEhvdXJzVG9NaW51dGVzT25DbGljazogITAsXG4gIGljb25TVkc6IFhmLFxuICB3aXRoSWNvbjogITAsXG4gIHBtTGFiZWw6IFwiUE1cIixcbiAgYW1MYWJlbDogXCJBTVwiLFxuICBhbmltYXRpb25zOiAhMFxufSwgcWYgPSB7XG4gIGFwcGVuZFZhbGlkYXRpb25JbmZvOiBcImJvb2xlYW5cIixcbiAgYm9keUlEOiBcInN0cmluZ1wiLFxuICBjYW5jZWxMYWJlbDogXCJzdHJpbmdcIixcbiAgY2xlYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgY2xvc2VNb2RhbE9uQmFja2Ryb3BDbGljazogXCJib29sZWFuXCIsXG4gIGNsb3NlTW9kYWxPbk1pbnV0ZXNDbGljazogXCJib29sZWFuXCIsXG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZGlzYWJsZWQ6IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlUGFzdDogXCJib29sZWFuXCIsXG4gIGRpc2FibGVGdXR1cmU6IFwiYm9vbGVhblwiLFxuICBlbmFibGVWYWxpZGF0aW9uOiBcImJvb2xlYW5cIixcbiAgZm9vdGVySUQ6IFwic3RyaW5nXCIsXG4gIGZvcm1hdDEyOiBcImJvb2xlYW5cIixcbiAgZm9ybWF0MjQ6IFwiYm9vbGVhblwiLFxuICBoZWFkSUQ6IFwic3RyaW5nXCIsXG4gIGluY3JlbWVudDogXCJib29sZWFuXCIsXG4gIGlubGluZTogXCJib29sZWFuXCIsXG4gIGludmFsaWRMYWJlbDogXCJzdHJpbmdcIixcbiAgbW9kYWxJRDogXCJzdHJpbmdcIixcbiAgb2tMYWJlbDogXCJzdHJpbmdcIixcbiAgb3ZlcmZsb3dIaWRkZW46IFwiYm9vbGVhblwiLFxuICBwaWNrZXJJRDogXCJzdHJpbmdcIixcbiAgcmVhZE9ubHk6IFwiYm9vbGVhblwiLFxuICBzaG93Q2xlYXJCdG46IFwiYm9vbGVhblwiLFxuICBzd2l0Y2hIb3Vyc1RvTWludXRlc09uQ2xpY2s6IFwiYm9vbGVhblwiLFxuICBkZWZhdWx0VGltZTogXCIoc3RyaW5nfGRhdGV8bnVtYmVyKVwiLFxuICBpY29uU1ZHOiBcInN0cmluZ1wiLFxuICB3aXRoSWNvbjogXCJib29sZWFuXCIsXG4gIHBtTGFiZWw6IFwic3RyaW5nXCIsXG4gIGFtTGFiZWw6IFwic3RyaW5nXCIsXG4gIGFuaW1hdGlvbnM6IFwiYm9vbGVhblwiXG59LCBaZiA9IHtcbiAgdGlwczogXCJhYnNvbHV0ZSByb3VuZGVkLVsxMDAlXSB3LVszMnB4XSBoLVszMnB4XSB0ZXh0LWNlbnRlciBjdXJzb3ItcG9pbnRlciB0ZXh0LVsxLjFyZW1dIHJvdW5kZWQtWzEwMCVdIGJnLXRyYW5zcGFyZW50IGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGZvbnQtbGlnaHQgZm9jdXM6b3V0bGluZS1ub25lIHNlbGVjdGlvbjpiZy10cmFuc3BhcmVudFwiLFxuICB0aXBzQWN0aXZlOiBcInRleHQtd2hpdGUgYmctWyMzYjcxY2FdIGZvbnQtbm9ybWFsXCIsXG4gIHRpcHNEaXNhYmxlZDogXCJ0ZXh0LVsjYjNhZmFmXSBwb2ludGVyLWV2ZW50cy1ub25lIGJnLXRyYW5zcGFyZW50XCIsXG4gIHRyYW5zZm9ybTogXCJ0cmFuc2l0aW9uLVt0cmFuc2Zvcm0saGVpZ2h0XSBlYXNlLWluLW91dCBkdXJhdGlvbi1bNDAwbXNdXCIsXG4gIG1vZGFsOiBcInotWzEwNjVdXCIsXG4gIGNsb2NrQW5pbWF0aW9uOiBcImFuaW1hdGUtW3Nob3ctdXAtY2xvY2tfMzUwbXNfbGluZWFyXVwiLFxuICBvcGFjaXR5OiBcIiFvcGFjaXR5LTEwMFwiLFxuICB0aW1lcGlja2VyV3JhcHBlcjogXCJ0b3VjaC1ub25lIG9wYWNpdHktMTAwIHotWzEwNjVdIGluc2V0LTAgYmctWyMwMDAwMDA2Nl0gaC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZsZXgtY29sIGZpeGVkXCIsXG4gIHRpbWVwaWNrZXJDb250YWluZXI6IFwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgbWF4LWgtW2NhbGMoMTAwJS02NHB4KV0gb3ZlcmZsb3cteS1hdXRvIHNoYWRvdy1bMF8xMHB4XzE1cHhfLTNweF9yZ2JhKDAsMCwwLDAuMDcpLDBfNHB4XzZweF8tMnB4X3JnYmEoMCwwLDAsMC4wNSldIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLWxnXCIsXG4gIHRpbWVwaWNrZXJFbGVtZW50czogXCJmbGV4IGZsZXgtY29sIG1pbi13LVszMTBweF0gbWluLWgtWzMyNXB4XSBiZy13aGl0ZSByb3VuZGVkLXQtWzAuNnJlbV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFmbGV4LXJvdyBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLXctW2F1dG9dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4taC1bYXV0b10gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm92ZXJmbG93LXktYXV0byBqdXN0aWZ5LWFyb3VuZFwiLFxuICB0aW1lcGlja2VySGVhZDogXCJiZy1bIzNiNzFjYV0gZGFyazpiZy16aW5jLTcwMCBoLVsxMDBweF0gcm91bmRlZC10LWxnIHByLVsyNHB4XSBwbC1bNTBweF0gcHktWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLXRyLW5vbmUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtYmwtbm9uZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cC1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnByLVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6aC1hdXRvIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4taC1bMzA1cHhdIGZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCIsXG4gIHRpbWVwaWNrZXJIZWFkQ29udGVudDogXCJtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6ZmxleC1jb2wgZmxleCB3LWZ1bGwganVzdGlmeS1ldmVubHlcIixcbiAgdGltZXBpY2tlckN1cnJlbnRXcmFwcGVyOiBcIltkaXJlY3Rpb246bHRyXSBydGw6W2RpcmVjdGlvbjpydGxdXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcjogXCJyZWxhdGl2ZSBoLWZ1bGxcIixcbiAgdGltZXBpY2tlckN1cnJlbnRCdXR0b246IFwidGV4dC1bMy43NXJlbV0gZm9udC1saWdodCBsZWFkaW5nLVsxLjJdIHRyYWNraW5nLVstMC4wMDgzM2VtXSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcC0wIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTp0ZXh0LTV4bCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Zm9udC1ub3JtYWwgY3Vyc29yLXBvaW50ZXIgaG92ZXI6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGZvY3VzOm91dGxpbmUtbm9uZSBcIixcbiAgdGltZXBpY2tlckRvdDogXCJmb250LWxpZ2h0IGxlYWRpbmctWzEuMl0gdHJhY2tpbmctWy0wLjAwODMzZW1dIHRleHQtWzMuNzVyZW1dIG9wYWNpdHktWy41NF0gYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcC0wIHRleHQtd2hpdGUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnRleHQtWzNyZW1dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmb250LW5vcm1hbFwiLFxuICB0aW1lcGlja2VyTW9kZVdyYXBwZXI6IFwiZmxleCBmbGV4LWNvbCBqdXN0aWZ5LWNlbnRlciB0ZXh0LVsxOHB4XSB0ZXh0LVsjZmZmZmZmOGFdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohanVzdGlmeS1hcm91bmQgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFmbGV4LXJvd1wiLFxuICB0aW1lcGlja2VyTW9kZUFtOiBcInAtMCBiZy10cmFuc3BhcmVudCBib3JkZXItbm9uZSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gY3Vyc29yLXBvaW50ZXIgaG92ZXI6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGZvY3VzOm91dGxpbmUtbm9uZVwiLFxuICB0aW1lcGlja2VyTW9kZVBtOiBcInAtMCBiZy10cmFuc3BhcmVudCBib3JkZXItbm9uZSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gY3Vyc29yLXBvaW50ZXIgaG92ZXI6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGZvY3VzOm91dGxpbmUtbm9uZVwiLFxuICB0aW1lcGlja2VyQ2xvY2tXcmFwcGVyOiBcIm1pbi13LVszMTBweF0gbWF4LXctWzMyNXB4XSBtaW4taC1bMzA1cHhdIG92ZXJmbG93LXgtaGlkZGVuIGgtZnVsbCBmbGV4IGp1c3RpZnktY2VudGVyIGZsZXgtY29sIGl0ZW1zLWNlbnRlciBkYXJrOmJnLXppbmMtNTAwXCIsXG4gIHRpbWVwaWNrZXJDbG9jazogXCJyZWxhdGl2ZSByb3VuZGVkLVsxMDAlXSB3LVsyNjBweF0gaC1bMjYwcHhdIGN1cnNvci1kZWZhdWx0IG15LTAgbXgtYXV0byBiZy1bIzAwMDAwMDEyXSBkYXJrOmJnLXppbmMtNjAwLzUwXCIsXG4gIHRpbWVwaWNrZXJNaWRkbGVEb3Q6IFwidG9wLTEvMiBsZWZ0LTEvMiB3LVs2cHhdIGgtWzZweF0gLXRyYW5zbGF0ZS15LTEvMiAtdHJhbnNsYXRlLXgtMS8yIHJvdW5kZWQtWzUwJV0gYmctWyMzYjcxY2FdIGFic29sdXRlXCIsXG4gIHRpbWVwaWNrZXJIYW5kUG9pbnRlcjogXCJiZy1bIzNiNzFjYV0gYm90dG9tLTEvMiBoLTIvNSBsZWZ0LVtjYWxjKDUwJS0xcHgpXSBydGw6IWxlZnQtYXV0byBvcmlnaW4tW2NlbnRlcl9ib3R0b21fMF0gcnRsOiFvcmlnaW4tWzUwJV81MCVfMF0gdy1bMnB4XSBhYnNvbHV0ZVwiLFxuICB0aW1lcGlja2VyUG9pbnRlckNpcmNsZTogXCItdG9wLVsyMXB4XSAtbGVmdC1bMTVweF0gdy1bNHB4XSBib3JkZXItWzE0cHhdIGJvcmRlci1zb2xpZCBib3JkZXItWyMzYjcxY2FdIGgtWzRweF0gYm94LWNvbnRlbnQgcm91bmRlZC1bMTAwJV0gYWJzb2x1dGVcIixcbiAgdGltZXBpY2tlckNsb2NrSW5uZXI6IFwiYWJzb2x1dGUgdG9wLTEvMiBsZWZ0LTEvMiAtdHJhbnNsYXRlLXktMS8yIC10cmFuc2xhdGUteC0xLzIgdy1bMTYwcHhdIGgtWzE2MHB4XSByb3VuZGVkLVsxMDAlXVwiLFxuICB0aW1lcGlja2VyRm9vdGVyV3JhcHBlcjogXCJyb3VuZGVkLWItbGcgZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIHctZnVsbCBoLVs1NnB4XSBweC1bMTJweF0gYmctd2hpdGUgZGFyazpiZy16aW5jLTUwMFwiLFxuICB0aW1lcGlja2VyRm9vdGVyOiBcInctZnVsbCBmbGV4IGp1c3RpZnktYmV0d2VlblwiLFxuICB0aW1lcGlja2VyRm9vdGVyQnV0dG9uOiBcInRleHQtWzAuOHJlbV0gbWluLXctWzY0cHhdIGJveC1ib3JkZXIgZm9udC1tZWRpdW0gbGVhZGluZy1bNDBweF0gcm91bmRlZC1bMTBweF0gdHJhY2tpbmctWzAuMXJlbV0gdXBwZXJjYXNlIHRleHQtWyMzYjcxY2FdIGRhcms6dGV4dC13aGl0ZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLVtiYWNrZ3JvdW5kLWNvbG9yLGJveC1zaGFkb3csYm9yZGVyXSBkdXJhdGlvbi1bMjUwbXNdIGVhc2UtW2N1YmljLWJlemllcigwLjQsMCwwLjIsMSldIGRlbGF5LVswbXNdIG91dGxpbmUtbm9uZSBweS0wIHB4LVsxMHB4XSBoLVs0MHB4XSBtYi1bMTBweF0gaG92ZXI6YmctWyMwMDAwMDAxNF0gZm9jdXM6YmctWyMwMDAwMDAxNF0gZm9jdXM6b3V0bGluZS1ub25lXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVXcmFwcGVyOiBcInRvdWNoLW5vbmUgb3BhY2l0eS0xMDAgei1bMTA2NV0gaW5zZXQtMCBiZy1bIzAwMDAwMDY2XSBoLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgcm91bmRlZC1sZ1wiLFxuICB0aW1lcGlja2VySW5saW5lQ29udGFpbmVyOiBcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZsZXgtY29sIG1heC1oLVtjYWxjKDEwMCUtNjRweCldIG92ZXJmbG93LXktYXV0byBzaGFkb3ctWzBfMTBweF8xNXB4Xy0zcHhfcmdiYSgwLDAsMCwwLjA3KSwwXzRweF82cHhfLTJweF9yZ2JhKDAsMCwwLDAuMDUpXVwiLFxuICB0aW1lcGlja2VySW5saW5lRWxlbWVudHM6IFwiZmxleCBmbGV4LWNvbCBtaW4taC1bYXV0b10gbWluLXctWzMxMHB4XSBiZy13aGl0ZSByb3VuZGVkLVswLjZyZW1dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohZmxleC1yb3cgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtYmwtbGcgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi13LVthdXRvXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Om1pbi1oLVthdXRvXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6b3ZlcmZsb3cteS1hdXRvIGp1c3RpZnktYXJvdW5kXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIZWFkOiBcImJnLVsjM2I3MWNhXSBkYXJrOmJnLXppbmMtNzAwIGgtWzEwMHB4XSByb3VuZGVkLXQtbGcgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtdHItbm9uZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC1ibC1ub25lIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpwLVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cHItWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpoLWF1dG8gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi1oLVszMDVweF0gZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcC0wIHJvdW5kZWQtYi1sZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSGVhZENvbnRlbnQ6IFwibWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZsZXgtY29sIGZsZXggdy1mdWxsIGp1c3RpZnktZXZlbmx5IGl0ZW1zLWNlbnRlclwiLFxuICB0aW1lcGlja2VySW5saW5lSG91cldyYXBwZXI6IFwicmVsYXRpdmUgaC1mdWxsICFvcGFjaXR5LTEwMFwiLFxuICB0aW1lcGlja2VyQ3VycmVudE1pbnV0ZVdyYXBwZXI6IFwicmVsYXRpdmUgaC1mdWxsXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uVXA6IFwiYWJzb2x1dGUgZmlsbC13aGl0ZSAtdG9wLVszNXB4XSBvcGFjaXR5LTAgaG92ZXI6b3BhY2l0eS0xMDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtW2Vhc2VdIGN1cnNvci1wb2ludGVyIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiBsZWZ0LTEvMiB3LVszMHB4XSBoLVszMHB4XSBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlclwiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblN2ZzogXCJoLTQgdy00XCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVDdXJyZW50QnV0dG9uOiBcImZvbnQtbGlnaHQgbGVhZGluZy1bMS4yXSB0cmFja2luZy1bLTAuMDA4MzNlbV0gdGV4dC13aGl0ZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBwLTAgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnRleHQtNXhsIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmb250LW5vcm1hbCAhb3BhY2l0eS0xMDAgY3Vyc29yLXBvaW50ZXIgZm9jdXM6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOm91dGxpbmUtbm9uZSB0ZXh0LVsyLjVyZW1dIGhvdmVyOmJnLVt1bnNldF1cIixcbiAgdGltZXBpY2tlcklubGluZUljb25Eb3duOiBcImFic29sdXRlIGZpbGwtd2hpdGUgLWJvdHRvbS1bNDdweF0gb3BhY2l0eS0wIGhvdmVyOm9wYWNpdHktMTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLVtlYXNlXSBjdXJzb3ItcG9pbnRlciAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgbGVmdC0xLzIgdy1bMzBweF0gaC1bMzBweF0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgdGltZXBpY2tlcklubGluZURvdDogXCJmb250LWxpZ2h0IGxlYWRpbmctWzEuMl0gdHJhY2tpbmctWy0wLjAwODMzZW1dIG9wYWNpdHktWy41NF0gYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcC0wIHRleHQtd2hpdGUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnRleHQtWzNyZW1dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmb250LW5vcm1hbCB0ZXh0LVsyLjVyZW1dXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlV3JhcHBlcjogXCJmbGV4IGp1c3RpZnktY2VudGVyIHRleHQtWzE4cHhdIHRleHQtWyNmZmZmZmY4YV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFqdXN0aWZ5LWFyb3VuZCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWZsZXgtcm93XCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlQW06IFwiaG92ZXI6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGZvY3VzOm91dGxpbmUtbm9uZSBwLTAgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGN1cnNvci1wb2ludGVyIG1yLTIgbWwtNlwiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZVBtOiBcImhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmUgcC0wIGJnLXRyYW5zcGFyZW50IGJvcmRlci1ub25lIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBjdXJzb3ItcG9pbnRlclwiLFxuICB0aW1lcGlja2VySW5saW5lU3VibWl0QnV0dG9uOiBcImhvdmVyOmJnLVsjMDAwMDAwMTRdIGZvY3VzOmJnLVsjMDAwMDAwMTRdIGZvY3VzOm91dGxpbmUtbm9uZSB0ZXh0LVswLjhyZW1dIGJveC1ib3JkZXIgZm9udC1tZWRpdW0gbGVhZGluZy1bNDBweF0gdHJhY2tpbmctWy4xcmVtXSB1cHBlcmNhc2UgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgW3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvcl8yNTBtc19jdWJpYy1iZXppZXIoMC40LDAsMC4yLDEpXzBtcyxib3gtc2hhZG93XzI1MG1zX2N1YmljLWJlemllcigwLjQsMCwwLjIsMSlfMG1zLGJvcmRlcl8yNTBtc19jdWJpYy1iZXppZXIoMC40LDAsMC4yLDEpXzBtc10gb3V0bGluZS1ub25lIHJvdW5kZWQtWzEwMCVdIGgtWzQ4cHhdIG1pbi13LVs0OHB4XSBpbmxpbmUtYmxvY2sgbWwtWzMwcHhdIHRleHQtd2hpdGUgcHktMSBweC0yIG1iLTBcIixcbiAgdGltZXBpY2tlclRvZ2dsZUJ1dHRvbjogXCJoLTQgdy00IG1sLWF1dG8gYWJzb2x1dGUgb3V0bGluZS1ub25lIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHJpZ2h0LTEuNSB0b3AtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMSldIGN1cnNvci1wb2ludGVyIGhvdmVyOnRleHQtWyMzYjcxY2FdIGZvY3VzOnRleHQtWyMzYjcxY2FdIGRhcms6aG92ZXI6dGV4dC1bIzNiNzFjYV0gZGFyazpmb2N1czp0ZXh0LVsjM2I3MWNhXSBkYXJrOnRleHQtd2hpdGVcIixcbiAgaW52YWxpZEZlZWRiYWNrOiBcImJsb2NrIGFic29sdXRlIHRleHQtc20gdGV4dC1yZWQtNTAwIGRhcms6dGV4dC1yZWQtMzAwXCJcbn0sIFFmID0ge1xuICB0aXBzOiBcInN0cmluZ1wiLFxuICB0aXBzQWN0aXZlOiBcInN0cmluZ1wiLFxuICB0aXBzRGlzYWJsZWQ6IFwic3RyaW5nXCIsXG4gIHRyYW5zZm9ybTogXCJzdHJpbmdcIixcbiAgbW9kYWw6IFwic3RyaW5nXCIsXG4gIGNsb2NrQW5pbWF0aW9uOiBcInN0cmluZ1wiLFxuICBvcGFjaXR5OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckVsZW1lbnRzOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySGVhZDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckhlYWRDb250ZW50OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ3VycmVudFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJEb3Q6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJNb2RlV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1vZGVBbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1vZGVQbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNsb2NrV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNsb2NrOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyTWlkZGxlRG90OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySGFuZFBvaW50ZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJQb2ludGVyQ2lyY2xlOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ2xvY2tJbm5lcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckZvb3RlcldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lQ29udGFpbmVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lRWxlbWVudHM6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIZWFkOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSGVhZENvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIb3VyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRNaW51dGVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblVwOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblN2ZzogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uRG93bjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZURvdDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZUFtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZVBtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lU3VibWl0QnV0dG9uOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyVG9nZ2xlQnV0dG9uOiBcInN0cmluZ1wiLFxuICBpbnZhbGlkRmVlZGJhY2s6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBZMCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgaSkge1xuICAgIEF0KHRoaXMsIFwiX3RvZ2dsZUFtUG1cIiwgKHQpID0+IHtcbiAgICAgIHQgPT09IFwiUE1cIiA/ICh0aGlzLl9pc1BtRW5hYmxlZCA9ICEwLCB0aGlzLl9pc0FtRW5hYmxlZCA9ICExKSA6IHQgPT09IFwiQU1cIiAmJiAodGhpcy5faXNQbUVuYWJsZWQgPSAhMSwgdGhpcy5faXNBbUVuYWJsZWQgPSAhMCk7XG4gICAgfSk7XG4gICAgQXQodGhpcywgXCJfdG9nZ2xlQmFja2dyb3VuZENvbG9yQ2lyY2xlXCIsICh0KSA9PiB7XG4gICAgICBpZiAodGhpcy5fbW9kYWwucXVlcnlTZWxlY3RvcihgJHt0fVske0h9XWApICE9PSBudWxsKSB7XG4gICAgICAgIGMuYWRkU3R5bGUodGhpcy5fY2lyY2xlLCB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMxOTc2ZDJcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYy5hZGRTdHlsZSh0aGlzLl9jaXJjbGUsIHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIEF0KHRoaXMsIFwiX3RvZ2dsZUNsYXNzQWN0aXZlXCIsICh0LCB7IHRleHRDb250ZW50OiBlIH0sIGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBbLi4udF0uZmluZChcbiAgICAgICAgKG8pID0+IE51bWJlcihvKSA9PT0gTnVtYmVyKGUpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBpZiAoIW8uaGFzQXR0cmlidXRlKFl0KSkge1xuICAgICAgICAgIGlmIChvLnRleHRDb250ZW50ID09PSBuKSB7XG4gICAgICAgICAgICBjLmFkZENsYXNzKG8sIHRoaXMuX2NsYXNzZXMudGlwc0FjdGl2ZSksIG8uc2V0QXR0cmlidXRlKEgsIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjLnJlbW92ZUNsYXNzKG8sIHRoaXMuX2NsYXNzZXMudGlwc0FjdGl2ZSksIG8ucmVtb3ZlQXR0cmlidXRlKEgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBBdCh0aGlzLCBcIl9tYWtlTWludXRlc0RlZ3JlZXNcIiwgKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5jcmVtZW50OiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgcmV0dXJuIHQgPCAwID8gKGUgPSBNYXRoLnJvdW5kKDM2MCArIHQgLyA2KSAlIDYwLCB0ID0gMzYwICsgTWF0aC5yb3VuZCh0IC8gNikgKiA2KSA6IChlID0gTWF0aC5yb3VuZCh0IC8gNikgJSA2MCwgdCA9IE1hdGgucm91bmQodCAvIDYpICogNiksIGkgJiYgKHQgPSBNYXRoLnJvdW5kKHQgLyAzMCkgKiAzMCwgZSA9IE1hdGgucm91bmQodCAvIDYpICogNiAvIDYsIGUgPT09IDYwICYmIChlID0gXCIwMFwiKSksIHQgPj0gMzYwICYmICh0ID0gMCksIHtcbiAgICAgICAgZGVncmVlczogdCxcbiAgICAgICAgbWludXRlOiBlLFxuICAgICAgICBhZGREZWdyZWVzOiBpID8gMzAgOiA2XG4gICAgICB9O1xuICAgIH0pO1xuICAgIEF0KHRoaXMsIFwiX21ha2VIb3VyRGVncmVlc1wiLCAodCwgZSwgaSkgPT4ge1xuICAgICAgaWYgKHQpXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNUYXJnZXRJbm5lckNsYXNzKHQpID8gZSA8IDAgPyAoaSA9IE1hdGgucm91bmQoMzYwICsgZSAvIDMwKSAlIDI0LCBlID0gMzYwICsgZSkgOiAoaSA9IE1hdGgucm91bmQoZSAvIDMwKSArIDEyLCBpID09PSAxMiAmJiAoaSA9IFwiMDBcIikpIDogZSA8IDAgPyAoaSA9IE1hdGgucm91bmQoMzYwICsgZSAvIDMwKSAlIDEyLCBlID0gMzYwICsgZSkgOiAoaSA9IE1hdGgucm91bmQoZSAvIDMwKSAlIDEyLCAoaSA9PT0gMCB8fCBpID4gMTIpICYmIChpID0gMTIpKSwgZSA+PSAzNjAgJiYgKGUgPSAwKSwge1xuICAgICAgICAgIGRlZ3JlZXM6IGUsXG4gICAgICAgICAgaG91cjogaSxcbiAgICAgICAgICBhZGREZWdyZWVzOiAzMFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIEF0KHRoaXMsIFwiX21ha2VJbm5lckhvdXJzRGVncmVlc1wiLCAodCwgZSkgPT4gKHQgPCAwID8gKGUgPSBNYXRoLnJvdW5kKDM2MCArIHQgLyAzMCkgJSAyNCwgdCA9IDM2MCArIHQpIDogKGUgPSBNYXRoLnJvdW5kKHQgLyAzMCkgKyAxMiwgZSA9PT0gMTIgJiYgKGUgPSBcIjAwXCIpKSwge1xuICAgICAgZGVncmVlczogdCxcbiAgICAgIGhvdXI6IGUsXG4gICAgICBhZGREZWdyZWVzOiAzMFxuICAgIH0pKTtcbiAgICBBdCh0aGlzLCBcIl9nZXRBcHBlbmRDbG9ja1wiLCAodCA9IFtdLCBlID0gYFske3VlfV1gLCBpKSA9PiB7XG4gICAgICBsZXQgeyBtaW5UaW1lOiBuLCBtYXhUaW1lOiBvIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgY29uc3QgeyBpbmxpbmU6IHIsIGZvcm1hdDEyOiBhLCBkaXNhYmxlUGFzdDogbCwgZGlzYWJsZUZ1dHVyZTogcCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIG4gPSBYdChuLCBsLCBhKSwgbyA9IEd0KG8sIHAsIGEpO1xuICAgICAgY29uc3QgW3UsIGYsIF9dID0gUihcbiAgICAgICAgbyxcbiAgICAgICAgITFcbiAgICAgICksIFttLCBnLCB2XSA9IFIoXG4gICAgICAgIG4sXG4gICAgICAgICExXG4gICAgICApO1xuICAgICAgIXIgJiYgYSAmJiB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ICYmICF0aGlzLl9BTS5oYXNBdHRyaWJ1dGUoSCkgJiYgKGMuYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShILCBcIlwiKSk7XG4gICAgICBjb25zdCBiID0gZC5maW5kT25lKGUpLCBDID0gMzYwIC8gdC5sZW5ndGg7XG4gICAgICBmdW5jdGlvbiB5KHcpIHtcbiAgICAgICAgcmV0dXJuIHcgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICB9XG4gICAgICBpZiAoYiA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgRSA9IChiLm9mZnNldFdpZHRoIC0gMzIpIC8gMiwgVCA9IChiLm9mZnNldEhlaWdodCAtIDMyKSAvIDIsIEEgPSBFIC0gNDtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsZXQgdztcbiAgICAgICAgYSAmJiAodyA9IGQuZmluZE9uZShcbiAgICAgICAgICBgJHtyc31bJHtIfV1gXG4gICAgICAgICkudGV4dENvbnRlbnQpLCB0aGlzLl9oYW5kbGVEaXNhYmxpbmdUaXBzTWluVGltZShcbiAgICAgICAgICB3LFxuICAgICAgICAgIHYsXG4gICAgICAgICAgZyxcbiAgICAgICAgICBtXG4gICAgICAgICksIHRoaXMuX2hhbmRsZURpc2FibGluZ1RpcHNNYXhUaW1lKFxuICAgICAgICAgIHcsXG4gICAgICAgICAgXyxcbiAgICAgICAgICBmLFxuICAgICAgICAgIHVcbiAgICAgICAgKTtcbiAgICAgIH0sIDApLCBbLi4udF0uZm9yRWFjaCgodywgUykgPT4ge1xuICAgICAgICBjb25zdCBrID0geShTICogQyksIHggPSBEKFwic3BhblwiKSwgJCA9IEQoXCJzcGFuXCIpO1xuICAgICAgICAkLmlubmVySFRNTCA9IHcsIGMuYWRkQ2xhc3MoeCwgdGhpcy5fY2xhc3Nlcy50aXBzKSwgeC5zZXRBdHRyaWJ1dGUoaSwgXCJcIik7XG4gICAgICAgIGNvbnN0IE8gPSB4Lm9mZnNldFdpZHRoLCBNID0geC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHJldHVybiBjLmFkZFN0eWxlKHgsIHtcbiAgICAgICAgICBsZWZ0OiBgJHtFICsgTWF0aC5zaW4oaykgKiBBIC0gT31weGAsXG4gICAgICAgICAgYm90dG9tOiBgJHtUICsgTWF0aC5jb3MoaykgKiBBIC0gTX1weGBcbiAgICAgICAgfSksIHQuaW5jbHVkZXMoXCIwNVwiKSAmJiB4LnNldEF0dHJpYnV0ZShYLCBcIlwiKSwgdC5pbmNsdWRlcyhcIjEzXCIpID8gJC5zZXRBdHRyaWJ1dGUoY3MsIFwiXCIpIDogJC5zZXRBdHRyaWJ1dGUobHMsIFwiXCIpLCB4LmFwcGVuZENoaWxkKCQpLCBiLmFwcGVuZENoaWxkKHgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2VsZW1lbnQgJiYgSS5zZXREYXRhKHQsIFNzLCB0aGlzKSwgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2N1cnJlbnRUaW1lID0gbnVsbCwgdGhpcy5fdG9nZ2xlQnV0dG9uSWQgPSBidChcInRpbWVwaWNrZXItdG9nZ2xlLVwiKSwgdGhpcy5ob3Vyc0FycmF5ID0gW1xuICAgICAgXCIxMlwiLFxuICAgICAgXCIxXCIsXG4gICAgICBcIjJcIixcbiAgICAgIFwiM1wiLFxuICAgICAgXCI0XCIsXG4gICAgICBcIjVcIixcbiAgICAgIFwiNlwiLFxuICAgICAgXCI3XCIsXG4gICAgICBcIjhcIixcbiAgICAgIFwiOVwiLFxuICAgICAgXCIxMFwiLFxuICAgICAgXCIxMVwiXG4gICAgXSwgdGhpcy5pbm5lckhvdXJzID0gW1xuICAgICAgXCIwMFwiLFxuICAgICAgXCIxM1wiLFxuICAgICAgXCIxNFwiLFxuICAgICAgXCIxNVwiLFxuICAgICAgXCIxNlwiLFxuICAgICAgXCIxN1wiLFxuICAgICAgXCIxOFwiLFxuICAgICAgXCIxOVwiLFxuICAgICAgXCIyMFwiLFxuICAgICAgXCIyMVwiLFxuICAgICAgXCIyMlwiLFxuICAgICAgXCIyM1wiXG4gICAgXSwgdGhpcy5taW51dGVzQXJyYXkgPSBbXG4gICAgICBcIjAwXCIsXG4gICAgICBcIjA1XCIsXG4gICAgICBcIjEwXCIsXG4gICAgICBcIjE1XCIsXG4gICAgICBcIjIwXCIsXG4gICAgICBcIjI1XCIsXG4gICAgICBcIjMwXCIsXG4gICAgICBcIjM1XCIsXG4gICAgICBcIjQwXCIsXG4gICAgICBcIjQ1XCIsXG4gICAgICBcIjUwXCIsXG4gICAgICBcIjU1XCJcbiAgICBdLCB0aGlzLmlucHV0ID0gZC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuZGF0YVdpdGhJY29uID0gdC5kYXRhc2V0LndpdGhJY29uLCB0aGlzLmRhdGFUb2dnbGUgPSB0LmRhdGFzZXQudG9nZ2xlLCB0aGlzLmN1c3RvbUljb24gPSBkLmZpbmRPbmUoXG4gICAgICBWZixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9jaGVja1RvZ2dsZUJ1dHRvbigpLCB0aGlzLmlucHV0Rm9ybWF0U2hvdyA9IGQuZmluZE9uZShcbiAgICAgIFdmLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuaW5wdXRGb3JtYXQgPSB0aGlzLmlucHV0Rm9ybWF0U2hvdyA9PT0gbnVsbCA/IFwiXCIgOiBPYmplY3QudmFsdWVzKHRoaXMuaW5wdXRGb3JtYXRTaG93LmRhdGFzZXQpWzBdLCB0aGlzLmVsZW1lbnRUb2dnbGUgPSBkLmZpbmRPbmUoXG4gICAgICBRcixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLnRvZ2dsZUVsZW1lbnQgPSBPYmplY3QudmFsdWVzKFxuICAgICAgdC5xdWVyeVNlbGVjdG9yKFFyKS5kYXRhc2V0XG4gICAgKVswXSwgdGhpcy5faG91ciA9IG51bGwsIHRoaXMuX21pbnV0ZXMgPSBudWxsLCB0aGlzLl9BTSA9IG51bGwsIHRoaXMuX1BNID0gbnVsbCwgdGhpcy5fd3JhcHBlciA9IG51bGwsIHRoaXMuX21vZGFsID0gbnVsbCwgdGhpcy5faGFuZCA9IG51bGwsIHRoaXMuX2NpcmNsZSA9IG51bGwsIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGwsIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2ludGVydmFsID0gbnVsbCwgdGhpcy5faW5wdXRWYWx1ZSA9IHRoaXMuX29wdGlvbnMuZGVmYXVsdFRpbWUgIT09IFwiXCIgPyB0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lIDogdGhpcy5pbnB1dC52YWx1ZSwgdGhpcy5fb3B0aW9ucy5mb3JtYXQyNCAmJiAodGhpcy5fb3B0aW9ucy5mb3JtYXQxMiA9ICExLCB0aGlzLl9jdXJyZW50VGltZSA9IFhyKHRoaXMuX2lucHV0VmFsdWUpKSwgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMiAmJiAodGhpcy5fb3B0aW9ucy5mb3JtYXQyNCA9ICExLCB0aGlzLl9jdXJyZW50VGltZSA9IGJlKHRoaXMuX2lucHV0VmFsdWUpKSwgdGhpcy5fb3B0aW9ucy5yZWFkT25seSAmJiB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZSh6ZiwgITApLCB0aGlzLmlucHV0Rm9ybWF0ID09PSBcInRydWVcIiAmJiB0aGlzLmlucHV0Rm9ybWF0ICE9PSBcIlwiICYmICh0aGlzLl9vcHRpb25zLmZvcm1hdDEyID0gITEsIHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgPSAhMCwgdGhpcy5fY3VycmVudFRpbWUgPSBYcih0aGlzLl9pbnB1dFZhbHVlKSksIHRoaXMuX2FuaW1hdGlvbnMgPSAhd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKS5tYXRjaGVzICYmIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9ucywgdGhpcy5pbml0KCksIHRoaXMuX2lzSG91cnMgPSAhMCwgdGhpcy5faXNNaW51dGVzID0gITEsIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgPSAhMSwgdGhpcy5faXNNb3VzZU1vdmUgPSAhMSwgdGhpcy5faXNJbm5lciA9ICExLCB0aGlzLl9pc0FtRW5hYmxlZCA9ICExLCB0aGlzLl9pc1BtRW5hYmxlZCA9ICExLCB0aGlzLl9vcHRpb25zLmZvcm1hdDEyICYmICF0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lICYmICh0aGlzLl9pc1BtRW5hYmxlZCA9ICEwKSwgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZSA9IHsgZGVncmVlczogbnVsbCB9LCB0aGlzLl9zY3JvbGxCYXIgPSBuZXcga2koKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4geWk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgY29uc3QgeyBmb3JtYXQxMjogdCwgZm9ybWF0MjQ6IGUsIGVuYWJsZVZhbGlkYXRpb246IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgbGV0IG4sIG8sIHI7XG4gICAgaWYgKHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKFVmLCBcIlwiKSwgdGhpcy5fY3VycmVudFRpbWUgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgeyBob3VyczogYSwgbWludXRlczogbCwgYW1PclBtOiBwIH0gPSB0aGlzLl9jdXJyZW50VGltZTtcbiAgICAgIG4gPSBOdW1iZXIoYSkgPCAxMCA/IDAgOiBcIlwiLCBvID0gYCR7bn0ke051bWJlcihhKX06JHtsfWAsIHIgPSBwLCB0ID8gdGhpcy5pbnB1dC52YWx1ZSA9IGAke299ICR7cn1gIDogZSAmJiAodGhpcy5pbnB1dC52YWx1ZSA9IGAke299YCk7XG4gICAgfSBlbHNlXG4gICAgICBuID0gXCJcIiwgbyA9IFwiXCIsIHIgPSBcIlwiLCB0aGlzLmlucHV0LnZhbHVlID0gXCJcIjtcbiAgICB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aCA+IDAgJiYgdGhpcy5pbnB1dC52YWx1ZSAhPT0gXCJcIiAmJiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoSCwgXCJcIiksIGgudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0XCIpKSwgISh0aGlzLl9vcHRpb25zID09PSBudWxsICYmIHRoaXMuX2VsZW1lbnQgPT09IG51bGwpICYmIChpICYmIHRoaXMuX2dldFZhbGlkYXRlKFwia2V5ZG93biBjaGFuZ2UgYmx1ciBmb2N1c1wiKSwgdGhpcy5faGFuZGxlT3BlbigpLCB0aGlzLl9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9yZW1vdmVNb2RhbCgpLCB0aGlzLl9lbGVtZW50ICE9PSBudWxsICYmIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBTcyksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsLCB0aGlzLmlucHV0ID0gbnVsbCwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbDtcbiAgICB9LCAzNTApLCBoLm9mZihcbiAgICAgIHRoaXMuX2RvY3VtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgYFtkYXRhLXRlLXRvZ2dsZT0nJHt0aGlzLnRvZ2dsZUVsZW1lbnR9J11gXG4gICAgKSwgaC5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWBcbiAgICApO1xuICB9XG4gIHVwZGF0ZSh0ID0ge30pIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fb3B0aW9ucywgLi4udCB9KTtcbiAgfVxuICAvLyBwcml2YXRlXG4gIF9jaGVja1RvZ2dsZUJ1dHRvbigpIHtcbiAgICB0aGlzLmN1c3RvbUljb24gPT09IG51bGwgJiYgKHRoaXMuZGF0YVdpdGhJY29uICE9PSB2b2lkIDAgJiYgKHRoaXMuX29wdGlvbnMud2l0aEljb24gPSBudWxsLCB0aGlzLmRhdGFXaXRoSWNvbiA9PT0gXCJ0cnVlXCIgJiYgdGhpcy5fYXBwZW5kVG9nZ2xlQnV0dG9uKHRoaXMuX29wdGlvbnMpKSwgdGhpcy5fb3B0aW9ucy53aXRoSWNvbiAmJiB0aGlzLl9hcHBlbmRUb2dnbGVCdXR0b24odGhpcy5fb3B0aW9ucykpO1xuICB9XG4gIF9hcHBlbmRUb2dnbGVCdXR0b24oKSB7XG4gICAgY29uc3QgdCA9ICRmKFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5pbnB1dC5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmVuZFwiLCB0KTtcbiAgfVxuICBfZ2V0RG9tRWxlbWVudHMoKSB7XG4gICAgdGhpcy5faG91ciA9IGQuZmluZE9uZShgWyR7YXN9XWApLCB0aGlzLl9taW51dGVzID0gZC5maW5kT25lKGBbJHtMbn1dYCksIHRoaXMuX0FNID0gZC5maW5kT25lKEJmKSwgdGhpcy5fUE0gPSBkLmZpbmRPbmUoSGYpLCB0aGlzLl93cmFwcGVyID0gZC5maW5kT25lKGBbJHskbn1dYCksIHRoaXMuX21vZGFsID0gZC5maW5kT25lKGBbJHtwYX1dYCksIHRoaXMuX2hhbmQgPSBkLmZpbmRPbmUoYFske01ufV1gKSwgdGhpcy5fY2lyY2xlID0gZC5maW5kT25lKGBbJHtObn1dYCksIHRoaXMuX2Nsb2NrID0gZC5maW5kT25lKGBbJHt1ZX1dYCksIHRoaXMuX2Nsb2NrSW5uZXIgPSBkLmZpbmRPbmUoXG4gICAgICBgWyR7YWl9XWBcbiAgICApO1xuICB9XG4gIF9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKHQsIGUsIGksIG4sIG8sIHIpIHtcbiAgICBpZiAoIWUgJiYgIWkpXG4gICAgICByZXR1cm4gITA7XG4gICAgY29uc3QgeyBmb3JtYXQyNDogYSwgZm9ybWF0MTI6IGwsIGRpc2FibGVQYXN0OiBwLCBkaXNhYmxlRnV0dXJlOiB1IH0gPSB0aGlzLl9vcHRpb25zLCB7IF9pc0FtRW5hYmxlZDogZiwgX2lzUG1FbmFibGVkOiBfIH0gPSB0aGlzLCBtID0gci5rZXlDb2RlLCBnID0gci50YXJnZXQuaGFzQXR0cmlidXRlKGFpKSB8fCByLnRhcmdldC5oYXNBdHRyaWJ1dGUoYXQpIHx8IHIudGFyZ2V0Lmhhc0F0dHJpYnV0ZShjcyk7XG4gICAgaSA9IFh0KGksIHAsIGwpLCBlID0gR3QoZSwgdSwgbCksIHR5cGVvZiBlICE9IFwibnVtYmVyXCIgJiYgKGUgPSBSKGUsICExKVswXSk7XG4gICAgY29uc3QgdiA9IGUgIT09IFwiXCIgPyBlICogMzAgOiBcIlwiLCBiID0gaSAhPT0gXCJcIiA/IGkgKiAzMCA6IFwiXCI7XG4gICAgdCA8IDAgJiYgKHQgPSAzNjAgKyB0KSwgdCA9IHQgPT09IDM2MCA/IDAgOiB0O1xuICAgIGNvbnN0IEMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBTID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgYFske2xzfV1gXG4gICAgICApLCBrID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgYFske2NzfV1gXG4gICAgICApLCB4ID0gUGYodGhpcy5faG91ci5pbm5lclRleHQpO1xuICAgICAgbGV0ICQsIE8sIE07XG4gICAgICByZXR1cm4gbSA9PT0gcnQgPyBPID0gMSA6IG0gPT09IHogJiYgKE8gPSAtMSksIHggPT09IDEyICYmIG0gPT09IHJ0ID8gTSA9IDEgOiB4ID09PSAwICYmIG0gPT09IHJ0ID8gTSA9IDEzIDogeCA9PT0gMCAmJiBtID09PSB6ID8gTSA9IDIzIDogeCA9PT0gMTMgJiYgbSA9PT0geiA/IE0gPSAwIDogeCA9PT0gMSAmJiBtID09PSB6ID8gTSA9IDEyIDogTSA9IHggKyBPLCBTLmZvckVhY2goKFApID0+IHtcbiAgICAgICAgTnVtYmVyKFAudGV4dENvbnRlbnQpID09PSBNICYmICgkID0gUCk7XG4gICAgICB9KSwgay5mb3JFYWNoKChQKSA9PiB7XG4gICAgICAgIE51bWJlcihQLnRleHRDb250ZW50KSA9PT0gTSAmJiAoJCA9IFApO1xuICAgICAgfSksICEkLnBhcmVudEVsZW1lbnQuaGFzQXR0cmlidXRlKFl0KTtcbiAgICB9LCB5ID0gKCkgPT4ge1xuICAgICAgY29uc3QgUyA9IGkgIT09IFwiXCIgJiYgaSA+IDEyID8gKGkgLSAxMikgKiAzMCA6IFwiXCIsIGsgPSBlICE9PSBcIlwiICYmIGUgPiAxMiA/IChlIC0gMTIpICogMzAgOiBcIlwiO1xuICAgICAgaWYgKCEoUyAmJiB0IDwgUyB8fCBrICYmIHQgPiBrIHx8IGUgJiYgZSA8IDEyKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH07XG4gICAgaWYgKGEgJiYgci50eXBlICE9PSBcImtleWRvd25cIiAmJiBnKVxuICAgICAgcmV0dXJuIHkoKTtcbiAgICBpZiAoci50eXBlID09PSBcImtleWRvd25cIilcbiAgICAgIHJldHVybiBDKCk7XG4gICAgY29uc3QgRSA9ICFvIHx8IG8gPT09IFwiUE1cIiAmJiBfIHx8IGkgIT09IFwiXCIgJiYgbyA9PT0gXCJBTVwiICYmIGYsIFQgPSAhbiB8fCBuID09PSBcIlBNXCIgJiYgXyB8fCBlICE9PSBcIlwiICYmIG4gPT09IFwiQU1cIiAmJiBmLCBBID0gKCkgPT4ge1xuICAgICAgY29uc3QgUyA9IGIgPT09IDM2MCAmJiBsID8gMCA6IGI7XG4gICAgICBpZiAoaSkge1xuICAgICAgICBpZiAobyA9PT0gXCJQTVwiICYmIGYgfHwgRSAmJiB0IDwgUylcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIHcgPSAoKSA9PiB7XG4gICAgICBjb25zdCBTID0gdiA9PT0gMzYwICYmIGwgPyAwIDogdjtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGlmIChuID09PSBcIkFNXCIgJiYgXyB8fCBUICYmIHQgPiBTKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITA7XG4gICAgfTtcbiAgICByZXR1cm4gQSgpICYmIHcoKTtcbiAgfVxuICBfaGFuZGxlS2V5Ym9hcmQoKSB7XG4gICAgaC5vbih0aGlzLl9kb2N1bWVudCwgbnMsIFwiXCIsICh0KSA9PiB7XG4gICAgICBsZXQgZSwgaSwgbjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5jcmVtZW50OiBvLFxuICAgICAgICBtYXhUaW1lOiByLFxuICAgICAgICBtaW5UaW1lOiBhLFxuICAgICAgICBmb3JtYXQxMjogbCxcbiAgICAgICAgZGlzYWJsZVBhc3Q6IHAsXG4gICAgICAgIGRpc2FibGVGdXR1cmU6IHVcbiAgICAgIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgbGV0IGYgPSBSKGEsICExKVswXSwgXyA9IFIociwgITEpWzBdO1xuICAgICAgY29uc3QgbSA9IFIoYSwgITEpWzJdLCBnID0gUihyLCAhMSlbMl07XG4gICAgICBmID0gWHQoZiwgcCwgbCksIF8gPSBHdChfLCB1LCBsKSwgdHlwZW9mIF8gIT0gXCJudW1iZXJcIiAmJiAoXyA9IFIoXywgITEpWzBdKTtcbiAgICAgIGNvbnN0IHYgPSBkLmZpbmRPbmUoYFske1h9XWApID09PSBudWxsLCBiID0gZC5maW5kT25lKGBbJHthdH1dYCkgIT09IG51bGwsIEMgPSBOdW1iZXIodGhpcy5faGFuZC5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgvW15cXGQtXS9nLCBcIlwiKSksIHkgPSBkLmZpbmQoXG4gICAgICAgIGBbJHtYfV1gLFxuICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgKSwgRSA9IGQuZmluZChcbiAgICAgICAgYFske0t9XWAsXG4gICAgICAgIHRoaXMuX21vZGFsXG4gICAgICApLCBUID0gZC5maW5kKFxuICAgICAgICBgWyR7YXR9XWAsXG4gICAgICAgIHRoaXMuX21vZGFsXG4gICAgICApO1xuICAgICAgbGV0IEEgPSB0aGlzLl9tYWtlSG91ckRlZ3JlZXModC50YXJnZXQsIEMsIGUpLmhvdXI7XG4gICAgICBjb25zdCB7IGRlZ3JlZXM6IHcsIGFkZERlZ3JlZXM6IFMgfSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyhcbiAgICAgICAgdC50YXJnZXQsXG4gICAgICAgIEMsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgICBsZXQgeyBtaW51dGU6IGssIGRlZ3JlZXM6IHggfSA9IHRoaXMuX21ha2VNaW51dGVzRGVncmVlcyhDLCBpKTtcbiAgICAgIGNvbnN0ICQgPSB0aGlzLl9tYWtlTWludXRlc0RlZ3JlZXMoXG4gICAgICAgIEMsXG4gICAgICAgIGlcbiAgICAgICkuYWRkRGVncmVlcztcbiAgICAgIGxldCB7IGhvdXI6IE8gfSA9IHRoaXMuX21ha2VJbm5lckhvdXJzRGVncmVlcyhcbiAgICAgICAgQyxcbiAgICAgICAgblxuICAgICAgKTtcbiAgICAgIGlmICh0LmtleUNvZGUgPT09IExpKSB7XG4gICAgICAgIGNvbnN0IE0gPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske2tufV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICk7XG4gICAgICAgIGgudHJpZ2dlcihNLCBcImNsaWNrXCIpO1xuICAgICAgfSBlbHNlIGlmICh2KSB7XG4gICAgICAgIGlmIChiICYmICh0LmtleUNvZGUgPT09IEJlICYmICh0aGlzLl9pc0lubmVyID0gITEsIGMuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgICAgICB9KSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICBBID4gMTIgPyAxIDogQVxuICAgICAgICApLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIEUpLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIFQpKSwgdC5rZXlDb2RlID09PSBQZSAmJiAodGhpcy5faXNJbm5lciA9ICEwLCBjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgICB9KSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICBPID49IDI0IHx8IE8gPT09IFwiMDBcIiA/IDAgOiBPXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgVCksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgICAgICB0aGlzLl9ob3VyIC0gMSxcbiAgICAgICAgICBFXG4gICAgICAgICkpKSwgdC5rZXlDb2RlID09PSBydCkge1xuICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlck1heE1pbkhvdXJzT3B0aW9ucyhcbiAgICAgICAgICAgIHcgKyAzMCxcbiAgICAgICAgICAgIF8sXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICB0XG4gICAgICAgICAgKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt3ICsgU31kZWcpYFxuICAgICAgICAgIH0pLCB0aGlzLl9pc0lubmVyID8gKE8gKz0gMSwgTyA9PT0gMjQgPyBPID0gMCA6IChPID09PSAyNSB8fCBPID09PSBcIjAwMVwiKSAmJiAoTyA9IDEzKSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShPKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBUKSkgOiAoQSArPSAxLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgICAgQSA+IDEyID8gMSA6IEFcbiAgICAgICAgICApLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIEUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodC5rZXlDb2RlID09PSB6KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKFxuICAgICAgICAgICAgdyAtIDMwLFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHRcbiAgICAgICAgICApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGMuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3cgLSBTfWRlZylgXG4gICAgICAgICAgfSksIHRoaXMuX2lzSW5uZXIgPyAoTyAtPSAxLCBPID09PSAxMiA/IE8gPSAwIDogTyA9PT0gLTEgJiYgKE8gPSAyMyksIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoTyksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgVCkpIDogKEEgLT0gMSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICAgIEEgPT09IDAgPyAxMiA6IEFcbiAgICAgICAgICApLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIEUpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIHQua2V5Q29kZSA9PT0gcnQgJiYgKHggKz0gJCwgYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3h9ZGVnKWBcbiAgICAgICAgfSksIGsgKz0gMSwgbyAmJiAoayArPSA0LCBrID09PSBcIjAwMTRcIiAmJiAoayA9IDUpKSwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICBrID4gNTkgPyAwIDoga1xuICAgICAgICApLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZShcbiAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICB0aGlzLl9taW51dGVzLFxuICAgICAgICAgIHlcbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQmFja2dyb3VuZENvbG9yQ2lyY2xlKFxuICAgICAgICAgIGBbJHtYfV1gXG4gICAgICAgICkpLCB0LmtleUNvZGUgPT09IHogJiYgKHggLT0gJCwgYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3h9ZGVnKWBcbiAgICAgICAgfSksIG8gPyBrIC09IDUgOiBrIC09IDEsIGsgPT09IC0xID8gayA9IDU5IDogayA9PT0gLTUgJiYgKGsgPSA1NSksIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoayksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgIHRoaXMubWludXRlc0FycmF5LFxuICAgICAgICAgIHRoaXMuX21pbnV0ZXMsXG4gICAgICAgICAgeVxuICAgICAgICApLCB0aGlzLl90b2dnbGVCYWNrZ3JvdW5kQ29sb3JDaXJjbGUoXG4gICAgICAgICAgYFske1h9XWBcbiAgICAgICAgKSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldEFjdGl2ZUNsYXNzVG9UaXBzT25PcGVuKHQsIC4uLmUpIHtcbiAgICBpZiAoIXRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQpXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5mb3JtYXQyNCkge1xuICAgICAgICBjb25zdCBpID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIG4gPSBkLmZpbmQoXG4gICAgICAgICAgYFske2F0fV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoaSwgdCksIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAobiwgdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbLi4uZV0uZmlsdGVyKChuKSA9PiAobiA9PT0gXCJQTVwiID8gKGMuYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShILCBcIlwiKSkgOiBuID09PSBcIkFNXCIgPyAoYy5hZGRDbGFzcyh0aGlzLl9BTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fQU0uc2V0QXR0cmlidXRlKEgsIFwiXCIpKSA6IChjLnJlbW92ZUNsYXNzKHRoaXMuX0FNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCBjLnJlbW92ZUNsYXNzKHRoaXMuX1BNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9BTS5yZW1vdmVBdHRyaWJ1dGUoSCksIHRoaXMuX1BNLnJlbW92ZUF0dHJpYnV0ZShIKSksIG4pKTtcbiAgICAgICAgY29uc3QgaSA9IGQuZmluZChcbiAgICAgICAgICBgWyR7S31dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKGksIHQpO1xuICAgICAgfVxuICB9XG4gIF9zZXRUaXBzQW5kVGltZXNEZXBlbmRPbklucHV0VmFsdWUodCwgZSkge1xuICAgIGNvbnN0IHsgaW5saW5lOiBpLCBmb3JtYXQxMjogbiB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAodGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdClcbiAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSBcIjEyXCIsIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBcIjAwXCIsIGkgfHwgYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgIHRyYW5zZm9ybTogXCJyb3RhdGVaKDBkZWcpXCJcbiAgICAgIH0pLCBuICYmIChjLmFkZENsYXNzKHRoaXMuX1BNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9QTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbyA9IHQgPiAxMiA/IHQgKiAzMCAtIDM2MCA6IHQgKiAzMDtcbiAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0LCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gZSwgaSB8fCAoYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHtvfWRlZylgXG4gICAgICB9KSwgYy5hZGRTdHlsZSh0aGlzLl9jaXJjbGUsIHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMxOTc2ZDJcIlxuICAgICAgfSksIChOdW1iZXIodCkgPiAxMiB8fCB0ID09PSBcIjAwXCIpICYmIGMuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuICBfbGlzdGVuVG9Ub2dnbGVLZXlkb3duKCkge1xuICAgIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWAsXG4gICAgICAodCkgPT4ge1xuICAgICAgICB0LmtleUNvZGUgPT09IGx0ICYmICh0LnByZXZlbnREZWZhdWx0KCksIGgudHJpZ2dlcih0aGlzLmVsZW1lbnRUb2dnbGUsIFwiY2xpY2tcIikpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZU9wZW4oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldENvbnRhaW5lcigpO1xuICAgIG9lLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGBbZGF0YS10ZS10b2dnbGU9JyR7dGhpcy50b2dnbGVFbGVtZW50fSddYCxcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zID09PSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZSh0aGlzLmlucHV0LCBcInRvZ2dsZVwiKSAhPT0gbnVsbCA/IDIwMCA6IDA7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGMuYWRkU3R5bGUodGhpcy5lbGVtZW50VG9nZ2xlLCB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICAgIH0pLCB0aGlzLmVsZW1lbnRUb2dnbGUuYmx1cigpO1xuICAgICAgICAgIGxldCBuO1xuICAgICAgICAgIFIodGhpcy5pbnB1dClbMF0gPT09IFwiXCIgPyBuID0gW1wiMTJcIiwgXCIwMFwiLCBcIlBNXCJdIDogbiA9IFIodGhpcy5pbnB1dCk7XG4gICAgICAgICAgY29uc3QgeyBtb2RhbElEOiBvLCBpbmxpbmU6IHIsIGZvcm1hdDEyOiBhIH0gPSB0aGlzLl9vcHRpb25zLCBbbCwgcCwgdV0gPSBuLCBmID0gRChcImRpdlwiKTtcbiAgICAgICAgICBpZiAoKE51bWJlcihsKSA+IDEyIHx8IGwgPT09IFwiMDBcIikgJiYgKHRoaXMuX2lzSW5uZXIgPSAhMCksIHRoaXMuaW5wdXQuYmx1cigpLCBlLnRhcmdldC5ibHVyKCksIGYuaW5uZXJIVE1MID0gRGYodGhpcy5fb3B0aW9ucywgdGhpcy5fY2xhc3NlcyksIGMuYWRkQ2xhc3MoZiwgdGhpcy5fY2xhc3Nlcy5tb2RhbCksIGYuc2V0QXR0cmlidXRlKHBhLCBcIlwiKSwgZi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZGlhbG9nXCIpLCBmLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIFwiLTFcIiksIGYuc2V0QXR0cmlidXRlKFwiaWRcIiwgbyksIHIgPyAodGhpcy5fcG9wcGVyID0gRWUodGhpcy5pbnB1dCwgZiwge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiXG4gICAgICAgICAgfSksIHQuYXBwZW5kQ2hpbGQoZikpIDogKHQuYXBwZW5kQ2hpbGQoZiksIHRoaXMuX3Njcm9sbEJhci5oaWRlKCkpLCB0aGlzLl9nZXREb21FbGVtZW50cygpLCB0aGlzLl9hbmltYXRpb25zID8gdGhpcy5fdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24oKSA6IGMuYWRkQ2xhc3ModGhpcy5fd3JhcHBlciwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fc2V0QWN0aXZlQ2xhc3NUb1RpcHNPbk9wZW4obCwgcCwgdSksIHRoaXMuX2FwcGVuZFRpbWVzKCksIHRoaXMuX3NldEFjdGl2ZUNsYXNzVG9UaXBzT25PcGVuKGwsIHAsIHUpLCB0aGlzLl9zZXRUaXBzQW5kVGltZXNEZXBlbmRPbklucHV0VmFsdWUobCwgcCksIHRoaXMuaW5wdXQudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IF8gPSBkLmZpbmQoXG4gICAgICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGEgJiYgKGMuYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShILCBcIlwiKSksIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSBcIjEyXCIsIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBcIjAwXCIsIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoXG4gICAgICAgICAgICAgIF8sXG4gICAgICAgICAgICAgIE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZVN3aXRjaFRpbWVNb2RlKCksIHRoaXMuX2hhbmRsZU9rQnV0dG9uKCksIHRoaXMuX2hhbmRsZUNsb3NlKCksIHIpXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVIb3ZlcklubGluZUJ0bigpLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrSW5saW5lKCksIHRoaXMuX2hhbmRsZUlubGluZUNsaWNrcygpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlU3dpdGNoSG91ck1pbnV0ZSgpLCB0aGlzLl9oYW5kbGVDbG9ja0NsaWNrKCksIHRoaXMuX2hhbmRsZUtleWJvYXJkKCk7XG4gICAgICAgICAgICBjb25zdCBfID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgYCR7b3N9WyR7SH1dYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGMuYWRkQ2xhc3MoXywgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgYy5hZGRTdHlsZSh0aGlzLl9ob3VyLCB7XG4gICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgICAgICAgICB9KSwgYy5hZGRTdHlsZSh0aGlzLl9taW51dGVzLCB7XG4gICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9mb2N1c1RyYXAgPSBuZXcgJGkodGhpcy5fd3JhcHBlciwge1xuICAgICAgICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgICAgICAgY29uZGl0aW9uOiAoeyBrZXk6IF8gfSkgPT4gXyA9PT0gXCJUYWJcIlxuICAgICAgICAgIH0pLCB0aGlzLl9mb2N1c1RyYXAudHJhcCgpO1xuICAgICAgICB9LCBpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVJbmxpbmVDbGlja3MoKSB7XG4gICAgbGV0IHQsIGU7XG4gICAgY29uc3QgaSA9IChfKSA9PiB7XG4gICAgICBsZXQgbSA9IF87XG4gICAgICByZXR1cm4gbSA+IDU5ID8gbSA9IDAgOiBtIDwgMCAmJiAobSA9IDU5KSwgbTtcbiAgICB9LCBuID0gKF8pID0+IHtcbiAgICAgIGxldCBtID0gXztcbiAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmZvcm1hdDI0ID8gKG0gPiAyNCA/IG0gPSAxIDogbSA8IDAgJiYgKG0gPSAyMyksIG0gPiAyMyAmJiAobSA9IDApKSA6IChtID4gMTIgPyBtID0gMSA6IG0gPCAxICYmIChtID0gMTIpLCBtID4gMTIgJiYgKG0gPSAxKSksIG07XG4gICAgfSwgbyA9IChfKSA9PiB7XG4gICAgICBjb25zdCBtID0gbihfKTtcbiAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUobSk7XG4gICAgfSwgciA9IChfKSA9PiB7XG4gICAgICBjb25zdCBtID0gaShfKTtcbiAgICAgIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUobSk7XG4gICAgfSwgYSA9ICgpID0+IHtcbiAgICAgIHQgKz0gMSwgbyh0KTtcbiAgICB9LCBsID0gKCkgPT4ge1xuICAgICAgZSArPSAxLCByKGUpO1xuICAgIH0sIHAgPSAoKSA9PiB7XG4gICAgICB0IC09IDEsIG8odCk7XG4gICAgfSwgdSA9ICgpID0+IHtcbiAgICAgIGUgLT0gMSwgcihlKTtcbiAgICB9LCBmID0gKF8pID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKF8sIDEwMCk7XG4gICAgfTtcbiAgICBvZS5vbihcbiAgICAgIHRoaXMuX21vZGFsLFxuICAgICAgXCJjbGljayBtb3VzZWRvd24gbW91c2V1cCB0b3VjaHN0YXJ0IHRvdWNoZW5kIGNvbnRleHRtZW51XCIsXG4gICAgICBgWyR7U259XSwgWyR7SW59XWAsXG4gICAgICAoXykgPT4ge1xuICAgICAgICB0ID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBlID0gTnVtYmVyKHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQpO1xuICAgICAgICBjb25zdCB7IHRhcmdldDogbSwgdHlwZTogZyB9ID0gXywgdiA9IGcgPT09IFwibW91c2Vkb3duXCIgfHwgZyA9PT0gXCJ0b3VjaHN0YXJ0XCI7XG4gICAgICAgIG0uY2xvc2VzdChgWyR7U259XWApID8gbS5jbG9zZXN0KGBbJHtTbn1dYCkucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoY2EpID8gdiA/IGYoYSkgOiBnID09PSBcIm1vdXNldXBcIiB8fCBnID09PSBcInRvdWNoZW5kXCIgfHwgZyA9PT0gXCJjb250ZXh0bWVudVwiID8gY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCkgOiBhKCkgOiB2ID8gZihsKSA6IGcgPT09IFwibW91c2V1cFwiIHx8IGcgPT09IFwidG91Y2hlbmRcIiB8fCBnID09PSBcImNvbnRleHRtZW51XCIgPyBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSA6IGwoKSA6IG0uY2xvc2VzdChgWyR7SW59XWApICYmIChtLmNsb3Nlc3QoYFske0lufV1gKS5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShjYSkgPyB2ID8gZihwKSA6IGcgPT09IFwibW91c2V1cFwiIHx8IGcgPT09IFwidG91Y2hlbmRcIiA/IGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpIDogcCgpIDogdiA/IGYodSkgOiBnID09PSBcIm1vdXNldXBcIiB8fCBnID09PSBcInRvdWNoZW5kXCIgPyBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSA6IHUoKSk7XG4gICAgICB9XG4gICAgKSwgaC5vbih3aW5kb3csIG5zLCAoXykgPT4ge1xuICAgICAgY29uc3QgbSA9IF8uY29kZSwgZyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKGFzKSwgdiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKFxuICAgICAgICBMblxuICAgICAgKSwgYiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHk7XG4gICAgICBzd2l0Y2ggKHQgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGUgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCksIG0pIHtcbiAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICBfLnByZXZlbnREZWZhdWx0KCksIGIgfHwgZyA/ICh0aGlzLl9ob3VyLmZvY3VzKCksIGEoKSkgOiB2ICYmIGwoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICAgIF8ucHJldmVudERlZmF1bHQoKSwgYiB8fCBnID8gKHRoaXMuX2hvdXIuZm9jdXMoKSwgcCgpKSA6IHYgJiYgdSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDbG9zZSgpIHtcbiAgICBoLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgWyR7JG59XSwgWyR7a259XSwgWyR7bGF9XWAsXG4gICAgICAoeyB0YXJnZXQ6IHQgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IGNsb3NlTW9kYWxPbkJhY2tkcm9wQ2xpY2s6IGUgfSA9IHRoaXMuX29wdGlvbnMsIGkgPSAoKSA9PiB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgYy5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgICAgfSksIHRoaXMuX2FuaW1hdGlvbnMgJiYgdGhpcy5fdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24oITApLCB0aGlzLl9yZW1vdmVNb2RhbCgpLCAobiA9IHRoaXMuX2ZvY3VzVHJhcCkgPT0gbnVsbCB8fCBuLmRpc2FibGUoKSwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5lbGVtZW50VG9nZ2xlID8gdGhpcy5lbGVtZW50VG9nZ2xlLmZvY3VzKCkgOiB0aGlzLmlucHV0ICYmIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHQuaGFzQXR0cmlidXRlKGxhKSkge1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZUFtUG0oXCJQTVwiKSwgdGhpcy5pbnB1dC52YWx1ZSA9IFwiXCIsIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKEgpO1xuICAgICAgICAgIGxldCBuO1xuICAgICAgICAgIFIodGhpcy5pbnB1dClbMF0gPT09IFwiXCIgPyBuID0gW1wiMTJcIiwgXCIwMFwiLCBcIlBNXCJdIDogbiA9IFIodGhpcy5pbnB1dCk7XG4gICAgICAgICAgY29uc3QgW28sIHIsIGFdID0gbjtcbiAgICAgICAgICB0aGlzLl9zZXRUaXBzQW5kVGltZXNEZXBlbmRPbklucHV0VmFsdWUoXCIxMlwiLCBcIjAwXCIpLCB0aGlzLl9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3BlbihvLCByLCBhKSwgdGhpcy5faG91ci5jbGljaygpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAodC5oYXNBdHRyaWJ1dGUoa24pIHx8IHQuaGFzQXR0cmlidXRlKE9uKSB8fCB0Lmhhc0F0dHJpYnV0ZSgkbikgJiYgZSkgJiYgaSgpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgc2hvd1ZhbHVlSW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsdWU7XG4gIH1cbiAgX2hhbmRsZU9rQnV0dG9uKCkge1xuICAgIG9lLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgWyR7T259XWAsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGxldCB7IG1heFRpbWU6IHQsIG1pblRpbWU6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmb3JtYXQxMjogaSxcbiAgICAgICAgICBmb3JtYXQyNDogbixcbiAgICAgICAgICByZWFkT25seTogbyxcbiAgICAgICAgICBmb2N1c0lucHV0QWZ0ZXJBcHByb3ZlOiByLFxuICAgICAgICAgIGRpc2FibGVQYXN0OiBhLFxuICAgICAgICAgIGRpc2FibGVGdXR1cmU6IGxcbiAgICAgICAgfSA9IHRoaXMuX29wdGlvbnMsIHAgPSB0aGlzLl9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGAke3JzfVske0h9XWBcbiAgICAgICAgKSwgdSA9IGAke3RoaXMuX2hvdXIudGV4dENvbnRlbnR9OiR7dGhpcy5fbWludXRlcy50ZXh0Q29udGVudH1gLCBmID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBfID0gZiA9PT0gMTIgJiYgaSA/IDAgOiBmLCBtID0gTnVtYmVyKHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQpO1xuICAgICAgICBlID0gWHQoZSwgYSwgaSksIHQgPSBHdCh0LCBsLCBpKTtcbiAgICAgICAgbGV0IFtnLCB2LCBiXSA9IFIoXG4gICAgICAgICAgdCxcbiAgICAgICAgICAhMVxuICAgICAgICApLCBbQywgeSwgRV0gPSBSKFxuICAgICAgICAgIGUsXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgICAgQyA9IEMgPT09IFwiMTJcIiAmJiBpID8gXCIwMFwiIDogQywgZyA9IGcgPT09IFwiMTJcIiAmJiBpID8gXCIwMFwiIDogZztcbiAgICAgICAgY29uc3QgVCA9IF8gPCBOdW1iZXIoQyksIEEgPSBfID4gTnVtYmVyKGcpO1xuICAgICAgICBsZXQgdyA9ICEwO1xuICAgICAgICBwICYmICh3ID0gYiA9PT0gcC50ZXh0Q29udGVudCk7XG4gICAgICAgIGxldCBTID0gITA7XG4gICAgICAgIHAgJiYgKFMgPSBFID09PSBwLnRleHRDb250ZW50KTtcbiAgICAgICAgY29uc3QgayA9IG0gPiB2ICYmIF8gPT09IE51bWJlcihnKSwgeCA9IG0gPCB5ICYmIF8gPT09IE51bWJlcihDKTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKEgsIFwiXCIpLCBjLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgIH0pLCB0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgaWYgKHcgJiYgKEEgfHwgaykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKGIgPT09IFwiQU1cIiAmJiBwLnRleHRDb250ZW50ID09PSBcIlBNXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZSAhPT0gXCJcIiAmJiAoUyAmJiAoVCB8fCB4KSB8fCBFID09PSBcIlBNXCIgJiYgcC50ZXh0Q29udGVudCA9PT0gXCJBTVwiKSB8fCBNZihcbiAgICAgICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgICAgIHRoaXMuaW5wdXQsXG4gICAgICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudFxuICAgICAgICApICE9PSB2b2lkIDAgJiYgKHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgJiYgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoRG4pLCAhbyAmJiByICYmIHRoaXMuaW5wdXQuZm9jdXMoKSwgYy5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIlxuICAgICAgICB9KSwgbiA/IHRoaXMuaW5wdXQudmFsdWUgPSB1IDogcCA9PT0gbnVsbCA/IHRoaXMuaW5wdXQudmFsdWUgPSBgJHt1fSBQTWAgOiB0aGlzLmlucHV0LnZhbHVlID0gYCR7dX0gJHtwLnRleHRDb250ZW50fWAsIHRoaXMuX2FuaW1hdGlvbnMgJiYgdGhpcy5fdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24oITApLCB0aGlzLl9yZW1vdmVNb2RhbCgpLCBoLnRyaWdnZXIodGhpcy5pbnB1dCwgXCJpbnB1dC50ZS50aW1lcGlja2VyXCIpLCBoLnRyaWdnZXIodGhpcy5pbnB1dCwgXCJpbnB1dFwiKSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlSG92ZXJJbmxpbmVCdG4oKSB7XG4gICAgb2Uub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwibW91c2VvdmVyIG1vdXNlbGVhdmVcIixcbiAgICAgIGBbJHtLZn1dYCxcbiAgICAgICh7IHR5cGU6IHQsIHRhcmdldDogZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSBkLmZpbmQoXG4gICAgICAgICAgYFske1lmfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIG4gPSBkLmZpbmQoXG4gICAgICAgICAgYFske2pmfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIG8gPSAobCwgcCkgPT4gbC5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIGMuYWRkQ2xhc3ModSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdS5zZXRBdHRyaWJ1dGUoSCwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGMucmVtb3ZlQ2xhc3ModSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdS5yZW1vdmVBdHRyaWJ1dGUoSCk7XG4gICAgICAgIH0pLCBhID0gZS5oYXNBdHRyaWJ1dGUoYXMpID8gaSA6IG47XG4gICAgICAgIG8oYSwgdCA9PT0gXCJtb3VzZW92ZXJcIik7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlRG9jdW1lbnRDbGlja0lubGluZSgpIHtcbiAgICBoLm9uKGRvY3VtZW50LCBKciwgKHsgdGFyZ2V0OiB0IH0pID0+IHtcbiAgICAgIGlmICh0aGlzLl9tb2RhbCAmJiAhdGhpcy5fbW9kYWwuY29udGFpbnModCkgJiYgIXQuaGFzQXR0cmlidXRlKEZmKSkge1xuICAgICAgICBpZiAoY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksIGMuYWRkU3R5bGUodGhpcy5lbGVtZW50VG9nZ2xlLCB7XG4gICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgfSksIHRoaXMuX3JlbW92ZU1vZGFsKCksICF0aGlzLl9hbmltYXRpb25zKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24oITApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVTd2l0Y2hIb3VyTWludXRlKCkge1xuICAgIExmKFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgb3MsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgaC5vbihcbiAgICAgIHRoaXMuX21vZGFsLFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgb3MsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZm9ybWF0MjQ6IHQgfSA9IHRoaXMuX29wdGlvbnMsIGUgPSBkLmZpbmQoXG4gICAgICAgICAgb3MsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgaSA9IGQuZmluZChcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBuID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIG8gPSBkLmZpbmQoXG4gICAgICAgICAgYFske2F0fV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIHIgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGEgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCksIGwgPSAocCwgdSkgPT4ge1xuICAgICAgICAgIG4uZm9yRWFjaCgoXykgPT4gXy5yZW1vdmUoKSksIGkuZm9yRWFjaCgoXykgPT4gXy5yZW1vdmUoKSksIGMuYWRkQ2xhc3ModGhpcy5faGFuZCwgdGhpcy5fY2xhc3Nlcy50cmFuc2Zvcm0pLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGMucmVtb3ZlQ2xhc3ModGhpcy5faGFuZCwgdGhpcy5fY2xhc3Nlcy50cmFuc2Zvcm0pO1xuICAgICAgICAgIH0sIDQwMSksIHRoaXMuX2dldEFwcGVuZENsb2NrKHAsIGBbJHt1ZX1dYCwgdSk7XG4gICAgICAgICAgY29uc3QgZiA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IF8gPSBkLmZpbmQoXG4gICAgICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKSwgbSA9IGQuZmluZChcbiAgICAgICAgICAgICAgYFske1h9XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChfLCByKSwgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChtLCBhKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICghdClcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBmKCk7XG4gICAgICAgICAgICB9LCA0MDEpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgXyA9IGQuZmluZChcbiAgICAgICAgICAgICAgYFske2F0fV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKF8sIHIpLCBmKCk7XG4gICAgICAgICAgICB9LCA0MDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgcC5oYXNBdHRyaWJ1dGUoSCkgJiYgKHAuaGFzQXR0cmlidXRlKExuKSA/IChjLmFkZENsYXNzKHRoaXMuX2hhbmQsIHRoaXMuX2NsYXNzZXMudHJhbnNmb3JtKSwgYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7dGhpcy5fbWludXRlcy50ZXh0Q29udGVudCAqIDZ9ZGVnKWAsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiY2FsYyg0MCUgKyAxcHgpXCJcbiAgICAgICAgICB9KSwgdCAmJiBvLmxlbmd0aCA+IDAgJiYgby5mb3JFYWNoKCh1KSA9PiB1LnJlbW92ZSgpKSwgbChcbiAgICAgICAgICAgIHRoaXMubWludXRlc0FycmF5LFxuICAgICAgICAgICAgWFxuICAgICAgICAgICksIHRoaXMuX2hvdXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiXCIsIHRoaXMuX21pbnV0ZXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiKSA6IHAuaGFzQXR0cmlidXRlKGFzKSAmJiAoYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7dGhpcy5faG91ci50ZXh0Q29udGVudCAqIDMwfWRlZylgXG4gICAgICAgICAgfSksIE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSA+IDEyID8gKGMuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3RoaXMuX2hvdXIudGV4dENvbnRlbnQgKiAzMCAtIDM2MH1kZWcpYCxcbiAgICAgICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICAgICAgfSksIE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSA+IDEyICYmIGMuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgaGVpZ2h0OiBcIjIxLjUlXCJcbiAgICAgICAgICB9KSkgOiBjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgICAgICAgIH0pLCB0ICYmIHRoaXMuX2dldEFwcGVuZENsb2NrKFxuICAgICAgICAgICAgdGhpcy5pbm5lckhvdXJzLFxuICAgICAgICAgICAgYFske2FpfV1gLFxuICAgICAgICAgICAgYXRcbiAgICAgICAgICApLCBvLmxlbmd0aCA+IDAgJiYgby5mb3JFYWNoKCh1KSA9PiB1LnJlbW92ZSgpKSwgbChcbiAgICAgICAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgICAgICAgIEtcbiAgICAgICAgICApLCBjLmFkZFN0eWxlKHRoaXMuX2hvdXIsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgICAgICAgfSksIGMuYWRkU3R5bGUodGhpcy5fbWludXRlcywge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJcIlxuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZURpc2FibGluZ1RpcHNNYXhUaW1lKHQsIGUsIGksIG4pIHtcbiAgICBpZiAoIXRoaXMuX29wdGlvbnMubWF4VGltZSAmJiAhdGhpcy5fb3B0aW9ucy5kaXNhYmxlRnV0dXJlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSBkLmZpbmQoXG4gICAgICBgWyR7S31dYFxuICAgICksIHIgPSBkLmZpbmQoXG4gICAgICBgWyR7YXR9XWBcbiAgICApLCBhID0gZC5maW5kKFxuICAgICAgYFske1h9XWBcbiAgICApO1xuICAgIGlmICghZSB8fCBlID09PSB0KSB7XG4gICAgICBxcihcbiAgICAgICAgcixcbiAgICAgICAgbixcbiAgICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICAgKSwgcXIoXG4gICAgICAgIG8sXG4gICAgICAgIG4sXG4gICAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICAgICksIE5mKFxuICAgICAgICBhLFxuICAgICAgICBpLFxuICAgICAgICBuLFxuICAgICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50LFxuICAgICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlID09PSBcIkFNXCIgJiYgdCA9PT0gXCJQTVwiICYmIChvLmZvckVhY2goKGwpID0+IHtcbiAgICAgIGMuYWRkQ2xhc3MobCwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBsLnNldEF0dHJpYnV0ZShZdCwgXCJcIik7XG4gICAgfSksIGEuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgYy5hZGRDbGFzcyhsLCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIGwuc2V0QXR0cmlidXRlKFl0LCBcIlwiKTtcbiAgICB9KSk7XG4gIH1cbiAgX2hhbmRsZURpc2FibGluZ1RpcHNNaW5UaW1lKHQsIGUsIGksIG4pIHtcbiAgICBpZiAoIXRoaXMuX29wdGlvbnMubWluVGltZSAmJiAhdGhpcy5fb3B0aW9ucy5kaXNhYmxlUGFzdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gZC5maW5kKFxuICAgICAgYFske0t9XWBcbiAgICApLCByID0gZC5maW5kKFxuICAgICAgYFske2F0fV1gXG4gICAgKSwgYSA9IGQuZmluZChcbiAgICAgIGBbJHtYfV1gXG4gICAgKTtcbiAgICAhZSB8fCBlID09PSB0ID8gKFpyKFxuICAgICAgbyxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICksIFpyKFxuICAgICAgcixcbiAgICAgIG4sXG4gICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICksIFJmKFxuICAgICAgYSxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCxcbiAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgKSkgOiBlID09PSBcIlBNXCIgJiYgdCA9PT0gXCJBTVwiICYmIChvLmZvckVhY2goKGwpID0+IHtcbiAgICAgIGMuYWRkQ2xhc3MobCwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBsLnNldEF0dHJpYnV0ZShZdCwgXCJcIik7XG4gICAgfSksIGEuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgYy5hZGRDbGFzcyhsLCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIGwuc2V0QXR0cmlidXRlKFl0LCBcIlwiKTtcbiAgICB9KSk7XG4gIH1cbiAgX2hhbmRsZVN3aXRjaFRpbWVNb2RlKCkge1xuICAgIGgub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIHJzLFxuICAgICAgKHsgdGFyZ2V0OiB0IH0pID0+IHtcbiAgICAgICAgbGV0IHsgbWF4VGltZTogZSwgbWluVGltZTogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBkaXNhYmxlUGFzdDogbiwgZGlzYWJsZUZ1dHVyZTogbywgZm9ybWF0MTI6IHIgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGkgPSBYdChpLCBuLCByKSwgZSA9IEd0KGUsIG8sIHIpO1xuICAgICAgICBjb25zdCBbYSwgbCwgcF0gPSBSKFxuICAgICAgICAgIGUsXG4gICAgICAgICAgITFcbiAgICAgICAgKSwgW3UsIGYsIF9dID0gUihcbiAgICAgICAgICBpLFxuICAgICAgICAgICExXG4gICAgICAgICksIG0gPSBkLmZpbmQoXG4gICAgICAgICAgYFske0t9XWBcbiAgICAgICAgKSwgZyA9IGQuZmluZChcbiAgICAgICAgICBgWyR7WH1dYFxuICAgICAgICApO1xuICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgIG0uZm9yRWFjaCgoYikgPT4ge1xuICAgICAgICAgICAgYy5yZW1vdmVDbGFzcyhiLCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIGIucmVtb3ZlQXR0cmlidXRlKFl0KTtcbiAgICAgICAgICB9KSwgZy5mb3JFYWNoKChiKSA9PiB7XG4gICAgICAgICAgICBjLnJlbW92ZUNsYXNzKGIsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgYi5yZW1vdmVBdHRyaWJ1dGUoWXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpLCB0aGlzLl9oYW5kbGVEaXNhYmxpbmdUaXBzTWluVGltZShcbiAgICAgICAgICB0LnRleHRDb250ZW50LFxuICAgICAgICAgIF8sXG4gICAgICAgICAgZixcbiAgICAgICAgICB1XG4gICAgICAgICksIHRoaXMuX2hhbmRsZURpc2FibGluZ1RpcHNNYXhUaW1lKFxuICAgICAgICAgIHQudGV4dENvbnRlbnQsXG4gICAgICAgICAgcCxcbiAgICAgICAgICBsLFxuICAgICAgICAgIGFcbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQW1QbSh0LnRleHRDb250ZW50KSwgdC5oYXNBdHRyaWJ1dGUoSCkgfHwgKGQuZmluZChcbiAgICAgICAgICByc1xuICAgICAgICApLmZvckVhY2goKEMpID0+IHtcbiAgICAgICAgICBDLmhhc0F0dHJpYnV0ZShIKSAmJiAoYy5yZW1vdmVDbGFzcyhDLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCBDLnJlbW92ZUF0dHJpYnV0ZShIKSk7XG4gICAgICAgIH0pLCBjLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHQuc2V0QXR0cmlidXRlKEgsIFwiXCIpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVDbG9ja0NsaWNrKCkge1xuICAgIGxldCB7IG1heFRpbWU6IHQsIG1pblRpbWU6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgeyBkaXNhYmxlUGFzdDogaSwgZGlzYWJsZUZ1dHVyZTogbiwgZm9ybWF0MTI6IG8gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgZSA9IFh0KGUsIGksIG8pLCB0ID0gR3QodCwgbiwgbyk7XG4gICAgY29uc3QgciA9IFIodCwgITEpWzJdLCBhID0gUihlLCAhMSlbMl0sIGwgPSBSKHQsICExKVswXSwgcCA9IFIoZSwgITEpWzBdLCB1ID0gZC5maW5kT25lKFxuICAgICAgYFske2RhfV1gXG4gICAgKTtcbiAgICBvZS5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgYCR7dGF9ICR7ZWF9ICR7aWF9ICR7c2F9ICR7bmF9ICR7YWF9ICR7b2F9ICR7cmF9YCxcbiAgICAgIFwiXCIsXG4gICAgICAoZikgPT4ge1xuICAgICAgICBzcygpIHx8IGYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgeyB0eXBlOiBfLCB0YXJnZXQ6IG0gfSA9IGYsIHsgY2xvc2VNb2RhbE9uTWludXRlc0NsaWNrOiBnLCBzd2l0Y2hIb3Vyc1RvTWludXRlc09uQ2xpY2s6IHYgfSA9IHRoaXMuX29wdGlvbnMsIGIgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske1h9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSAhPT0gbnVsbCwgQyA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7S31dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApICE9PSBudWxsLCB5ID0gZC5maW5kT25lKFxuICAgICAgICAgIGBbJHthdH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApICE9PSBudWxsLCBFID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIFQgPSBHcihmLCB1KSwgQSA9IHUub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICBsZXQgdyA9IE1hdGguYXRhbjIoVC55IC0gQSwgVC54IC0gQSk7XG4gICAgICAgIGlmIChzcygpKSB7XG4gICAgICAgICAgY29uc3QgJCA9IEdyKGYsIHUsICEwKTtcbiAgICAgICAgICB3ID0gTWF0aC5hdGFuMigkLnkgLSBBLCAkLnggLSBBKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgUyA9IG51bGwsIGsgPSBudWxsLCB4ID0gbnVsbDtcbiAgICAgICAgaWYgKF8gPT09IFwibW91c2Vkb3duXCIgfHwgXyA9PT0gXCJtb3VzZW1vdmVcIiB8fCBfID09PSBcInRvdWNobW92ZVwiIHx8IF8gPT09IFwidG91Y2hzdGFydFwiKVxuICAgICAgICAgIChfID09PSBcIm1vdXNlZG93blwiIHx8IF8gPT09IFwidG91Y2hzdGFydFwiIHx8IF8gPT09IFwidG91Y2htb3ZlXCIpICYmICh0aGlzLl9oYXNUYXJnZXRJbm5lckNsYXNzKG0pIHx8IG0uaGFzQXR0cmlidXRlKGRhKSB8fCBtLmhhc0F0dHJpYnV0ZSh1ZSkgfHwgbS5oYXNBdHRyaWJ1dGUoWCkgfHwgbS5oYXNBdHRyaWJ1dGUoSykgfHwgbS5oYXNBdHRyaWJ1dGUoTm4pIHx8IG0uaGFzQXR0cmlidXRlKE1uKSB8fCBtLmhhc0F0dHJpYnV0ZSh1YSkgfHwgbS5oYXNBdHRyaWJ1dGUobHMpKSAmJiAodGhpcy5faXNNb3VzZU1vdmUgPSAhMCwgc3MoKSAmJiBmLnRvdWNoZXMgJiYgKFMgPSBmLnRvdWNoZXNbMF0uY2xpZW50WCwgayA9IGYudG91Y2hlc1swXS5jbGllbnRZLCB4ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChTLCBrKSkpO1xuICAgICAgICBlbHNlIGlmIChfID09PSBcIm1vdXNldXBcIiB8fCBfID09PSBcInRvdWNoZW5kXCIpIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNNb3VzZU1vdmUgPSAhMSwgdGhpcy5faGFzVGFyZ2V0SW5uZXJDbGFzcyhtKSB8fCBtLmhhc0F0dHJpYnV0ZSh1ZSkgfHwgbS5oYXNBdHRyaWJ1dGUoSykgfHwgbS5oYXNBdHRyaWJ1dGUoTm4pIHx8IG0uaGFzQXR0cmlidXRlKE1uKSB8fCBtLmhhc0F0dHJpYnV0ZSh1YSkgfHwgbS5oYXNBdHRyaWJ1dGUobHMpKSB7XG4gICAgICAgICAgICBpZiAoKEMgfHwgeSkgJiYgdikge1xuICAgICAgICAgICAgICBjb25zdCAkID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpID4gbCB8fCBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPCBwO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5mb3JtYXQyNCAmJiBsICE9PSBcIlwiICYmIHAgIT09IFwiXCIgJiYgJClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0ICYmIHAgIT09IFwiXCIgJiYgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpIDwgcClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoLnRyaWdnZXIodGhpcy5fbWludXRlcywgXCJjbGlja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGIgJiYgZykge1xuICAgICAgICAgICAgY29uc3QgJCA9IGQuZmluZE9uZShcbiAgICAgICAgICAgICAgYFske09ufV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGgudHJpZ2dlcigkLCBcImNsaWNrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYikge1xuICAgICAgICAgIGxldCAkO1xuICAgICAgICAgIGNvbnN0IE8gPSBNYXRoLnRydW5jKHcgKiAxODAgLyBNYXRoLlBJKSArIDkwLCB7IGRlZ3JlZXM6IE0sIG1pbnV0ZTogUCB9ID0gdGhpcy5fbWFrZU1pbnV0ZXNEZWdyZWVzKE8sICQpO1xuICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyTWF4TWluTWludXRlc09wdGlvbnMoTSwgUCkgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCB7IGRlZ3JlZXM6IHR0LCBtaW51dGU6IGV0IH0gPSB0aGlzLl9oYW5kbGVyTWF4TWluTWludXRlc09wdGlvbnMoTSwgUCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAoYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0dH1kZWcpYFxuICAgICAgICAgICAgfSksIGV0ID09PSB2b2lkIDApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IFUgPSAoKSA9PiBldCA+PSAxMCB8fCBldCA9PT0gXCIwMFwiID8gZXQgOiBgMCR7ZXR9YDtcbiAgICAgICAgICAgIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBVKCksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICAgICAgdGhpcy5fbWludXRlcyxcbiAgICAgICAgICAgICAgRVxuICAgICAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQmFja2dyb3VuZENvbG9yQ2lyY2xlKFxuICAgICAgICAgICAgICBgWyR7WH1dYFxuICAgICAgICAgICAgKSwgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZS5kZWdyZWVzTWludXRlcyA9IHR0LCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLm1pbnV0ZXMgPSBldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEMgfHwgeSkge1xuICAgICAgICAgIGxldCAkLCBPID0gTWF0aC50cnVuYyh3ICogMTgwIC8gTWF0aC5QSSkgKyA5MDtcbiAgICAgICAgICBpZiAoTyA9IE1hdGgucm91bmQoTyAvIDMwKSAqIDMwLCBjLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMxOTc2ZDJcIlxuICAgICAgICAgIH0pLCB0aGlzLl9tYWtlSG91ckRlZ3JlZXMobSwgTywgJCkgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCBNID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNzKCkgJiYgTyAmJiB4KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgZGVncmVlczogUCwgaG91cjogdHQgfSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyh4LCBPLCAkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZU1vdmVIYW5kKFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgdHQsXG4gICAgICAgICAgICAgICAgUFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkZWdyZWVzOiBQLCBob3VyOiB0dCB9ID0gdGhpcy5fbWFrZUhvdXJEZWdyZWVzKG0sIE8sICQpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlTW92ZUhhbmQobSwgdHQsIFApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZS5kZWdyZWVzSG91cnMgPSBPLCB0aGlzLl9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKFxuICAgICAgICAgICAgTyxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBmXG4gICAgICAgICAgKSAmJiBNKCk7XG4gICAgICAgIH1cbiAgICAgICAgZi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYXNUYXJnZXRJbm5lckNsYXNzKHQpIHtcbiAgICByZXR1cm4gdC5oYXNBdHRyaWJ1dGUoYWkpIHx8IHQuaGFzQXR0cmlidXRlKGF0KSB8fCB0Lmhhc0F0dHJpYnV0ZShjcyk7XG4gIH1cbiAgX2hhbmRsZU1vdmVIYW5kKHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gZC5maW5kKFxuICAgICAgYFske0t9XWAsXG4gICAgICB0aGlzLl9tb2RhbFxuICAgICksIG8gPSBkLmZpbmQoXG4gICAgICBgWyR7YXR9XWAsXG4gICAgICB0aGlzLl9tb2RhbFxuICAgICk7XG4gICAgdGhpcy5faXNNb3VzZU1vdmUgJiYgKHRoaXMuX2hhc1RhcmdldElubmVyQ2xhc3ModCkgPyBjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgfSkgOiBjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgIH0pLCBjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHtpfWRlZylgXG4gICAgfSksIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSBlID49IDEwIHx8IGUgPT09IFwiMDBcIiA/IGUgOiBgMCR7ZX1gLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIG4pLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIG8pLCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLmhvdXIgPSBlID49IDEwIHx8IGUgPT09IFwiMDBcIiA/IGUgOiBgMCR7ZX1gKTtcbiAgfVxuICBfaGFuZGxlck1heE1pbk1pbnV0ZXNPcHRpb25zKHQsIGUpIHtcbiAgICBsZXQgeyBtYXhUaW1lOiBpLCBtaW5UaW1lOiBuIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IHsgZm9ybWF0MTI6IG8sIGluY3JlbWVudDogciwgZGlzYWJsZVBhc3Q6IGEsIGRpc2FibGVGdXR1cmU6IGwgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgbiA9IFh0KG4sIGEsIG8pLCBpID0gR3QoaSwgbCwgbyk7XG4gICAgY29uc3QgcCA9IFIoaSwgITEpWzFdLCB1ID0gUihuLCAhMSlbMV0sIGYgPSBSKGksICExKVswXSwgXyA9IFIobiwgITEpWzBdLCBtID0gXyA9PT0gXCIxMlwiICYmIG8gPyBcIjBcIiA6IF8sIGcgPSBmID09PSBcIjEyXCIgJiYgbyA/IFwiMFwiIDogZiwgdiA9IFIoaSwgITEpWzJdLCBiID0gUihuLCAhMSlbMl0sIEMgPSBwICE9PSBcIlwiID8gcCAqIDYgOiBcIlwiLCB5ID0gdSAhPT0gXCJcIiA/IHUgKiA2IDogXCJcIiwgRSA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgVCA9IEUgPT09IDEyICYmIG8gPyAwIDogRTtcbiAgICBpZiAoIXYgJiYgIWIpIHtcbiAgICAgIGlmIChpICE9PSBcIlwiICYmIG4gIT09IFwiXCIpIHtcbiAgICAgICAgaWYgKE51bWJlcihnKSA9PT0gVCAmJiB0ID4gQyB8fCBOdW1iZXIobSkgPT09IFQgJiYgdCA8IHkpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9IGVsc2UgaWYgKG4gIT09IFwiXCIgJiYgVCA8PSBOdW1iZXIobSkpIHtcbiAgICAgICAgaWYgKHQgPD0geSAtIDYpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9IGVsc2UgaWYgKGkgIT09IFwiXCIgJiYgVCA+PSBOdW1iZXIoZykgJiYgdCA+PSBDICsgNilcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuICE9PSBcIlwiKSB7XG4gICAgICAgIGlmIChiID09PSBcIlBNXCIgJiYgdGhpcy5faXNBbUVuYWJsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoYiA9PT0gXCJQTVwiICYmIHRoaXMuX2lzUG1FbmFibGVkKSB7XG4gICAgICAgICAgaWYgKFQgPCBOdW1iZXIobSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKFQgPD0gTnVtYmVyKG0pICYmIHQgPD0geSAtIDYpXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSBcIkFNXCIgJiYgdGhpcy5faXNBbUVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoVCA8IE51bWJlcihtKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAoVCA8PSBOdW1iZXIobSkgJiYgdCA8PSB5IC0gNilcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSAhPT0gXCJcIikge1xuICAgICAgICBpZiAodiA9PT0gXCJBTVwiICYmIHRoaXMuX2lzUG1FbmFibGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHYgPT09IFwiUE1cIiAmJiB0aGlzLl9pc1BtRW5hYmxlZCkge1xuICAgICAgICAgIGlmIChUID49IE51bWJlcihnKSAmJiB0ID49IEMgKyA2KVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0gZWxzZSBpZiAodiA9PT0gXCJBTVwiICYmIHRoaXMuX2lzQW1FbmFibGVkICYmIFQgPj0gTnVtYmVyKGcpICYmIHQgPj0gQyArIDYpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByICYmICh0ID0gTWF0aC5yb3VuZCh0IC8gMzApICogMzApLCB0IDwgMCA/IHQgPSAzNjAgKyB0IDogdCA+PSAzNjAgJiYgKHQgPSAwKSwge1xuICAgICAgZGVncmVlczogdCxcbiAgICAgIG1pbnV0ZTogZVxuICAgIH07XG4gIH1cbiAgX3JlbW92ZU1vZGFsKCkge1xuICAgIHRoaXMuX2FuaW1hdGlvbnMgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZU1vZGFsRWxlbWVudHMoKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgfSwgMzAwKSA6ICh0aGlzLl9yZW1vdmVNb2RhbEVsZW1lbnRzKCksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpKSwgb2Uub2ZmKFxuICAgICAgdGhpcy5fZG9jdW1lbnQsXG4gICAgICBgJHtKcn0gJHtuc30gJHt0YX0gJHtlYX0gJHtpYX0gJHtzYX0gJHtuYX0gJHthYX0gJHtvYX0gJHtyYX1gXG4gICAgKSwgaC5vZmYod2luZG93LCBucyk7XG4gIH1cbiAgX3JlbW92ZU1vZGFsRWxlbWVudHMoKSB7XG4gICAgdGhpcy5fbW9kYWwgJiYgdGhpcy5fbW9kYWwucmVtb3ZlKCk7XG4gIH1cbiAgX3RvZ2dsZUJhY2tkcm9wQW5pbWF0aW9uKHQgPSAhMSkge1xuICAgIHQgPyB0aGlzLl93cmFwcGVyLmNsYXNzTGlzdC5hZGQoXCJhbmltYXRlLVtmYWRlLW91dF8zNTBtc19lYXNlLWluLW91dF1cIikgOiAodGhpcy5fd3JhcHBlci5jbGFzc0xpc3QuYWRkKFwiYW5pbWF0ZS1bZmFkZS1pbl8zNTBtc19lYXNlLWluLW91dF1cIiksIHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IGMuYWRkQ2xhc3ModGhpcy5fY2xvY2ssIHRoaXMuX2NsYXNzZXMuY2xvY2tBbmltYXRpb24pKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl93cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgIFwiYW5pbWF0ZS1bZmFkZS1vdXRfMzUwbXNfZWFzZS1pbi1vdXRdXCIsXG4gICAgICAgIFwiYW5pbWF0ZS1bZmFkZS1pbl8zNTBtc19lYXNlLWluLW91dF1cIlxuICAgICAgKTtcbiAgICB9LCAzNTEpO1xuICB9XG4gIF9hZGRBY3RpdmVDbGFzc1RvVGlwKHQsIGUpIHtcbiAgICB0LmZvckVhY2goKGkpID0+IHtcbiAgICAgIE51bWJlcihpLnRleHRDb250ZW50KSA9PT0gTnVtYmVyKGUpICYmIChjLmFkZENsYXNzKGksIHRoaXMuX2NsYXNzZXMudGlwc0FjdGl2ZSksIGkuc2V0QXR0cmlidXRlKEgsIFwiXCIpKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0SG91ck9yTWludXRlKHQpIHtcbiAgICByZXR1cm4gdCA8IDEwID8gYDAke3R9YCA6IHQ7XG4gIH1cbiAgX2FwcGVuZFRpbWVzKCkge1xuICAgIGNvbnN0IHsgZm9ybWF0MjQ6IHQgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgaWYgKHQpIHtcbiAgICAgIHRoaXMuX2dldEFwcGVuZENsb2NrKFxuICAgICAgICB0aGlzLmhvdXJzQXJyYXksXG4gICAgICAgIGBbJHt1ZX1dYCxcbiAgICAgICAgS1xuICAgICAgKSwgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICAgIHRoaXMuaW5uZXJIb3VycyxcbiAgICAgICAgYFske2FpfV1gLFxuICAgICAgICBhdFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICB0aGlzLmhvdXJzQXJyYXksXG4gICAgICBgWyR7dWV9XWAsXG4gICAgICBLXG4gICAgKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLkdmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKHlpLCB0LCBxZiksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5aZixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTCh5aSwgdCwgUWYpLCB0O1xuICB9XG4gIF9nZXRDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZSh0aGlzLl9vcHRpb25zLmNvbnRhaW5lcik7XG4gIH1cbiAgX2dldFZhbGlkYXRlKHQpIHtcbiAgICBjb25zdCB7IGludmFsaWRMYWJlbDogZSwgZm9ybWF0MjQ6IGksIGZvcm1hdDEyOiBuLCBhcHBlbmRWYWxpZGF0aW9uSW5mbzogbyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBsZXQgcjtcbiAgICBvICYmIChyID0gRChcImRpdlwiKSwgci5zZXRBdHRyaWJ1dGUoaGEsIFwiXCIpLCBjLmFkZENsYXNzKHIsIHRoaXMuX2NsYXNzZXMuaW52YWxpZEZlZWRiYWNrKSwgci5pbm5lckhUTUwgPSBlKSwgb2Uub24odGhpcy5pbnB1dCwgdCwgKHsgdGFyZ2V0OiBhIH0pID0+IHtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zID09PSBudWxsIHx8IHRoaXMuaW5wdXQudmFsdWUgPT09IFwiXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGwgPSAvXigwP1sxLTldfDFbMDEyXSkoOlswLTVdXFxkKSBbQVBhcF1bbU1dJC8sIHAgPSAvXihbMDFdXFxkfDJbMC0zXSkoOlswLTVdXFxkKSQvLCB1ID0gbC50ZXN0KGEudmFsdWUpO1xuICAgICAgaWYgKHAudGVzdChhLnZhbHVlKSAhPT0gITAgJiYgaSB8fCB1ICE9PSAhMCAmJiBuKSB7XG4gICAgICAgIG8gJiYgKHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKERuLCBcIlwiKSwgdGhpcy5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShcbiAgICAgICAgICByLFxuICAgICAgICAgIHRoaXMuaW5wdXQubmV4dFNpYmxpbmdcbiAgICAgICAgKSksIGMuYWRkU3R5bGUoYSwgeyBtYXJnaW5Cb3R0b206IDAgfSksIGMuYWRkU3R5bGUociwgeyBib3R0b206IFwiLTIzcHhcIiB9KSwgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICEwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShEbiksIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgPSAhMTtcbiAgICAgIGNvbnN0IF8gPSBkLmZpbmRPbmUoXG4gICAgICAgIGBbJHtoYX1dYFxuICAgICAgKTtcbiAgICAgIF8gIT09IG51bGwgJiYgXy5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIFNzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBKZiA9IHtcbiAgdGhyZXNob2xkOiAxMCxcbiAgZGlyZWN0aW9uOiBcImFsbFwiXG59O1xuY2xhc3MgdG0ge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsLCB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgLi4uSmYsXG4gICAgICAuLi5lXG4gICAgfTtcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCk7XG4gIH1cbiAgaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICBpZiAoIXRoaXMuX3N0YXJ0UG9zaXRpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpLCBpID0ge1xuICAgICAgeDogZS54IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi54LFxuICAgICAgeTogZS55IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi55XG4gICAgfSwgbiA9IHRoaXMuX2dldERpcmVjdGlvbihpKTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwiYWxsXCIpIHtcbiAgICAgIGlmIChuLnkudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiBuLngudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IG4ueS52YWx1ZSA+IG4ueC52YWx1ZSA/IG4ueS5kaXJlY3Rpb24gOiBuLnguZGlyZWN0aW9uO1xuICAgICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7cn1gKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwic3dpcGVcIiwgeyBkaXJlY3Rpb246IHIgfSksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvID0gdGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwibGVmdFwiIHx8IHRoaXMuX29wdGlvbnMgPT09IFwicmlnaHRcIiA/IFwieFwiIDogXCJ5XCI7XG4gICAgbltvXS5kaXJlY3Rpb24gPT09IHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uICYmIG5bb10udmFsdWUgPiB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiAoaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7bltvXS5kaXJlY3Rpb259YCksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsKTtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgfVxuICBfZ2V0Q29vcmRpbmF0ZXModCkge1xuICAgIGNvbnN0IFtlXSA9IHQudG91Y2hlcztcbiAgICByZXR1cm4ge1xuICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgeTogZS5jbGllbnRZXG4gICAgfTtcbiAgfVxuICBfZ2V0RGlyZWN0aW9uKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDoge1xuICAgICAgICBkaXJlY3Rpb246IHQueCA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKHQueClcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIGRpcmVjdGlvbjogdC55IDwgMCA/IFwidXBcIiA6IFwiZG93blwiLFxuICAgICAgICB2YWx1ZTogTWF0aC5hYnModC55KVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmNsYXNzIGVtIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IFwic3dpcGVcIiwgaSA9IHt9KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2V2ZW50ID0gZSwgdGhpcy5zd2lwZSA9IG5ldyB0bSh0LCBpKSwgdGhpcy5fdG91Y2hTdGFydEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0LmJpbmQodGhpcyksIHRoaXMuX3RvdWNoTW92ZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVUb3VjaE1vdmUuYmluZCh0aGlzKSwgdGhpcy5fdG91Y2hFbmRIYW5kbGVyID0gdGhpcy5faGFuZGxlVG91Y2hFbmQuYmluZCh0aGlzKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fdG91Y2hTdGFydEhhbmRsZXIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fdG91Y2hFbmRIYW5kbGVyKTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQodClcbiAgICApLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVRvdWNoTW92ZSh0KVxuICAgICksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgKHQpID0+IHRoaXMuX2hhbmRsZVRvdWNoRW5kKHQpKTtcbiAgfVxuICBfaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgdGhpc1t0aGlzLl9ldmVudF0uaGFuZGxlVG91Y2hTdGFydCh0KTtcbiAgfVxuICBfaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaE1vdmUodCk7XG4gIH1cbiAgX2hhbmRsZVRvdWNoRW5kKHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaEVuZCh0KTtcbiAgfVxufVxuY29uc3QgX2EgPSBcInNpZGVuYXZcIiwgaHMgPSBcInRlLnNpZGVuYXZcIiwgaW0gPSBcImRhdGEtdGUtc2lkZW5hdi1yb3RhdGUtaWNvbi1yZWZcIiwgUm4gPSBcIltkYXRhLXRlLXNpZGVuYXYtdG9nZ2xlLXJlZl1cIiwgc20gPSBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsIG5tID0gJ1tkYXRhLXRlLXNpZGVuYXYtc2xpbT1cInRydWVcIl0nLCBvbSA9ICdbZGF0YS10ZS1zaWRlbmF2LXNsaW09XCJmYWxzZVwiXScsIHJtID0gXCJbZGF0YS10ZS1zaWRlbmF2LW1lbnUtcmVmXVwiLCBrZSA9IFwiW2RhdGEtdGUtc2lkZW5hdi1jb2xsYXBzZS1yZWZdXCIsIGxpID0gXCJbZGF0YS10ZS1zaWRlbmF2LWxpbmstcmVmXVwiLCBhbSA9IEYoKSA/IDEwMCA6IC0xMDAsIGxtID0gRigpID8gLTEwMCA6IDEwMCwgY20gPSB7XG4gIHNpZGVuYXZBY2NvcmRpb246IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZCYWNrZHJvcDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkJhY2tkcm9wQ2xhc3M6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBzaWRlbmF2Q2xvc2VPbkVzYzogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkNvbG9yOiBcIihzdHJpbmcpXCIsXG4gIHNpZGVuYXZDb250ZW50OiBcIihudWxsfHN0cmluZylcIixcbiAgc2lkZW5hdkV4cGFuZGFibGU6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZFeHBhbmRPbkhvdmVyOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2Rm9jdXNUcmFwOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2SGlkZGVuOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2TW9kZTogXCIoc3RyaW5nKVwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyOiBcIihudWxsfHN0cmluZ3xudW1iZXIpXCIsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGU6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaDogXCIobnVsbHxzdHJpbmd8bnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludFNtOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50TWQ6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnRMZzogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludFhsOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50MnhsOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZTY3JvbGxDb250YWluZXI6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBzaWRlbmF2U2xpbTogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdlNsaW1Db2xsYXBzZWQ6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZTbGltV2lkdGg6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdlBvc2l0aW9uOiBcIihzdHJpbmcpXCIsXG4gIHNpZGVuYXZSaWdodDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbjogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2V2lkdGg6IFwiKG51bWJlcilcIlxufSwgaG0gPSB7XG4gIHNpZGVuYXZBY2NvcmRpb246ICExLFxuICBzaWRlbmF2QmFja2Ryb3A6ICEwLFxuICBzaWRlbmF2QmFja2Ryb3BDbGFzczogbnVsbCxcbiAgc2lkZW5hdkNsb3NlT25Fc2M6ICEwLFxuICBzaWRlbmF2Q29sb3I6IFwicHJpbWFyeVwiLFxuICBzaWRlbmF2Q29udGVudDogbnVsbCxcbiAgc2lkZW5hdkV4cGFuZGFibGU6ICEwLFxuICBzaWRlbmF2RXhwYW5kT25Ib3ZlcjogITEsXG4gIHNpZGVuYXZGb2N1c1RyYXA6ICEwLFxuICBzaWRlbmF2SGlkZGVuOiAhMCxcbiAgc2lkZW5hdk1vZGU6IFwib3ZlclwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyOiBudWxsLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlOiBudWxsLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoOiBudWxsLFxuICBzaWRlbmF2QnJlYWtwb2ludFNtOiA2NDAsXG4gIHNpZGVuYXZCcmVha3BvaW50TWQ6IDc2OCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRMZzogMTAyNCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRYbDogMTI4MCxcbiAgc2lkZW5hdkJyZWFrcG9pbnQyeGw6IDE1MzYsXG4gIHNpZGVuYXZTY3JvbGxDb250YWluZXI6IG51bGwsXG4gIHNpZGVuYXZTbGltOiAhMSxcbiAgc2lkZW5hdlNsaW1Db2xsYXBzZWQ6ICExLFxuICBzaWRlbmF2U2xpbVdpZHRoOiA3NyxcbiAgc2lkZW5hdlBvc2l0aW9uOiBcImZpeGVkXCIsXG4gIHNpZGVuYXZSaWdodDogITEsXG4gIHNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb246IDMwMCxcbiAgc2lkZW5hdldpZHRoOiAyNDBcbn07XG5jbGFzcyBwaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIEF0KHRoaXMsIFwiX2FkZEJhY2tkcm9wT25Jbml0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuX29wdGlvbnMuc2lkZW5hdkhpZGRlbiB8fCAodGhpcy5fYmFja2Ryb3Auc2hvdygpLCBoLm9mZih0aGlzLl9lbGVtZW50LCBcInRyYW5zaXRpb25lbmRcIiwgdGhpcy5fYWRkQmFja2Ryb3BPbkluaXQpKTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IGUsIHRoaXMuX0lEID0gYnQoXCJcIiksIHRoaXMuX2NvbnRlbnQgPSBudWxsLCB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlID0gbnVsbCwgdGhpcy5fc2xpbUNvbGxhcHNlZCA9ICExLCB0aGlzLl9hY3RpdmVOb2RlID0gbnVsbCwgdGhpcy5fdGVtcFNsaW0gPSAhMSwgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKSwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG51bGwsIHRoaXMuX3RvdWNoID0gbnVsbCwgdGhpcy5fc2V0TW9kZUZyb21CcmVha3BvaW50cygpLCB0aGlzLmVzY0hhbmRsZXIgPSAoaSkgPT4ge1xuICAgICAgaS5rZXlDb2RlID09PSBMaSAmJiB0aGlzLnRvZ2dsZXIgJiYgTHQodGhpcy50b2dnbGVyKSAmJiAodGhpcy5fdXBkYXRlKCExKSwgaC5vZmYod2luZG93LCBcImtleWRvd25cIiwgdGhpcy5lc2NIYW5kbGVyKSk7XG4gICAgfSwgdGhpcy5oYXNoSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKCk7XG4gICAgfSwgdCAmJiAoSS5zZXREYXRhKHQsIGhzLCB0aGlzKSwgdGhpcy5fc2V0dXAoKSksIHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgIXRoaXMub3B0aW9ucy5zaWRlbmF2SGlkZGVuICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgaC5vbih0aGlzLl9lbGVtZW50LCBcInRyYW5zaXRpb25lbmRcIiwgdGhpcy5fYWRkQmFja2Ryb3BPbkluaXQpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gX2E7XG4gIH1cbiAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbiA9PT0gXCJmaXhlZFwiKVxuICAgICAgcmV0dXJuIGQuZmluZE9uZShcImJvZHlcIik7XG4gICAgY29uc3QgdCA9IChlKSA9PiAhZS5wYXJlbnROb2RlIHx8IGUucGFyZW50Tm9kZSA9PT0gZG9jdW1lbnQgPyBlIDogZS5wYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgZS5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucyhcInJlbGF0aXZlXCIpID8gZS5wYXJlbnROb2RlIDogdChlLnBhcmVudE5vZGUpO1xuICAgIHJldHVybiB0KHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgbGV0IHQgPSAwLCBlID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24gIT09IFwiZml4ZWRcIikge1xuICAgICAgY29uc3QgbiA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdCA9IG4ueCwgZSA9IG4ueCArIG4ud2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IHsgeDogaSB9ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodCA/IE1hdGguYWJzKGkgLSBlKSA+IDEwIDogTWF0aC5hYnMoaSAtIHQpIDwgMTA7XG4gIH1cbiAgZ2V0IGxpbmtzKCkge1xuICAgIHJldHVybiBkLmZpbmQobGksIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBuYXZpZ2F0aW9uKCkge1xuICAgIHJldHVybiBkLmZpbmQocm0sIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICAuLi5obSxcbiAgICAgIC4uLmMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50aGlzLl9vcHRpb25zXG4gICAgfTtcbiAgICByZXR1cm4gTChfYSwgdCwgY20pLCB0O1xuICB9XG4gIGdldCBzaWRlbmF2U3R5bGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBgJHt0aGlzLndpZHRofXB4YCxcbiAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gXCIxMDB2aFwiIDogXCIxMDAlXCIsXG4gICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbixcbiAgICAgIHRyYW5zaXRpb246IGBhbGwgJHt0aGlzLnRyYW5zaXRpb25EdXJhdGlvbn0gbGluZWFyYFxuICAgIH07XG4gIH1cbiAgZ2V0IHRvZ2dsZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZChSbikuZmluZChcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSBjLmdldERhdGFBdHRyaWJ1dGUoZSwgXCJ0YXJnZXRcIik7XG4gICAgICAgIHJldHVybiBkLmZpbmRPbmUoaSkgPT09IHRoaXMuX2VsZW1lbnQ7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXQgdHJhbnNpdGlvbkR1cmF0aW9uKCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbiAvIDFlM31zYDtcbiAgfVxuICBnZXQgdHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQgPyBsbSA6IGFtO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2xpbUNvbGxhcHNlZCA/IHRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbVdpZHRoIDogdGhpcy5vcHRpb25zLnNpZGVuYXZXaWR0aDtcbiAgfVxuICBnZXQgaXNCYWNrZHJvcFZpc2libGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fYmFja2Ryb3AuX2VsZW1lbnQ7XG4gIH1cbiAgLy8gUHVibGljXG4gIGNoYW5nZU1vZGUodCkge1xuICAgIHRoaXMuX3NldE1vZGUodCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBoLm9mZih3aW5kb3csIFwia2V5ZG93blwiLCB0aGlzLmVzY0hhbmRsZXIpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wICYmIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKSwgaC5vZmYod2luZG93LCBcImhhc2hjaGFuZ2VcIiwgdGhpcy5oYXNoSGFuZGxlciksIHRoaXMuX3RvdWNoLmRpc3Bvc2UoKSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGhzKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLl9lbWl0RXZlbnRzKCExKSwgdGhpcy5fdXBkYXRlKCExKSwgdGhpcy5fb3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgdGhpcy5pc0JhY2tkcm9wVmlzaWJsZSAmJiB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICB0aGlzLl9lbWl0RXZlbnRzKCEwKSwgdGhpcy5fdXBkYXRlKCEwKSwgdGhpcy5fb3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgdGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fYmFja2Ryb3Auc2hvdygpO1xuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLl9lbWl0RXZlbnRzKCF0aGlzLmlzVmlzaWJsZSksIHRoaXMuX3VwZGF0ZSghdGhpcy5pc1Zpc2libGUpO1xuICB9XG4gIHRvZ2dsZVNsaW0oKSB7XG4gICAgdGhpcy5fc2V0U2xpbSghdGhpcy5fc2xpbUNvbGxhcHNlZCk7XG4gIH1cbiAgdXBkYXRlKHQpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdCwgdGhpcy5fc2V0dXAoKTtcbiAgfVxuICBnZXRCcmVha3BvaW50KHQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtQnJlYWtwb2ludFZhbHVlc1RvT2JqZWN0KClbdF07XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8IChoLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBSbixcbiAgICAgIHBpLnRvZ2dsZVNpZGVuYXYoKVxuICAgICksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX3RyYW5zZm9ybUJyZWFrcG9pbnRWYWx1ZXNUb09iamVjdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc206IHRoaXMub3B0aW9ucy5zaWRlbmF2QnJlYWtwb2ludFNtLFxuICAgICAgbWQ6IHRoaXMub3B0aW9ucy5zaWRlbmF2QnJlYWtwb2ludE1kLFxuICAgICAgbGc6IHRoaXMub3B0aW9ucy5zaWRlbmF2QnJlYWtwb2ludExnLFxuICAgICAgeGw6IHRoaXMub3B0aW9ucy5zaWRlbmF2QnJlYWtwb2ludFhsLFxuICAgICAgXCIyeGxcIjogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50MnhsXG4gICAgfTtcbiAgfVxuICBfc2V0TW9kZUZyb21CcmVha3BvaW50cygpIHtcbiAgICBjb25zdCB0ID0gd2luZG93LmlubmVyV2lkdGgsIGUgPSB0aGlzLl90cmFuc2Zvcm1CcmVha3BvaW50VmFsdWVzVG9PYmplY3QoKTtcbiAgICBpZiAodCA9PT0gdm9pZCAwIHx8ICFlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXIgPT0gXCJudW1iZXJcIiA/IHQgLSB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50T3ZlciA6IHQgLSBlW3RoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyXSwgbiA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZSA9PSBcIm51bWJlclwiID8gdCAtIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlIDogdCAtIGVbdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGVdLCBvID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoID09IFwibnVtYmVyXCIgPyB0IC0gdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2ggOiB0IC0gZVt0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaF0sIHIgPSAobCwgcCkgPT4gbCAtIHAgPCAwID8gLTEgOiBwIC0gbCA8IDAgPyAxIDogMCwgYSA9IFtpLCBuLCBvXS5maWx0ZXIoKGwpID0+IGwgIT0gbnVsbCAmJiBsID49IDApLnNvcnQocilbMF07XG4gICAgaSA+IDAgJiYgaSA9PT0gYSA/ICh0aGlzLl9vcHRpb25zLnNpZGVuYXZNb2RlID0gXCJvdmVyXCIsIHRoaXMuX29wdGlvbnMuc2lkZW5hdkhpZGRlbiA9ICEwKSA6IG4gPiAwICYmIG4gPT09IGEgPyB0aGlzLl9vcHRpb25zLnNpZGVuYXZNb2RlID0gXCJzaWRlXCIgOiBvID4gMCAmJiBvID09PSBhICYmICh0aGlzLl9vcHRpb25zLnNpZGVuYXZNb2RlID0gXCJwdXNoXCIpO1xuICB9XG4gIF9jb2xsYXBzZUl0ZW1zKCkge1xuICAgIHRoaXMubmF2aWdhdGlvbi5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBkLmZpbmQoa2UsIHQpLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgcXQuZ2V0SW5zdGFuY2UoaSkuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2dldE9mZnNldFZhbHVlKHQsIHsgaW5kZXg6IGUsIHByb3BlcnR5OiBpLCBvZmZzZXRzOiBuIH0pIHtcbiAgICBjb25zdCBvID0gdGhpcy5fZ2V0UHhWYWx1ZShcbiAgICAgIHRoaXMuX2luaXRpYWxDb250ZW50U3R5bGVbZV1bbltpXS5wcm9wZXJ0eV1cbiAgICApLCByID0gdCA/IG5baV0udmFsdWUgOiAwO1xuICAgIHJldHVybiBvICsgcjtcbiAgfVxuICBfZ2V0UHJvcGVydHkoLi4udCkge1xuICAgIHJldHVybiB0Lm1hcCgoZSwgaSkgPT4gaSA9PT0gMCA/IGUgOiBlWzBdLnRvVXBwZXJDYXNlKCkuY29uY2F0KGUuc2xpY2UoMSkpKS5qb2luKFwiXCIpO1xuICB9XG4gIF9nZXRQeFZhbHVlKHQpIHtcbiAgICByZXR1cm4gdCA/IHBhcnNlRmxvYXQodCkgOiAwO1xuICB9XG4gIF9oYW5kbGVTd2lwZSh0LCBlKSB7XG4gICAgZSAmJiB0aGlzLl9zbGltQ29sbGFwc2VkICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbSAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdkV4cGFuZGFibGUgPyB0aGlzLnRvZ2dsZVNsaW0oKSA6IGUgfHwgKHRoaXMuX3NsaW1Db2xsYXBzZWQgfHwgIXRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbSB8fCAhdGhpcy5vcHRpb25zLnNpZGVuYXZFeHBhbmRhYmxlID8gdGhpcy50b2dnbGVyICYmIEx0KHRoaXMudG9nZ2xlcikgJiYgdGhpcy50b2dnbGUoKSA6IHRoaXMudG9nZ2xlU2xpbSgpKTtcbiAgfVxuICBfaXNBY3RpdmUodCwgZSkge1xuICAgIHJldHVybiBlID8gZSA9PT0gdCA6IHQuYXR0cmlidXRlcy5ocmVmID8gbmV3IFVSTCh0LCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZiA9PT0gd2luZG93LmxvY2F0aW9uLmhyZWYgOiAhMTtcbiAgfVxuICBfaXNBbGxUb0JlQ29sbGFwc2VkKCkge1xuICAgIHJldHVybiBkLmZpbmQoXG4gICAgICBzbSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLmZpbHRlcihcbiAgICAgIChpKSA9PiBpLmdldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIikgPT09IFwidHJ1ZVwiXG4gICAgKS5sZW5ndGggPT09IDA7XG4gIH1cbiAgX2lzQWxsQ29sbGFwc2VkKCkge1xuICAgIHJldHVybiBkLmZpbmQoa2UsIHRoaXMuX2VsZW1lbnQpLmZpbHRlcihcbiAgICAgICh0KSA9PiBMdCh0KVxuICAgICkubGVuZ3RoID09PSAwO1xuICB9XG4gIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wQ2xhc3MgPyB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wQ2xhc3Muc3BsaXQoXCIgXCIpIDogdGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbiA/IFtcbiAgICAgIFwib3BhY2l0eS01MFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uLWFsbFwiLFxuICAgICAgXCJkdXJhdGlvbi0zMDBcIixcbiAgICAgIFwiZWFzZS1pbi1vdXRcIixcbiAgICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24sXG4gICAgICBcInRvcC0wXCIsXG4gICAgICBcImxlZnQtMFwiLFxuICAgICAgXCJ6LTUwXCIsXG4gICAgICBcImJnLWJsYWNrLzEwXCIsXG4gICAgICBcImRhcms6YmctYmxhY2stNjBcIixcbiAgICAgIFwidy1mdWxsXCIsXG4gICAgICBcImgtZnVsbFwiLFxuICAgICAgdGhpcy5fZWxlbWVudC5pZFxuICAgIF0gOiBudWxsO1xuICAgIHJldHVybiBuZXcgU28oe1xuICAgICAgaXNWaXNpYmxlOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wLFxuICAgICAgaXNBbmltYXRlZDogITAsXG4gICAgICByb290RWxlbWVudDogdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgYmFja2Ryb3BDbGFzc2VzOiB0LFxuICAgICAgY2xpY2tDYWxsYmFjazogKCkgPT4gdGhpcy5oaWRlKClcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlQmFja2Ryb3AodCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiKSB7XG4gICAgICB0ID8gdGhpcy5fYmFja2Ryb3Auc2hvdygpIDogdGhpcy5pc0JhY2tkcm9wVmlzaWJsZSAmJiB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNCYWNrZHJvcFZpc2libGUgJiYgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xuICB9XG4gIF9zZXR1cCgpIHtcbiAgICB0aGlzLl9zZXR1cFRvdWNoKCksIHRoaXMub3B0aW9ucy5zaWRlbmF2Rm9jdXNUcmFwICYmIHRoaXMuX3NldHVwRm9jdXNUcmFwKCksIHRoaXMuX3NldHVwQ29sbGFwc2UoKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltICYmIHRoaXMuX3NldHVwU2xpbSgpLCB0aGlzLl9zZXR1cEluaXRpYWxTdHlsaW5nKCksIHRoaXMuX3NldHVwU2Nyb2xsaW5nKCksIHRoaXMub3B0aW9ucy5zaWRlbmF2Q29udGVudCAmJiB0aGlzLl9zZXR1cENvbnRlbnQoKSwgdGhpcy5fc2V0dXBBY3RpdmVTdGF0ZSgpLCB0aGlzLl9zZXR1cFJpcHBsZUVmZmVjdCgpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkhpZGRlbiB8fCB0aGlzLl91cGRhdGVPZmZzZXRzKCEwLCAhMCksIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fc2V0VGFiaW5kZXgoITApO1xuICB9XG4gIF9zZXR1cEFjdGl2ZVN0YXRlKCkge1xuICAgIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKCksIHRoaXMubGlua3MuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgaC5vbih0LCBcImNsaWNrXCIsICgpID0+IHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKHQpKSwgaC5vbih0LCBcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgZS5rZXlDb2RlID09PSBsdCAmJiB0aGlzLl9zZXRBY3RpdmVFbGVtZW50cyh0KTtcbiAgICAgIH0pO1xuICAgIH0pLCBoLm9uKHdpbmRvdywgXCJoYXNoY2hhbmdlXCIsIHRoaXMuaGFzaEhhbmRsZXIpO1xuICB9XG4gIF9zZXR1cENvbGxhcHNlKCkge1xuICAgIHRoaXMubmF2aWdhdGlvbi5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBkLmZpbmQoa2UsIHQpLmZvckVhY2goXG4gICAgICAgIChuLCBvKSA9PiB0aGlzLl9zZXR1cENvbGxhcHNlTGlzdCh7IGxpc3Q6IG4sIGluZGV4OiBvLCBtZW51OiB0LCBtZW51SW5kZXg6IGUgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgX2dlbmVyYXRlQ29sbHBhc2VJRCh0LCBlKSB7XG4gICAgcmV0dXJuIGBzaWRlbmF2LWNvbGxhcHNlLSR7dGhpcy5fSUR9LSR7ZX0tJHt0fWA7XG4gIH1cbiAgX3NldHVwQ29sbGFwc2VMaXN0KHsgbGlzdDogdCwgaW5kZXg6IGUsIG1lbnU6IGksIG1lbnVJbmRleDogbiB9KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuX2dlbmVyYXRlQ29sbHBhc2VJRChlLCBuKTtcbiAgICB0LnNldEF0dHJpYnV0ZShcImlkXCIsIG8pLCB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtY29sbGFwc2UtaXRlbVwiLCBcIlwiKTtcbiAgICBjb25zdCBbcl0gPSBkLnByZXYodCwgbGkpO1xuICAgIGMuc2V0RGF0YUF0dHJpYnV0ZShyLCBcImNvbGxhcHNlLWluaXRcIiwgXCJcIiksIHIuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7b31gKSwgci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiYnV0dG9uXCIpO1xuICAgIGNvbnN0IGEgPSBxdC5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgcXQodCwge1xuICAgICAgdG9nZ2xlOiAhMSxcbiAgICAgIHBhcmVudDogdGhpcy5vcHRpb25zLnNpZGVuYXZBY2NvcmRpb24gPyBpIDogdFxuICAgIH0pO1xuICAgICh0LmRhdGFzZXQudGVTaWRlbmF2U3RhdGVTaG93ID09PSBcIlwiIHx8IHQuZGF0YXNldC50ZUNvbGxhcHNlU2hvdyA9PT0gXCJcIikgJiYgdGhpcy5fcm90YXRlQXJyb3cociwgITEpLCBoLm9uKHIsIFwiY2xpY2tcIiwgKGwpID0+IHtcbiAgICAgIHRoaXMuX3RvZ2dsZUNhdGVnb3J5KGwsIGEsIHQpLCB0aGlzLl90ZW1wU2xpbSAmJiB0aGlzLl9pc0FsbFRvQmVDb2xsYXBzZWQoKSAmJiAodGhpcy5fc2V0U2xpbSghMCksIHRoaXMuX3RlbXBTbGltID0gITEpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMuX2ZvY3VzVHJhcCAmJiB0aGlzLl9mb2N1c1RyYXAudXBkYXRlKCk7XG4gICAgfSksIGgub24oXG4gICAgICB0LFxuICAgICAgXCJzaG93LnRlLmNvbGxhcHNlXCIsXG4gICAgICAoKSA9PiB0aGlzLl9yb3RhdGVBcnJvdyhyLCAhMSlcbiAgICApLCBoLm9uKFxuICAgICAgdCxcbiAgICAgIFwiaGlkZS50ZS5jb2xsYXBzZVwiLFxuICAgICAgKCkgPT4gdGhpcy5fcm90YXRlQXJyb3cociwgITApXG4gICAgKSwgaC5vbih0LCBcInNob3duLnRlLmNvbGxhcHNlXCIsICgpID0+IHtcbiAgICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcC51cGRhdGUoKTtcbiAgICB9KSwgaC5vbih0LCBcImhpZGRlbi50ZS5jb2xsYXBzZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl90ZW1wU2xpbSAmJiB0aGlzLl9pc0FsbENvbGxhcHNlZCgpICYmICh0aGlzLl9zZXRTbGltKCEwKSwgdGhpcy5fdGVtcFNsaW0gPSAhMSksIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcC51cGRhdGUoKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBDb250ZW50KCkge1xuICAgIHRoaXMuX2NvbnRlbnQgPSBkLmZpbmQodGhpcy5vcHRpb25zLnNpZGVuYXZDb250ZW50KSwgdGhpcy5fY29udGVudC5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gW1xuICAgICAgICBcIiFwXCIsXG4gICAgICAgIFwiIW1cIixcbiAgICAgICAgXCIhcHhcIixcbiAgICAgICAgXCIhcGxcIixcbiAgICAgICAgXCIhcHJcIixcbiAgICAgICAgXCIhbXhcIixcbiAgICAgICAgXCIhbWxcIixcbiAgICAgICAgXCIhbXJcIixcbiAgICAgICAgXCIhLXBcIixcbiAgICAgICAgXCIhLW1cIixcbiAgICAgICAgXCIhLXB4XCIsXG4gICAgICAgIFwiIS1wbFwiLFxuICAgICAgICBcIiEtcHJcIixcbiAgICAgICAgXCIhLW14XCIsXG4gICAgICAgIFwiIS1tbFwiLFxuICAgICAgICBcIiEtbXJcIlxuICAgICAgXTtcbiAgICAgIFsuLi50LmNsYXNzTGlzdF0uZmlsdGVyKFxuICAgICAgICAobikgPT4gZS5maW5kSW5kZXgoKG8pID0+IG4uaW5jbHVkZXMobykpID49IDBcbiAgICAgICkuZm9yRWFjaCgobikgPT4gdC5jbGFzc0xpc3QucmVtb3ZlKG4pKTtcbiAgICB9KSwgdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZSA9IHRoaXMuX2NvbnRlbnQubWFwKCh0KSA9PiB7XG4gICAgICBjb25zdCB7IHBhZGRpbmdMZWZ0OiBlLCBwYWRkaW5nUmlnaHQ6IGksIG1hcmdpbkxlZnQ6IG4sIG1hcmdpblJpZ2h0OiBvLCB0cmFuc2l0aW9uOiByIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KTtcbiAgICAgIHJldHVybiB7IHBhZGRpbmdMZWZ0OiBlLCBwYWRkaW5nUmlnaHQ6IGksIG1hcmdpbkxlZnQ6IG4sIG1hcmdpblJpZ2h0OiBvLCB0cmFuc2l0aW9uOiByIH07XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwRm9jdXNUcmFwKCkge1xuICAgIHRoaXMuX2ZvY3VzVHJhcCA9IG5ldyAkaShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICB7XG4gICAgICAgIGV2ZW50OiBcImtleWRvd25cIixcbiAgICAgICAgY29uZGl0aW9uOiAodCkgPT4gdC5rZXlDb2RlID09PSBPaSxcbiAgICAgICAgb25seVZpc2libGU6ICEwXG4gICAgICB9LFxuICAgICAgdGhpcy50b2dnbGVyXG4gICAgKTtcbiAgfVxuICBfc2V0dXBJbml0aWFsU3R5bGluZygpIHtcbiAgICB0aGlzLl9zZXRDb2xvcigpLCBjLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHRoaXMuc2lkZW5hdlN0eWxlKTtcbiAgfVxuICBfc2V0dXBTY3JvbGxpbmcoKSB7XG4gICAgbGV0IHQgPSB0aGlzLl9lbGVtZW50O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lkZW5hdlNjcm9sbENvbnRhaW5lcikge1xuICAgICAgdCA9IGQuZmluZE9uZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZTY3JvbGxDb250YWluZXIsXG4gICAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICAgICk7XG4gICAgICBjb25zdCBpID0gVmModC5wYXJlbnROb2RlLmNoaWxkcmVuKS5maWx0ZXIoXG4gICAgICAgIChuKSA9PiBuICE9PSB0XG4gICAgICApLnJlZHVjZSgobiwgbykgPT4gbiArIG8uY2xpZW50SGVpZ2h0LCAwKTtcbiAgICAgIGMuc3R5bGUodCwge1xuICAgICAgICBtYXhIZWlnaHQ6IGBjYWxjKDEwMCUgLSAke2l9cHgpYCxcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIgPSBuZXcgeWModCwge1xuICAgICAgc3VwcHJlc3NTY3JvbGxYOiAhMCxcbiAgICAgIGhhbmRsZXJzOiBbXCJjbGljay1yYWlsXCIsIFwiZHJhZy10aHVtYlwiLCBcIndoZWVsXCIsIFwidG91Y2hcIl1cbiAgICB9KTtcbiAgfVxuICBfc2V0dXBTbGltKCkge1xuICAgIHRoaXMuX3NsaW1Db2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW1Db2xsYXBzZWQsIHRoaXMuX3RvZ2dsZVNsaW1EaXNwbGF5KHRoaXMuX3NsaW1Db2xsYXBzZWQpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkV4cGFuZE9uSG92ZXIgJiYgKHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2xpbUNvbGxhcHNlZCAmJiB0aGlzLl9zZXRTbGltKCExKTtcbiAgICB9KSwgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zbGltQ29sbGFwc2VkIHx8IHRoaXMuX3NldFNsaW0oITApO1xuICAgIH0pKTtcbiAgfVxuICBfc2V0dXBSaXBwbGVFZmZlY3QoKSB7XG4gICAgdGhpcy5saW5rcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBsZXQgZSA9IFVlLmdldEluc3RhbmNlKHQpLCBpID0gdGhpcy5vcHRpb25zLnNpZGVuYXZDb2xvcjtcbiAgICAgIGlmIChlICYmIGUuX29wdGlvbnMuc2lkZW5hdkNvbG9yICE9PSB0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbG9yKVxuICAgICAgICBlLmRpc3Bvc2UoKTtcbiAgICAgIGVsc2UgaWYgKGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIChsb2NhbFN0b3JhZ2UudGhlbWUgPT09IFwiZGFya1wiIHx8ICEoXCJ0aGVtZVwiIGluIGxvY2FsU3RvcmFnZSkgJiYgd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIpLm1hdGNoZXMpICYmIChpID0gXCJ3aGl0ZVwiKSwgZSA9IG5ldyBVZSh0LCB7IHJpcHBsZUNvbG9yOiBpIH0pO1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cFRvdWNoKCkge1xuICAgIHRoaXMuX3RvdWNoID0gbmV3IGVtKHRoaXMuX2VsZW1lbnQsIFwic3dpcGVcIiwgeyB0aHJlc2hvbGQ6IDIwIH0pLCB0aGlzLl90b3VjaC5pbml0KCksIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJzd2lwZWxlZnRcIixcbiAgICAgICh0KSA9PiB0aGlzLl9oYW5kbGVTd2lwZSh0LCB0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0KVxuICAgICksIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJzd2lwZXJpZ2h0XCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlU3dpcGUodCwgIXRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQpXG4gICAgKTtcbiAgfVxuICBfc2V0QWN0aXZlKHQsIGUpIHtcbiAgICB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZWJhci1zdGF0ZS1hY3RpdmVcIiwgXCJcIiksIHRoaXMuX2FjdGl2ZU5vZGUgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLXNpZGViYXItc3RhdGUtYWN0aXZlXCIpLCB0aGlzLl9hY3RpdmVOb2RlID0gdDtcbiAgICBjb25zdCBbaV0gPSBkLnBhcmVudHMoXG4gICAgICB0aGlzLl9hY3RpdmVOb2RlLFxuICAgICAga2VcbiAgICApO1xuICAgIGlmICghaSkge1xuICAgICAgdGhpcy5fc2V0QWN0aXZlQ2F0ZWdvcnkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW25dID0gZC5wcmV2KGksIGxpKTtcbiAgICB0aGlzLl9zZXRBY3RpdmVDYXRlZ29yeShuKSwgIWUgJiYgIXRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgcXQuZ2V0SW5zdGFuY2UoaSkuc2hvdygpO1xuICB9XG4gIF9zZXRBY3RpdmVDYXRlZ29yeSh0KSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGQuZmluZChrZSwgZSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBjb25zdCBbb10gPSBkLnByZXYobiwgbGkpO1xuICAgICAgICBvICE9PSB0ID8gby5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLXNpZGVuYXYtc3RhdGUtYWN0aXZlXCIpIDogby5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNpZGVuYXYtc3RhdGUtYWN0aXZlXCIsIFwiXCIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldEFjdGl2ZUVsZW1lbnRzKHQpIHtcbiAgICB0aGlzLm5hdmlnYXRpb24uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZC5maW5kKGxpLCBlKS5maWx0ZXIoKG4pID0+IGQubmV4dChuLCBrZSkubGVuZ3RoID09PSAwKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzQWN0aXZlKG4sIHQpICYmIG4gIT09IHRoaXMuX2FjdGl2ZU5vZGUgJiYgdGhpcy5fc2V0QWN0aXZlKG4sIHQpO1xuICAgICAgfSk7XG4gICAgfSksIHQgJiYgdGhpcy5fdXBkYXRlRm9jdXModGhpcy5pc1Zpc2libGUpO1xuICB9XG4gIF9zZXRDb2xvcigpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgXCJwcmltYXJ5XCIsXG4gICAgICBcInNlY29uZGFyeVwiLFxuICAgICAgXCJzdWNjZXNzXCIsXG4gICAgICBcImluZm9cIixcbiAgICAgIFwid2FybmluZ1wiLFxuICAgICAgXCJkYW5nZXJcIixcbiAgICAgIFwibGlnaHRcIixcbiAgICAgIFwiZGFya1wiXG4gICAgXSwgeyBzaWRlbmF2Q29sb3I6IGUgfSA9IHRoaXMub3B0aW9ucywgaSA9IHQuaW5jbHVkZXMoZSkgPyBlIDogXCJwcmltYXJ5XCI7XG4gICAgdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoYHNpZGVuYXYtJHtufWApO1xuICAgIH0pLCBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIGBzaWRlbmF2LSR7aX1gKTtcbiAgfVxuICBfc2V0Q29udGVudE9mZnNldHModCwgZSwgaSkge1xuICAgIHRoaXMuX2NvbnRlbnQuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgY29uc3QgciA9IHRoaXMuX2dldE9mZnNldFZhbHVlKHQsIHtcbiAgICAgICAgaW5kZXg6IG8sXG4gICAgICAgIHByb3BlcnR5OiBcInBhZGRpbmdcIixcbiAgICAgICAgb2Zmc2V0czogZVxuICAgICAgfSksIGEgPSB0aGlzLl9nZXRPZmZzZXRWYWx1ZSh0LCB7XG4gICAgICAgIGluZGV4OiBvLFxuICAgICAgICBwcm9wZXJ0eTogXCJtYXJnaW5cIixcbiAgICAgICAgb2Zmc2V0czogZVxuICAgICAgfSksIGwgPSB7fTtcbiAgICAgIGlmIChpIHx8IChsLnRyYW5zaXRpb24gPSBgYWxsICR7dGhpcy50cmFuc2l0aW9uRHVyYXRpb259IGxpbmVhcmApLCBsW2UucGFkZGluZy5wcm9wZXJ0eV0gPSBgJHtyfXB4YCwgbFtlLm1hcmdpbi5wcm9wZXJ0eV0gPSBgJHthfXB4YCwgYy5zdHlsZShuLCBsKSwgISF0KSB7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgYy5zdHlsZShuLCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlW29dLnRyYW5zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaC5vbihuLCBcInRyYW5zaXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgICAgIGMuc3R5bGUobiwge1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZVtvXS50cmFuc2l0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9zZXRNb2RlKHQpIHtcbiAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgIT09IHQgJiYgKHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSB0LCB0aGlzLl91cGRhdGUodGhpcy5pc1Zpc2libGUpKTtcbiAgfVxuICBfc2V0U2xpbSh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyBbXCJjb2xsYXBzZVwiLCBcImNvbGxhcHNlZFwiXSA6IFtcImV4cGFuZFwiLCBcImV4cGFuZGVkXCJdO1xuICAgIHRoaXMuX3RyaWdnZXJFdmVudHMoLi4uZSksIHQgJiYgdGhpcy5fY29sbGFwc2VJdGVtcygpLCB0aGlzLl9zbGltQ29sbGFwc2VkID0gdCwgdGhpcy5fdG9nZ2xlU2xpbURpc3BsYXkodCksIGMuc3R5bGUodGhpcy5fZWxlbWVudCwgeyB3aWR0aDogYCR7dGhpcy53aWR0aH1weGAgfSksIHRoaXMuX3VwZGF0ZU9mZnNldHModGhpcy5pc1Zpc2libGUpO1xuICB9XG4gIF9zZXRUYWJpbmRleCh0KSB7XG4gICAgdGhpcy5saW5rcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBlLnRhYkluZGV4ID0gdCA/IDAgOiAtMTtcbiAgICB9KTtcbiAgfVxuICBfZW1pdEV2ZW50cyh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyBbXCJzaG93XCIsIFwic2hvd25cIl0gOiBbXCJoaWRlXCIsIFwiaGlkZGVuXCJdO1xuICAgIHRoaXMuX3RyaWdnZXJFdmVudHMoLi4uZSk7XG4gIH1cbiAgX3JvdGF0ZUFycm93KHQsIGUpIHtcbiAgICBjb25zdCBbaV0gPSBkLmNoaWxkcmVuKHQsIGBbJHtpbX1dYCk7XG4gICAgaSAmJiAoZSA/IGMucmVtb3ZlQ2xhc3MoaSwgXCJyb3RhdGUtMTgwXCIpIDogYy5hZGRDbGFzcyhpLCBcInJvdGF0ZS0xODBcIikpO1xuICB9XG4gIF90b2dnbGVDYXRlZ29yeSh0LCBlKSB7XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpLCBlLnRvZ2dsZSgpLCB0aGlzLl9zbGltQ29sbGFwc2VkICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kYWJsZSAmJiAodGhpcy5fdGVtcFNsaW0gPSAhMCwgdGhpcy5fc2V0U2xpbSghMSkpO1xuICB9XG4gIF90b2dnbGVTbGltRGlzcGxheSh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZChcbiAgICAgIG5tLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGkgPSBkLmZpbmQoXG4gICAgICBvbSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBuID0gKCkgPT4ge1xuICAgICAgZS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIGMuc3R5bGUobywge1xuICAgICAgICAgIGRpc3BsYXk6IHRoaXMuX3NsaW1Db2xsYXBzZWQgPyBcInVuc2V0XCIgOiBcIm5vbmVcIlxuICAgICAgICB9KTtcbiAgICAgIH0pLCBpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgYy5zdHlsZShvLCB7XG4gICAgICAgICAgZGlzcGxheTogdGhpcy5fc2xpbUNvbGxhcHNlZCA/IFwibm9uZVwiIDogXCJ1bnNldFwiXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0ID8gc2V0VGltZW91dChcbiAgICAgICgpID0+IG4oKSxcbiAgICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uXG4gICAgKSA6IG4oKTtcbiAgfVxuICBhc3luYyBfdHJpZ2dlckV2ZW50cyh0LCBlKSB7XG4gICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke3R9LnRlLnNpZGVuYXZgKSwgZSAmJiBhd2FpdCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHtlfS50ZS5zaWRlbmF2YCk7XG4gICAgfSwgdGhpcy5vcHRpb25zLnNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb24gKyA1KTtcbiAgfVxuICBfaXNpUGhvbmUoKSB7XG4gICAgcmV0dXJuIC9pUGhvbmV8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cbiAgX3VwZGF0ZSh0KSB7XG4gICAgdCAmJiB0aGlzLl9pc2lQaG9uZSgpICYmIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJwcy0tc2Nyb2xsaW5nLXlcIiksIHRoaXMudG9nZ2xlciAmJiB0aGlzLl91cGRhdGVUb2dnbGVyQXJpYSh0KSwgdGhpcy5fdXBkYXRlRGlzcGxheSh0KSwgdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLl91cGRhdGVCYWNrZHJvcCh0KSwgdGhpcy5fdXBkYXRlT2Zmc2V0cyh0KSwgdCAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdkNsb3NlT25Fc2MgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlICE9PSBcInNpZGVcIiAmJiBoLm9uKHdpbmRvdywgXCJrZXlkb3duXCIsIHRoaXMuZXNjSGFuZGxlciksIHRoaXMub3B0aW9ucy5zaWRlbmF2Rm9jdXNUcmFwICYmIHRoaXMuX3VwZGF0ZUZvY3VzKHQpO1xuICB9XG4gIF91cGRhdGVEaXNwbGF5KHQpIHtcbiAgICBjb25zdCBlID0gdCA/IDAgOiB0aGlzLnRyYW5zbGF0aW9uO1xuICAgIGMuc3R5bGUodGhpcy5fZWxlbWVudCwge1xuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2V9JSlgXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZUZvY3VzKHQpIHtcbiAgICBpZiAodGhpcy5fc2V0VGFiaW5kZXgodCksIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZGb2N1c1RyYXApIHtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcC50cmFwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvY3VzVHJhcC5kaXNhYmxlKCk7XG4gICAgfVxuICAgIHRoaXMuX2ZvY3VzVHJhcC5kaXNhYmxlKCk7XG4gIH1cbiAgX3VwZGF0ZU9mZnNldHModCwgZSA9ICExKSB7XG4gICAgY29uc3QgW2ksIG5dID0gdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodCA/IFtcInJpZ2h0XCIsIFwibGVmdFwiXSA6IFtcImxlZnRcIiwgXCJyaWdodFwiXSwgbyA9IHtcbiAgICAgIHByb3BlcnR5OiB0aGlzLl9nZXRQcm9wZXJ0eShcInBhZGRpbmdcIiwgaSksXG4gICAgICB2YWx1ZTogdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiA/IDAgOiB0aGlzLndpZHRoXG4gICAgfSwgciA9IHtcbiAgICAgIHByb3BlcnR5OiB0aGlzLl9nZXRQcm9wZXJ0eShcIm1hcmdpblwiLCBuKSxcbiAgICAgIHZhbHVlOiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwicHVzaFwiID8gLTEgKiB0aGlzLndpZHRoIDogMFxuICAgIH07XG4gICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwidXBkYXRlLnRlLnNpZGVuYXZcIiwge1xuICAgICAgbWFyZ2luOiByLFxuICAgICAgcGFkZGluZzogb1xuICAgIH0pLCB0aGlzLl9jb250ZW50ICYmICh0aGlzLl9jb250ZW50LmNsYXNzTmFtZSA9IFwiXCIsIHRoaXMuX3NldENvbnRlbnRPZmZzZXRzKHQsIHsgcGFkZGluZzogbywgbWFyZ2luOiByIH0sIGUpKTtcbiAgfVxuICBfdXBkYXRlVG9nZ2xlckFyaWEodCkge1xuICAgIHRoaXMudG9nZ2xlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIHQpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgdG9nZ2xlU2lkZW5hdigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29uc3QgZSA9IGQuY2xvc2VzdCh0LnRhcmdldCwgUm4pLCBpID0gYy5nZXREYXRhQXR0cmlidXRlcyhlKS50YXJnZXQ7XG4gICAgICBkLmZpbmQoaSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICAocGkuZ2V0SW5zdGFuY2UobikgfHwgbmV3IHBpKG4pKS50b2dnbGUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gSS5nZXREYXRhKHRoaXMsIGhzKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgcGkodGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgaHMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IGxvID0gXCJzdGVwcGVyXCIsIElzID0gXCJ0ZS5zdGVwcGVyXCIsIEtzID0gYC4ke0lzfWAsIE1pID0gYGRhdGEtdGUtJHtsb31gLCBfaSA9IFwiaG9yaXpvbnRhbFwiLCB4dCA9IFwidmVydGljYWxcIiwgZG0gPSB7XG4gIHN0ZXBwZXJUeXBlOiBcInN0cmluZ1wiLFxuICBzdGVwcGVyTGluZWFyOiBcImJvb2xlYW5cIixcbiAgc3RlcHBlck5vRWRpdGFibGU6IFwiYm9vbGVhblwiLFxuICBzdGVwcGVyQWN0aXZlOiBcInN0cmluZ1wiLFxuICBzdGVwcGVyQ29tcGxldGVkOiBcInN0cmluZ1wiLFxuICBzdGVwcGVySW52YWxpZDogXCJzdHJpbmdcIixcbiAgc3RlcHBlckRpc2FibGVkOiBcInN0cmluZ1wiLFxuICBzdGVwcGVyVmVydGljYWxCcmVha3BvaW50OiBcIm51bWJlclwiLFxuICBzdGVwcGVyTW9iaWxlQnJlYWtwb2ludDogXCJudW1iZXJcIixcbiAgc3RlcHBlck1vYmlsZUJhckJyZWFrcG9pbnQ6IFwibnVtYmVyXCJcbn0sIHVtID0ge1xuICBzdGVwcGVyVHlwZTogX2ksXG4gIHN0ZXBwZXJMaW5lYXI6ICExLFxuICBzdGVwcGVyTm9FZGl0YWJsZTogITEsXG4gIHN0ZXBwZXJBY3RpdmU6IFwiXCIsXG4gIHN0ZXBwZXJDb21wbGV0ZWQ6IFwiXCIsXG4gIHN0ZXBwZXJJbnZhbGlkOiBcIlwiLFxuICBzdGVwcGVyRGlzYWJsZWQ6IFwiXCIsXG4gIHN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQ6IDAsXG4gIHN0ZXBwZXJNb2JpbGVCcmVha3BvaW50OiAwLFxuICBzdGVwcGVyTW9iaWxlQmFyQnJlYWtwb2ludDogNFxufSwgZmEgPSBgbW91c2Vkb3duJHtLc31gLCBtYSA9IGBrZXlkb3duJHtLc31gLCBwbSA9IGBrZXl1cCR7S3N9YCwgZ2EgPSBgcmVzaXplJHtLc31gLCBqdCA9IGBbJHtNaX0tc3RlcC1yZWZdYCwgRyA9IGBbJHtNaX0taGVhZC1yZWZdYCwgYmEgPSBgWyR7TWl9LWhlYWQtdGV4dC1yZWZdYCwgZHMgPSBgWyR7TWl9LWhlYWQtaWNvbi1yZWZdYCwgc3QgPSBgWyR7TWl9LWNvbnRlbnQtcmVmXWA7XG5jbGFzcyBqMCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fZWxlbWVudEhlaWdodCA9IDAsIHRoaXMuX3N0ZXBzID0gZC5maW5kKGAke2p0fWAsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9jdXJyZW50VmlldyA9IFwiXCIsIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCA9IDAsIHRoaXMuX3ZlcnRpY2FsU3RlcHBlclN0eWxlcyA9IFtdLCB0aGlzLl9lbGVtZW50ICYmIChJLnNldERhdGEodCwgSXMsIHRoaXMpLCB0aGlzLl9pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBsbztcbiAgfVxuICBnZXQgYWN0aXZlU3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlcHNbdGhpcy5fYWN0aXZlU3RlcEluZGV4XTtcbiAgfVxuICBnZXQgYWN0aXZlU3RlcEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVTdGVwSW5kZXg7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgaC5vZmYodCwgZmEpLCBoLm9mZih0LCBtYSk7XG4gICAgfSksIGgub2ZmKHdpbmRvdywgZ2EpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgSXMpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBjaGFuZ2VTdGVwKHQpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwKHQpO1xuICB9XG4gIG5leHRTdGVwKCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXAodGhpcy5fYWN0aXZlU3RlcEluZGV4ICsgMSk7XG4gIH1cbiAgcHJldmlvdXNTdGVwKCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXAodGhpcy5fYWN0aXZlU3RlcEluZGV4IC0gMSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKGAke2p0fWAsIHRoaXMuX2VsZW1lbnQpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uc2V0QXR0cmlidXRlKFwiZGF0YS10ZVwiLCBcImFjdGl2ZS1zdGVwXCIpLCBlID0gZC5maW5kKFxuICAgICAgYCR7YmF9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBpID0gZC5maW5kKFxuICAgICAgYCR7ZHN9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHN3aXRjaCAodCA/ICh0aGlzLl9hY3RpdmVTdGVwSW5kZXggPSB0aGlzLl9zdGVwcy5pbmRleE9mKHQpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCJmb250LW1lZGl1bVwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtcHJpbWFyeS03MDBcIikpIDogKGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiZm9udC1tZWRpdW1cIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiF0ZXh0LXByaW1hcnktNzAwXCIpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKSksIHRoaXMuX2JpbmRNb3VzZURvd24oKSwgdGhpcy5fYmluZEtleXNOYXZpZ2F0aW9uKCksIHRoaXMuX29wdGlvbnMuc3RlcHBlclR5cGUpIHtcbiAgICAgIGNhc2UgeHQ6XG4gICAgICAgIHRoaXMuX3RvZ2dsZVZlcnRpY2FsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5fdG9nZ2xlSG9yaXpvbnRhbCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgKHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCB8fCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJNb2JpbGVCcmVha3BvaW50KSAmJiB0aGlzLl90b2dnbGVTdGVwcGVyVmlldygpLCB0aGlzLl9iaW5kUmVzaXplKCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi51bSxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTChsbywgdCwgZG0pLCB0O1xuICB9XG4gIF9iaW5kTW91c2VEb3duKCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7R31gLCB0KTtcbiAgICAgIGgub24oZSwgZmEsIChpKSA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSBkLnBhcmVudHMoaS50YXJnZXQsIGAke2p0fWApWzBdLCBvID0gdGhpcy5fc3RlcHMuaW5kZXhPZihuKTtcbiAgICAgICAgaS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl90b2dnbGVTdGVwKG8pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRSZXNpemUoKSB7XG4gICAgaC5vbih3aW5kb3csIGdhLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jdXJyZW50VmlldyA9PT0geHQgJiYgdGhpcy5fc2V0U2luZ2xlU3RlcEhlaWdodCh0aGlzLmFjdGl2ZVN0ZXApLCB0aGlzLl9jdXJyZW50VmlldyA9PT0gX2kgJiYgdGhpcy5fc2V0SGVpZ2h0KHRoaXMuYWN0aXZlU3RlcCksICh0aGlzLl9vcHRpb25zLnN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQgfHwgdGhpcy5fb3B0aW9ucy5zdGVwcGVyTW9iaWxlQnJlYWtwb2ludCkgJiYgdGhpcy5fdG9nZ2xlU3RlcHBlclZpZXcoKTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlU3RlcHBlclZpZXcoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCA8IHdpbmRvdy5pbm5lcldpZHRoLCBlID0gdGhpcy5fb3B0aW9ucy5zdGVwcGVyVmVydGljYWxCcmVha3BvaW50ID4gd2luZG93LmlubmVyV2lkdGgsIGkgPSB0aGlzLl9vcHRpb25zLnN0ZXBwZXJNb2JpbGVCcmVha3BvaW50ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdCAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0gX2kgJiYgdGhpcy5fdG9nZ2xlSG9yaXpvbnRhbCgpLCBlICYmICFpICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB4dCAmJiAodGhpcy5fc3RlcHMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgY29uc3QgbyA9IGQuZmluZE9uZShgJHtzdH1gLCBuKTtcbiAgICAgIHRoaXMuX3Jlc2V0U3RlcHBlckhlaWdodCgpLCB0aGlzLl9zaG93RWxlbWVudChvKTtcbiAgICB9KSwgdGhpcy5fdG9nZ2xlVmVydGljYWwoKSk7XG4gIH1cbiAgX3RvZ2dsZVN0ZXAodCkge1xuICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAhPT0gdCAmJiAodGhpcy5fb3B0aW9ucy5zdGVwcGVyTm9FZGl0YWJsZSAmJiB0aGlzLl90b2dnbGVEaXNhYmxlZCgpLCB0aGlzLl9zaG93RWxlbWVudChcbiAgICAgIGQuZmluZE9uZShgJHtzdH1gLCB0aGlzLl9zdGVwc1t0XSlcbiAgICApLCB0aGlzLl90b2dnbGVBY3RpdmUodCksIHQgPiB0aGlzLl9hY3RpdmVTdGVwSW5kZXggJiYgdGhpcy5fdG9nZ2xlQ29tcGxldGVkKHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCksIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBfaSA/IHRoaXMuX2FuaW1hdGVIb3Jpem9udGFsU3RlcCh0KSA6ICh0aGlzLl9hbmltYXRlVmVydGljYWxTdGVwKHQpLCB0aGlzLl9zZXRTaW5nbGVTdGVwSGVpZ2h0KHRoaXMuX3N0ZXBzW3RdKSksIHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChcbiAgICAgIGQuZmluZE9uZShgJHtHfWAsIHRoaXMuYWN0aXZlU3RlcCksXG4gICAgICBkLmZpbmRPbmUoYCR7R31gLCB0aGlzLl9zdGVwc1t0XSlcbiAgICApLCB0aGlzLl9hY3RpdmVTdGVwSW5kZXggPSB0LCB0aGlzLl9zdGVwc1t0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLnNldEF0dHJpYnV0ZShcImRhdGEtdGVcIiwgXCJhY3RpdmUtc3RlcFwiKSwgdGhpcy5fc3RlcHMuZm9yRWFjaCgoZSwgaSkgPT4ge1xuICAgICAgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdICE9PSBpICYmIGUucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZVwiKTtcbiAgICB9KSk7XG4gIH1cbiAgX3Jlc2V0U3RlcHBlckhlaWdodCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gIH1cbiAgX3NldFN0ZXBzSGVpZ2h0KCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7c3R9YCwgdCksIGkgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKTtcbiAgICAgIHRoaXMuX3ZlcnRpY2FsU3RlcHBlclN0eWxlcy5wdXNoKHtcbiAgICAgICAgcGFkZGluZ1RvcDogcGFyc2VGbG9hdChpLnBhZGRpbmdUb3ApLFxuICAgICAgICBwYWRkaW5nQm90dG9tOiBwYXJzZUZsb2F0KGkucGFkZGluZ0JvdHRvbSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbiA9IGUuc2Nyb2xsSGVpZ2h0O1xuICAgICAgZS5zdHlsZS5oZWlnaHQgPSBgJHtufXB4YDtcbiAgICB9KTtcbiAgfVxuICBfc2V0U2luZ2xlU3RlcEhlaWdodCh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShgJHtzdH1gLCB0KSwgaSA9IHRoaXMuYWN0aXZlU3RlcCA9PT0gdCwgbiA9IHRoaXMuX3N0ZXBzLmluZGV4T2YodCk7XG4gICAgbGV0IG87XG4gICAgaSA/IChlLnN0eWxlLmhlaWdodCA9IFwiXCIsIG8gPSBlLnNjcm9sbEhlaWdodCkgOiBvID0gZS5zY3JvbGxIZWlnaHQgKyB0aGlzLl92ZXJ0aWNhbFN0ZXBwZXJTdHlsZXNbbl0ucGFkZGluZ1RvcCArIHRoaXMuX3ZlcnRpY2FsU3RlcHBlclN0eWxlc1tuXS5wYWRkaW5nQm90dG9tLCBlLnN0eWxlLmhlaWdodCA9IGAke299cHhgO1xuICB9XG4gIF90b2dnbGVWZXJ0aWNhbCgpIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IHh0LCB0aGlzLl9zZXRTdGVwc0hlaWdodCgpLCB0aGlzLl9oaWRlSW5hY3RpdmVTdGVwcygpO1xuICB9XG4gIF90b2dnbGVIb3Jpem9udGFsKCkge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0gX2ksIHRoaXMuX3NldEhlaWdodCh0aGlzLmFjdGl2ZVN0ZXApLCB0aGlzLl9oaWRlSW5hY3RpdmVTdGVwcygpO1xuICB9XG4gIF90b2dnbGVTdGVwcGVyQ2xhc3MoKSB7XG4gICAgZC5maW5kT25lKFxuICAgICAgXCJbZGF0YS10ZS1zdGVwcGVyLXR5cGVdXCIsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSAhPT0gbnVsbCAmJiB0aGlzLl9zdGVwcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBkLmZpbmRPbmUoYCR7c3R9YCwgZSkuY2xhc3NMaXN0LnJlbW92ZShcIiFteS0wXCIpLCBkLmZpbmRPbmUoYCR7c3R9YCwgZSkuY2xhc3NMaXN0LnJlbW92ZShcIiFweS0wXCIpLCBkLmZpbmRPbmUoYCR7c3R9YCwgZSkuY2xhc3NMaXN0LnJlbW92ZShcIiFoLTBcIik7XG4gICAgfSk7XG4gIH1cbiAgX3RvZ2dsZVN0ZXBDbGFzcyh0LCBlLCBpKSB7XG4gICAgaSAmJiB0aGlzLl9zdGVwc1t0XS5jbGFzc0xpc3RbZV0oaSk7XG4gIH1cbiAgX2JpbmRLZXlzTmF2aWdhdGlvbigpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoXG4gICAgICAhMSxcbiAgICAgIGQuZmluZE9uZShgJHtHfWAsIHRoaXMuYWN0aXZlU3RlcClcbiAgICApLCB0aGlzLl9zdGVwcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKGAke0d9YCwgdCk7XG4gICAgICBoLm9uKGUsIG1hLCAoaSkgPT4ge1xuICAgICAgICBjb25zdCBuID0gZC5wYXJlbnRzKFxuICAgICAgICAgIGkuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBgJHtqdH1gXG4gICAgICAgIClbMF0sIG8gPSBkLm5leHQobiwgYCR7anR9YClbMF0sIHIgPSBkLnByZXYobiwgYCR7anR9YClbMF0sIGEgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7R31gLFxuICAgICAgICAgIG5cbiAgICAgICAgKSwgbCA9IGQuZmluZE9uZShcbiAgICAgICAgICBgJHtHfWAsXG4gICAgICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgICAgICk7XG4gICAgICAgIGxldCBwID0gbnVsbCwgdSA9IG51bGw7XG4gICAgICAgIGlmIChvICYmIChwID0gZC5maW5kT25lKGAke0d9YCwgbykpLCByICYmICh1ID0gZC5maW5kT25lKGAke0d9YCwgcikpLCBpLmtleUNvZGUgPT09IFBlICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB4dCAmJiAodSA/ICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgdSksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgdSksIHUuZm9jdXMoKSkgOiBwICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgcCksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgcCksIHAuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09IEJlICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB4dCAmJiAocCA/ICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgcCksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgcCksIHAuZm9jdXMoKSkgOiB1ICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgdSksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgdSksIHUuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09IHogJiYgdGhpcy5fY3VycmVudFZpZXcgPT09IHh0ICYmIChpLnByZXZlbnREZWZhdWx0KCksIHAgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBwKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBwKSwgcC5mb2N1cygpKSksIGkua2V5Q29kZSA9PT0gcnQgJiYgdGhpcy5fY3VycmVudFZpZXcgPT09IHh0ICYmIChpLnByZXZlbnREZWZhdWx0KCksIHUgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCB1KSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCB1KSwgdS5mb2N1cygpKSksIGkua2V5Q29kZSA9PT0gSGUpIHtcbiAgICAgICAgICBjb25zdCBmID0gZC5maW5kT25lKFxuICAgICAgICAgICAgYCR7R31gLFxuICAgICAgICAgICAgdGhpcy5fc3RlcHNbMF1cbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBmKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBmKSwgZi5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpLmtleUNvZGUgPT09IFdlKSB7XG4gICAgICAgICAgY29uc3QgZiA9IHRoaXMuX3N0ZXBzW3RoaXMuX3N0ZXBzLmxlbmd0aCAtIDFdLCBfID0gZC5maW5kT25lKGAke0d9YCwgZik7XG4gICAgICAgICAgdGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIF8pLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIF8pLCBfLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgKGkua2V5Q29kZSA9PT0gbHQgfHwgaS5rZXlDb2RlID09PSBrcykgJiYgKGkucHJldmVudERlZmF1bHQoKSwgdGhpcy5jaGFuZ2VTdGVwKHRoaXMuX3N0ZXBzLmluZGV4T2YobikpKSwgaS5rZXlDb2RlID09PSBPaSAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGwpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsICExKSwgbC5mb2N1cygpKTtcbiAgICAgIH0pLCBoLm9uKGUsIHBtLCAoaSkgPT4ge1xuICAgICAgICBjb25zdCBuID0gZC5wYXJlbnRzKFxuICAgICAgICAgIGkuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBgJHtqdH1gXG4gICAgICAgIClbMF0sIG8gPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7R31gLFxuICAgICAgICAgIG5cbiAgICAgICAgKSwgciA9IGQuZmluZE9uZShcbiAgICAgICAgICBgJHtHfWAsXG4gICAgICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgICAgICk7XG4gICAgICAgIGkua2V5Q29kZSA9PT0gT2kgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChvLCByKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyghMSwgciksIHIuZm9jdXMoKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlU3RlcFRhYkluZGV4KHQsIGUpIHtcbiAgICB0ICYmIHQuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgLTEpLCBlICYmIGUuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgMCk7XG4gIH1cbiAgX3RvZ2dsZU91dGxpbmVTdHlsZXModCwgZSkge1xuICAgIHQgJiYgKHQuc3R5bGUub3V0bGluZSA9IFwiXCIpLCBlICYmIChlLnN0eWxlLm91dGxpbmUgPSBcInJldmVydFwiKTtcbiAgfVxuICBfdG9nZ2xlRGlzYWJsZWQoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZChgJHtHfWAsIHRoaXMuX2VsZW1lbnQpLCBlID0gZC5maW5kKFxuICAgICAgYCR7ZHN9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHRbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiY29sb3ItWyM4NTg1ODVdXCIpLCB0W3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcImN1cnNvci1kZWZhdWx0XCIpLCBlW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiFiZy1bIzg1ODU4NV1cIiksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwiYWRkXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJEaXNhYmxlZFxuICAgICk7XG4gIH1cbiAgX3RvZ2dsZUFjdGl2ZSh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZChcbiAgICAgIGAke2JhfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaSA9IGQuZmluZChcbiAgICAgIGAke2RzfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBlW3RdLmNsYXNzTGlzdC5hZGQoXCJmb250LW1lZGl1bVwiKSwgaVt0XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RdLmNsYXNzTGlzdC5hZGQoXCIhdGV4dC1wcmltYXJ5LTcwMFwiKSwgaVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIWJnLXN1Y2Nlc3MtMTAwXCIpLCBpW3RdLmNsYXNzTGlzdC5yZW1vdmUoXCIhdGV4dC1zdWNjZXNzLTcwMFwiKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoXCJmb250LW1lZGl1bVwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgXCIhdGV4dC1wcmltYXJ5LTcwMFwiXG4gICAgKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKHQsIFwiYWRkXCIsIHRoaXMuX29wdGlvbnMuc3RlcHBlckFjdGl2ZSksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwicmVtb3ZlXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJBY3RpdmVcbiAgICApO1xuICB9XG4gIF90b2dnbGVDb21wbGV0ZWQodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmQoXG4gICAgICBgJHtkc31gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgZVt0XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXN1Y2Nlc3MtMTAwXCIpLCBlW3RdLmNsYXNzTGlzdC5hZGQoXCIhdGV4dC1zdWNjZXNzLTcwMFwiKSwgZVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIWJnLWRhbmdlci0xMDBcIiksIGVbdF0uY2xhc3NMaXN0LnJlbW92ZShcIiF0ZXh0LWRhbmdlci03MDBcIiksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyh0LCBcImFkZFwiLCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJDb21wbGV0ZWQpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3ModCwgXCJyZW1vdmVcIiwgdGhpcy5fb3B0aW9ucy5zdGVwcGVySW52YWxpZCk7XG4gIH1cbiAgX2hpZGVJbmFjdGl2ZVN0ZXBzKCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZVwiKSB8fCB0aGlzLl9oaWRlRWxlbWVudChkLmZpbmRPbmUoYCR7c3R9YCwgdCkpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRIZWlnaHQodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7c3R9YCwgdCksIGkgPSBnZXRDb21wdXRlZFN0eWxlKGUpLCBuID0gZC5maW5kT25lKGAke0d9YCwgdCksIG8gPSBnZXRDb21wdXRlZFN0eWxlKG4pLCByID0gZS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KGkubWFyZ2luVG9wKSArIHBhcnNlRmxvYXQoaS5tYXJnaW5Cb3R0b20pLCBhID0gbi5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KG8ubWFyZ2luVG9wKSArIHBhcnNlRmxvYXQoby5tYXJnaW5Cb3R0b20pO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7YSArIHJ9cHhgO1xuICB9XG4gIF9oaWRlRWxlbWVudCh0KSB7XG4gICAgIWQucGFyZW50cyhcbiAgICAgIHQsXG4gICAgICBgJHtqdH1gXG4gICAgKVswXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlXCIpICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB4dCB8fCAodC5jbGFzc0xpc3QuYWRkKFwiIW15LTBcIiksIHQuY2xhc3NMaXN0LmFkZChcIiFweS0wXCIpLCB0LmNsYXNzTGlzdC5hZGQoXCIhaC0wXCIpKTtcbiAgfVxuICBfc2hvd0VsZW1lbnQodCkge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID09PSB4dCA/ICh0LmNsYXNzTGlzdC5yZW1vdmUoXCIhbXktMFwiKSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwiIXB5LTBcIiksIHQuY2xhc3NMaXN0LnJlbW92ZShcIiFoLTBcIikpIDogdC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICB9XG4gIF9hbmltYXRlSG9yaXpvbnRhbFN0ZXAodCkge1xuICAgIGNvbnN0IGUgPSB0ID4gdGhpcy5fYWN0aXZlU3RlcEluZGV4LCBpID0gZC5maW5kT25lKFxuICAgICAgYCR7c3R9YCxcbiAgICAgIHRoaXMuX3N0ZXBzW3RdXG4gICAgKSwgbiA9IGQuZmluZE9uZShcbiAgICAgIGAke3N0fWAsXG4gICAgICB0aGlzLmFjdGl2ZVN0ZXBcbiAgICApO1xuICAgIGxldCBvLCByO1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHUsIGYpID0+IHtcbiAgICAgIGNvbnN0IF8gPSBkLmZpbmRPbmUoYCR7c3R9YCwgdSk7XG4gICAgICBmICE9PSB0ICYmIGYgIT09IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAmJiB0aGlzLl9oaWRlRWxlbWVudChfKTtcbiAgICB9KTtcbiAgICBjb25zdCBhID0gXCJ0cmFuc2xhdGUteC1bMTUwJV1cIiwgbCA9IFwiLXRyYW5zbGF0ZS14LVsxNTAlXVwiLCBwID0gXCJ0cmFuc2xhdGUtMFwiO1xuICAgIGUgPyAociA9IGwsIG8gPSBwLCBpLmNsYXNzTGlzdC5yZW1vdmUoXCJ0cmFuc2xhdGUteC1bMTUwJV1cIiksIGkuY2xhc3NMaXN0LnJlbW92ZShcIi10cmFuc2xhdGUteC1bMTUwJV1cIikpIDogKHIgPSBhLCBvID0gcCwgaS5jbGFzc0xpc3QucmVtb3ZlKFwiLXRyYW5zbGF0ZS14LVsxNTAlXVwiKSwgaS5jbGFzc0xpc3QucmVtb3ZlKFwidHJhbnNsYXRlLXgtWzE1MCVdXCIpKSwgbi5jbGFzc0xpc3QuYWRkKHIpLCBpLmNsYXNzTGlzdC5hZGQobyksIHRoaXMuX3NldEhlaWdodCh0aGlzLl9zdGVwc1t0XSk7XG4gIH1cbiAgX2FuaW1hdGVWZXJ0aWNhbFN0ZXAodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXG4gICAgICBgJHtzdH1gLFxuICAgICAgdGhpcy5fc3RlcHNbdF1cbiAgICApLCBpID0gZC5maW5kT25lKFxuICAgICAgYCR7c3R9YCxcbiAgICAgIHRoaXMuYWN0aXZlU3RlcFxuICAgICk7XG4gICAgdGhpcy5faGlkZUVsZW1lbnQoaSksIHRoaXMuX3Nob3dFbGVtZW50KGUpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBJcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgdmEgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIHVzID0gXCJkYXRhLXRlLWlucHV0LXNlbGVjdGVkXCIsIFRhID0gXCJkYXRhLXRlLWlucHV0LW11bHRpcGxlLWFjdGl2ZVwiLCBFYSA9IFwiW2RhdGEtdGUtZm9ybS1jaGVjay1pbnB1dF1cIjtcbmNsYXNzIENhIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSwgbiwgbywgciwgYSwgbCwgcCwgdSwgZikge1xuICAgIHRoaXMuaWQgPSB0LCB0aGlzLm5hdGl2ZU9wdGlvbiA9IGUsIHRoaXMubXVsdGlwbGUgPSBpLCB0aGlzLnZhbHVlID0gbiwgdGhpcy5sYWJlbCA9IG8sIHRoaXMuc2VsZWN0ZWQgPSByLCB0aGlzLmRpc2FibGVkID0gYSwgdGhpcy5oaWRkZW4gPSBsLCB0aGlzLnNlY29uZGFyeVRleHQgPSBwLCB0aGlzLmdyb3VwSWQgPSB1LCB0aGlzLmljb24gPSBmLCB0aGlzLm5vZGUgPSBudWxsLCB0aGlzLmFjdGl2ZSA9ICExO1xuICB9XG4gIHNlbGVjdCgpIHtcbiAgICB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0TXVsdGlwbGUoKSA6IHRoaXMuX3NlbGVjdFNpbmdsZSgpO1xuICB9XG4gIF9zZWxlY3RTaW5nbGUoKSB7XG4gICAgdGhpcy5zZWxlY3RlZCB8fCAodGhpcy5ub2RlLnNldEF0dHJpYnV0ZSh1cywgXCJcIiksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEwKSwgdGhpcy5zZWxlY3RlZCA9ICEwLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMCkpO1xuICB9XG4gIF9zZWxlY3RNdWx0aXBsZSgpIHtcbiAgICBpZiAoIXRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICAgIEVhLFxuICAgICAgICB0aGlzLm5vZGVcbiAgICAgICk7XG4gICAgICB0LmNoZWNrZWQgPSAhMCwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSh1cywgXCJcIiksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEwKSwgdGhpcy5zZWxlY3RlZCA9ICEwLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMCk7XG4gICAgfVxuICB9XG4gIGRlc2VsZWN0KCkge1xuICAgIHRoaXMubXVsdGlwbGUgPyB0aGlzLl9kZXNlbGVjdE11bHRpcGxlKCkgOiB0aGlzLl9kZXNlbGVjdFNpbmdsZSgpO1xuICB9XG4gIF9kZXNlbGVjdFNpbmdsZSgpIHtcbiAgICB0aGlzLnNlbGVjdGVkICYmICh0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKHVzKSwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITEpLCB0aGlzLnNlbGVjdGVkID0gITEsIHRoaXMubmF0aXZlT3B0aW9uICYmICh0aGlzLm5hdGl2ZU9wdGlvbi5zZWxlY3RlZCA9ICExKSk7XG4gIH1cbiAgX2Rlc2VsZWN0TXVsdGlwbGUoKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICAgIEVhLFxuICAgICAgICB0aGlzLm5vZGVcbiAgICAgICk7XG4gICAgICB0LmNoZWNrZWQgPSAhMSwgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSh1cyksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKSwgdGhpcy5zZWxlY3RlZCA9ICExLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMSk7XG4gICAgfVxuICB9XG4gIHNldE5vZGUodCkge1xuICAgIHRoaXMubm9kZSA9IHQ7XG4gIH1cbiAgc2V0QWN0aXZlU3R5bGVzKCkge1xuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoVGEsIFwiXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZSA9ICEwLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKHZhLCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQWN0aXZlU3R5bGVzKCkge1xuICAgIHRoaXMuYWN0aXZlICYmICh0aGlzLmFjdGl2ZSA9ICExLCB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKHZhKSksIHRoaXMubXVsdGlwbGUgJiYgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShUYSk7XG4gIH1cbn1cbmNsYXNzIF9tIHtcbiAgY29uc3RydWN0b3IodCA9ICExKSB7XG4gICAgdGhpcy5fbXVsdGlwbGUgPSB0LCB0aGlzLl9zZWxlY3Rpb25zID0gW107XG4gIH1cbiAgc2VsZWN0KHQpIHtcbiAgICB0aGlzLl9tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdGlvbnMucHVzaCh0KSA6IHRoaXMuX3NlbGVjdGlvbnMgPSBbdF07XG4gIH1cbiAgZGVzZWxlY3QodCkge1xuICAgIGlmICh0aGlzLl9tdWx0aXBsZSkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX3NlbGVjdGlvbnMuZmluZEluZGV4KFxuICAgICAgICAoaSkgPT4gdCA9PT0gaVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbnMuc3BsaWNlKGUsIDEpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5fc2VsZWN0aW9ucyA9IFtdO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3NlbGVjdGlvbnMgPSBbXTtcbiAgfVxuICBnZXQgc2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zWzBdO1xuICB9XG4gIGdldCBzZWxlY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zO1xuICB9XG4gIGdldCBsYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uc1swXSAmJiB0aGlzLnNlbGVjdGlvbi5sYWJlbDtcbiAgfVxuICBnZXQgbGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zLm1hcCgodCkgPT4gdC5sYWJlbCkuam9pbihcIiwgXCIpO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25zWzBdICYmIHRoaXMuc2VsZWN0aW9uLnZhbHVlO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnMubWFwKCh0KSA9PiB0LnZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gY28ocykge1xuICByZXR1cm4gcy5maWx0ZXIoKHQpID0+ICF0LmRpc2FibGVkKS5ldmVyeSgodCkgPT4gdC5zZWxlY3RlZCk7XG59XG5jb25zdCBmbSA9IFwiZGF0YS10ZS1zZWxlY3QtZm9ybS1vdXRsaW5lLXJlZlwiLCBtbSA9IFwiZGF0YS10ZS1zZWxlY3Qtd3JhcHBlci1yZWZcIiwgZ20gPSBcImRhdGEtdGUtc2VsZWN0LWlucHV0LXJlZlwiLCBibSA9IFwiZGF0YS10ZS1zZWxlY3QtY2xlYXItYnRuLXJlZlwiLCB2bSA9IFwiZGF0YS10ZS1zZWxlY3QtZHJvcGRvd24tY29udGFpbmVyLXJlZlwiLCBUbSA9IFwiZGF0YS10ZS1zZWxlY3QtZHJvcGRvd24tcmVmXCIsIEVtID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb25zLXdyYXBwZXItcmVmXCIsIENtID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb25zLWxpc3QtcmVmXCIsIEFtID0gXCJkYXRhLXRlLXNlbGVjdC1pbnB1dC1maWx0ZXItcmVmXCIsIGFjID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tcmVmXCIsIHltID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tYWxsLXJlZlwiLCB3bSA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLXRleHQtcmVmXCIsIHhtID0gXCJkYXRhLXRlLWZvcm0tY2hlY2staW5wdXRcIiwga20gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1yZWZcIiwgT20gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1sYWJlbC1yZWZcIiwgbGMgPSBcImRhdGEtdGUtc2VsZWN0LXNlbGVjdGVkXCIsIFNtID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSA4LjI1bC03LjUgNy41LTcuNS03LjVcIiAvPlxuPC9zdmc+XG5gLCBJbSA9IChzKSA9PiB7XG4gIHMuY29kZSA9PT0gXCJUYWJcIiB8fCBzLmNvZGUgPT09IFwiRXNjXCIgfHwgcy5wcmV2ZW50RGVmYXVsdCgpO1xufTtcbmZ1bmN0aW9uIHBzKHMsIHQsIGUsIGksIG4pIHtcbiAgdC5zZWxlY3RTaXplID09PSBcImRlZmF1bHRcIiAmJiBjLmFkZENsYXNzKHMsIGUpLCB0LnNlbGVjdFNpemUgPT09IFwic21cIiAmJiBjLmFkZENsYXNzKHMsIGkpLCB0LnNlbGVjdFNpemUgPT09IFwibGdcIiAmJiBjLmFkZENsYXNzKHMsIG4pO1xufVxuZnVuY3Rpb24gRG0ocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBzKSwgbi5zZXRBdHRyaWJ1dGUobW0sIFwiXCIpO1xuICBjb25zdCBvID0gRChcImRpdlwiKTtcbiAgby5zZXRBdHRyaWJ1dGUoZm0sIFwiXCIpLCBjLmFkZENsYXNzKG8sIGkuZm9ybU91dGxpbmUpO1xuICBjb25zdCByID0gRChcImlucHV0XCIpLCBhID0gdC5zZWxlY3RGaWx0ZXIgPyBcImNvbWJvYm94XCIgOiBcImxpc3Rib3hcIiwgbCA9IHQubXVsdGlwbGUgPyBcInRydWVcIiA6IFwiZmFsc2VcIiwgcCA9IHQuZGlzYWJsZWQgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgci5zZXRBdHRyaWJ1dGUoZ20sIFwiXCIpLCBjLmFkZENsYXNzKHIsIGkuc2VsZWN0SW5wdXQpLCBwcyhcbiAgICByLFxuICAgIHQsXG4gICAgaS5zZWxlY3RJbnB1dFNpemVEZWZhdWx0LFxuICAgIGkuc2VsZWN0SW5wdXRTaXplU20sXG4gICAgaS5zZWxlY3RJbnB1dFNpemVMZ1xuICApLCB0LnNlbGVjdEZvcm1XaGl0ZSAmJiBjLmFkZENsYXNzKHIsIGkuc2VsZWN0SW5wdXRXaGl0ZSksIHIuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHRcIiksIHIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBhKSwgci5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiLCBsKSwgci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsIHApLCByLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgXCJ0cnVlXCIpLCByLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgITEpLCB0LnRhYkluZGV4ICYmIHIuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgdC50YWJJbmRleCksIHQuZGlzYWJsZWQgJiYgci5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSwgdC5zZWxlY3RQbGFjZWhvbGRlciAhPT0gXCJcIiAmJiByLnNldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIsIHQuc2VsZWN0UGxhY2Vob2xkZXIpLCB0LnNlbGVjdFZhbGlkYXRpb24gPyAoYy5hZGRTdHlsZShyLCB7XG4gICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcIm5vbmVcIixcbiAgICBcImNhcmV0LWNvbG9yXCI6IFwidHJhbnNwYXJlbnRcIlxuICB9KSwgYy5hZGRTdHlsZShvLCB7IGN1cnNvcjogXCJwb2ludGVyXCIgfSkpIDogci5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCBcInRydWVcIiksIHQuc2VsZWN0VmFsaWRhdGlvbiAmJiAoci5zZXRBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiLCBcInRydWVcIiksIHIuc2V0QXR0cmlidXRlKFwiYXJpYS1yZXF1aXJlZFwiLCBcInRydWVcIiksIHIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgSW0pKTtcbiAgY29uc3QgdSA9IEQoXCJkaXZcIik7XG4gIGMuYWRkQ2xhc3ModSwgaS5zZWxlY3RWYWxpZGF0aW9uVmFsaWQpO1xuICBjb25zdCBmID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgYCR7dC5zZWxlY3RWYWxpZEZlZWRiYWNrfWBcbiAgKTtcbiAgdS5hcHBlbmRDaGlsZChmKTtcbiAgY29uc3QgXyA9IEQoXCJkaXZcIik7XG4gIGMuYWRkQ2xhc3MoXywgaS5zZWxlY3RWYWxpZGF0aW9uSW52YWxpZCk7XG4gIGNvbnN0IG0gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcbiAgICBgJHt0LnNlbGVjdEludmFsaWRGZWVkYmFja31gXG4gICk7XG4gIF8uYXBwZW5kQ2hpbGQobSk7XG4gIGNvbnN0IGcgPSBEKFwic3BhblwiKTtcbiAgZy5zZXRBdHRyaWJ1dGUoYm0sIFwiXCIpLCBjLmFkZENsYXNzKGcsIGkuc2VsZWN0Q2xlYXJCdG4pLCBwcyhcbiAgICBnLFxuICAgIHQsXG4gICAgaS5zZWxlY3RDbGVhckJ0bkRlZmF1bHQsXG4gICAgaS5zZWxlY3RDbGVhckJ0blNtLFxuICAgIGkuc2VsZWN0Q2xlYXJCdG5MZ1xuICApLCB0LnNlbGVjdEZvcm1XaGl0ZSAmJiBjLmFkZENsYXNzKGcsIGkuc2VsZWN0Q2xlYXJCdG5XaGl0ZSk7XG4gIGNvbnN0IHYgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIuKclVwiKTtcbiAgZy5hcHBlbmRDaGlsZCh2KSwgZy5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gIGNvbnN0IGIgPSBEKFwic3BhblwiKTtcbiAgcmV0dXJuIGMuYWRkQ2xhc3MoYiwgaS5zZWxlY3RBcnJvdyksIHBzKFxuICAgIGIsXG4gICAgdCxcbiAgICBpLnNlbGVjdEFycm93RGVmYXVsdCxcbiAgICBpLnNlbGVjdEFycm93U20sXG4gICAgaS5zZWxlY3RBcnJvd0xnXG4gICksIHQuc2VsZWN0Rm9ybVdoaXRlICYmIGMuYWRkQ2xhc3MoYiwgaS5zZWxlY3RBcnJvd1doaXRlKSwgYi5pbm5lckhUTUwgPSBTbSwgby5hcHBlbmRDaGlsZChyKSwgZSAmJiAoYy5hZGRDbGFzcyhlLCBpLnNlbGVjdExhYmVsKSwgcHMoXG4gICAgZSxcbiAgICB0LFxuICAgIGkuc2VsZWN0TGFiZWxTaXplRGVmYXVsdCxcbiAgICBpLnNlbGVjdExhYmVsU2l6ZVNtLFxuICAgIGkuc2VsZWN0TGFiZWxTaXplTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgYy5hZGRDbGFzcyhlLCBpLnNlbGVjdExhYmVsV2hpdGUpLCBvLmFwcGVuZENoaWxkKGUpKSwgdC5zZWxlY3RWYWxpZGF0aW9uICYmIChvLmFwcGVuZENoaWxkKHUpLCBvLmFwcGVuZENoaWxkKF8pKSwgdC5zZWxlY3RDbGVhckJ1dHRvbiAmJiBvLmFwcGVuZENoaWxkKGcpLCBvLmFwcGVuZENoaWxkKGIpLCBuLmFwcGVuZENoaWxkKG8pLCBuO1xufVxuZnVuY3Rpb24gQWEocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICBjb25zdCBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbC5zZXRBdHRyaWJ1dGUodm0sIFwiXCIpLCBjLmFkZENsYXNzKGwsIGEuc2VsZWN0RHJvcGRvd25Db250YWluZXIpLCBsLnNldEF0dHJpYnV0ZShcImlkXCIsIGAke3N9YCksIGwuc3R5bGUud2lkdGggPSBgJHtlfXB4YDtcbiAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHAuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCksIHAuc2V0QXR0cmlidXRlKFRtLCBcIlwiKSwgYy5hZGRDbGFzcyhwLCBhLmRyb3Bkb3duKTtcbiAgY29uc3QgdSA9IEQoXCJkaXZcIik7XG4gIHUuc2V0QXR0cmlidXRlKEVtLCBcIlwiKSwgYy5hZGRDbGFzcyh1LCBhLm9wdGlvbnNXcmFwcGVyKSwgYy5hZGRDbGFzcyh1LCBhLm9wdGlvbnNXcmFwcGVyU2Nyb2xsYmFyKSwgdS5zdHlsZS5tYXhIZWlnaHQgPSBgJHtpfXB4YDtcbiAgY29uc3QgZiA9IGNjKFxuICAgIG8sXG4gICAgbixcbiAgICB0LFxuICAgIGFcbiAgKTtcbiAgcmV0dXJuIHUuYXBwZW5kQ2hpbGQoZiksIHQuc2VsZWN0RmlsdGVyICYmIHAuYXBwZW5kQ2hpbGQoXG4gICAgJG0odC5zZWxlY3RTZWFyY2hQbGFjZWhvbGRlciwgYSlcbiAgKSwgcC5hcHBlbmRDaGlsZCh1KSwgciAmJiBwLmFwcGVuZENoaWxkKHIpLCBsLmFwcGVuZENoaWxkKHApLCBsO1xufVxuZnVuY3Rpb24gY2MocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0gRChcImRpdlwiKTtcbiAgbi5zZXRBdHRyaWJ1dGUoQ20sIFwiXCIpLCBjLmFkZENsYXNzKG4sIGkub3B0aW9uc0xpc3QpO1xuICBsZXQgbztcbiAgcmV0dXJuIGUubXVsdGlwbGUgPyBvID0gTW0oXG4gICAgcyxcbiAgICB0LFxuICAgIGUsXG4gICAgaVxuICApIDogbyA9IExtKHMsIGUsIGkpLCBvLmZvckVhY2goKHIpID0+IHtcbiAgICBuLmFwcGVuZENoaWxkKHIpO1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uICRtKHMsIHQpIHtcbiAgY29uc3QgZSA9IEQoXCJkaXZcIik7XG4gIGMuYWRkQ2xhc3MoZSwgdC5pbnB1dEdyb3VwKTtcbiAgY29uc3QgaSA9IEQoXCJpbnB1dFwiKTtcbiAgcmV0dXJuIGkuc2V0QXR0cmlidXRlKEFtLCBcIlwiKSwgYy5hZGRDbGFzcyhpLCB0LnNlbGVjdEZpbHRlcklucHV0KSwgaS5wbGFjZWhvbGRlciA9IHMsIGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInNlYXJjaGJveFwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dFwiKSwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbn1cbmZ1bmN0aW9uIExtKHMsIHQsIGUpIHtcbiAgcmV0dXJuIGhjKHMsIHQsIGUpO1xufVxuZnVuY3Rpb24gTW0ocywgdCwgZSwgaSkge1xuICBsZXQgbiA9IG51bGw7XG4gIGUuc2VsZWN0QWxsICYmIChuID0gTm0oXG4gICAgdCxcbiAgICBzLFxuICAgIGUsXG4gICAgaVxuICApKTtcbiAgY29uc3QgbyA9IGhjKHMsIGUsIGkpO1xuICByZXR1cm4gbiA/IFtuLCAuLi5vXSA6IG87XG59XG5mdW5jdGlvbiBoYyhzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBbXTtcbiAgcmV0dXJuIHMuZm9yRWFjaCgobikgPT4ge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICBuLFxuICAgICAgXCJvcHRpb25zXCJcbiAgICApKSB7XG4gICAgICBjb25zdCByID0gSG0obiwgdCwgZSk7XG4gICAgICBpLnB1c2gocik7XG4gICAgfSBlbHNlXG4gICAgICBpLnB1c2goZGMobiwgdCwgZSkpO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIE5tKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IGNvKHQpLCBvID0gRChcImRpdlwiKTtcbiAgcmV0dXJuIG8uc2V0QXR0cmlidXRlKGFjLCBcIlwiKSwgYy5hZGRDbGFzcyhvLCBpLnNlbGVjdE9wdGlvbiksIG8uc2V0QXR0cmlidXRlKHltLCBcIlwiKSwgYy5hZGRTdHlsZShvLCB7XG4gICAgaGVpZ2h0OiBgJHtlLnNlbGVjdE9wdGlvbkhlaWdodH1weGBcbiAgfSksIG8uc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKSwgby5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIG4pLCBuICYmIG8uc2V0QXR0cmlidXRlKGxjLCBcIlwiKSwgby5hcHBlbmRDaGlsZCh1YyhzLCBlLCBpKSksIHMuc2V0Tm9kZShvKSwgbztcbn1cbmZ1bmN0aW9uIGRjKHMsIHQsIGUpIHtcbiAgaWYgKHMubm9kZSlcbiAgICByZXR1cm4gcy5ub2RlO1xuICBjb25zdCBpID0gRChcImRpdlwiKTtcbiAgcmV0dXJuIGkuc2V0QXR0cmlidXRlKGFjLCBcIlwiKSwgYy5hZGRDbGFzcyhpLCBlLnNlbGVjdE9wdGlvbiksIGMuYWRkU3R5bGUoaSwge1xuICAgIGhlaWdodDogYCR7dC5zZWxlY3RPcHRpb25IZWlnaHR9cHhgXG4gIH0pLCBjLnNldERhdGFBdHRyaWJ1dGUoaSwgXCJpZFwiLCBzLmlkKSwgaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpLCBpLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgcy5zZWxlY3RlZCksIGkuc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLCBzLmRpc2FibGVkKSwgcy5zZWxlY3RlZCAmJiBpLnNldEF0dHJpYnV0ZShsYywgXCJcIiksIHMuZGlzYWJsZWQgJiYgaS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRcIiwgITApLCBzLmhpZGRlbiAmJiBjLmFkZENsYXNzKGksIFwiaGlkZGVuXCIpLCBpLmFwcGVuZENoaWxkKHVjKHMsIHQsIGUpKSwgcy5pY29uICYmIGkuYXBwZW5kQ2hpbGQoQm0ocywgZSkpLCBzLnNldE5vZGUoaSksIGk7XG59XG5mdW5jdGlvbiB1YyhzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBEKFwic3BhblwiKTtcbiAgaS5zZXRBdHRyaWJ1dGUod20sIFwiXCIpLCBjLmFkZENsYXNzKGksIGUuc2VsZWN0T3B0aW9uVGV4dCk7XG4gIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzLmxhYmVsKTtcbiAgcmV0dXJuIHQubXVsdGlwbGUgJiYgaS5hcHBlbmRDaGlsZChQbShzLCBlKSksIGkuYXBwZW5kQ2hpbGQobiksIChzLnNlY29uZGFyeVRleHQgfHwgdHlwZW9mIHMuc2Vjb25kYXJ5VGV4dCA9PSBcIm51bWJlclwiKSAmJiBpLmFwcGVuZENoaWxkKFxuICAgIFJtKHMuc2Vjb25kYXJ5VGV4dCwgZSlcbiAgKSwgaTtcbn1cbmZ1bmN0aW9uIFJtKHMsIHQpIHtcbiAgY29uc3QgZSA9IEQoXCJzcGFuXCIpO1xuICBjLmFkZENsYXNzKGUsIHQuc2VsZWN0T3B0aW9uU2Vjb25kYXJ5VGV4dCk7XG4gIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzKTtcbiAgcmV0dXJuIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG59XG5mdW5jdGlvbiBQbShzLCB0KSB7XG4gIGNvbnN0IGUgPSBEKFwiaW5wdXRcIik7XG4gIGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImNoZWNrYm94XCIpLCBjLmFkZENsYXNzKGUsIHQuZm9ybUNoZWNrSW5wdXQpLCBlLnNldEF0dHJpYnV0ZSh4bSwgXCJcIik7XG4gIGNvbnN0IGkgPSBEKFwibGFiZWxcIik7XG4gIHJldHVybiBzLnNlbGVjdGVkICYmIGUuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCAhMCksIHMuZGlzYWJsZWQgJiYgZS5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCAhMCksIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG59XG5mdW5jdGlvbiBCbShzLCB0KSB7XG4gIGNvbnN0IGUgPSBEKFwic3BhblwiKSwgaSA9IEQoXCJpbWdcIik7XG4gIHJldHVybiBjLmFkZENsYXNzKGksIHQuc2VsZWN0T3B0aW9uSWNvbiksIGkuc3JjID0gcy5pY29uLCBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gSG0ocywgdCwgZSkge1xuICBjb25zdCBpID0gRChcImRpdlwiKTtcbiAgaS5zZXRBdHRyaWJ1dGUoa20sIFwiXCIpLCBjLmFkZENsYXNzKGksIGUuc2VsZWN0T3B0aW9uR3JvdXApLCBpLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJncm91cFwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBzLmlkKSwgcy5oaWRkZW4gJiYgYy5hZGRDbGFzcyhpLCBcImhpZGRlblwiKTtcbiAgY29uc3QgbiA9IEQoXCJsYWJlbFwiKTtcbiAgcmV0dXJuIG4uc2V0QXR0cmlidXRlKE9tLCBcIlwiKSwgYy5hZGRDbGFzcyhuLCBlLnNlbGVjdE9wdGlvbkdyb3VwTGFiZWwpLCBjLmFkZFN0eWxlKG4sIHsgaGVpZ2h0OiBgJHt0LnNlbGVjdE9wdGlvbkhlaWdodH1weGAgfSksIG4uc2V0QXR0cmlidXRlKFwiZm9yXCIsIHMuaWQpLCBuLnRleHRDb250ZW50ID0gcy5sYWJlbCwgaS5hcHBlbmRDaGlsZChuKSwgcy5vcHRpb25zLmZvckVhY2goKG8pID0+IHtcbiAgICBpLmFwcGVuZENoaWxkKGRjKG8sIHQsIGUpKTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiBXbShzLCB0KSB7XG4gIGNvbnN0IGUgPSBEKFwiZGl2XCIpO1xuICByZXR1cm4gZS5pbm5lckhUTUwgPSBzLCBjLmFkZENsYXNzKGUsIHQuc2VsZWN0TGFiZWwpLCBjLmFkZENsYXNzKGUsIHQuc2VsZWN0RmFrZVZhbHVlKSwgZTtcbn1cbmNvbnN0IFBuID0gXCJzZWxlY3RcIiwgZmkgPSBcInRlLnNlbGVjdFwiLCBOaSA9IGAuJHtmaX1gLCBWbSA9IGBjbG9zZSR7Tml9YCwgRm0gPSBgb3BlbiR7Tml9YCwgeWEgPSBgb3B0aW9uU2VsZWN0JHtOaX1gLCB3YSA9IGBvcHRpb25EZXNlbGVjdCR7Tml9YCwgWW0gPSBgdmFsdWVDaGFuZ2Uke05pfWAsIGptID0gXCJjaGFuZ2VcIiwgeGEgPSBcImRhdGEtdGUtc2VsZWN0LWluaXRcIiwgcGMgPSBcImRhdGEtdGUtc2VsZWN0LW5vLXJlc3VsdHMtcmVmXCIsIGthID0gXCJkYXRhLXRlLXNlbGVjdC1vcGVuXCIsIHEgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIEt0ID0gXCJkYXRhLXRlLWlucHV0LWZvY3VzZWRcIiwgQm4gPSBcImRhdGEtdGUtaW5wdXQtZGlzYWJsZWRcIiwgS20gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1sYWJlbC1yZWZcIiwgem0gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1hbGwtcmVmXCIsIGNpID0gXCJkYXRhLXRlLXNlbGVjdC1zZWxlY3RlZFwiLCBVbSA9IFwiW2RhdGEtdGUtc2VsZWN0LWxhYmVsLXJlZl1cIiwgT2EgPSBcIltkYXRhLXRlLXNlbGVjdC1pbnB1dC1yZWZdXCIsIFhtID0gXCJbZGF0YS10ZS1zZWxlY3QtaW5wdXQtZmlsdGVyLXJlZl1cIiwgR20gPSBcIltkYXRhLXRlLXNlbGVjdC1kcm9wZG93bi1yZWZdXCIsIHFtID0gXCJbZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy13cmFwcGVyLXJlZl1cIiwgU2EgPSBcIltkYXRhLXRlLXNlbGVjdC1vcHRpb25zLWxpc3QtcmVmXVwiLCBabSA9IFwiW2RhdGEtdGUtc2VsZWN0LW9wdGlvbi1yZWZdXCIsIFFtID0gXCJbZGF0YS10ZS1zZWxlY3QtY2xlYXItYnRuLXJlZl1cIiwgSm0gPSBcIltkYXRhLXRlLXNlbGVjdC1jdXN0b20tY29udGVudC1yZWZdXCIsIHRnID0gYFske3BjfV1gLCBJYSA9IFwiW2RhdGEtdGUtc2VsZWN0LWZvcm0tb3V0bGluZS1yZWZdXCIsIGVnID0gXCJbZGF0YS10ZS1zZWxlY3QtdG9nZ2xlXVwiLCBIbiA9IFwiW2RhdGEtdGUtaW5wdXQtbm90Y2gtcmVmXVwiLCBpZyA9IDIwMCwgc2cgPSB7XG4gIHNlbGVjdEF1dG9TZWxlY3Q6ICExLFxuICBzZWxlY3RDb250YWluZXI6IFwiYm9keVwiLFxuICBzZWxlY3RDbGVhckJ1dHRvbjogITEsXG4gIGRpc2FibGVkOiAhMSxcbiAgc2VsZWN0RGlzcGxheWVkTGFiZWxzOiA1LFxuICBzZWxlY3RGb3JtV2hpdGU6ICExLFxuICBtdWx0aXBsZTogITEsXG4gIHNlbGVjdE9wdGlvbnNTZWxlY3RlZExhYmVsOiBcIm9wdGlvbnMgc2VsZWN0ZWRcIixcbiAgc2VsZWN0T3B0aW9uSGVpZ2h0OiAzOCxcbiAgc2VsZWN0QWxsOiAhMCxcbiAgc2VsZWN0QWxsTGFiZWw6IFwiU2VsZWN0IGFsbFwiLFxuICBzZWxlY3RTZWFyY2hQbGFjZWhvbGRlcjogXCJTZWFyY2guLi5cIixcbiAgc2VsZWN0U2l6ZTogXCJkZWZhdWx0XCIsXG4gIHNlbGVjdFZpc2libGVPcHRpb25zOiA1LFxuICBzZWxlY3RGaWx0ZXI6ICExLFxuICBzZWxlY3RGaWx0ZXJEZWJvdW5jZTogMzAwLFxuICBzZWxlY3ROb1Jlc3VsdFRleHQ6IFwiTm8gcmVzdWx0c1wiLFxuICBzZWxlY3RWYWxpZGF0aW9uOiAhMSxcbiAgc2VsZWN0VmFsaWRGZWVkYmFjazogXCJWYWxpZFwiLFxuICBzZWxlY3RJbnZhbGlkRmVlZGJhY2s6IFwiSW52YWxpZFwiLFxuICBzZWxlY3RQbGFjZWhvbGRlcjogXCJcIlxufSwgbmcgPSB7XG4gIHNlbGVjdEF1dG9TZWxlY3Q6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnV0dG9uOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZWQ6IFwiYm9vbGVhblwiLFxuICBzZWxlY3REaXNwbGF5ZWRMYWJlbHM6IFwibnVtYmVyXCIsXG4gIHNlbGVjdEZvcm1XaGl0ZTogXCJib29sZWFuXCIsXG4gIG11bHRpcGxlOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0T3B0aW9uc1NlbGVjdGVkTGFiZWw6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbkhlaWdodDogXCJudW1iZXJcIixcbiAgc2VsZWN0QWxsOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0QWxsTGFiZWw6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFNlYXJjaFBsYWNlaG9sZGVyOiBcInN0cmluZ1wiLFxuICBzZWxlY3RTaXplOiBcInN0cmluZ1wiLFxuICBzZWxlY3RWaXNpYmxlT3B0aW9uczogXCJudW1iZXJcIixcbiAgc2VsZWN0RmlsdGVyOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0RmlsdGVyRGVib3VuY2U6IFwibnVtYmVyXCIsXG4gIHNlbGVjdE5vUmVzdWx0VGV4dDogXCJzdHJpbmdcIixcbiAgc2VsZWN0VmFsaWRhdGlvbjogXCJib29sZWFuXCIsXG4gIHNlbGVjdFZhbGlkRmVlZGJhY2s6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEludmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgc2VsZWN0UGxhY2Vob2xkZXI6IFwic3RyaW5nXCJcbn0sIG9nID0ge1xuICBkcm9wZG93bjogXCJyZWxhdGl2ZSBvdXRsaW5lLW5vbmUgbWluLXctWzEwMHB4XSBtLTAgc2NhbGUtWzAuOF0gb3BhY2l0eS0wIGJnLXdoaXRlIHNoYWRvdy1bMF8ycHhfNXB4XzBfcmdiYSgwLDAsMCwwLjE2KSxfMF8ycHhfMTBweF8wX3JnYmEoMCwwLDAsMC4xMildIHRyYW5zaXRpb24gZHVyYXRpb24tMjAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhdGEtW3RlLXNlbGVjdC1vcGVuXTpzY2FsZS0xMDAgZGF0YS1bdGUtc2VsZWN0LW9wZW5dOm9wYWNpdHktMTAwIGRhcms6YmctemluYy03MDBcIixcbiAgZm9ybUNoZWNrSW5wdXQ6IFwicmVsYXRpdmUgZmxvYXQtbGVmdCBtdC1bMC4xNXJlbV0gbXItWzhweF0gaC1bMS4xMjVyZW1dIHctWzEuMTI1cmVtXSBhcHBlYXJhbmNlLW5vbmUgcm91bmRlZC1bMC4yNXJlbV0gYm9yZGVyLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1uZXV0cmFsLTMwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBvdXRsaW5lLW5vbmUgYmVmb3JlOnBvaW50ZXItZXZlbnRzLW5vbmUgYmVmb3JlOmFic29sdXRlIGJlZm9yZTpoLVswLjg3NXJlbV0gYmVmb3JlOnctWzAuODc1cmVtXSBiZWZvcmU6c2NhbGUtMCBiZWZvcmU6cm91bmRlZC1mdWxsIGJlZm9yZTpiZy10cmFuc3BhcmVudCBiZWZvcmU6b3BhY2l0eS0wIGJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfdHJhbnNwYXJlbnRdIGJlZm9yZTpjb250ZW50LVsnJ10gY2hlY2tlZDpib3JkZXItcHJpbWFyeSBkYXJrOmNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgY2hlY2tlZDpiZy1wcmltYXJ5IGRhcms6Y2hlY2tlZDpiZy1wcmltYXJ5IGNoZWNrZWQ6YmVmb3JlOm9wYWNpdHktWzAuMTZdIGNoZWNrZWQ6YWZ0ZXI6YWJzb2x1dGUgY2hlY2tlZDphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDphZnRlcjotbXQtcHggY2hlY2tlZDphZnRlcjpibG9jayBjaGVja2VkOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmFmdGVyOmJvcmRlci10LTAgY2hlY2tlZDphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgY2hlY2tlZDphZnRlcjpjb250ZW50LVsnJ10gaG92ZXI6Y3Vyc29yLXBvaW50ZXIgaG92ZXI6YmVmb3JlOm9wYWNpdHktWzAuMDRdIGhvdmVyOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBmb2N1czpzaGFkb3ctbm9uZSBmb2N1czp0cmFuc2l0aW9uLVtib3JkZXItY29sb3JfMC4yc10gZm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBmb2N1czpiZWZvcmU6b3BhY2l0eS1bMC4xMl0gZm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGRhcms6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDI1NSwyNTUsMjU1LDAuNCldIGZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGZvY3VzOmFmdGVyOmFic29sdXRlIGZvY3VzOmFmdGVyOnotWzFdIGZvY3VzOmFmdGVyOmJsb2NrIGZvY3VzOmFmdGVyOmgtWzAuODc1cmVtXSBmb2N1czphZnRlcjp3LVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6cm91bmRlZC1bMC4xMjVyZW1dIGZvY3VzOmFmdGVyOmNvbnRlbnQtWycnXSBjaGVja2VkOmZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgY2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGRhcms6Y2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gY2hlY2tlZDpmb2N1czphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjotbXQtcHggY2hlY2tlZDpmb2N1czphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm91bmRlZC1ub25lIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJnLXRyYW5zcGFyZW50XCIsXG4gIGZvcm1PdXRsaW5lOiBcInJlbGF0aXZlXCIsXG4gIGluaXRpYWxpemVkOiBcImhpZGRlblwiLFxuICBpbnB1dEdyb3VwOiBcImZsZXggaXRlbXMtY2VudGVyIHdoaXRlc3BhY2Utbm93cmFwIHAtMi41IHRleHQtY2VudGVyIHRleHQtYmFzZSBmb250LW5vcm1hbCBsZWFkaW5nLVsxLjZdIHRleHQtZ3JheS03MDAgZGFyazpiZy16aW5jLTgwMCBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwXCIsXG4gIG5vUmVzdWx0OiBcImZsZXggaXRlbXMtY2VudGVyIHB4LTRcIixcbiAgb3B0aW9uc0xpc3Q6IFwibGlzdC1ub25lIG0tMCBwLTBcIixcbiAgb3B0aW9uc1dyYXBwZXI6IFwib3ZlcmZsb3cteS1hdXRvXCIsXG4gIG9wdGlvbnNXcmFwcGVyU2Nyb2xsYmFyOiBcIlsmOjotd2Via2l0LXNjcm9sbGJhcl06dy0xIFsmOjotd2Via2l0LXNjcm9sbGJhcl06aC0xIFsmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b25dOmJsb2NrIFsmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b25dOmgtMCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXTpiZy10cmFuc3BhcmVudCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOmJnLXRyYW5zcGFyZW50IFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06cm91bmRlZC1ub25lIFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06IFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06cm91bmRlZC1sIFsmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYl06aC1bNTBweF0gWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iXTpiZy1bIzk5OV0gWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iXTpyb3VuZGVkXCIsXG4gIHNlbGVjdEFycm93OiBcImFic29sdXRlIHJpZ2h0LTMgdGV4dC1bMC44cmVtXSBjdXJzb3ItcG9pbnRlciBwZWVyLWZvY3VzOnRleHQtcHJpbWFyeSBwZWVyLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnRleHQtcHJpbWFyeSBncm91cC1kYXRhLVt0ZS13YXMtdmFsaWRhdGVkXS92YWxpZGF0aW9uOnBlZXItdmFsaWQ6dGV4dC1ncmVlbi02MDAgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLWludmFsaWQ6dGV4dC1bcmdiKDIyMCw3NiwxMDApXSB3LTUgaC01XCIsXG4gIHNlbGVjdEFycm93V2hpdGU6IFwidGV4dC1ncmF5LTUwIHBlZXItZm9jdXM6IXRleHQtd2hpdGUgcGVlci1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTohdGV4dC13aGl0ZVwiLFxuICBzZWxlY3RBcnJvd0RlZmF1bHQ6IFwidG9wLTJcIixcbiAgc2VsZWN0QXJyb3dMZzogXCJ0b3AtWzEzcHhdXCIsXG4gIHNlbGVjdEFycm93U206IFwidG9wLTFcIixcbiAgc2VsZWN0Q2xlYXJCdG46IFwiYWJzb2x1dGUgdG9wLTIgcmlnaHQtOSB0ZXh0LWJsYWNrIGN1cnNvci1wb2ludGVyIGZvY3VzOnRleHQtcHJpbWFyeSBvdXRsaW5lLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwXCIsXG4gIHNlbGVjdENsZWFyQnRuV2hpdGU6IFwiIXRleHQtZ3JheS01MFwiLFxuICBzZWxlY3RDbGVhckJ0bkRlZmF1bHQ6IFwidG9wLTIgdGV4dC1iYXNlXCIsXG4gIHNlbGVjdENsZWFyQnRuTGc6IFwidG9wLVsxMXB4XSB0ZXh0LWJhc2VcIixcbiAgc2VsZWN0Q2xlYXJCdG5TbTogXCJ0b3AtMSB0ZXh0LVswLjhyZW1dXCIsXG4gIHNlbGVjdERyb3Bkb3duQ29udGFpbmVyOiBcInotWzEwNzBdXCIsXG4gIHNlbGVjdEZha2VWYWx1ZTogXCJ0cmFuc2Zvcm0tbm9uZSBoaWRkZW4gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpibG9ja1wiLFxuICBzZWxlY3RGaWx0ZXJJbnB1dDogXCJyZWxhdGl2ZSBtLTAgYmxvY2sgdy1mdWxsIG1pbi13LTAgZmxleC1hdXRvIHJvdW5kZWQgYm9yZGVyIGJvcmRlci1zb2xpZCBib3JkZXItZ3JheS0zMDAgYmctdHJhbnNwYXJlbnQgYmctY2xpcC1wYWRkaW5nIHB4LTMgcHktMS41IHRleHQtYmFzZSBmb250LW5vcm1hbCB0ZXh0LWdyYXktNzAwIHRyYW5zaXRpb24gZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0IG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGZvY3VzOmJvcmRlci1wcmltYXJ5IGZvY3VzOnRleHQtZ3JheS03MDAgZm9jdXM6c2hhZG93LXRlLXByaW1hcnkgZm9jdXM6b3V0bGluZS1ub25lIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBsYWNlaG9sZGVyOnRleHQtZ3JheS0yMDBcIixcbiAgc2VsZWN0SW5wdXQ6IFwicGVlciBibG9jayBtaW4taC1bYXV0b10gdy1mdWxsIHJvdW5kZWQgYm9yZGVyLTAgYmctdHJhbnNwYXJlbnQgb3V0bGluZS1ub25lIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBmb2N1czpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOnBsYWNlaG9sZGVyOm9wYWNpdHktMTAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBsYWNlaG9sZGVyOnRleHQtZ3JheS0yMDAgWyY6bm90KFtkYXRhLXRlLWlucHV0LXBsYWNlaG9sZGVyLWFjdGl2ZV0pXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTAgY3Vyc29yLXBvaW50ZXIgZGF0YS1bdGUtaW5wdXQtZGlzYWJsZWRdOmJnLVsjZTllY2VmXSBkYXRhLVt0ZS1pbnB1dC1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjptYi00IGRhcms6ZGF0YS1bdGUtaW5wdXQtZGlzYWJsZWRdOmJnLXppbmMtNjAwXCIsXG4gIHNlbGVjdElucHV0V2hpdGU6IFwiIXRleHQtZ3JheS01MFwiLFxuICBzZWxlY3RJbnB1dFNpemVEZWZhdWx0OiBcInB5LVswLjMycmVtXSBweC0zIGxlYWRpbmctWzEuNl1cIixcbiAgc2VsZWN0SW5wdXRTaXplTGc6IFwicHktWzAuMzJyZW1dIHB4LTMgbGVhZGluZy1bMi4xNV1cIixcbiAgc2VsZWN0SW5wdXRTaXplU206IFwicHktWzAuMzNyZW1dIHB4LTMgdGV4dC14cyBsZWFkaW5nLVsxLjVdXCIsXG4gIHNlbGVjdExhYmVsOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG9wLTAgbGVmdC0zIG1iLTAgbWF4LXctWzkwJV0gb3JpZ2luLVswXzBdIHRydW5jYXRlIHRleHQtZ3JheS01MDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2Utb3V0IHBlZXItZm9jdXM6c2NhbGUtWzAuOF0gcGVlci1mb2N1czp0ZXh0LXByaW1hcnkgcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOnNjYWxlLVswLjhdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBlZXItZm9jdXM6dGV4dC1ncmF5LTIwMCBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOnNjYWxlLVswLjhdIGRhcms6cGVlci1mb2N1czp0ZXh0LXByaW1hcnlcIixcbiAgc2VsZWN0TGFiZWxXaGl0ZTogXCIhdGV4dC1ncmF5LTUwXCIsXG4gIHNlbGVjdExhYmVsU2l6ZURlZmF1bHQ6IFwicHQtWzAuMzdyZW1dIGxlYWRpbmctWzEuNl0gcGVlci1mb2N1czotdHJhbnNsYXRlLXktWzAuOXJlbV0gcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC45cmVtXSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC45cmVtXVwiLFxuICBzZWxlY3RMYWJlbFNpemVMZzogXCJwdC1bMC4zN3JlbV0gbGVhZGluZy1bMi4xNV0gcGVlci1mb2N1czotdHJhbnNsYXRlLXktWzEuMTVyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzEuMTVyZW1dIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVsxLjE1cmVtXVwiLFxuICBzZWxlY3RMYWJlbFNpemVTbTogXCJwdC1bMC4zN3JlbV0gdGV4dC14cyBsZWFkaW5nLVsxLjVdIHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVswLjc1cmVtXSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVswLjc1cmVtXSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC43NXJlbV1cIixcbiAgc2VsZWN0T3B0aW9uOiBcImZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiB3LWZ1bGwgcHgtNCB0cnVuY2F0ZSB0ZXh0LWdyYXktNzAwIGJnLXRyYW5zcGFyZW50IHNlbGVjdC1ub25lIGN1cnNvci1wb2ludGVyIGRhdGEtW3RlLWlucHV0LW11bHRpcGxlLWFjdGl2ZV06YmctYmxhY2svNSBob3ZlcjpbJjpub3QoW2RhdGEtdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF0pXTpiZy1ibGFjay81IGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06YmctYmxhY2svNSBkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLXNlbGVjdGVkXTpkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJnLWJsYWNrLzUgZGF0YS1bdGUtc2VsZWN0LXNlbGVjdGVkXTpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTpjdXJzb3ItZGVmYXVsdCBkYXRhLVt0ZS1zZWxlY3Qtc2VsZWN0ZWRdOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOnRleHQtZ3JheS00MDAgZGF0YS1bdGUtc2VsZWN0LXNlbGVjdGVkXTpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTpiZy10cmFuc3BhcmVudCBkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLXNlbGVjdGVkXTpiZy1ibGFjay9bMC4wMl0gZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06dGV4dC1ncmF5LTQwMCBkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTpjdXJzb3ItZGVmYXVsdCBncm91cC1kYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWdyb3VwLXJlZl0vb3B0OnBsLTcgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6aG92ZXI6WyY6bm90KFtkYXRhLXRlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdKV06Ymctd2hpdGUvMzAgZGFyazpkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJnLXdoaXRlLzMwIGRhcms6ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1zZWxlY3RlZF06ZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy13aGl0ZS8zMCBkYXJrOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOnRleHQtZ3JheS00MDAgZGFyazpkYXRhLVt0ZS1pbnB1dC1tdWx0aXBsZS1hY3RpdmVdOmJnLXdoaXRlLzMwXCIsXG4gIHNlbGVjdE9wdGlvbkdyb3VwOiBcImdyb3VwL29wdFwiLFxuICBzZWxlY3RPcHRpb25Hcm91cExhYmVsOiBcImZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIHctZnVsbCBweC00IHRydW5jYXRlIGJnLXRyYW5zcGFyZW50IHRleHQtYmxhY2svNTAgc2VsZWN0LW5vbmUgZGFyazp0ZXh0LWdyYXktMzAwXCIsXG4gIHNlbGVjdE9wdGlvbkljb246IFwidy03IGgtNyByb3VuZGVkLWZ1bGxcIixcbiAgc2VsZWN0T3B0aW9uU2Vjb25kYXJ5VGV4dDogXCJibG9jayB0ZXh0LVswLjhyZW1dIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktMzAwXCIsXG4gIHNlbGVjdE9wdGlvblRleHQ6IFwiZ3JvdXBcIixcbiAgc2VsZWN0VmFsaWRhdGlvblZhbGlkOiBcImhpZGRlbiBhYnNvbHV0ZSAtbXQtMyB3LWF1dG8gdGV4dC1zbSB0ZXh0LWdyZWVuLTYwMCBjdXJzb3ItcG9pbnRlciBncm91cC1kYXRhLVt0ZS13YXMtdmFsaWRhdGVkXS92YWxpZGF0aW9uOnBlZXItdmFsaWQ6YmxvY2tcIixcbiAgc2VsZWN0VmFsaWRhdGlvbkludmFsaWQ6IFwiaGlkZGVuIGFic29sdXRlIC1tdC0zIHctYXV0byB0ZXh0LXNtIHRleHQtW3JnYigyMjAsNzYsMTAwKV0gY3Vyc29yLXBvaW50ZXIgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLWludmFsaWQ6YmxvY2tcIlxufSwgcmcgPSB7XG4gIGRyb3Bkb3duOiBcInN0cmluZ1wiLFxuICBmb3JtQ2hlY2tJbnB1dDogXCJzdHJpbmdcIixcbiAgZm9ybU91dGxpbmU6IFwic3RyaW5nXCIsXG4gIGluaXRpYWxpemVkOiBcInN0cmluZ1wiLFxuICBpbnB1dEdyb3VwOiBcInN0cmluZ1wiLFxuICBub1Jlc3VsdDogXCJzdHJpbmdcIixcbiAgb3B0aW9uc0xpc3Q6IFwic3RyaW5nXCIsXG4gIG9wdGlvbnNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBvcHRpb25zV3JhcHBlclNjcm9sbGJhcjogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3c6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEFycm93RGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3dMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3dTbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG46IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnRuRGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG5MZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG5TbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0RHJvcGRvd25Db250YWluZXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEZha2VWYWx1ZTogXCJzdHJpbmdcIixcbiAgc2VsZWN0RmlsdGVySW5wdXQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdElucHV0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dFNpemVEZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dFNpemVMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW5wdXRTaXplU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdExhYmVsOiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbFNpemVEZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbFNpemVMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0TGFiZWxTaXplU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbjogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uR3JvdXA6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbkdyb3VwTGFiZWw6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbkljb246IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvblNlY29uZGFyeVRleHQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvblRleHQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyAkbyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fY29uZmlnLnNlbGVjdFBsYWNlaG9sZGVyICYmICF0aGlzLl9jb25maWcubXVsdGlwbGUgJiYgdGhpcy5fYWRkUGxhY2Vob2xkZXJPcHRpb24oKSwgdGhpcy5fb3B0aW9uc1RvUmVuZGVyID0gdGhpcy5fZ2V0T3B0aW9uc1RvUmVuZGVyKHQpLCB0aGlzLl9wbGFpbk9wdGlvbnMgPSB0aGlzLl9nZXRQbGFpbk9wdGlvbnModGhpcy5fb3B0aW9uc1RvUmVuZGVyKSwgdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA9IG51bGwsIHRoaXMuX3NlbGVjdGlvbk1vZGVsID0gbmV3IF9tKHRoaXMubXVsdGlwbGUpLCB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCA9IC0xLCB0aGlzLl9hY3RpdmVPcHRpb24gPSBudWxsLCB0aGlzLl93cmFwcGVySWQgPSBidChcInNlbGVjdC13cmFwcGVyLVwiKSwgdGhpcy5fZHJvcGRvd25Db250YWluZXJJZCA9IGJ0KFwic2VsZWN0LWRyb3Bkb3duLWNvbnRhaW5lci1cIiksIHRoaXMuX3NlbGVjdEFsbElkID0gYnQoXCJzZWxlY3QtYWxsLVwiKSwgdGhpcy5fZGVib3VuY2VUaW1lb3V0SWQgPSBudWxsLCB0aGlzLl9kcm9wZG93bkhlaWdodCA9IHRoaXMuX2NvbmZpZy5zZWxlY3RPcHRpb25IZWlnaHQgKiB0aGlzLl9jb25maWcuc2VsZWN0VmlzaWJsZU9wdGlvbnMsIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2lucHV0ID0gbnVsbCwgdGhpcy5fbGFiZWwgPSBkLm5leHQodGhpcy5fZWxlbWVudCwgVW0pWzBdLCB0aGlzLl9ub3RjaCA9IG51bGwsIHRoaXMuX2Zha2VWYWx1ZSA9IG51bGwsIHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID0gITEsIHRoaXMuX2N1c3RvbUNvbnRlbnQgPSBkLm5leHQoXG4gICAgICB0LFxuICAgICAgSm1cbiAgICApWzBdLCB0aGlzLl90b2dnbGVCdXR0b24gPSBudWxsLCB0aGlzLl9lbGVtZW50VG9nZ2xlID0gbnVsbCwgdGhpcy5fd3JhcHBlciA9IG51bGwsIHRoaXMuX2lucHV0RWwgPSBudWxsLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciA9IG51bGwsIHRoaXMuX2NvbnRhaW5lciA9IG51bGwsIHRoaXMuX3NlbGVjdEFsbE9wdGlvbiA9IG51bGwsIHRoaXMuX2luaXQoKSwgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGwsIHRoaXMuX2lzT3BlbiA9ICExLCB0aGlzLl9hZGRNdXRhdGlvbk9ic2VydmVyKCksIHRoaXMuX2VsZW1lbnQgJiYgSS5zZXREYXRhKHQsIGZpLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFBuO1xuICB9XG4gIGdldCBmaWx0ZXJJbnB1dCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgWG0sXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lclxuICAgICk7XG4gIH1cbiAgZ2V0IGRyb3Bkb3duKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoR20sIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKTtcbiAgfVxuICBnZXQgb3B0aW9uc0xpc3QoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIFNhLFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJcbiAgICApO1xuICB9XG4gIGdldCBvcHRpb25zV3JhcHBlcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgcW0sXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lclxuICAgICk7XG4gIH1cbiAgZ2V0IGNsZWFyQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoUW0sIHRoaXMuX3dyYXBwZXIpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID8gdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA6IHRoaXMuX3BsYWluT3B0aW9ucztcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC52YWx1ZXMgOiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC52YWx1ZTtcbiAgfVxuICBnZXQgbXVsdGlwbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5tdWx0aXBsZTtcbiAgfVxuICBnZXQgaGFzU2VsZWN0QWxsKCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGxlICYmIHRoaXMuX2NvbmZpZy5zZWxlY3RBbGw7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gMDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnNnLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShcIm11bHRpcGxlXCIpICYmICh0Lm11bHRpcGxlID0gITApLCB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpICYmICh0LmRpc2FibGVkID0gITApLCB0aGlzLl9lbGVtZW50LnRhYkluZGV4ICYmICh0LnRhYkluZGV4ID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiKSksIEwoUG4sIHQsIG5nKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLm9nLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKFBuLCB0LCByZyksIHQ7XG4gIH1cbiAgX2FkZFBsYWNlaG9sZGVyT3B0aW9uKCkge1xuICAgIGNvbnN0IHQgPSBuZXcgT3B0aW9uKFwiXCIsIFwiXCIsICEwLCAhMCk7XG4gICAgdC5oaWRkZW4gPSAhMCwgdC5zZWxlY3RlZCA9ICEwLCB0aGlzLl9lbGVtZW50LnByZXBlbmQodCk7XG4gIH1cbiAgX2dldE9wdGlvbnNUb1JlbmRlcih0KSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHJldHVybiB0LmNoaWxkTm9kZXMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgaWYgKG4ubm9kZU5hbWUgPT09IFwiT1BUR1JPVVBcIikge1xuICAgICAgICBjb25zdCBvID0ge1xuICAgICAgICAgIGlkOiBidChcImdyb3VwLVwiKSxcbiAgICAgICAgICBsYWJlbDogbi5sYWJlbCxcbiAgICAgICAgICBkaXNhYmxlZDogbi5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSxcbiAgICAgICAgICBoaWRkZW46IG4uaGFzQXR0cmlidXRlKFwiaGlkZGVuXCIpLFxuICAgICAgICAgIG9wdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIG4uY2hpbGROb2Rlcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgICAgYS5ub2RlTmFtZSA9PT0gXCJPUFRJT05cIiAmJiBvLm9wdGlvbnMucHVzaChcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU9wdGlvbk9iamVjdChhLCBvKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pLCBlLnB1c2gobyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbi5ub2RlTmFtZSA9PT0gXCJPUFRJT05cIiAmJiBlLnB1c2godGhpcy5fY3JlYXRlT3B0aW9uT2JqZWN0KG4pKTtcbiAgICB9KSwgZTtcbiAgfVxuICBfZ2V0UGxhaW5PcHRpb25zKHQpIHtcbiAgICBpZiAoIWQuZmluZE9uZShcIm9wdGdyb3VwXCIsIHRoaXMuX2VsZW1lbnQpKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgaSA9IFtdO1xuICAgIHJldHVybiB0LmZvckVhY2goKG4pID0+IHtcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgICAgbixcbiAgICAgICAgXCJvcHRpb25zXCJcbiAgICAgICkgPyBuLm9wdGlvbnMuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICBpLnB1c2gocik7XG4gICAgICB9KSA6IGkucHVzaChuKTtcbiAgICB9KSwgaTtcbiAgfVxuICBfY3JlYXRlT3B0aW9uT2JqZWN0KHQsIGUgPSB7fSkge1xuICAgIGNvbnN0IGkgPSBidChcIm9wdGlvbi1cIiksIG4gPSBlLmlkID8gZS5pZCA6IG51bGwsIG8gPSBlLmRpc2FibGVkID8gZS5kaXNhYmxlZCA6ICExLCByID0gdC5zZWxlY3RlZCB8fCB0Lmhhc0F0dHJpYnV0ZShjaSksIGEgPSB0Lmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpIHx8IG8sIGwgPSB0Lmhhc0F0dHJpYnV0ZShcImhpZGRlblwiKSB8fCBlICYmIGUuaGlkZGVuLCBwID0gdGhpcy5tdWx0aXBsZSwgdSA9IHQudmFsdWUsIGYgPSB0LmxhYmVsLCBfID0gYy5nZXREYXRhQXR0cmlidXRlKFxuICAgICAgdCxcbiAgICAgIFwic2VsZWN0U2Vjb25kYXJ5VGV4dFwiXG4gICAgKSwgbSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInNlbGVjdC1pY29uXCIpO1xuICAgIHJldHVybiBuZXcgQ2EoXG4gICAgICBpLFxuICAgICAgdCxcbiAgICAgIHAsXG4gICAgICB1LFxuICAgICAgZixcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbCxcbiAgICAgIF8sXG4gICAgICBuLFxuICAgICAgbVxuICAgICk7XG4gIH1cbiAgX2dldE5hdmlnYXRpb25PcHRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMuZmlsdGVyKChlKSA9PiAhZS5oaWRkZW4pO1xuICAgIHJldHVybiB0aGlzLmhhc1NlbGVjdEFsbCA/IFt0aGlzLl9zZWxlY3RBbGxPcHRpb24sIC4uLnRdIDogdDtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9yZW5kZXJNYXRlcmlhbFdyYXBwZXIoKSwgdGhpcy5fd3JhcHBlciA9IGQuZmluZE9uZShgIyR7dGhpcy5fd3JhcHBlcklkfWApLCB0aGlzLl9pbnB1dCA9IGQuZmluZE9uZShPYSwgdGhpcy5fd3JhcHBlciksIHRoaXMuX2NvbmZpZy5kaXNhYmxlZCAmJiB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoQm4sIFwiXCIpO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuc2VsZWN0Q29udGFpbmVyO1xuICAgIHQgPT09IFwiYm9keVwiID8gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuYm9keSA6IHRoaXMuX2NvbnRhaW5lciA9IGQuZmluZE9uZSh0KSwgdGhpcy5faW5pdE91dGxpbmVJbnB1dCgpLCB0aGlzLl9zZXREZWZhdWx0U2VsZWN0aW9ucygpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX2FwcGVuZEZha2VWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpLCB0aGlzLl9iaW5kQ29tcG9uZW50RXZlbnRzKCksIHRoaXMuaGFzU2VsZWN0QWxsICYmICh0aGlzLl9zZWxlY3RBbGxPcHRpb24gPSB0aGlzLl9jcmVhdGVTZWxlY3RBbGxPcHRpb24oKSksIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyID0gQWEoXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkLFxuICAgICAgdGhpcy5fY29uZmlnLFxuICAgICAgdGhpcy5faW5wdXQub2Zmc2V0V2lkdGgsXG4gICAgICB0aGlzLl9kcm9wZG93bkhlaWdodCxcbiAgICAgIHRoaXMuX3NlbGVjdEFsbE9wdGlvbixcbiAgICAgIHRoaXMuX29wdGlvbnNUb1JlbmRlcixcbiAgICAgIHRoaXMuX2N1c3RvbUNvbnRlbnQsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSwgdGhpcy5fbGlzdGVuVG9Gb2N1c0NoYW5nZSgpO1xuICB9XG4gIF9yZW5kZXJNYXRlcmlhbFdyYXBwZXIoKSB7XG4gICAgY29uc3QgdCA9IERtKFxuICAgICAgdGhpcy5fd3JhcHBlcklkLFxuICAgICAgdGhpcy5fY29uZmlnLFxuICAgICAgdGhpcy5fbGFiZWwsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsIHRoaXMuX2VsZW1lbnQpLCBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaW5pdGlhbGl6ZWQpLCB0LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9pbml0T3V0bGluZUlucHV0KCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICBJYSxcbiAgICAgIHRoaXMuX3dyYXBwZXJcbiAgICApO1xuICAgIG5ldyBXKFxuICAgICAgdCxcbiAgICAgIHtcbiAgICAgICAgaW5wdXRGb3JtV2hpdGU6IHRoaXMuX2NvbmZpZy5zZWxlY3RGb3JtV2hpdGVcbiAgICAgIH0sXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKS5pbml0KCksIHRoaXMuX25vdGNoID0gZC5maW5kT25lKEhuLCB0aGlzLl93cmFwcGVyKTtcbiAgfVxuICBfYmluZENvbXBvbmVudEV2ZW50cygpIHtcbiAgICB0aGlzLl9saXN0ZW5Ub0NvbXBvbmVudEtleWRvd24oKSwgdGhpcy5fbGlzdGVuVG9XcmFwcGVyQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9DbGVhckJ0bkNsaWNrKCksIHRoaXMuX2xpc3RlblRvQ2xlYXJCdG5LZXlkb3duKCk7XG4gIH1cbiAgX3NldERlZmF1bHRTZWxlY3Rpb25zKCkge1xuICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LnNlbGVjdGVkICYmIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdCh0KTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9Db21wb25lbnRLZXlkb3duKCkge1xuICAgIGgub24odGhpcy5fd3JhcHBlciwgXCJrZXlkb3duXCIsIHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKSk7XG4gIH1cbiAgX2hhbmRsZUtleWRvd24odCkge1xuICAgIHRoaXMuX2lzT3BlbiAmJiAhdGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlciA/IHRoaXMuX2hhbmRsZU9wZW5LZXlkb3duKHQpIDogdGhpcy5faGFuZGxlQ2xvc2VkS2V5ZG93bih0KTtcbiAgfVxuICBfaGFuZGxlT3BlbktleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0LmtleUNvZGUsIGkgPSBlID09PSBMaSB8fCBlID09PSBydCAmJiB0LmFsdEtleSB8fCBlID09PSBPaTtcbiAgICBpZiAoZSA9PT0gT2kgJiYgdGhpcy5fY29uZmlnLnNlbGVjdEF1dG9TZWxlY3QgJiYgIXRoaXMubXVsdGlwbGUgJiYgdGhpcy5faGFuZGxlQXV0b1NlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pLCBpKSB7XG4gICAgICB0aGlzLmNsb3NlKCksIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZSkge1xuICAgICAgY2FzZSB6OlxuICAgICAgICB0aGlzLl9zZXROZXh0T3B0aW9uQWN0aXZlKCksIHRoaXMuX3Njcm9sbFRvT3B0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBydDpcbiAgICAgICAgdGhpcy5fc2V0UHJldmlvdXNPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhlOlxuICAgICAgICB0aGlzLl9zZXRGaXJzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgV2U6XG4gICAgICAgIHRoaXMuX3NldExhc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGx0OlxuICAgICAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2FjdGl2ZU9wdGlvbiAmJiAodGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPT09IDAgPyB0aGlzLl9oYW5kbGVTZWxlY3RBbGwoKSA6IHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2hhbmRsZUNsb3NlZEtleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0LmtleUNvZGU7XG4gICAgaWYgKGUgPT09IGx0ICYmIHQucHJldmVudERlZmF1bHQoKSwgKGUgPT09IGx0IHx8IGUgPT09IHogJiYgdC5hbHRLZXkgfHwgZSA9PT0geiAmJiB0aGlzLm11bHRpcGxlKSAmJiB0aGlzLm9wZW4oKSwgdGhpcy5tdWx0aXBsZSlcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIHo6XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgcnQ6XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIHo6XG4gICAgICAgICAgdGhpcy5fc2V0TmV4dE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBydDpcbiAgICAgICAgICB0aGlzLl9zZXRQcmV2aW91c09wdGlvbkFjdGl2ZSgpLCB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIZTpcbiAgICAgICAgICB0aGlzLl9zZXRGaXJzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBXZTpcbiAgICAgICAgICB0aGlzLl9zZXRMYXN0T3B0aW9uQWN0aXZlKCksIHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX3Njcm9sbFRvT3B0aW9uKHQpIHtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGU7XG4gICAgY29uc3QgaSA9IHRoaXMub3B0aW9ucy5maWx0ZXIoKHUpID0+ICF1LmhpZGRlbik7XG4gICAgdGhpcy5oYXNTZWxlY3RBbGwgPyBlID0gaS5pbmRleE9mKHQpICsgMSA6IGUgPSBpLmluZGV4T2YodCk7XG4gICAgY29uc3QgbiA9IHRoaXMuX2dldE51bWJlck9mR3JvdXBzQmVmb3JlT3B0aW9uKGUpLCBvID0gZSArIG4sIHIgPSB0aGlzLm9wdGlvbnNXcmFwcGVyLCBhID0gci5vZmZzZXRIZWlnaHQsIGwgPSB0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uSGVpZ2h0LCBwID0gci5zY3JvbGxUb3A7XG4gICAgaWYgKGUgPiAtMSkge1xuICAgICAgY29uc3QgdSA9IG8gKiBsLCBmID0gdSArIGwgPiBwICsgYTtcbiAgICAgIHUgPCBwID8gci5zY3JvbGxUb3AgPSB1IDogZiA/IHIuc2Nyb2xsVG9wID0gdSAtIGEgKyBsIDogci5zY3JvbGxUb3AgPSBwO1xuICAgIH1cbiAgfVxuICBfZ2V0TnVtYmVyT2ZHcm91cHNCZWZvcmVPcHRpb24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbnMuZmlsdGVyKChyKSA9PiAhci5oaWRkZW4pLCBpID0gdGhpcy5fb3B0aW9uc1RvUmVuZGVyLmZpbHRlcigocikgPT4gIXIuaGlkZGVuKSwgbiA9IHRoaXMuaGFzU2VsZWN0QWxsID8gdCAtIDEgOiB0O1xuICAgIGxldCBvID0gMDtcbiAgICBmb3IgKGxldCByID0gMDsgciA8PSBuOyByKyspXG4gICAgICBlW3JdLmdyb3VwSWQgJiYgaVtvXSAmJiBpW29dLmlkICYmIGVbcl0uZ3JvdXBJZCA9PT0gaVtvXS5pZCAmJiBvKys7XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgX3NldE5leHRPcHRpb25BY3RpdmUoKSB7XG4gICAgbGV0IHQgPSB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCArIDE7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCk7XG4gICAgaWYgKGVbdF0pIHtcbiAgICAgIGZvciAoOyBlW3RdLmRpc2FibGVkOyApXG4gICAgICAgIGlmICh0ICs9IDEsICFlW3RdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZU9wdGlvbihlW3RdLCB0KTtcbiAgICB9XG4gIH1cbiAgX3NldFByZXZpb3VzT3B0aW9uQWN0aXZlKCkge1xuICAgIGxldCB0ID0gdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggLSAxO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpO1xuICAgIGlmIChlW3RdKSB7XG4gICAgICBmb3IgKDsgZVt0XS5kaXNhYmxlZDsgKVxuICAgICAgICBpZiAodCAtPSAxLCAhZVt0XSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl91cGRhdGVBY3RpdmVPcHRpb24oZVt0XSwgdCk7XG4gICAgfVxuICB9XG4gIF9zZXRGaXJzdE9wdGlvbkFjdGl2ZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKTtcbiAgICB0aGlzLl91cGRhdGVBY3RpdmVPcHRpb24oZVswXSwgMCk7XG4gIH1cbiAgX3NldExhc3RPcHRpb25BY3RpdmUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCksIGUgPSB0Lmxlbmd0aCAtIDE7XG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKHRbZV0sIGUpO1xuICB9XG4gIF91cGRhdGVBY3RpdmVPcHRpb24odCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9hY3RpdmVPcHRpb247XG4gICAgaSAmJiBpLnJlbW92ZUFjdGl2ZVN0eWxlcygpLCB0LnNldEFjdGl2ZVN0eWxlcygpLCB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCA9IGUsIHRoaXMuX2FjdGl2ZU9wdGlvbiA9IHQ7XG4gIH1cbiAgX2xpc3RlblRvV3JhcHBlckNsaWNrKCkge1xuICAgIGgub24odGhpcy5fd3JhcHBlciwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0NsZWFyQnRuQ2xpY2soKSB7XG4gICAgaC5vbih0aGlzLmNsZWFyQnV0dG9uLCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICB0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCksIHRoaXMuX2hhbmRsZUNsZWFyKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvQ2xlYXJCdG5LZXlkb3duKCkge1xuICAgIGgub24odGhpcy5jbGVhckJ1dHRvbiwgXCJrZXlkb3duXCIsICh0KSA9PiB7XG4gICAgICB0LmtleUNvZGUgPT09IGx0ICYmICh0aGlzLl9oYW5kbGVDbGVhcigpLCB0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCkpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDbGVhcigpIHtcbiAgICBpZiAodGhpcy5tdWx0aXBsZSlcbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCksIHRoaXMuX2Rlc2VsZWN0QWxsT3B0aW9ucyh0aGlzLm9wdGlvbnMpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbjtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCksIHQuZGVzZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy5fZmFrZVZhbHVlLmlubmVySFRNTCA9IFwiXCIsIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQobnVsbCksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpO1xuICB9XG4gIF9saXN0ZW5Ub09wdGlvbnNDbGljaygpIHtcbiAgICBoLm9uKHRoaXMub3B0aW9uc1dyYXBwZXIsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0LnRhcmdldC5oYXNBdHRyaWJ1dGUoXG4gICAgICAgIEttXG4gICAgICApKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldCA6IGQuY2xvc2VzdCh0LnRhcmdldCwgWm0pO1xuICAgICAgaWYgKGkuaGFzQXR0cmlidXRlKHptKSkge1xuICAgICAgICB0aGlzLl9oYW5kbGVTZWxlY3RBbGwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbyA9IGkuZGF0YXNldC50ZUlkLCByID0gdGhpcy5vcHRpb25zLmZpbmQoKGEpID0+IGEuaWQgPT09IG8pO1xuICAgICAgciAmJiAhci5kaXNhYmxlZCAmJiB0aGlzLl9oYW5kbGVTZWxlY3Rpb24ocik7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdEFsbCgpIHtcbiAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0ZWQgPyAodGhpcy5fZGVzZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5kZXNlbGVjdCgpKSA6ICh0aGlzLl9zZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5zZWxlY3QoKSksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQodGhpcy52YWx1ZSksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpO1xuICB9XG4gIF9zZWxlY3RBbGxPcHRpb25zKHQpIHtcbiAgICB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgICFlLnNlbGVjdGVkICYmICFlLmRpc2FibGVkICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QoZSksIGUuc2VsZWN0KCkpO1xuICAgIH0pO1xuICB9XG4gIF9kZXNlbGVjdEFsbE9wdGlvbnModCkge1xuICAgIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5zZWxlY3RlZCAmJiAhZS5kaXNhYmxlZCAmJiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoZSksIGUuZGVzZWxlY3QoKSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5tdWx0aXBsZSA/ICh0aGlzLl9oYW5kbGVNdWx0aVNlbGVjdGlvbih0KSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSkgOiB0aGlzLl9oYW5kbGVTaW5nbGVTZWxlY3Rpb24odCksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKTtcbiAgfVxuICBfaGFuZGxlQXV0b1NlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5fc2luZ2xlT3B0aW9uU2VsZWN0KHQpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCk7XG4gIH1cbiAgX2hhbmRsZVNpbmdsZVNlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5fc2luZ2xlT3B0aW9uU2VsZWN0KHQpLCB0aGlzLmNsb3NlKCksIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gIH1cbiAgX3NpbmdsZU9wdGlvblNlbGVjdCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnNbMF07XG4gICAgZSAmJiBlICE9PSB0ICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdChlKSwgZS5kZXNlbGVjdCgpLCBlLm5vZGUuc2V0QXR0cmlidXRlKGNpLCAhMSksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB3YSwge1xuICAgICAgdmFsdWU6IGUudmFsdWVcbiAgICB9KSksICghZSB8fCBlICYmIHQgIT09IGUpICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QodCksIHQuc2VsZWN0KCksIHQubm9kZS5zZXRBdHRyaWJ1dGUoY2ksICEwKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHlhLCB7XG4gICAgICB2YWx1ZTogdC52YWx1ZVxuICAgIH0pLCB0aGlzLl9lbWl0VmFsdWVDaGFuZ2VFdmVudCh0aGlzLnZhbHVlKSwgdGhpcy5fZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCkpO1xuICB9XG4gIF9oYW5kbGVNdWx0aVNlbGVjdGlvbih0KSB7XG4gICAgdC5zZWxlY3RlZCA/ICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdCh0KSwgdC5kZXNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKGNpLCAhMSksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB3YSwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSkgOiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHQpLCB0LnNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKGNpLCAhMCksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB5YSwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHRoaXMudmFsdWUpLCB0aGlzLl9lbWl0TmF0aXZlQ2hhbmdlRXZlbnQoKTtcbiAgfVxuICBfZW1pdFZhbHVlQ2hhbmdlRXZlbnQodCkge1xuICAgIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBZbSwgeyB2YWx1ZTogdCB9KTtcbiAgfVxuICBfZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCkge1xuICAgIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBqbSk7XG4gIH1cbiAgX3VwZGF0ZUlucHV0VmFsdWUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5sYWJlbHMgOiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5sYWJlbDtcbiAgICBsZXQgZTtcbiAgICB0aGlzLm11bHRpcGxlICYmIHRoaXMuX2NvbmZpZy5zZWxlY3REaXNwbGF5ZWRMYWJlbHMgIT09IC0xICYmIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gdGhpcy5fY29uZmlnLnNlbGVjdERpc3BsYXllZExhYmVscyA/IGUgPSBgJHt0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zLmxlbmd0aH0gJHt0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uc1NlbGVjdGVkTGFiZWx9YCA6IGUgPSB0LCAhdGhpcy5tdWx0aXBsZSAmJiAhdGhpcy5faXNTZWxlY3Rpb25WYWxpZCh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24pID8gdGhpcy5faW5wdXQudmFsdWUgPSBcIlwiIDogdGhpcy5faXNMYWJlbEVtcHR5KHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbikgPyB0aGlzLl9pbnB1dC52YWx1ZSA9IFwiIFwiIDogZSA/IHRoaXMuX2lucHV0LnZhbHVlID0gZSA6IHRoaXMubXVsdGlwbGUgfHwgIXRoaXMuX29wdGlvbnNUb1JlbmRlclswXSA/IHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiA6IHRoaXMuX2lucHV0LnZhbHVlID0gdGhpcy5fb3B0aW9uc1RvUmVuZGVyWzBdLmxhYmVsO1xuICB9XG4gIF9pc1NlbGVjdGlvblZhbGlkKHQpIHtcbiAgICByZXR1cm4gISh0ICYmICh0LmRpc2FibGVkIHx8IHQudmFsdWUgPT09IFwiXCIpKTtcbiAgfVxuICBfaXNMYWJlbEVtcHR5KHQpIHtcbiAgICByZXR1cm4gISEodCAmJiB0LmxhYmVsID09PSBcIlwiKTtcbiAgfVxuICBfYXBwZW5kRmFrZVZhbHVlKCkge1xuICAgIGlmICghdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLl9tdWx0aXBsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uLmxhYmVsO1xuICAgIHRoaXMuX2Zha2VWYWx1ZSA9IFdtKHQsIHRoaXMuX2NsYXNzZXMpLCBkLmZpbmRPbmUoXG4gICAgICBJYSxcbiAgICAgIHRoaXMuX3dyYXBwZXJcbiAgICApLmFwcGVuZENoaWxkKHRoaXMuX2Zha2VWYWx1ZSk7XG4gIH1cbiAgX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKHhhKSwgZSA9IHRoaXMuX2lucHV0LnZhbHVlICE9PSBcIlwiO1xuICAgIHRoaXMuX2xhYmVsICYmICh0ICYmIChlIHx8IHRoaXMuX2lzT3BlbiB8fCB0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSkgPyAodGhpcy5fbGFiZWwuc2V0QXR0cmlidXRlKHEsIFwiXCIpLCB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUocSwgXCJcIikpIDogKHRoaXMuX2xhYmVsLnJlbW92ZUF0dHJpYnV0ZShxKSwgdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKHEsIFwiXCIpKSk7XG4gIH1cbiAgX3VwZGF0ZUxhYmVsUG9zaXRpb25XaGlsZUNsb3NpbmcoKSB7XG4gICAgdGhpcy5fbGFiZWwgJiYgKHRoaXMuX2lucHV0LnZhbHVlICE9PSBcIlwiIHx8IHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID8gKHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZShxLCBcIlwiKSwgdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKHEsIFwiXCIpKSA6ICh0aGlzLl9sYWJlbC5yZW1vdmVBdHRyaWJ1dGUocSksIHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShxKSkpO1xuICB9XG4gIF91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpIHtcbiAgICB0aGlzLl9mYWtlVmFsdWUgJiYgKHRoaXMuX2lucHV0LnZhbHVlID09PSBcIlwiICYmIHRoaXMuX2Zha2VWYWx1ZS5pbm5lckhUTUwgIT09IFwiXCIgJiYgIXRoaXMuX2NvbmZpZy5zZWxlY3RQbGFjZWhvbGRlciA/ICh0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA9ICEwLCB0aGlzLl9mYWtlVmFsdWUuc2V0QXR0cmlidXRlKHEsIFwiXCIpKSA6ICh0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA9ICExLCB0aGlzLl9mYWtlVmFsdWUucmVtb3ZlQXR0cmlidXRlKHEpKSk7XG4gIH1cbiAgX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpIHtcbiAgICBpZiAoIXRoaXMuY2xlYXJCdXR0b24pXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gMCA/IGMuYWRkU3R5bGUodGhpcy5jbGVhckJ1dHRvbiwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSkgOiBjLmFkZFN0eWxlKHRoaXMuY2xlYXJCdXR0b24sIHsgZGlzcGxheTogXCJub25lXCIgfSk7XG4gIH1cbiAgX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0ZWQsIGUgPSBjbyh0aGlzLm9wdGlvbnMpO1xuICAgICFlICYmIHQgPyB0aGlzLl9zZWxlY3RBbGxPcHRpb24uZGVzZWxlY3QoKSA6IGUgJiYgIXQgJiYgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLnNlbGVjdCgpO1xuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLl9pc09wZW4gPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKTtcbiAgfVxuICBvcGVuKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuZGlzYWJsZWQsIGUgPSBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRm0pO1xuICAgIHRoaXMuX2lzT3BlbiB8fCB0IHx8IGUuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fb3BlbkRyb3Bkb3duKCksIHRoaXMuX3VwZGF0ZURyb3Bkb3duV2lkdGgoKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKSwgdGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlciAmJiAoc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmZpbHRlcklucHV0LmZvY3VzKCk7XG4gICAgfSwgMCksIHRoaXMuX2xpc3RlblRvU2VsZWN0U2VhcmNoKCksIHRoaXMuX2xpc3RlblRvRHJvcGRvd25LZXlkb3duKCkpLCB0aGlzLl9saXN0ZW5Ub09wdGlvbnNDbGljaygpLCB0aGlzLl9saXN0ZW5Ub091dHNpZGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub1dpbmRvd1Jlc2l6ZSgpLCB0aGlzLl9pc09wZW4gPSAhMCwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl9zZXRJbnB1dEFjdGl2ZVN0eWxlcygpKTtcbiAgfVxuICBfb3BlbkRyb3Bkb3duKCkge1xuICAgIHRoaXMuX3BvcHBlciA9IEVlKHRoaXMuX2lucHV0LCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciwge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiLFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDFdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSksIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kcm9wZG93bkNvbnRhaW5lciksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kcm9wZG93bi5zZXRBdHRyaWJ1dGUoa2EsIFwiXCIpO1xuICAgIH0sIDApO1xuICB9XG4gIF91cGRhdGVEcm9wZG93bldpZHRoKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9pbnB1dC5vZmZzZXRXaWR0aDtcbiAgICBjLmFkZFN0eWxlKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLCB7IHdpZHRoOiBgJHt0fXB4YCB9KTtcbiAgfVxuICBfc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCksIGUgPSB0aGlzLl9hY3RpdmVPcHRpb247XG4gICAgZSAmJiBlLnJlbW92ZUFjdGl2ZVN0eWxlcygpO1xuICAgIGNvbnN0IGkgPSB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uc1swXSA6IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbjtcbiAgICBpID8gKHRoaXMuX2FjdGl2ZU9wdGlvbiA9IGksIGkuc2V0QWN0aXZlU3R5bGVzKCksIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gdC5maW5kSW5kZXgoXG4gICAgICAobikgPT4gbiA9PT0gaVxuICAgICkpIDogKHRoaXMuX2FjdGl2ZU9wdGlvbiA9IG51bGwsIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gLTEpO1xuICB9XG4gIF9zZXRJbnB1dEFjdGl2ZVN0eWxlcygpIHtcbiAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoS3QsIFwiXCIpLCBkLmZpbmRPbmUoSG4sIHRoaXMuX3dyYXBwZXIpLnNldEF0dHJpYnV0ZShcbiAgICAgIEt0LFxuICAgICAgXCJcIlxuICAgICk7XG4gIH1cbiAgX2xpc3RlblRvV2luZG93UmVzaXplKCkge1xuICAgIGgub24od2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemUuYmluZCh0aGlzKSk7XG4gIH1cbiAgX2hhbmRsZVdpbmRvd1Jlc2l6ZSgpIHtcbiAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciAmJiB0aGlzLl91cGRhdGVEcm9wZG93bldpZHRoKCk7XG4gIH1cbiAgX2xpc3RlblRvU2VsZWN0U2VhcmNoKCkge1xuICAgIHRoaXMuZmlsdGVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC50YXJnZXQudmFsdWUsIGkgPSB0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyRGVib3VuY2U7XG4gICAgICB0aGlzLl9kZWJvdW5jZUZpbHRlcihlLCBpKTtcbiAgICB9KTtcbiAgfVxuICBfZGVib3VuY2VGaWx0ZXIodCwgZSkge1xuICAgIHRoaXMuX2RlYm91bmNlVGltZW91dElkICYmIGNsZWFyVGltZW91dCh0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCksIHRoaXMuX2RlYm91bmNlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9maWx0ZXJPcHRpb25zKHQpO1xuICAgIH0sIGUpO1xuICB9XG4gIF9maWx0ZXJPcHRpb25zKHQpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICAgIG8sXG4gICAgICAgIFwib3B0aW9uc1wiXG4gICAgICApLCBhID0gIXIgJiYgby5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHQudG9Mb3dlckNhc2UoKSksIGwgPSB7fTtcbiAgICAgIHIgJiYgKGwubGFiZWwgPSBvLmxhYmVsLCBsLm9wdGlvbnMgPSB0aGlzLl9maWx0ZXIodCwgby5vcHRpb25zKSwgbC5vcHRpb25zLmxlbmd0aCA+IDAgJiYgZS5wdXNoKGwpKSwgYSAmJiBlLnB1c2gobyk7XG4gICAgfSk7XG4gICAgY29uc3QgaSA9IHRoaXMuX2NvbmZpZy5zZWxlY3ROb1Jlc3VsdFRleHQgIT09IFwiXCIsIG4gPSBlLmxlbmd0aCAhPT0gMDtcbiAgICBpZiAobilcbiAgICAgIHRoaXMuX3VwZGF0ZU9wdGlvbnNMaXN0VGVtcGxhdGUoZSksIHRoaXMuX3BvcHBlci5mb3JjZVVwZGF0ZSgpLCB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0UGxhaW5PcHRpb25zKGUpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpO1xuICAgIGVsc2UgaWYgKCFuICYmIGkpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLl9nZXROb1Jlc3VsdFRlbXBsYXRlKCk7XG4gICAgICB0aGlzLm9wdGlvbnNXcmFwcGVyLmlubmVySFRNTCA9IG87XG4gICAgfVxuICB9XG4gIF91cGRhdGVPcHRpb25zTGlzdFRlbXBsYXRlKHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKFNhLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcikgfHwgZC5maW5kT25lKHRnLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciksIGkgPSBjYyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24sXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLm9wdGlvbnNXcmFwcGVyLnJlbW92ZUNoaWxkKGUpLCB0aGlzLm9wdGlvbnNXcmFwcGVyLmFwcGVuZENoaWxkKGkpO1xuICB9XG4gIF9nZXROb1Jlc3VsdFRlbXBsYXRlKCkge1xuICAgIHJldHVybiBgPGRpdiBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5ub1Jlc3VsdH1cIiAke3BjfSBzdHlsZT1cImhlaWdodDogJHt0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uSGVpZ2h0fXB4XCI+JHt0aGlzLl9jb25maWcuc2VsZWN0Tm9SZXN1bHRUZXh0fTwvZGl2PmA7XG4gIH1cbiAgX2ZpbHRlcih0LCBlKSB7XG4gICAgY29uc3QgaSA9IHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gZS5maWx0ZXIoXG4gICAgICAobikgPT4gbi5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGkpXG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9Ecm9wZG93bktleWRvd24oKSB7XG4gICAgaC5vbihcbiAgICAgIHRoaXMuZHJvcGRvd24sXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMuX2hhbmRsZU9wZW5LZXlkb3duLmJpbmQodGhpcylcbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub091dHNpZGVDbGljaygpIHtcbiAgICB0aGlzLl9vdXRzaWRlQ2xpY2sgPSB0aGlzLl9oYW5kbGVPdXRTaWRlQ2xpY2suYmluZCh0aGlzKSwgaC5vbihkb2N1bWVudCwgXCJjbGlja1wiLCB0aGlzLl9vdXRzaWRlQ2xpY2spO1xuICB9XG4gIF9saXN0ZW5Ub0ZvY3VzQ2hhbmdlKHQgPSAhMCkge1xuICAgIGlmICh0ID09PSAhMSkge1xuICAgICAgaC5vZmYoXG4gICAgICAgIHRoaXMuX2lucHV0LFxuICAgICAgICBcImZvY3VzXCIsXG4gICAgICAgICgpID0+IHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZShLdCwgXCJcIilcbiAgICAgICksIGgub2ZmKFxuICAgICAgICB0aGlzLl9pbnB1dCxcbiAgICAgICAgXCJibHVyXCIsXG4gICAgICAgICgpID0+IHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShLdClcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGgub24oXG4gICAgICB0aGlzLl9pbnB1dCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgICgpID0+IHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZShLdCwgXCJcIilcbiAgICApLCBoLm9uKFxuICAgICAgdGhpcy5faW5wdXQsXG4gICAgICBcImJsdXJcIixcbiAgICAgICgpID0+IHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShLdClcbiAgICApO1xuICB9XG4gIF9oYW5kbGVPdXRTaWRlQ2xpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl93cmFwcGVyICYmIHRoaXMuX3dyYXBwZXIuY29udGFpbnModC50YXJnZXQpLCBpID0gdC50YXJnZXQgPT09IHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLCBuID0gdGhpcy5fZHJvcGRvd25Db250YWluZXIgJiYgdGhpcy5fZHJvcGRvd25Db250YWluZXIuY29udGFpbnModC50YXJnZXQpO1xuICAgIGxldCBvO1xuICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbiB8fCAodGhpcy5fZWxlbWVudFRvZ2dsZSA9IGQuZmluZChlZykpLCB0aGlzLl9lbGVtZW50VG9nZ2xlICYmIHRoaXMuX2VsZW1lbnRUb2dnbGUuZm9yRWFjaCgocikgPT4ge1xuICAgICAgY29uc3QgYSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgcixcbiAgICAgICAgXCJzZWxlY3QtdG9nZ2xlXCJcbiAgICAgICk7XG4gICAgICAoYSA9PT0gdGhpcy5fZWxlbWVudC5pZCB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhhKSkgJiYgKHRoaXMuX3RvZ2dsZUJ1dHRvbiA9IHIsIG8gPSB0aGlzLl90b2dnbGVCdXR0b24uY29udGFpbnModC50YXJnZXQpKTtcbiAgICB9KSwgIWUgJiYgIWkgJiYgIW4gJiYgIW8gJiYgdGhpcy5jbG9zZSgpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGNvbnN0IHQgPSBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVm0pO1xuICAgICF0aGlzLl9pc09wZW4gfHwgdC5kZWZhdWx0UHJldmVudGVkIHx8ICh0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyICYmIHRoaXMuaGFzU2VsZWN0QWxsICYmICh0aGlzLl9yZXNldEZpbHRlclN0YXRlKCksIHRoaXMuX3VwZGF0ZU9wdGlvbnNMaXN0VGVtcGxhdGUodGhpcy5fb3B0aW9uc1RvUmVuZGVyKSwgdGhpcy5fY29uZmlnLm11bHRpcGxlICYmIHRoaXMuX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCkpLCB0aGlzLl9yZW1vdmVEcm9wZG93bkV2ZW50cygpLCB0aGlzLmRyb3Bkb3duLnJlbW92ZUF0dHJpYnV0ZShrYSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKEt0KSwgdGhpcy5faW5wdXQuYmx1cigpLCBkLmZpbmRPbmUoSG4sIHRoaXMuX3dyYXBwZXIpLnJlbW92ZUF0dHJpYnV0ZShcbiAgICAgICAgS3RcbiAgICAgICksIHRoaXMuX2xhYmVsICYmICF0aGlzLmhhc1NlbGVjdGlvbiAmJiAodGhpcy5fbGFiZWwucmVtb3ZlQXR0cmlidXRlKHEpLCB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUocSwgXCJcIiksIHRoaXMuX2lucHV0LnJlbW92ZUF0dHJpYnV0ZShxKSwgdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKHEpKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbldoaWxlQ2xvc2luZygpO1xuICAgIH0sIDApLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9kcm9wZG93bkNvbnRhaW5lci5wYXJlbnROb2RlID09PSB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKSwgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgdGhpcy5faXNPcGVuID0gITEsIGgub2ZmKHRoaXMuZHJvcGRvd24sIFwidHJhbnNpdGlvbmVuZFwiKTtcbiAgICB9LCBpZykpO1xuICB9XG4gIF9yZXNldEZpbHRlclN0YXRlKCkge1xuICAgIHRoaXMuZmlsdGVySW5wdXQudmFsdWUgPSBcIlwiLCB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID0gbnVsbDtcbiAgfVxuICBfcmVtb3ZlRHJvcGRvd25FdmVudHMoKSB7XG4gICAgaC5vZmYoZG9jdW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fb3V0c2lkZUNsaWNrKSwgdGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlciAmJiBoLm9mZih0aGlzLmRyb3Bkb3duLCBcImtleWRvd25cIiksIGgub2ZmKHRoaXMub3B0aW9uc1dyYXBwZXIsIFwiY2xpY2tcIik7XG4gIH1cbiAgX2FkZE11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgIHRoaXMuX3dyYXBwZXIgJiYgKHRoaXMuX3VwZGF0ZVNlbGVjdGlvbnMoKSwgdGhpcy5fdXBkYXRlRGlzYWJsZWRTdGF0ZSgpKTtcbiAgICB9KSwgdGhpcy5fb2JzZXJ2ZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgfVxuICBfdXBkYXRlU2VsZWN0aW9ucygpIHtcbiAgICB0aGlzLl9vcHRpb25zVG9SZW5kZXIgPSB0aGlzLl9nZXRPcHRpb25zVG9SZW5kZXIodGhpcy5fZWxlbWVudCksIHRoaXMuX3BsYWluT3B0aW9ucyA9IHRoaXMuX2dldFBsYWluT3B0aW9ucyh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpLCB0aGlzLl9zZXREZWZhdWx0U2VsZWN0aW9ucygpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCksIHRoaXMuaGFzU2VsZWN0QWxsICYmIHRoaXMuX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCk7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZy5maWx0ZXIgJiYgdGhpcy5maWx0ZXJJbnB1dCAmJiB0aGlzLmZpbHRlcklucHV0LnZhbHVlO1xuICAgIHRoaXMuX2lzT3BlbiAmJiAhdCA/ICh0aGlzLl91cGRhdGVPcHRpb25zTGlzdFRlbXBsYXRlKHRoaXMuX29wdGlvbnNUb1JlbmRlciksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCkpIDogdGhpcy5faXNPcGVuICYmIHQgPyAodGhpcy5fZmlsdGVyT3B0aW9ucyh0aGlzLmZpbHRlcklucHV0LnZhbHVlKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSkgOiB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciA9IEFhKFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJJZCxcbiAgICAgIHRoaXMuX2NvbmZpZyxcbiAgICAgIHRoaXMuX2lucHV0Lm9mZnNldFdpZHRoLFxuICAgICAgdGhpcy5fZHJvcGRvd25IZWlnaHQsXG4gICAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24sXG4gICAgICB0aGlzLl9vcHRpb25zVG9SZW5kZXIsXG4gICAgICB0aGlzLl9jdXN0b21Db250ZW50LFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gIH1cbiAgX3VwZGF0ZURpc2FibGVkU3RhdGUoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShPYSwgdGhpcy5fd3JhcHBlcik7XG4gICAgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA/ICh0aGlzLl9jb25maWcuZGlzYWJsZWQgPSAhMCwgdC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSwgdC5zZXRBdHRyaWJ1dGUoQm4sIFwiXCIpKSA6ICh0aGlzLl9jb25maWcuZGlzYWJsZWQgPSAhMSwgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSwgdC5yZW1vdmVBdHRyaWJ1dGUoQm4pKTtcbiAgfVxuICBfb2JzZXJ2ZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciAmJiB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy5fZWxlbWVudCwge1xuICAgICAgYXR0cmlidXRlczogITAsXG4gICAgICBjaGlsZExpc3Q6ICEwLFxuICAgICAgY2hhcmFjdGVyRGF0YTogITAsXG4gICAgICBzdWJ0cmVlOiAhMFxuICAgIH0pO1xuICB9XG4gIF9kaXNjb25uZWN0TXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgJiYgKHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbCk7XG4gIH1cbiAgX2NyZWF0ZVNlbGVjdEFsbE9wdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2VsZWN0QWxsSWQsIGUgPSBudWxsLCBpID0gITAsIG4gPSBcInNlbGVjdC1hbGxcIiwgbyA9IHRoaXMuX2NvbmZpZy5zZWxlY3RBbGxMYWJlbCwgciA9IGNvKHRoaXMub3B0aW9ucyksIGEgPSAhMSwgbCA9ICExLCBwID0gbnVsbCwgdSA9IG51bGwsIGYgPSBudWxsO1xuICAgIHJldHVybiBuZXcgQ2EoXG4gICAgICB0LFxuICAgICAgZSxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgbyxcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbCxcbiAgICAgIHAsXG4gICAgICB1LFxuICAgICAgZlxuICAgICk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9yZW1vdmVDb21wb25lbnRFdmVudHMoKSwgdGhpcy5fZGVzdHJveU1hdGVyaWFsU2VsZWN0KCksIHRoaXMuX2xpc3RlblRvRm9jdXNDaGFuZ2UoITEpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgZmkpO1xuICB9XG4gIF9yZW1vdmVDb21wb25lbnRFdmVudHMoKSB7XG4gICAgaC5vZmYodGhpcy5pbnB1dCwgXCJjbGlja1wiKSwgaC5vZmYodGhpcy53cmFwcGVyLCB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcykpLCBoLm9mZih0aGlzLmNsZWFyQnV0dG9uLCBcImNsaWNrXCIpLCBoLm9mZih0aGlzLmNsZWFyQnV0dG9uLCBcImtleWRvd25cIiksIGgub2ZmKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5faGFuZGxlV2luZG93UmVzaXplLmJpbmQodGhpcykpO1xuICB9XG4gIF9kZXN0cm95TWF0ZXJpYWxTZWxlY3QoKSB7XG4gICAgdGhpcy5faXNPcGVuICYmIHRoaXMuY2xvc2UoKSwgdGhpcy5fZGVzdHJveU1hdGVyaWFsVGVtcGxhdGUoKTtcbiAgfVxuICBfZGVzdHJveU1hdGVyaWFsVGVtcGxhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3dyYXBwZXIucGFyZW50Tm9kZSwgZSA9IGQuZmluZChcImxhYmVsXCIsIHRoaXMuX3dyYXBwZXIpO1xuICAgIHQuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCksIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgdC5hcHBlbmRDaGlsZChpKTtcbiAgICB9KSwgZS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBpLnJlbW92ZUF0dHJpYnV0ZShxKTtcbiAgICB9KSwgYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmluaXRpYWxpemVkKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoeGEpLCB0LnJlbW92ZUNoaWxkKHRoaXMuX3dyYXBwZXIpO1xuICB9XG4gIHNldFZhbHVlKHQpIHtcbiAgICB0aGlzLm9wdGlvbnMuZmlsdGVyKChpKSA9PiBpLnNlbGVjdGVkKS5mb3JFYWNoKChpKSA9PiBpLm5hdGl2ZU9wdGlvbi5zZWxlY3RlZCA9ICExKSwgQXJyYXkuaXNBcnJheSh0KSA/IHQuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgdGhpcy5fc2VsZWN0QnlWYWx1ZShpKTtcbiAgICB9KSA6IHRoaXMuX3NlbGVjdEJ5VmFsdWUodCksIHRoaXMuX3VwZGF0ZVNlbGVjdGlvbnMoKTtcbiAgfVxuICBfc2VsZWN0QnlWYWx1ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucy5maW5kKFxuICAgICAgKGkpID0+IGkudmFsdWUgPT09IHRcbiAgICApO1xuICAgIHJldHVybiBlID8gKGUubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITAsICEwKSA6ICExO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaSA9IEkuZ2V0RGF0YSh0aGlzLCBmaSk7XG4gICAgICBjb25zdCBuID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWkgJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3ICRvKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIGZpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBhZyA9ICh7IGlucHV0SUQ6IHMsIGxhYmVsVGV4dDogdCB9LCBlKSA9PiBgPGRpdiBkYXRhLXRlLWNoaXBzLWlucHV0LXdyYXBwZXIgZGF0YS10ZS1pbnB1dC13cmFwcGVyLWluaXQgY2xhc3M9XCIke2UuY2hpcHNJbnB1dFdyYXBwZXJ9XCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgY2xhc3M9XCIke2UuY2hpcHNJbnB1dH1cIlxuICAgICAgICAgIGlkPVwiJHtzfVwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJFeGFtcGxlIGxhYmVsXCIgLz5cbiAgICAgICAgPGxhYmVsXG4gICAgICAgICAgZm9yPVwiJHtzfVwiXG4gICAgICAgICAgY2xhc3M9XCIke2UuY2hpcHNMYWJlbH1cIlxuICAgICAgICAgID4ke3R9XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5gLCBsZyA9ICh7IHRleHQ6IHMsIGljb25TVkc6IHQgfSwgZSkgPT4gYDxkaXYgZGF0YS10ZS1jaGlwLWluaXQgZGF0YS10ZS1yaXBwbGUtaW5pdCBjbGFzcz1cIiR7ZS5jaGlwRWxlbWVudH1cIj5cbiAgICA8c3BhbiBkYXRhLXRlLWNoaXAtdGV4dD4ke3N9PC9zcGFuPiBcbiAgICAgIDxzcGFuIGRhdGEtdGUtY2hpcC1jbG9zZSBjbGFzcz1cIiR7ZS5jaGlwQ2xvc2VJY29ufVwiPlxuICAgICAgICAke3R9XG4gICAgICA8L3NwYW4+XG4gIDwvZGl2PmAsIERzID0gXCJjaGlwXCIsIGNnID0gYHRlLiR7RHN9YCwgX2MgPSBcImRhdGEtdGUtY2hpcC1jbG9zZVwiLCBXbiA9IGBbJHtfY31dYCwgaGcgPSBcImRlbGV0ZS50ZS5jaGlwc1wiLCBkZyA9IFwic2VsZWN0LnRlLmNoaXBcIiwgdWcgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTMgaC0zXCI+IDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNiAxOEwxOCA2TTYgNmwxMiAxMlwiIC8+PC9zdmc+JywgcGcgPSB7XG4gIHRleHQ6IFwic3RyaW5nXCIsXG4gIGNsb3NlSWNvbjogXCJib29sZWFuXCIsXG4gIGltZzogXCJvYmplY3RcIixcbiAgaWNvblNWRzogXCJzdHJpbmdcIlxufSwgX2cgPSB7XG4gIHRleHQ6IFwiXCIsXG4gIGNsb3NlSWNvbjogITEsXG4gIGltZzogeyBwYXRoOiBcIlwiLCBhbHQ6IFwiXCIgfSxcbiAgaWNvblNWRzogdWdcbn0sIGZnID0ge1xuICBpY29uOiBcImZsb2F0LXJpZ2h0IHBsLVs4cHhdIHRleHQtWzE2cHhdIG9wYWNpdHktWy41M10gY3Vyc29yLXBvaW50ZXIgZmlsbC1bI2FmYWZhZl0gaG92ZXI6dGV4dC1bIzhiOGI4Yl0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0XCIsXG4gIGNoaXBFbGVtZW50OiBcImZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlciBoLVszMnB4XSBsZWFkaW5nLWxvb3NlIHB5LVs1cHhdIHB4LVsxMnB4XSBtci00IG15LVs1cHhdIHRleHQtWzEzcHhdIGZvbnQtbm9ybWFsIHRleHQtWyM0ZjRmNGZdIGN1cnNvci1wb2ludGVyIGJnLVsjZWNlZmYxXSBkYXJrOnRleHQtd2hpdGUgZGFyazpiZy1uZXV0cmFsLTYwMCByb3VuZGVkLVsxNnB4XSB0cmFuc2l0aW9uLVtvcGFjaXR5XSBkdXJhdGlvbi0zMDAgZWFzZS1saW5lYXIgW3dvcmQtd3JhcDogYnJlYWstd29yZF0gc2hhZG93LW5vbmUgbm9ybWFsLWNhc2UgaG92ZXI6IXNoYWRvdy1ub25lIGFjdGl2ZTpiZy1bI2NhY2ZkMV0gaW5saW5lLWJsb2NrIGZvbnQtbWVkaXVtIGxlYWRpbmctbm9ybWFsIHRleHQtWyM0ZjRmNGZdIHRleHQtY2VudGVyIG5vLXVuZGVybGluZSBhbGlnbi1taWRkbGUgY3Vyc29yLXBvaW50ZXIgc2VsZWN0LW5vbmUgYm9yZGVyLVsuMTI1cmVtXSBib3JkZXItc29saWQgYm9yZGVyLXRyYW5zcGFyZW50IHB5LTEuNSBweC0zIHRleHQteHMgcm91bmRlZFwiLFxuICBjaGlwQ2xvc2VJY29uOiBcInctNCBmbG9hdC1yaWdodCBwbC1bOHB4XSB0ZXh0LVsxNnB4XSBvcGFjaXR5LVsuNTNdIGN1cnNvci1wb2ludGVyIGZpbGwtWyNhZmFmYWZdIGhvdmVyOmZpbGwtWyM4YjhiOGJdIGRhcms6ZmlsbC1ncmF5LTQwMCBkYXJrOmhvdmVyOmZpbGwtZ3JheS0xMDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0XCJcbn0sIG1nID0ge1xuICBpY29uOiBcInN0cmluZ1wiLFxuICBjaGlwRWxlbWVudDogXCJzdHJpbmdcIixcbiAgY2hpcENsb3NlSWNvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIGhpIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBEcztcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9hcHBlbmRDbG9zZUljb24oKSwgdGhpcy5faGFuZGxlRGVsZXRlKCksIHRoaXMuX2hhbmRsZVRleHRDaGlwKCksIHRoaXMuX2hhbmRsZUNsaWNrT25DaGlwKCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIGgub2ZmKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIik7XG4gIH1cbiAgYXBwZW5kQ2hpcCgpIHtcbiAgICBjb25zdCB7IHRleHQ6IHQsIGNsb3NlSWNvbjogZSwgaWNvblNWRzogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICByZXR1cm4gbGcoeyB0ZXh0OiB0LCBjbG9zZUljb246IGUsIGljb25TVkc6IGkgfSwgdGhpcy5fY2xhc3Nlcyk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfYXBwZW5kQ2xvc2VJY29uKHQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgaWYgKCEoZC5maW5kKFduLCB0aGlzLl9lbGVtZW50KS5sZW5ndGggPiAwKSAmJiB0aGlzLl9vcHRpb25zLmNsb3NlSWNvbikge1xuICAgICAgY29uc3QgZSA9IEQoXCJzcGFuXCIpO1xuICAgICAgZS5jbGFzc0xpc3QgPSB0aGlzLl9jbGFzc2VzLmljb24sIGUuc2V0QXR0cmlidXRlKF9jKSwgZS5pbm5lckhUTUwgPSB0aGlzLl9vcHRpb25zLmljb25TVkcsIHQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYmVmb3JlZW5kXCIsIGUpO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlQ2xpY2tPbkNoaXAoKSB7XG4gICAgaC5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCB7IHRleHRDb250ZW50OiBlIH0gPSB0LnRhcmdldCwgaSA9IHt9O1xuICAgICAgaS50YWcgPSBlLnRyaW0oKSwgaC50cmlnZ2VyKGRnLCB7IGV2ZW50OiB0LCBvYmo6IGkgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZURlbGV0ZSgpIHtcbiAgICBkLmZpbmQoXG4gICAgICBXbixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLmxlbmd0aCAhPT0gMCAmJiBoLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgV24sICgpID0+IHtcbiAgICAgIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBoZyksIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVRleHRDaGlwKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuaW5uZXJUZXh0ID09PSBcIlwiICYmICh0aGlzLl9lbGVtZW50LmlubmVyVGV4dCA9IHRoaXMuX29wdGlvbnMudGV4dCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLl9nLFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBMKERzLCBlLCBwZyksIGU7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5mZyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTChEcywgdCwgbWcpLCB0O1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBjZyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3Qgd2kgPSBcImNoaXBzXCIsIFJpID0gYGRhdGEtdGUtJHt3aX1gLCBEYSA9IGB0ZS4ke3dpfWAsIGdnID0gYCR7Uml9LWlucHV0LWluaXRgLCBmdCA9IGAke1JpfS1hY3RpdmVgLCAkYSA9IGAke1JpfS1pbml0aWFsYCwgZmMgPSBgJHtSaX0tcGxhY2Vob2xkZXJgLCBiZyA9IGAke1JpfS1pbnB1dC13cmFwcGVyYCwgaG8gPSBcImRhdGEtdGUtY2hpcC1pbml0XCIsIG1jID0gXCJkYXRhLXRlLWNoaXAtY2xvc2VcIiwgZ2MgPSBcImRhdGEtdGUtY2hpcC10ZXh0XCIsIHZnID0gYFske2Z0fV1gLCB1byA9IGBbJHtob31dYCwgVGcgPSBgJHt1b30ke3ZnfWAsIFZuID0gYFske21jfV1gLCBFZyA9IGBbJHtiZ31dYCwgQ2cgPSBgWyR7Z2N9XWAsIEFnID0gYFske2ZjfV1gLCB5ZyA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1sZWFkaW5nLXJlZlwiLCB3ZyA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1taWRkbGUtcmVmXCIsIHhnID0gYFske3lnfV1gLCBrZyA9IGBbJHt3Z31dYCwgT2UgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIEZuID0gXCJbZGF0YS10ZS1pbnB1dC1ub3RjaC1yZWZdXCIsIE9nID0gXCJhZGQudGUuY2hpcHNcIiwgU2cgPSBcImFycm93RG93bi50ZS5jaGlwc1wiLCBJZyA9IFwiYXJyb3dMZWZ0LnRlLmNoaXBzXCIsIERnID0gXCJhcnJvd1JpZ2h0LnRlLmNoaXBzXCIsICRnID0gXCJhcnJvd1VwLnRlLmNoaXBzXCIsIExhID0gXCJkZWxldGUudGUuY2hpcHNcIiwgTWEgPSBcInNlbGVjdC50ZS5jaGlwc1wiLCBMZyA9IHtcbiAgaW5wdXRJRDogXCJzdHJpbmdcIixcbiAgcGFyZW50U2VsZWN0b3I6IFwic3RyaW5nXCIsXG4gIGluaXRpYWxWYWx1ZXM6IFwiYXJyYXlcIixcbiAgZWRpdGFibGU6IFwiYm9vbGVhblwiLFxuICBsYWJlbFRleHQ6IFwic3RyaW5nXCIsXG4gIGlucHV0Q2xhc3NlczogXCJvYmplY3RcIixcbiAgaW5wdXRPcHRpb25zOiBcIm9iamVjdFwiXG59LCBNZyA9IHtcbiAgaW5wdXRJRDogYnQoXCJjaGlwcy1pbnB1dC1cIiksXG4gIHBhcmVudFNlbGVjdG9yOiBcIlwiLFxuICBpbml0aWFsVmFsdWVzOiBbeyB0YWc6IFwiaW5pdDFcIiB9LCB7IHRhZzogXCJpbml0MlwiIH1dLFxuICBlZGl0YWJsZTogITEsXG4gIGxhYmVsVGV4dDogXCJFeGFtcGxlIGxhYmVsXCIsXG4gIGlucHV0Q2xhc3Nlczoge30sXG4gIGlucHV0T3B0aW9uczoge31cbn0sIE5nID0ge1xuICBvcGFjaXR5OiBcIm9wYWNpdHktMFwiLFxuICBpbnB1dFdyYXBwZXJQYWRkaW5nOiBcInAtWzVweF1cIixcbiAgdHJhbnNpdGlvbjogXCJ0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMSldXCIsXG4gIGNvbnRlbnRFZGl0YWJsZTogXCJvdXRsaW5lLW5vbmUgIWJvcmRlci1bM3B4XSAhYm9yZGVyLXNvbGlkICFib3JkZXItWyNiMmIzYjRdXCIsXG4gIGNoaXBzSW5wdXRXcmFwcGVyOiBcInJlbGF0aXZlIGZsZXggaXRlbXMtY2VudGVyIGZsZXgtd3JhcCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMSldXCIsXG4gIGNoaXBzSW5wdXQ6IFwicGVlciBibG9jayBtaW4taC1bYXV0b10gdy1bMTUwcHhdIHJvdW5kZWQgYm9yZGVyLTAgYmctdHJhbnNwYXJlbnQgcHktWzAuMzJyZW1dIHB4LTMgbGVhZGluZy1bMS42XSBvdXRsaW5lLW5vbmUgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIGZvY3VzOnBsYWNlaG9sZGVyOm9wYWNpdHktMTAwIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGxhY2Vob2xkZXI6dGV4dC1ncmF5LTIwMCBbJjpub3QoW2RhdGEtdGUtaW5wdXQtcGxhY2Vob2xkZXItYWN0aXZlXSldOnBsYWNlaG9sZGVyOm9wYWNpdHktMFwiLFxuICBjaGlwc0xhYmVsOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG9wLTAgbGVmdC0zIG1iLTAgbWF4LXctWzkwJV0gb3JpZ2luLVswXzBdIHRydW5jYXRlIHB0LVswLjM3cmVtXSBsZWFkaW5nLVsxLjZdIHRleHQtZ3JheS01MDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2Utb3V0IHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVswLjlyZW1dIHBlZXItZm9jdXM6c2NhbGUtWzAuOF0gcGVlci1mb2N1czp0ZXh0LXByaW1hcnkgcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC45cmVtXSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06c2NhbGUtWzAuOF0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGVlci1mb2N1czp0ZXh0LWdyYXktMjAwXCJcbn0sIFJnID0ge1xuICBvcGFjaXR5OiBcInN0cmluZ1wiLFxuICBpbnB1dFdyYXBwZXJQYWRkaW5nOiBcInN0cmluZ1wiLFxuICB0cmFuc2l0aW9uOiBcInN0cmluZ1wiLFxuICBjb250ZW50RWRpdGFibGU6IFwic3RyaW5nXCIsXG4gIGNoaXBzSW5wdXRXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBjaGlwc0lucHV0OiBcInN0cmluZ1wiLFxuICBjaGlwc0xhYmVsOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgSzAgZXh0ZW5kcyBoaSB7XG4gIGNvbnN0cnVjdG9yKGUsIGkgPSB7fSwgbikge1xuICAgIHN1cGVyKGUsIGkpO1xuICAgIEF0KHRoaXMsIFwiX2hhbmRsZUJsdXJJbnB1dFwiLCAoeyB0YXJnZXQ6IGUgfSkgPT4ge1xuICAgICAgZS52YWx1ZS5sZW5ndGggPiAwICYmIHRoaXMuX2hhbmRsZUNyZWF0ZUNoaXAoZSwgZS52YWx1ZSksIHRoaXMuYWxsQ2hpcHMubGVuZ3RoID4gMCA/IChlLnNldEF0dHJpYnV0ZShmdCwgXCJcIiksIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKE9lLCBcIlwiKSwgZC5maW5kT25lKFxuICAgICAgICBGbixcbiAgICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXG4gICAgICApLnNldEF0dHJpYnV0ZShPZSwgXCJcIiksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICAgKSkgOiAoZS5yZW1vdmVBdHRyaWJ1dGUoZnQpLCB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShPZSksIGQuZmluZE9uZShcbiAgICAgICAgRm4sXG4gICAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZVxuICAgICAgKS5yZW1vdmVBdHRyaWJ1dGUoT2UpLCB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICAgICkpLCB0aGlzLmFsbENoaXBzLmZvckVhY2goKGkpID0+IGkucmVtb3ZlQXR0cmlidXRlKGZ0KSk7XG4gICAgfSk7XG4gICAgdGhpcy5fZWxlbWVudCA9IGUsIHRoaXMuX2lucHV0SW5zdGFuY2UgPSBudWxsLCB0aGlzLl9lbGVtZW50ICYmIEkuc2V0RGF0YShlLCBEYSwgdGhpcyksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoaSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKG4pLCB0aGlzLm51bWJlckNsaWNrcyA9IDAsIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiB3aTtcbiAgfVxuICBnZXQgYWN0aXZlQ2hpcCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFRnLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgaW5wdXQoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBhbGxDaGlwcygpIHtcbiAgICByZXR1cm4gZC5maW5kKHVvLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgY2hpcHNJbnB1dFdyYXBwZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShFZywgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fc2V0Q2hpcHNDbGFzcygpLCB0aGlzLl9hcHBlbmRJbnB1dFRvRWxlbWVudChmYyksIHRoaXMuX2hhbmRsZUluaXRpYWxWYWx1ZSgpLCB0aGlzLl9oYW5kbGVJbnB1dFRleHQoKSwgdGhpcy5faGFuZGxlS2V5Ym9hcmQoKSwgdGhpcy5faGFuZGxlQ2hpcHNPblNlbGVjdCgpLCB0aGlzLl9oYW5kbGVFZGl0YWJsZSgpLCB0aGlzLl9oYW5kbGVDaGlwc0ZvY3VzKCksIHRoaXMuX2hhbmRsZUNsaWNrc09uQ2hpcHMoKSwgdGhpcy5faW5wdXRJbnN0YW5jZS5fZ2V0TGFiZWxXaWR0aCgpLCB0aGlzLl9pbnB1dEluc3RhbmNlLl9hcHBseU5vdGNoKCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Tm90Y2hEYXRhKCkge1xuICAgIHRoaXMuX25vdGNoTWlkZGxlID0gZC5maW5kT25lKFxuICAgICAga2csXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gZC5maW5kT25lKFxuICAgICAgeGcsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgfVxuICBfc2V0Q2hpcHNDbGFzcygpIHtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShnZywgXCJcIik7XG4gIH1cbiAgX2hhbmRsZURlbGV0ZUV2ZW50cyhlKSB7XG4gICAgY29uc3QgW2ldID0gdGhpcy5hbGxDaGlwcy5zbGljZSgtMSk7XG4gICAgaWYgKHRoaXMuYWN0aXZlQ2hpcCA9PT0gbnVsbClcbiAgICAgIGkucmVtb3ZlKCksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBMYSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5hbGxDaGlwcy5maW5kSW5kZXgoKGEpID0+IGEgPT09IHRoaXMuYWN0aXZlQ2hpcCksIG8gPSB0aGlzLl9oYW5kbGVBY3RpdmVDaGlwQWZ0ZXJSZW1vdmUobiksIHIgPSBbXTtcbiAgICAgIGlmICh0aGlzLmFjdGl2ZUNoaXAgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuYWN0aXZlQ2hpcC5yZW1vdmUoKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIExhKSwgdGhpcy5udW1iZXJDbGlja3MgPSBuLCBvLnNldEF0dHJpYnV0ZShmdCwgXCJcIiksIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBhLmhhc0F0dHJpYnV0ZShmdCkgJiYgKHIucHVzaChhKSwgci5sZW5ndGggPiAxICYmIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgobCkgPT4gbC5yZW1vdmUoKSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVVcEV2ZW50cyhlKSB7XG4gICAgdGhpcy5udW1iZXJDbGlja3MgKz0gMSwgdGhpcy5udW1iZXJDbGlja3MgPT09IHRoaXMuYWxsQ2hpcHMubGVuZ3RoICsgMSAmJiAodGhpcy5udW1iZXJDbGlja3MgPSAwKSwgdGhpcy5faGFuZGxlUmlnaHRLZXlib2FyZEFycm93KHRoaXMubnVtYmVyQ2xpY2tzKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIERnKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsICRnKTtcbiAgfVxuICBfaGFuZGxlRG93bkV2ZW50cyhlKSB7XG4gICAgdGhpcy5udW1iZXJDbGlja3MgLT0gMSwgdGhpcy5udW1iZXJDbGlja3MgPD0gMCAmJiAodGhpcy5udW1iZXJDbGlja3MgPSB0aGlzLmFsbENoaXBzLmxlbmd0aCksIHRoaXMuX2hhbmRsZUxlZnRLZXlib2FyZEFycm93KHRoaXMubnVtYmVyQ2xpY2tzKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIElnKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIFNnKTtcbiAgfVxuICBfa2V5Ym9hcmRFdmVudHMoZSkge1xuICAgIGNvbnN0IHsgdGFyZ2V0OiBpLCBrZXlDb2RlOiBuLCBjdHJsS2V5OiBvIH0gPSBlO1xuICAgIGkudmFsdWUubGVuZ3RoID4gMCB8fCB0aGlzLmFsbENoaXBzLmxlbmd0aCA9PT0gMCB8fCAobiA9PT0gSV8gfHwgbiA9PT0gRF8gPyB0aGlzLl9oYW5kbGVEZWxldGVFdmVudHMoZSkgOiBuID09PSBCZSB8fCBuID09PSBydCA/IHRoaXMuX2hhbmRsZVVwRXZlbnRzKGUpIDogbiA9PT0gUGUgfHwgbiA9PT0geiA/IHRoaXMuX2hhbmRsZURvd25FdmVudHMoZSkgOiBuID09PSA2NSAmJiBvICYmIHRoaXMuX2hhbmRsZUFkZEFjdGl2ZUNsYXNzKCkpO1xuICB9XG4gIF9oYW5kbGVLZXlib2FyZCgpIHtcbiAgICBoLm9uKFxuICAgICAgdGhpcy5pbnB1dCxcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgKGUpID0+IHRoaXMuX2tleWJvYXJkRXZlbnRzKGUpXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlRWRpdGFibGUoKSB7XG4gICAgY29uc3QgeyBlZGl0YWJsZTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBlICYmIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgaC5vbihpLCBcImRibGNsaWNrXCIsIChuKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBkLmZpbmRPbmUoVm4sIGkpO1xuICAgICAgICBpLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5jb250ZW50RWRpdGFibGUuc3BsaXQoXCIgXCIpKSwgaS5jb250ZW50RWRpdGFibGUgPSAhMCwgaS5mb2N1cygpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjLmFkZFN0eWxlKG8sIHsgZGlzcGxheTogXCJub25lXCIgfSk7XG4gICAgICAgIH0sIDIwMCksIG8uY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKSwgbi50YXJnZXQudGV4dENvbnRlbnQsIGgudHJpZ2dlcihpLCBNYSwge1xuICAgICAgICAgIGV2ZW50OiBuLFxuICAgICAgICAgIGFsbENoaXBzOiB0aGlzLmFsbENoaXBzXG4gICAgICAgIH0pO1xuICAgICAgfSksIGgub24oZG9jdW1lbnQsIFwiY2xpY2tcIiwgKHsgdGFyZ2V0OiBuIH0pID0+IHtcbiAgICAgICAgY29uc3QgbyA9IGQuZmluZE9uZShWbiwgaSksIHIgPSBkLmZpbmRPbmUoQ2csIGkpLCBhID0gbiA9PT0gaSwgbCA9IGkgJiYgaS5jb250YWlucyhuKTtcbiAgICAgICAgIWEgJiYgIWwgJiYgKGkuY29udGVudEVkaXRhYmxlID0gITEsIGkuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLmNvbnRlbnRFZGl0YWJsZS5zcGxpdChcIiBcIikpLCByLnRleHRDb250ZW50ICE9PSBcIlwiICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGMuYWRkU3R5bGUobywgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIG8uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgfSwgMTYwKSksIHIudGV4dENvbnRlbnQgPT09IFwiXCIgJiYgKHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgfSwgMjAwKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaS5yZW1vdmUoKTtcbiAgICAgICAgfSwgMzAwKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSB7XG4gICAgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChlKSA9PiBlLnJlbW92ZUF0dHJpYnV0ZShmdCkpO1xuICB9XG4gIF9oYW5kbGVBZGRBY3RpdmVDbGFzcygpIHtcbiAgICB0aGlzLmFsbENoaXBzLmZvckVhY2goKGUpID0+IGUuc2V0QXR0cmlidXRlKGZ0LCBcIlwiKSk7XG4gIH1cbiAgX2hhbmRsZVJpZ2h0S2V5Ym9hcmRBcnJvdyhlKSB7XG4gICAgdGhpcy5faGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSwgZSA9PT0gMCAmJiAoZSA9IDEpLCB0aGlzLl9oYW5kbGVBZGRBY3RpdmVDbGFzc1dpdGhLZWJ5Ym9hcmQoZSk7XG4gIH1cbiAgX2hhbmRsZUxlZnRLZXlib2FyZEFycm93KGUpIHtcbiAgICB0aGlzLl9oYW5kbGVSZW1vdmVBY3RpdmVDbGFzcygpLCB0aGlzLl9oYW5kbGVBZGRBY3RpdmVDbGFzc1dpdGhLZWJ5Ym9hcmQoZSk7XG4gIH1cbiAgX2hhbmRsZUFjdGl2ZUNoaXBBZnRlclJlbW92ZShlKSB7XG4gICAgY29uc3QgaSA9IGUgPT09IDAgPyAxIDogZSAtIDE7XG4gICAgcmV0dXJuIHRoaXMuYWxsQ2hpcHNbaV07XG4gIH1cbiAgX2hhbmRsZUNsaWNrc09uQ2hpcHMoKSB7XG4gICAgaC5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuYWxsQ2hpcHMubGVuZ3RoID09PSAwICYmICh0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICAgICksIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKGZ0KSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVRleHRDb250ZW50KCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChpKSA9PiBlLnB1c2goeyB0YWc6IGkudGV4dENvbnRlbnQudHJpbSgpIH0pKSwgZTtcbiAgfVxuICBfaGFuZGxlRXZlbnRzKGUsIGkpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faGFuZGxlVGV4dENvbnRlbnQoKSwgbyA9IHRoaXMuYWxsQ2hpcHMuZmlsdGVyKFxuICAgICAgKHIpID0+IHIuaGFzQXR0cmlidXRlKGZ0KSAmJiByXG4gICAgKTtcbiAgICBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgaSwge1xuICAgICAgZXZlbnQ6IGUsXG4gICAgICBhbGxDaGlwczogdGhpcy5hbGxDaGlwcyxcbiAgICAgIGFyck9mT2JqZWN0czogbixcbiAgICAgIGFjdGl2ZTogbyxcbiAgICAgIGFjdGl2ZU9iajoge1xuICAgICAgICB0YWc6IG8ubGVuZ3RoIDw9IDAgPyBcIlwiIDogb1swXS50ZXh0Q29udGVudC50cmltKClcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2hpcHNGb2N1cygpIHtcbiAgICBoLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKHsgdGFyZ2V0OiB7IGF0dHJpYnV0ZXM6IGUgfSB9KSA9PiB7XG4gICAgICBjb25zdCBpID0gWy4uLmVdO1xuICAgICAgaS5pbmNsdWRlcyhobykgfHwgaS5pbmNsdWRlcyhtYykgfHwgaS5pbmNsdWRlcyhnYykgfHwgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVJbml0aWFsVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuX2FwcGVuZElucHV0VG9FbGVtZW50KCRhKSwgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoJGEpKSB7XG4gICAgICBjb25zdCB7IGluaXRpYWxWYWx1ZXM6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBlLmZvckVhY2goXG4gICAgICAgICh7IHRhZzogaSB9KSA9PiB0aGlzLl9oYW5kbGVDcmVhdGVDaGlwKHRoaXMuaW5wdXQsIGkpXG4gICAgICApLCBkLmZpbmRPbmUoXG4gICAgICAgIEZuLFxuICAgICAgICB0aGlzLmlucHV0LnBhcmVudE5vZGVcbiAgICAgICkuc2V0QXR0cmlidXRlKE9lLCBcIlwiKSwgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoZnQsIFwiXCIpLCB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShPZSwgXCJcIik7XG4gICAgfVxuICAgIHRoaXMuYWxsQ2hpcHMubGVuZ3RoID4gMCAmJiAodGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMudHJhbnNpdGlvbi5zcGxpdChcIiBcIilcbiAgICApKTtcbiAgfVxuICBfaGFuZGxlS2V5c0lucHV0VG9FbGVtZW50KGUpIHtcbiAgICBjb25zdCB7IGtleUNvZGU6IGksIHRhcmdldDogbiB9ID0gZTtcbiAgICBpZiAobi5oYXNBdHRyaWJ1dGUoaG8pKSB7XG4gICAgICBjb25zdCBvID0gZC5maW5kT25lKFZuLCBuKTtcbiAgICAgIGkgPT09IGx0ICYmIChuLmNvbnRlbnRFZGl0YWJsZSA9ICExLCBuLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5jb250ZW50RWRpdGFibGUuc3BsaXQoXCIgXCIpKSwgbi50ZXh0Q29udGVudCAhPT0gXCJcIiA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjLmFkZFN0eWxlKG8sIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCBvLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICB9LCAxNjApIDogbi50ZXh0Q29udGVudCA9PT0gXCJcIiAmJiAoc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4uY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgIH0sIDIwMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBuLnJlbW92ZSgpO1xuICAgICAgfSwgMzAwKSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gbHQpIHtcbiAgICAgIGlmIChuLnZhbHVlID09PSBcIlwiKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9oYW5kbGVDcmVhdGVDaGlwKG4sIG4udmFsdWUpLCB0aGlzLl9oYW5kbGVSZW1vdmVBY3RpdmVDbGFzcygpLCB0aGlzLm51bWJlckNsaWNrcyA9IHRoaXMuYWxsQ2hpcHMubGVuZ3RoICsgMSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIE9nKTtcbiAgICB9XG4gICAgdGhpcy5hbGxDaGlwcy5sZW5ndGggPiAwID8gKHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICApLCB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLnRyYW5zaXRpb24uc3BsaXQoXCIgXCIpXG4gICAgKSkgOiB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlSW5wdXRUZXh0KCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXG4gICAgICBBZyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXl1cFwiLFxuICAgICAgZSxcbiAgICAgIChpKSA9PiB0aGlzLl9oYW5kbGVLZXlzSW5wdXRUb0VsZW1lbnQoaSlcbiAgICApLCBoLm9uKHRoaXMuaW5wdXQsIFwiYmx1clwiLCAoaSkgPT4gdGhpcy5faGFuZGxlQmx1cklucHV0KGkpKTtcbiAgfVxuICBfYXBwZW5kSW5wdXRUb0VsZW1lbnQoZSkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IGFnKHRoaXMuX29wdGlvbnMsIHRoaXMuX2NsYXNzZXMpO1xuICAgIHRoaXMuX2VsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGkpO1xuICAgIGNvbnN0IG4gPSBkLmZpbmRPbmUoXG4gICAgICBcIltkYXRhLXRlLWNoaXBzLWlucHV0LXdyYXBwZXJdXCIsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICB0aGlzLl9pbnB1dEluc3RhbmNlID0gbmV3IFcoXG4gICAgICBuLFxuICAgICAgdGhpcy5fb3B0aW9ucy5pbnB1dE9wdGlvbnMsXG4gICAgICB0aGlzLl9vcHRpb25zLmlucHV0Q2xhc3Nlc1xuICAgICk7XG4gIH1cbiAgX2hhbmRsZUNyZWF0ZUNoaXAoZSwgaSkge1xuICAgIGNvbnN0IG4gPSBEKFwiZGl2XCIpLCBvID0gaGkuZ2V0SW5zdGFuY2UobiksIHIgPSBuZXcgaGkobywgeyB0ZXh0OiBpIH0sIHRoaXMuX2NsYXNzZXMpO1xuICAgIHRoaXMuX29wdGlvbnMucGFyZW50U2VsZWN0b3IgIT09IFwiXCIgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuX29wdGlvbnMucGFyZW50U2VsZWN0b3IpLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCByLmFwcGVuZENoaXAoKSkgOiBlLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWJlZ2luXCIsIHIuYXBwZW5kQ2hpcCgpKSwgZS52YWx1ZSA9IFwiXCIsIGQuZmluZCh1bykuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgbGV0IGwgPSBoaS5nZXRJbnN0YW5jZShhKTtcbiAgICAgIHJldHVybiBsIHx8IChsID0gbmV3IGhpKGEsIHt9LCB0aGlzLl9jbGFzc2VzKSksIGwuaW5pdCgpO1xuICAgIH0pLCB0aGlzLl9oYW5kbGVFZGl0YWJsZSgpO1xuICB9XG4gIF9oYW5kbGVDaGlwc09uU2VsZWN0KCkge1xuICAgIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaC5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIChpKSA9PiB7XG4gICAgICAgIGgudHJpZ2dlcihlLCBNYSwge1xuICAgICAgICAgIGV2ZW50OiBpLFxuICAgICAgICAgIGFsbENoaXBzOiB0aGlzLmFsbENoaXBzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUFkZEFjdGl2ZUNsYXNzV2l0aEtlYnlib2FyZChlKSB7XG4gICAgbGV0IGk7XG4gICAgdGhpcy5hbGxDaGlwc1tlIC0gMV0gPT09IHZvaWQgMCA/IGkgPSB0aGlzLmFsbENoaXBzW2UgLSAyXSA6IGkgPSB0aGlzLmFsbENoaXBzW2UgLSAxXSwgaS5zZXRBdHRyaWJ1dGUoZnQpO1xuICB9XG4gIF9nZXRDb25maWcoZSkge1xuICAgIGNvbnN0IGkgPSB7XG4gICAgICAuLi5NZyxcbiAgICAgIC4uLmMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi5lXG4gICAgfTtcbiAgICByZXR1cm4gTCh3aSwgaSwgTGcpLCBpO1xuICB9XG4gIF9nZXRDbGFzc2VzKGUpIHtcbiAgICBjb25zdCBpID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBlID0ge1xuICAgICAgLi4uTmcsXG4gICAgICAuLi5pLFxuICAgICAgLi4uZVxuICAgIH0sIEwod2ksIGUsIFJnKSwgZTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZSkge1xuICAgIHJldHVybiBJLmdldERhdGEoZSwgRGEpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKGUsIGkgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKGUpIHx8IG5ldyB0aGlzKGUsIHR5cGVvZiBpID09IFwib2JqZWN0XCIgPyBpIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IHp0ID0ge1xuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgY29sb3I6IFwicmdiKDEwMiwxMDIsMTAyKVwiXG4gICAgICB9XG4gICAgfVxuICB9XG59LCBtaSA9IHtcbiAgbGluZToge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC4wKVwiLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICAgICAgdGVuc2lvbjogMFxuICAgICAgICB9LFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9LFxuICAgICAgdG9vbHRpcHM6IHtcbiAgICAgICAgaW50ZXJzZWN0OiAhMSxcbiAgICAgICAgbW9kZTogXCJpbmRleFwiXG4gICAgICB9LFxuICAgICAgZGF0YXNldHM6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IFwicmVkXCJcbiAgICAgIH0sXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIHN0YWNrZWQ6ICEwLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIHN0YWNrZWQ6ICExLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIGRyYXdCb3JkZXI6ICExLFxuICAgICAgICAgICAgemVyb0xpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogWzJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmFyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICB0b29sdGlwczoge1xuICAgICAgICBpbnRlcnNlY3Q6ICExLFxuICAgICAgICBtb2RlOiBcImluZGV4XCJcbiAgICAgIH0sXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIHN0YWNrZWQ6ICEwLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIHN0YWNrZWQ6ICEwLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIGRyYXdCb3JkZXI6ICExLFxuICAgICAgICAgICAgemVyb0xpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogWzJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGllOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBhcmM6IHsgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkb3VnaG51dDoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgYXJjOiB7IGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9sYXJBcmVhOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBhcmM6IHsgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCIgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICByYWRhcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC41KVwiLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDJcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhdHRlcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC41KVwiLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICAgICAgdGVuc2lvbjogMFxuICAgICAgICB9LFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9LFxuICAgICAgdG9vbHRpcHM6IHtcbiAgICAgICAgaW50ZXJzZWN0OiAhMSxcbiAgICAgICAgbW9kZTogXCJpbmRleFwiXG4gICAgICB9LFxuICAgICAgZGF0YXNldHM6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IFwicmVkXCJcbiAgICAgIH0sXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIHN0YWNrZWQ6ICEwLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIHN0YWNrZWQ6ICExLFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIGRyYXdCb3JkZXI6ICExLFxuICAgICAgICAgICAgemVyb0xpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogWzJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYnViYmxlOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9LFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBib3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICBkcmF3Qm9yZGVyOiAhMSxcbiAgICAgICAgICAgIHplcm9MaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IFsyXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgUGcgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiBCZyh0KSAmJiAhSGcodCk7XG59O1xuZnVuY3Rpb24gQmcocykge1xuICByZXR1cm4gISFzICYmIHR5cGVvZiBzID09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBIZyhzKSB7XG4gIHZhciB0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHMpO1xuICByZXR1cm4gdCA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIiB8fCB0ID09PSBcIltvYmplY3QgRGF0ZV1cIiB8fCBGZyhzKTtcbn1cbnZhciBXZyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5mb3IsIFZnID0gV2cgPyBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSA6IDYwMTAzO1xuZnVuY3Rpb24gRmcocykge1xuICByZXR1cm4gcy4kJHR5cGVvZiA9PT0gVmc7XG59XG5mdW5jdGlvbiBZZyhzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHMpID8gW10gOiB7fTtcbn1cbmZ1bmN0aW9uIFNpKHMsIHQpIHtcbiAgcmV0dXJuIHQuY2xvbmUgIT09ICExICYmIHQuaXNNZXJnZWFibGVPYmplY3QocykgPyBYZShZZyhzKSwgcywgdCkgOiBzO1xufVxuZnVuY3Rpb24gamcocywgdCwgZSkge1xuICByZXR1cm4gcy5jb25jYXQodCkubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gU2koaSwgZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gS2cocywgdCkge1xuICBpZiAoIXQuY3VzdG9tTWVyZ2UpXG4gICAgcmV0dXJuIFhlO1xuICB2YXIgZSA9IHQuY3VzdG9tTWVyZ2Uocyk7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogWGU7XG59XG5mdW5jdGlvbiB6ZyhzKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKS5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCB0KTtcbiAgfSkgOiBbXTtcbn1cbmZ1bmN0aW9uIE5hKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHMpLmNvbmNhdCh6ZyhzKSk7XG59XG5mdW5jdGlvbiBiYyhzLCB0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHQgaW4gcztcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBVZyhzLCB0KSB7XG4gIHJldHVybiBiYyhzLCB0KSAmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHQpICYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHQpKTtcbn1cbmZ1bmN0aW9uIFhnKHMsIHQsIGUpIHtcbiAgdmFyIGkgPSB7fTtcbiAgcmV0dXJuIGUuaXNNZXJnZWFibGVPYmplY3QocykgJiYgTmEocykuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgaVtuXSA9IFNpKHNbbl0sIGUpO1xuICB9KSwgTmEodCkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgVWcocywgbikgfHwgKGJjKHMsIG4pICYmIGUuaXNNZXJnZWFibGVPYmplY3QodFtuXSkgPyBpW25dID0gS2cobiwgZSkoc1tuXSwgdFtuXSwgZSkgOiBpW25dID0gU2kodFtuXSwgZSkpO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIFhlKHMsIHQsIGUpIHtcbiAgZSA9IGUgfHwge30sIGUuYXJyYXlNZXJnZSA9IGUuYXJyYXlNZXJnZSB8fCBqZywgZS5pc01lcmdlYWJsZU9iamVjdCA9IGUuaXNNZXJnZWFibGVPYmplY3QgfHwgUGcsIGUuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBTaTtcbiAgdmFyIGkgPSBBcnJheS5pc0FycmF5KHQpLCBuID0gQXJyYXkuaXNBcnJheShzKSwgbyA9IGkgPT09IG47XG4gIHJldHVybiBvID8gaSA/IGUuYXJyYXlNZXJnZShzLCB0LCBlKSA6IFhnKHMsIHQsIGUpIDogU2kodCwgZSk7XG59XG5YZS5hbGwgPSBmdW5jdGlvbih0LCBlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXlcIik7XG4gIHJldHVybiB0LnJlZHVjZShmdW5jdGlvbihpLCBuKSB7XG4gICAgcmV0dXJuIFhlKGksIG4sIGUpO1xuICB9LCB7fSk7XG59O1xudmFyIEdnID0gWGUsIHBvID0gR2c7XG5jb25zdCBSYSA9IFwiY2hhcnRcIiwgX3MgPSBcInRlLmNoYXJ0XCIsIHFnID0gXCJjaGFydFwiLCBZbiA9IChzLCB0LCBlKSA9PiB7XG4gIGNvbnN0IGkgPSAobiwgbywgcikgPT4ge1xuICAgIGNvbnN0IGEgPSBuLnNsaWNlKCk7XG4gICAgcmV0dXJuIG8uZm9yRWFjaCgobCwgcCkgPT4ge1xuICAgICAgdHlwZW9mIGFbcF0gPiBcInVcIiA/IGFbcF0gPSByLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKFxuICAgICAgICBsLFxuICAgICAgICByXG4gICAgICApIDogci5pc01lcmdlYWJsZU9iamVjdChsKSA/IGFbcF0gPSBwbyhuW3BdLCBsLCByKSA6IG4uaW5kZXhPZihsKSA9PT0gLTEgJiYgYS5wdXNoKGwpO1xuICAgIH0pLCBhO1xuICB9O1xuICByZXR1cm4gcG8oZVt0XSwgcywge1xuICAgIGFycmF5TWVyZ2U6IGlcbiAgfSk7XG59LCBaZyA9IHtcbiAgZGFya1RpY2tzQ29sb3I6IFwiI2ZmZlwiLFxuICBkYXJrTGFiZWxDb2xvcjogXCIjZmZmXCIsXG4gIGRhcmtHcmlkTGluZXNDb2xvcjogXCIjNTU1XCIsXG4gIGRhcmttb2RlT2ZmOiBcInVuZGVmaW5lZFwiLFxuICBkYXJrTW9kZTogbnVsbCxcbiAgZGFya0JnQ29sb3I6IFwiIzI2MjYyNlwiLFxuICBkYXJrQmdDb2xvckxpZ2h0OiBcIiNmZmZcIixcbiAgb3B0aW9uczogbnVsbFxufSwgUWcgPSB7XG4gIGRhcmtUaWNrc0NvbG9yOiBcInN0cmluZ1wiLFxuICBkYXJrTGFiZWxDb2xvcjogXCJzdHJpbmdcIixcbiAgZGFya0dyaWRMaW5lc0NvbG9yOiBcInN0cmluZ1wiLFxuICBkYXJrbW9kZU9mZjogXCIoc3RyaW5nfG51bGwpXCIsXG4gIGRhcmtNb2RlOiBcIihzdHJpbmd8bnVsbClcIixcbiAgZGFya0JnQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmtCZ0NvbG9yTGlnaHQ6IFwic3RyaW5nXCIsXG4gIG9wdGlvbnM6IFwiKG9iamVjdHxudWxsKVwiXG59O1xuY2xhc3MgdmMge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpID0ge30sIG4gPSB7fSkge1xuICAgIHRoaXMuX3dhaXRGb3JDaGFydHModCwgZSwgaSwgbik7XG4gIH1cbiAgYXN5bmMgX2dldENoYXJ0anMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgQ2hhcnQ6IHQsXG4gICAgICBBcmNFbGVtZW50OiBlLFxuICAgICAgTGluZUVsZW1lbnQ6IGksXG4gICAgICBCYXJFbGVtZW50OiBuLFxuICAgICAgUG9pbnRFbGVtZW50OiBvLFxuICAgICAgQmFyQ29udHJvbGxlcjogcixcbiAgICAgIEJ1YmJsZUNvbnRyb2xsZXI6IGEsXG4gICAgICBEb3VnaG51dENvbnRyb2xsZXI6IGwsXG4gICAgICBMaW5lQ29udHJvbGxlcjogcCxcbiAgICAgIFBpZUNvbnRyb2xsZXI6IHUsXG4gICAgICBQb2xhckFyZWFDb250cm9sbGVyOiBmLFxuICAgICAgUmFkYXJDb250cm9sbGVyOiBfLFxuICAgICAgU2NhdHRlckNvbnRyb2xsZXI6IG0sXG4gICAgICBDYXRlZ29yeVNjYWxlOiBnLFxuICAgICAgTGluZWFyU2NhbGU6IHYsXG4gICAgICBMb2dhcml0aG1pY1NjYWxlOiBiLFxuICAgICAgUmFkaWFsTGluZWFyU2NhbGU6IEMsXG4gICAgICBUaW1lU2NhbGU6IHksXG4gICAgICBUaW1lU2VyaWVzU2NhbGU6IEUsXG4gICAgICBEZWNpbWF0aW9uOiBULFxuICAgICAgRmlsbGVyOiBBLFxuICAgICAgTGVnZW5kOiB3LFxuICAgICAgVGl0bGU6IFMsXG4gICAgICBUb29sdGlwOiBrLFxuICAgICAgU3ViVGl0bGU6IHhcbiAgICB9ID0gYXdhaXQgaW1wb3J0KFwiLi9jaGFydC5lcy5qc1wiKS50aGVuKCgkKSA9PiAkLmYpO1xuICAgIHJldHVybiB0LnJlZ2lzdGVyKFxuICAgICAgZSxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgbyxcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbCxcbiAgICAgIHAsXG4gICAgICB1LFxuICAgICAgZixcbiAgICAgIF8sXG4gICAgICBtLFxuICAgICAgZyxcbiAgICAgIHYsXG4gICAgICBiLFxuICAgICAgQyxcbiAgICAgIHksXG4gICAgICBFLFxuICAgICAgVCxcbiAgICAgIEEsXG4gICAgICB3LFxuICAgICAgUyxcbiAgICAgIGssXG4gICAgICB4XG4gICAgKSwgdDtcbiAgfVxuICBhc3luYyBfZ2V0Q2hhcnREYXRhTGFiZWxzKCkge1xuICAgIHJldHVybiBhd2FpdCBpbXBvcnQoXCIuL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuZXMuanNcIik7XG4gIH1cbiAgYXN5bmMgX3dhaXRGb3JDaGFydHModCwgZSwgaSA9IHt9LCBuID0ge30pIHtcbiAgICBpZiAodGhpcy5fQ2hhcnRqcyA9IGF3YWl0IHRoaXMuX2dldENoYXJ0anMoKSwgdGhpcy5fQ2hhcnREYXRhTGFiZWxzID0gYXdhaXQgdGhpcy5fZ2V0Q2hhcnREYXRhTGFiZWxzKCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9kYXRhID0gZSwgdGhpcy5fb3B0aW9ucyA9IGksIHRoaXMuX3R5cGUgPSBlLnR5cGUsIHRoaXMuX2NhbnZhcyA9IG51bGwsIHRoaXMuX2NoYXJ0ID0gbnVsbCwgdGhpcy5fZGFya09wdGlvbnMgPSB0aGlzLl9nZXREYXJrQ29uZmlnKG4pLCB0aGlzLl9kYXJrTW9kZUNsYXNzQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWxcIiksIHRoaXMuX3ByZXZDb25maWcgPSBudWxsLCB0aGlzLl9vYnNlcnZlciA9IG51bGwsIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCBfcywgdGhpcyksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgcWcpLCB0aGlzLl9jaGFydENvbnN0cnVjdG9yKCkpLCB0aGlzLl9kYXJrT3B0aW9ucy5kYXJrbW9kZU9mZiAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbyA9IHRoaXMuX2RhcmtPcHRpb25zLmRhcmtNb2RlID09PSBcImRhcmtcIiA/IFwiZGFya1wiIDogdGhpcy5fZGFya09wdGlvbnMuZGFya01vZGUgPT09IFwibGlnaHRcIiA/IFwibGlnaHRcIiA6IHRoaXMuc3lzdGVtQ29sb3JNb2RlO1xuICAgICAgdGhpcy5faGFuZGxlTW9kZShvKSwgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9vYnNlcnZlckNhbGxiYWNrLmJpbmQodGhpcykpLCB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RhcmtNb2RlQ2xhc3NDb250YWluZXIsIHtcbiAgICAgICAgYXR0cmlidXRlczogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gUmE7XG4gIH1cbiAgZ2V0IHN5c3RlbUNvbG9yTW9kZSgpIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnRoZW1lIHx8ICh0aGlzLl9kYXJrTW9kZUNsYXNzQ29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcImRhcmtcIikgPyBcImRhcmtcIiA6IFwibGlnaHRcIik7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgX3MpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICB1cGRhdGUodCwgZSkge1xuICAgIHQgJiYgKHRoaXMuX2RhdGEgPSB7IC4uLnRoaXMuX2RhdGEsIC4uLnQgfSwgdGhpcy5fY2hhcnQuZGF0YSA9IHRoaXMuX2RhdGEpO1xuICAgIGNvbnN0IGkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICBlLFxuICAgICAgXCJvcHRpb25zXCJcbiAgICApID8gZSA6IHsgb3B0aW9uczogeyAuLi5lIH0gfTtcbiAgICB0aGlzLl9vcHRpb25zID0gcG8odGhpcy5fb3B0aW9ucywgaSksIHRoaXMuX2NoYXJ0Lm9wdGlvbnMgPSBZbihcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl90eXBlLFxuICAgICAgbWlcbiAgICApLm9wdGlvbnMsIHRoaXMuX2NoYXJ0LnVwZGF0ZSgpO1xuICB9XG4gIHNldFRoZW1lKHQpIHtcbiAgICB0ICE9PSBcImRhcmtcIiAmJiB0ICE9PSBcImxpZ2h0XCIgfHwgIXRoaXMuX2RhdGEgfHwgdGhpcy5faGFuZGxlTW9kZSh0KTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXREYXJrQ29uZmlnKHQpIHtcbiAgICBsZXQgZSA9IHt9O1xuICAgIGNvbnN0IGkgPSBjLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIE9iamVjdC5rZXlzKGkpLmZvckVhY2goXG4gICAgICAocCkgPT4gcC5zdGFydHNXaXRoKFwiZGFya1wiKSAmJiAoZVtwXSA9IGlbcF0pXG4gICAgKSwgZSA9IHtcbiAgICAgIC4uLlpnLFxuICAgICAgLi4uZVxuICAgIH07XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIHk6IHtcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvclxuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya0dyaWRMaW5lc0NvbG9yXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB4OiB7XG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya1RpY2tzQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtHcmlkTGluZXNDb2xvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgbyA9IHtcbiAgICAgIHI6IHtcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvcixcbiAgICAgICAgICBiYWNrZHJvcENvbG9yOiBlLmRhcmtCZ0NvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrR3JpZExpbmVzQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgbCA9IHtcbiAgICAgIHNjYWxlczogW1wicGllXCIsIFwiZG91Z2hudXRcIiwgXCJwb2xhckFyZWFcIiwgXCJyYWRhclwiXS5pbmNsdWRlcyh0aGlzLl90eXBlKSA/IFtcInBvbGFyQXJlYVwiLCBcInJhZGFyXCJdLmluY2x1ZGVzKHRoaXMuX3R5cGUpID8gbyA6IHt9IDogbixcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBjb2xvcjogZS5kYXJrTGFiZWxDb2xvclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5lLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICAuLi5sXG4gICAgICB9LFxuICAgICAgLi4udFxuICAgIH0sIEwoUmEsIHQsIFFnKSwgdDtcbiAgfVxuICBfY2hhcnRDb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlQ2FudmFzKCk7XG4gICAgICBjb25zdCB0ID0gWW4odGhpcy5fb3B0aW9ucywgdGhpcy5fdHlwZSwgbWkpLCBlID0gW107XG4gICAgICB0LmRhdGFMYWJlbHNQbHVnaW4gJiYgZS5wdXNoKHRoaXMuX0NoYXJ0RGF0YUxhYmVscy5kZWZhdWx0KSwgdGhpcy5fcHJldkNvbmZpZyA9IHQsIHRoaXMuX2NoYXJ0ID0gbmV3IHRoaXMuX0NoYXJ0anModGhpcy5fY2FudmFzLCB7XG4gICAgICAgIC4uLnRoaXMuX2RhdGEsXG4gICAgICAgIC4uLnQsXG4gICAgICAgIHBsdWdpbnM6IGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlQ2FudmFzKCkge1xuICAgIHRoaXMuX2NhbnZhcyB8fCAodGhpcy5fZWxlbWVudC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIiA/IHRoaXMuX2NhbnZhcyA9IHRoaXMuX2VsZW1lbnQgOiAodGhpcy5fY2FudmFzID0gRChcImNhbnZhc1wiKSwgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpKSk7XG4gIH1cbiAgX2hhbmRsZU1vZGUodCkge1xuICAgIHQgPT09IFwiZGFya1wiID8gKHRoaXMuX2NoYW5nZURhdGFzZXRCb3JkZXJDb2xvcigpLCB0aGlzLnVwZGF0ZShudWxsLCB0aGlzLl9kYXJrT3B0aW9ucy5vcHRpb25zKSkgOiAodGhpcy5fY2hhbmdlRGF0YXNldEJvcmRlckNvbG9yKCExKSwgdGhpcy5fcHJldkNvbmZpZyAmJiB0aGlzLnVwZGF0ZShudWxsLCB0aGlzLl9wcmV2Q29uZmlnKSk7XG4gIH1cbiAgX29ic2VydmVyQ2FsbGJhY2sodCkge1xuICAgIGZvciAoY29uc3QgZSBvZiB0KVxuICAgICAgZS50eXBlID09PSBcImF0dHJpYnV0ZXNcIiAmJiB0aGlzLl9oYW5kbGVNb2RlKHRoaXMuc3lzdGVtQ29sb3JNb2RlKTtcbiAgfVxuICBfY2hhbmdlRGF0YXNldEJvcmRlckNvbG9yKHQgPSAhMCkge1xuICAgIFsuLi50aGlzLl9kYXRhLmRhdGEuZGF0YXNldHNdLmZvckVhY2goXG4gICAgICAoZSkgPT4gW1wicGllXCIsIFwiZG91Z2hudXRcIiwgXCJwb2xhckFyZWFcIl0uaW5jbHVkZXModGhpcy5fdHlwZSkgJiYgKGUuYm9yZGVyQ29sb3IgPSB0ID8gdGhpcy5fZGFya09wdGlvbnMuZGFya0JnQ29sb3IgOiB0aGlzLl9kYXJrT3B0aW9ucy5kYXJrQmdDb2xvckxpZ2h0KVxuICAgICk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlLCBpKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBuID0gSS5nZXREYXRhKHRoaXMsIF9zKTtcbiAgICAgIGlmICghKCFuICYmIC9kaXNwb3NlLy50ZXN0KHQpKSkge1xuICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICBjb25zdCBvID0gZSA/IFluKGUsIGksIG1pKSA6IG1pW2ldO1xuICAgICAgICAgIG4gPSBuZXcgdmModGhpcywge1xuICAgICAgICAgICAgLi4udCxcbiAgICAgICAgICAgIC4uLm9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygblt0XSA+IFwidVwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgICAgblt0XShlLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBfcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuLyohXG4gKiBwZXJmZWN0LXNjcm9sbGJhciB2MS41LjNcbiAqIENvcHlyaWdodCAyMDIxIEh5dW5qZSBKdW4sIE1EQm9vdHN0cmFwIGFuZCBDb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICovXG5mdW5jdGlvbiAkdChzKSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHMpO1xufVxuZnVuY3Rpb24gb3QocywgdCkge1xuICBmb3IgKHZhciBlIGluIHQpIHtcbiAgICB2YXIgaSA9IHRbZV07XG4gICAgdHlwZW9mIGkgPT0gXCJudW1iZXJcIiAmJiAoaSA9IGkgKyBcInB4XCIpLCBzLnN0eWxlW2VdID0gaTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGZzKHMpIHtcbiAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICByZXR1cm4gdC5jbGFzc05hbWUgPSBzLCB0O1xufVxudmFyIFBhID0gdHlwZW9mIEVsZW1lbnQgPCBcInVcIiAmJiAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yKTtcbmZ1bmN0aW9uIFp0KHMsIHQpIHtcbiAgaWYgKCFQYSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlbGVtZW50IG1hdGNoaW5nIG1ldGhvZCBzdXBwb3J0ZWRcIik7XG4gIHJldHVybiBQYS5jYWxsKHMsIHQpO1xufVxuZnVuY3Rpb24gTmUocykge1xuICBzLnJlbW92ZSA/IHMucmVtb3ZlKCkgOiBzLnBhcmVudE5vZGUgJiYgcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHMpO1xufVxuZnVuY3Rpb24gQmEocywgdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKFxuICAgIHMuY2hpbGRyZW4sXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIFp0KGUsIHQpO1xuICAgIH1cbiAgKTtcbn1cbnZhciBqID0ge1xuICBtYWluOiBcInBzXCIsXG4gIHJ0bDogXCJwc19fcnRsXCIsXG4gIGVsZW1lbnQ6IHtcbiAgICB0aHVtYjogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHNfX3RodW1iLVwiICsgcztcbiAgICB9LFxuICAgIHJhaWw6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBcInBzX19yYWlsLVwiICsgcztcbiAgICB9LFxuICAgIGNvbnN1bWluZzogXCJwc19fY2hpbGQtLWNvbnN1bWVcIlxuICB9LFxuICBzdGF0ZToge1xuICAgIGZvY3VzOiBcInBzLS1mb2N1c1wiLFxuICAgIGNsaWNraW5nOiBcInBzLS1jbGlja2luZ1wiLFxuICAgIGFjdGl2ZTogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHMtLWFjdGl2ZS1cIiArIHM7XG4gICAgfSxcbiAgICBzY3JvbGxpbmc6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBcInBzLS1zY3JvbGxpbmctXCIgKyBzO1xuICAgIH1cbiAgfVxufSwgVGMgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcbmZ1bmN0aW9uIEVjKHMsIHQpIHtcbiAgdmFyIGUgPSBzLmVsZW1lbnQuY2xhc3NMaXN0LCBpID0gai5zdGF0ZS5zY3JvbGxpbmcodCk7XG4gIGUuY29udGFpbnMoaSkgPyBjbGVhclRpbWVvdXQoVGNbdF0pIDogZS5hZGQoaSk7XG59XG5mdW5jdGlvbiBDYyhzLCB0KSB7XG4gIFRjW3RdID0gc2V0VGltZW91dChcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzLmlzQWxpdmUgJiYgcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5zY3JvbGxpbmcodCkpO1xuICAgIH0sXG4gICAgcy5zZXR0aW5ncy5zY3JvbGxpbmdUaHJlc2hvbGRcbiAgKTtcbn1cbmZ1bmN0aW9uIEpnKHMsIHQpIHtcbiAgRWMocywgdCksIENjKHMsIHQpO1xufVxudmFyIFBpID0gZnVuY3Rpb24odCkge1xuICB0aGlzLmVsZW1lbnQgPSB0LCB0aGlzLmhhbmRsZXJzID0ge307XG59LCBBYyA9IHsgaXNFbXB0eTogeyBjb25maWd1cmFibGU6ICEwIH0gfTtcblBpLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24odCwgZSkge1xuICB0eXBlb2YgdGhpcy5oYW5kbGVyc1t0XSA+IFwidVwiICYmICh0aGlzLmhhbmRsZXJzW3RdID0gW10pLCB0aGlzLmhhbmRsZXJzW3RdLnB1c2goZSksIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHQsIGUsICExKTtcbn07XG5QaS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24odCwgZSkge1xuICB2YXIgaSA9IHRoaXM7XG4gIHRoaXMuaGFuZGxlcnNbdF0gPSB0aGlzLmhhbmRsZXJzW3RdLmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIGUgJiYgbiAhPT0gZSA/ICEwIDogKGkuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHQsIG4sICExKSwgITEpO1xuICB9KTtcbn07XG5QaS5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIHQgaW4gdGhpcy5oYW5kbGVycylcbiAgICB0aGlzLnVuYmluZCh0KTtcbn07XG5BYy5pc0VtcHR5LmdldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcyA9IHRoaXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmhhbmRsZXJzKS5ldmVyeShcbiAgICBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gcy5oYW5kbGVyc1t0XS5sZW5ndGggPT09IDA7XG4gICAgfVxuICApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFBpLnByb3RvdHlwZSwgQWMpO1xudmFyIEplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xufTtcbkplLnByb3RvdHlwZS5ldmVudEVsZW1lbnQgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gdGhpcy5ldmVudEVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIGkuZWxlbWVudCA9PT0gdDtcbiAgfSlbMF07XG4gIHJldHVybiBlIHx8IChlID0gbmV3IFBpKHQpLCB0aGlzLmV2ZW50RWxlbWVudHMucHVzaChlKSksIGU7XG59O1xuSmUucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50KHQpLmJpbmQoZSwgaSk7XG59O1xuSmUucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgdmFyIG4gPSB0aGlzLmV2ZW50RWxlbWVudCh0KTtcbiAgbi51bmJpbmQoZSwgaSksIG4uaXNFbXB0eSAmJiB0aGlzLmV2ZW50RWxlbWVudHMuc3BsaWNlKHRoaXMuZXZlbnRFbGVtZW50cy5pbmRleE9mKG4pLCAxKTtcbn07XG5KZS5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC51bmJpbmRBbGwoKTtcbiAgfSksIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xufTtcbkplLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICB2YXIgbiA9IHRoaXMuZXZlbnRFbGVtZW50KHQpLCBvID0gZnVuY3Rpb24ocikge1xuICAgIG4udW5iaW5kKGUsIG8pLCBpKHIpO1xuICB9O1xuICBuLmJpbmQoZSwgbyk7XG59O1xuZnVuY3Rpb24gbXMocykge1xuICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChzKTtcbiAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICByZXR1cm4gdC5pbml0Q3VzdG9tRXZlbnQocywgITEsICExLCB2b2lkIDApLCB0O1xufVxuZnVuY3Rpb24gQnMocywgdCwgZSwgaSwgbikge1xuICBpID09PSB2b2lkIDAgJiYgKGkgPSAhMCksIG4gPT09IHZvaWQgMCAmJiAobiA9ICExKTtcbiAgdmFyIG87XG4gIGlmICh0ID09PSBcInRvcFwiKVxuICAgIG8gPSBbXG4gICAgICBcImNvbnRlbnRIZWlnaHRcIixcbiAgICAgIFwiY29udGFpbmVySGVpZ2h0XCIsXG4gICAgICBcInNjcm9sbFRvcFwiLFxuICAgICAgXCJ5XCIsXG4gICAgICBcInVwXCIsXG4gICAgICBcImRvd25cIlxuICAgIF07XG4gIGVsc2UgaWYgKHQgPT09IFwibGVmdFwiKVxuICAgIG8gPSBbXG4gICAgICBcImNvbnRlbnRXaWR0aFwiLFxuICAgICAgXCJjb250YWluZXJXaWR0aFwiLFxuICAgICAgXCJzY3JvbGxMZWZ0XCIsXG4gICAgICBcInhcIixcbiAgICAgIFwibGVmdFwiLFxuICAgICAgXCJyaWdodFwiXG4gICAgXTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihcIkEgcHJvcGVyIGF4aXMgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO1xuICB0YihzLCBlLCBvLCBpLCBuKTtcbn1cbmZ1bmN0aW9uIHRiKHMsIHQsIGUsIGksIG4pIHtcbiAgdmFyIG8gPSBlWzBdLCByID0gZVsxXSwgYSA9IGVbMl0sIGwgPSBlWzNdLCBwID0gZVs0XSwgdSA9IGVbNV07XG4gIGkgPT09IHZvaWQgMCAmJiAoaSA9ICEwKSwgbiA9PT0gdm9pZCAwICYmIChuID0gITEpO1xuICB2YXIgZiA9IHMuZWxlbWVudDtcbiAgcy5yZWFjaFtsXSA9IG51bGwsIGZbYV0gPCAxICYmIChzLnJlYWNoW2xdID0gXCJzdGFydFwiKSwgZlthXSA+IHNbb10gLSBzW3JdIC0gMSAmJiAocy5yZWFjaFtsXSA9IFwiZW5kXCIpLCB0ICYmIChmLmRpc3BhdGNoRXZlbnQobXMoXCJwcy1zY3JvbGwtXCIgKyBsKSksIHQgPCAwID8gZi5kaXNwYXRjaEV2ZW50KG1zKFwicHMtc2Nyb2xsLVwiICsgcCkpIDogdCA+IDAgJiYgZi5kaXNwYXRjaEV2ZW50KG1zKFwicHMtc2Nyb2xsLVwiICsgdSkpLCBpICYmIEpnKHMsIGwpKSwgcy5yZWFjaFtsXSAmJiAodCB8fCBuKSAmJiBmLmRpc3BhdGNoRXZlbnQobXMoXCJwcy1cIiArIGwgKyBcIi1yZWFjaC1cIiArIHMucmVhY2hbbF0pKTtcbn1cbmZ1bmN0aW9uIFYocykge1xuICByZXR1cm4gcGFyc2VJbnQocywgMTApIHx8IDA7XG59XG5mdW5jdGlvbiBlYihzKSB7XG4gIHJldHVybiBadChzLCBcImlucHV0LFtjb250ZW50ZWRpdGFibGVdXCIpIHx8IFp0KHMsIFwic2VsZWN0LFtjb250ZW50ZWRpdGFibGVdXCIpIHx8IFp0KHMsIFwidGV4dGFyZWEsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHwgWnQocywgXCJidXR0b24sW2NvbnRlbnRlZGl0YWJsZV1cIik7XG59XG5mdW5jdGlvbiBpYihzKSB7XG4gIHZhciB0ID0gJHQocyk7XG4gIHJldHVybiBWKHQud2lkdGgpICsgVih0LnBhZGRpbmdMZWZ0KSArIFYodC5wYWRkaW5nUmlnaHQpICsgVih0LmJvcmRlckxlZnRXaWR0aCkgKyBWKHQuYm9yZGVyUmlnaHRXaWR0aCk7XG59XG52YXIgJGUgPSB7XG4gIGlzV2ViS2l0OiB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiBcIldlYmtpdEFwcGVhcmFuY2VcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gIHN1cHBvcnRzVG91Y2g6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiAoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cgfHwgXCJtYXhUb3VjaFBvaW50c1wiIGluIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCksXG4gIHN1cHBvcnRzSWVQb2ludGVyOiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMsXG4gIGlzQ2hyb21lOiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgL0Nocm9tZS9pLnRlc3QobmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQpXG59O1xuZnVuY3Rpb24gQnQocykge1xuICB2YXIgdCA9IHMuZWxlbWVudCwgZSA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCBpID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcy5jb250YWluZXJXaWR0aCA9IE1hdGgucm91bmQoaS53aWR0aCksIHMuY29udGFpbmVySGVpZ2h0ID0gTWF0aC5yb3VuZChpLmhlaWdodCksIHMuY29udGVudFdpZHRoID0gdC5zY3JvbGxXaWR0aCwgcy5jb250ZW50SGVpZ2h0ID0gdC5zY3JvbGxIZWlnaHQsIHQuY29udGFpbnMocy5zY3JvbGxiYXJYUmFpbCkgfHwgKEJhKHQsIGouZWxlbWVudC5yYWlsKFwieFwiKSkuZm9yRWFjaChcbiAgICBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gTmUobik7XG4gICAgfVxuICApLCB0LmFwcGVuZENoaWxkKHMuc2Nyb2xsYmFyWFJhaWwpKSwgdC5jb250YWlucyhzLnNjcm9sbGJhcllSYWlsKSB8fCAoQmEodCwgai5lbGVtZW50LnJhaWwoXCJ5XCIpKS5mb3JFYWNoKFxuICAgIGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBOZShuKTtcbiAgICB9XG4gICksIHQuYXBwZW5kQ2hpbGQocy5zY3JvbGxiYXJZUmFpbCkpLCAhcy5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFggJiYgcy5jb250YWluZXJXaWR0aCArIHMuc2V0dGluZ3Muc2Nyb2xsWE1hcmdpbk9mZnNldCA8IHMuY29udGVudFdpZHRoID8gKHMuc2Nyb2xsYmFyWEFjdGl2ZSA9ICEwLCBzLnJhaWxYV2lkdGggPSBzLmNvbnRhaW5lcldpZHRoIC0gcy5yYWlsWE1hcmdpbldpZHRoLCBzLnJhaWxYUmF0aW8gPSBzLmNvbnRhaW5lcldpZHRoIC8gcy5yYWlsWFdpZHRoLCBzLnNjcm9sbGJhclhXaWR0aCA9IEhhKFxuICAgIHMsXG4gICAgVihzLnJhaWxYV2lkdGggKiBzLmNvbnRhaW5lcldpZHRoIC8gcy5jb250ZW50V2lkdGgpXG4gICksIHMuc2Nyb2xsYmFyWExlZnQgPSBWKFxuICAgIChzLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIHQuc2Nyb2xsTGVmdCkgKiAocy5yYWlsWFdpZHRoIC0gcy5zY3JvbGxiYXJYV2lkdGgpIC8gKHMuY29udGVudFdpZHRoIC0gcy5jb250YWluZXJXaWR0aClcbiAgKSkgOiBzLnNjcm9sbGJhclhBY3RpdmUgPSAhMSwgIXMuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxZICYmIHMuY29udGFpbmVySGVpZ2h0ICsgcy5zZXR0aW5ncy5zY3JvbGxZTWFyZ2luT2Zmc2V0IDwgcy5jb250ZW50SGVpZ2h0ID8gKHMuc2Nyb2xsYmFyWUFjdGl2ZSA9ICEwLCBzLnJhaWxZSGVpZ2h0ID0gcy5jb250YWluZXJIZWlnaHQgLSBzLnJhaWxZTWFyZ2luSGVpZ2h0LCBzLnJhaWxZUmF0aW8gPSBzLmNvbnRhaW5lckhlaWdodCAvIHMucmFpbFlIZWlnaHQsIHMuc2Nyb2xsYmFyWUhlaWdodCA9IEhhKFxuICAgIHMsXG4gICAgVihzLnJhaWxZSGVpZ2h0ICogcy5jb250YWluZXJIZWlnaHQgLyBzLmNvbnRlbnRIZWlnaHQpXG4gICksIHMuc2Nyb2xsYmFyWVRvcCA9IFYoXG4gICAgZSAqIChzLnJhaWxZSGVpZ2h0IC0gcy5zY3JvbGxiYXJZSGVpZ2h0KSAvIChzLmNvbnRlbnRIZWlnaHQgLSBzLmNvbnRhaW5lckhlaWdodClcbiAgKSkgOiBzLnNjcm9sbGJhcllBY3RpdmUgPSAhMSwgcy5zY3JvbGxiYXJYTGVmdCA+PSBzLnJhaWxYV2lkdGggLSBzLnNjcm9sbGJhclhXaWR0aCAmJiAocy5zY3JvbGxiYXJYTGVmdCA9IHMucmFpbFhXaWR0aCAtIHMuc2Nyb2xsYmFyWFdpZHRoKSwgcy5zY3JvbGxiYXJZVG9wID49IHMucmFpbFlIZWlnaHQgLSBzLnNjcm9sbGJhcllIZWlnaHQgJiYgKHMuc2Nyb2xsYmFyWVRvcCA9IHMucmFpbFlIZWlnaHQgLSBzLnNjcm9sbGJhcllIZWlnaHQpLCBzYih0LCBzKSwgcy5zY3JvbGxiYXJYQWN0aXZlID8gdC5jbGFzc0xpc3QuYWRkKGouc3RhdGUuYWN0aXZlKFwieFwiKSkgOiAodC5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuYWN0aXZlKFwieFwiKSksIHMuc2Nyb2xsYmFyWFdpZHRoID0gMCwgcy5zY3JvbGxiYXJYTGVmdCA9IDAsIHQuc2Nyb2xsTGVmdCA9IHMuaXNSdGwgPT09ICEwID8gcy5jb250ZW50V2lkdGggOiAwKSwgcy5zY3JvbGxiYXJZQWN0aXZlID8gdC5jbGFzc0xpc3QuYWRkKGouc3RhdGUuYWN0aXZlKFwieVwiKSkgOiAodC5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuYWN0aXZlKFwieVwiKSksIHMuc2Nyb2xsYmFyWUhlaWdodCA9IDAsIHMuc2Nyb2xsYmFyWVRvcCA9IDAsIHQuc2Nyb2xsVG9wID0gMCk7XG59XG5mdW5jdGlvbiBIYShzLCB0KSB7XG4gIHJldHVybiBzLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCAmJiAodCA9IE1hdGgubWF4KHQsIHMuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoKSksIHMuc2V0dGluZ3MubWF4U2Nyb2xsYmFyTGVuZ3RoICYmICh0ID0gTWF0aC5taW4odCwgcy5zZXR0aW5ncy5tYXhTY3JvbGxiYXJMZW5ndGgpKSwgdDtcbn1cbmZ1bmN0aW9uIHNiKHMsIHQpIHtcbiAgdmFyIGUgPSB7IHdpZHRoOiB0LnJhaWxYV2lkdGggfSwgaSA9IE1hdGguZmxvb3Iocy5zY3JvbGxUb3ApO1xuICB0LmlzUnRsID8gZS5sZWZ0ID0gdC5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBzLnNjcm9sbExlZnQgKyB0LmNvbnRhaW5lcldpZHRoIC0gdC5jb250ZW50V2lkdGggOiBlLmxlZnQgPSBzLnNjcm9sbExlZnQsIHQuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPyBlLmJvdHRvbSA9IHQuc2Nyb2xsYmFyWEJvdHRvbSAtIGkgOiBlLnRvcCA9IHQuc2Nyb2xsYmFyWFRvcCArIGksIG90KHQuc2Nyb2xsYmFyWFJhaWwsIGUpO1xuICB2YXIgbiA9IHsgdG9wOiBpLCBoZWlnaHQ6IHQucmFpbFlIZWlnaHQgfTtcbiAgdC5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID8gdC5pc1J0bCA/IG4ucmlnaHQgPSB0LmNvbnRlbnRXaWR0aCAtICh0Lm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIHMuc2Nyb2xsTGVmdCkgLSB0LnNjcm9sbGJhcllSaWdodCAtIHQuc2Nyb2xsYmFyWU91dGVyV2lkdGggLSA5IDogbi5yaWdodCA9IHQuc2Nyb2xsYmFyWVJpZ2h0IC0gcy5zY3JvbGxMZWZ0IDogdC5pc1J0bCA/IG4ubGVmdCA9IHQubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgcy5zY3JvbGxMZWZ0ICsgdC5jb250YWluZXJXaWR0aCAqIDIgLSB0LmNvbnRlbnRXaWR0aCAtIHQuc2Nyb2xsYmFyWUxlZnQgLSB0LnNjcm9sbGJhcllPdXRlcldpZHRoIDogbi5sZWZ0ID0gdC5zY3JvbGxiYXJZTGVmdCArIHMuc2Nyb2xsTGVmdCwgb3QodC5zY3JvbGxiYXJZUmFpbCwgbiksIG90KHQuc2Nyb2xsYmFyWCwge1xuICAgIGxlZnQ6IHQuc2Nyb2xsYmFyWExlZnQsXG4gICAgd2lkdGg6IHQuc2Nyb2xsYmFyWFdpZHRoIC0gdC5yYWlsQm9yZGVyWFdpZHRoXG4gIH0pLCBvdCh0LnNjcm9sbGJhclksIHtcbiAgICB0b3A6IHQuc2Nyb2xsYmFyWVRvcCxcbiAgICBoZWlnaHQ6IHQuc2Nyb2xsYmFyWUhlaWdodCAtIHQucmFpbEJvcmRlcllXaWR0aFxuICB9KTtcbn1cbmZ1bmN0aW9uIG5iKHMpIHtcbiAgcy5lbGVtZW50LCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJZLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pLCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJZUmFpbCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCAtIHMuc2Nyb2xsYmFyWVJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wLCBpID0gZSA+IHMuc2Nyb2xsYmFyWVRvcCA/IDEgOiAtMTtcbiAgICBzLmVsZW1lbnQuc2Nyb2xsVG9wICs9IGkgKiBzLmNvbnRhaW5lckhlaWdodCwgQnQocyksIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pLCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJYLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pLCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJYUmFpbCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCAtIHMuc2Nyb2xsYmFyWFJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCwgaSA9IGUgPiBzLnNjcm9sbGJhclhMZWZ0ID8gMSA6IC0xO1xuICAgIHMuZWxlbWVudC5zY3JvbGxMZWZ0ICs9IGkgKiBzLmNvbnRhaW5lcldpZHRoLCBCdChzKSwgdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBvYihzKSB7XG4gIFdhKHMsIFtcbiAgICBcImNvbnRhaW5lcldpZHRoXCIsXG4gICAgXCJjb250ZW50V2lkdGhcIixcbiAgICBcInBhZ2VYXCIsXG4gICAgXCJyYWlsWFdpZHRoXCIsXG4gICAgXCJzY3JvbGxiYXJYXCIsXG4gICAgXCJzY3JvbGxiYXJYV2lkdGhcIixcbiAgICBcInNjcm9sbExlZnRcIixcbiAgICBcInhcIixcbiAgICBcInNjcm9sbGJhclhSYWlsXCJcbiAgXSksIFdhKHMsIFtcbiAgICBcImNvbnRhaW5lckhlaWdodFwiLFxuICAgIFwiY29udGVudEhlaWdodFwiLFxuICAgIFwicGFnZVlcIixcbiAgICBcInJhaWxZSGVpZ2h0XCIsXG4gICAgXCJzY3JvbGxiYXJZXCIsXG4gICAgXCJzY3JvbGxiYXJZSGVpZ2h0XCIsXG4gICAgXCJzY3JvbGxUb3BcIixcbiAgICBcInlcIixcbiAgICBcInNjcm9sbGJhcllSYWlsXCJcbiAgXSk7XG59XG5mdW5jdGlvbiBXYShzLCB0KSB7XG4gIHZhciBlID0gdFswXSwgaSA9IHRbMV0sIG4gPSB0WzJdLCBvID0gdFszXSwgciA9IHRbNF0sIGEgPSB0WzVdLCBsID0gdFs2XSwgcCA9IHRbN10sIHUgPSB0WzhdLCBmID0gcy5lbGVtZW50LCBfID0gbnVsbCwgbSA9IG51bGwsIGcgPSBudWxsO1xuICBmdW5jdGlvbiB2KHkpIHtcbiAgICB5LnRvdWNoZXMgJiYgeS50b3VjaGVzWzBdICYmICh5W25dID0geS50b3VjaGVzWzBdLnBhZ2VZKSwgZltsXSA9IF8gKyBnICogKHlbbl0gLSBtKSwgRWMocywgcCksIEJ0KHMpLCB5LnN0b3BQcm9wYWdhdGlvbigpLCB5LnR5cGUuc3RhcnRzV2l0aChcInRvdWNoXCIpICYmIHkuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMSAmJiB5LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZnVuY3Rpb24gYigpIHtcbiAgICBDYyhzLCBwKSwgc1t1XS5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuY2xpY2tpbmcpLCBzLmV2ZW50LnVuYmluZChzLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIHYpO1xuICB9XG4gIGZ1bmN0aW9uIEMoeSwgRSkge1xuICAgIF8gPSBmW2xdLCBFICYmIHkudG91Y2hlcyAmJiAoeVtuXSA9IHkudG91Y2hlc1swXS5wYWdlWSksIG0gPSB5W25dLCBnID0gKHNbaV0gLSBzW2VdKSAvIChzW29dIC0gc1thXSksIEUgPyBzLmV2ZW50LmJpbmQocy5vd25lckRvY3VtZW50LCBcInRvdWNobW92ZVwiLCB2KSA6IChzLmV2ZW50LmJpbmQocy5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCB2KSwgcy5ldmVudC5vbmNlKHMub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIGIpLCB5LnByZXZlbnREZWZhdWx0KCkpLCBzW3VdLmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5jbGlja2luZyksIHkuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgcy5ldmVudC5iaW5kKHNbcl0sIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICBDKHkpO1xuICB9KSwgcy5ldmVudC5iaW5kKHNbcl0sIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbih5KSB7XG4gICAgQyh5LCAhMCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmIocykge1xuICB2YXIgdCA9IHMuZWxlbWVudCwgZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBadCh0LCBcIjpob3ZlclwiKTtcbiAgfSwgaSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBadChzLnNjcm9sbGJhclgsIFwiOmZvY3VzXCIpIHx8IFp0KHMuc2Nyb2xsYmFyWSwgXCI6Zm9jdXNcIik7XG4gIH07XG4gIGZ1bmN0aW9uIG4obywgcikge1xuICAgIHZhciBhID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCk7XG4gICAgaWYgKG8gPT09IDApIHtcbiAgICAgIGlmICghcy5zY3JvbGxiYXJZQWN0aXZlKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAoYSA9PT0gMCAmJiByID4gMCB8fCBhID49IHMuY29udGVudEhlaWdodCAtIHMuY29udGFpbmVySGVpZ2h0ICYmIHIgPCAwKVxuICAgICAgICByZXR1cm4gIXMuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICB9XG4gICAgdmFyIGwgPSB0LnNjcm9sbExlZnQ7XG4gICAgaWYgKHIgPT09IDApIHtcbiAgICAgIGlmICghcy5zY3JvbGxiYXJYQWN0aXZlKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAobCA9PT0gMCAmJiBvIDwgMCB8fCBsID49IHMuY29udGVudFdpZHRoIC0gcy5jb250YWluZXJXaWR0aCAmJiBvID4gMClcbiAgICAgICAgcmV0dXJuICFzLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICBzLmV2ZW50LmJpbmQocy5vd25lckRvY3VtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24obykge1xuICAgIGlmICghKG8uaXNEZWZhdWx0UHJldmVudGVkICYmIG8uaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgby5kZWZhdWx0UHJldmVudGVkKSAmJiAhKCFlKCkgJiYgIWkoKSkpIHtcbiAgICAgIHZhciByID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA/IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBzLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIGlmIChyLnRhZ05hbWUgPT09IFwiSUZSQU1FXCIpXG4gICAgICAgICAgciA9IHIuY29udGVudERvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKDsgci5zaGFkb3dSb290OyApXG4gICAgICAgICAgICByID0gci5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChlYihyKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYSA9IDAsIGwgPSAwO1xuICAgICAgc3dpdGNoIChvLndoaWNoKSB7XG4gICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgby5tZXRhS2V5ID8gYSA9IC1zLmNvbnRlbnRXaWR0aCA6IG8uYWx0S2V5ID8gYSA9IC1zLmNvbnRhaW5lcldpZHRoIDogYSA9IC0zMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBsID0gcy5jb250ZW50SGVpZ2h0IDogby5hbHRLZXkgPyBsID0gcy5jb250YWluZXJIZWlnaHQgOiBsID0gMzA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgby5tZXRhS2V5ID8gYSA9IHMuY29udGVudFdpZHRoIDogby5hbHRLZXkgPyBhID0gcy5jb250YWluZXJXaWR0aCA6IGEgPSAzMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBsID0gLXMuY29udGVudEhlaWdodCA6IG8uYWx0S2V5ID8gbCA9IC1zLmNvbnRhaW5lckhlaWdodCA6IGwgPSAtMzA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgby5zaGlmdEtleSA/IGwgPSBzLmNvbnRhaW5lckhlaWdodCA6IGwgPSAtcy5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgbCA9IHMuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgIGwgPSAtcy5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgbCA9IHMuY29udGVudEhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICBsID0gLXMuY29udGVudEhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWCAmJiBhICE9PSAwIHx8IHMuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxZICYmIGwgIT09IDAgfHwgKHQuc2Nyb2xsVG9wIC09IGwsIHQuc2Nyb2xsTGVmdCArPSBhLCBCdChzKSwgbihhLCBsKSAmJiBvLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhYihzKSB7XG4gIHZhciB0ID0gcy5lbGVtZW50O1xuICBmdW5jdGlvbiBlKHIsIGEpIHtcbiAgICB2YXIgbCA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCBwID0gdC5zY3JvbGxUb3AgPT09IDAsIHUgPSBsICsgdC5vZmZzZXRIZWlnaHQgPT09IHQuc2Nyb2xsSGVpZ2h0LCBmID0gdC5zY3JvbGxMZWZ0ID09PSAwLCBfID0gdC5zY3JvbGxMZWZ0ICsgdC5vZmZzZXRXaWR0aCA9PT0gdC5zY3JvbGxXaWR0aCwgbTtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSkgPiBNYXRoLmFicyhyKSA/IG0gPSBwIHx8IHUgOiBtID0gZiB8fCBfLCBtID8gIXMuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbiA6ICEwO1xuICB9XG4gIGZ1bmN0aW9uIGkocikge1xuICAgIHZhciBhID0gci5kZWx0YVgsIGwgPSAtMSAqIHIuZGVsdGFZO1xuICAgIHJldHVybiAodHlwZW9mIGEgPiBcInVcIiB8fCB0eXBlb2YgbCA+IFwidVwiKSAmJiAoYSA9IC0xICogci53aGVlbERlbHRhWCAvIDYsIGwgPSByLndoZWVsRGVsdGFZIC8gNiksIHIuZGVsdGFNb2RlICYmIHIuZGVsdGFNb2RlID09PSAxICYmIChhICo9IDEwLCBsICo9IDEwKSwgYSAhPT0gYSAmJiBsICE9PSBsICYmIChhID0gMCwgbCA9IHIud2hlZWxEZWx0YSksIHIuc2hpZnRLZXkgPyBbLWwsIC1hXSA6IFthLCBsXTtcbiAgfVxuICBmdW5jdGlvbiBuKHIsIGEsIGwpIHtcbiAgICBpZiAoISRlLmlzV2ViS2l0ICYmIHQucXVlcnlTZWxlY3RvcihcInNlbGVjdDpmb2N1c1wiKSlcbiAgICAgIHJldHVybiAhMDtcbiAgICBpZiAoIXQuY29udGFpbnMocikpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yICh2YXIgcCA9IHI7IHAgJiYgcCAhPT0gdDsgKSB7XG4gICAgICBpZiAocC5jbGFzc0xpc3QuY29udGFpbnMoai5lbGVtZW50LmNvbnN1bWluZykpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHZhciB1ID0gJHQocCk7XG4gICAgICBpZiAobCAmJiB1Lm92ZXJmbG93WS5tYXRjaCgvKHNjcm9sbHxhdXRvKS8pKSB7XG4gICAgICAgIHZhciBmID0gcC5zY3JvbGxIZWlnaHQgLSBwLmNsaWVudEhlaWdodDtcbiAgICAgICAgaWYgKGYgPiAwICYmIChwLnNjcm9sbFRvcCA+IDAgJiYgbCA8IDAgfHwgcC5zY3JvbGxUb3AgPCBmICYmIGwgPiAwKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBpZiAoYSAmJiB1Lm92ZXJmbG93WC5tYXRjaCgvKHNjcm9sbHxhdXRvKS8pKSB7XG4gICAgICAgIHZhciBfID0gcC5zY3JvbGxXaWR0aCAtIHAuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmIChfID4gMCAmJiAocC5zY3JvbGxMZWZ0ID4gMCAmJiBhIDwgMCB8fCBwLnNjcm9sbExlZnQgPCBfICYmIGEgPiAwKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBwID0gcC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gbyhyKSB7XG4gICAgdmFyIGEgPSBpKHIpLCBsID0gYVswXSwgcCA9IGFbMV07XG4gICAgaWYgKCFuKHIudGFyZ2V0LCBsLCBwKSkge1xuICAgICAgdmFyIHUgPSAhMTtcbiAgICAgIHMuc2V0dGluZ3MudXNlQm90aFdoZWVsQXhlcyA/IHMuc2Nyb2xsYmFyWUFjdGl2ZSAmJiAhcy5zY3JvbGxiYXJYQWN0aXZlID8gKHAgPyB0LnNjcm9sbFRvcCAtPSBwICogcy5zZXR0aW5ncy53aGVlbFNwZWVkIDogdC5zY3JvbGxUb3AgKz0gbCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCwgdSA9ICEwKSA6IHMuc2Nyb2xsYmFyWEFjdGl2ZSAmJiAhcy5zY3JvbGxiYXJZQWN0aXZlICYmIChsID8gdC5zY3JvbGxMZWZ0ICs9IGwgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQgOiB0LnNjcm9sbExlZnQgLT0gcCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCwgdSA9ICEwKSA6ICh0LnNjcm9sbFRvcCAtPSBwICogcy5zZXR0aW5ncy53aGVlbFNwZWVkLCB0LnNjcm9sbExlZnQgKz0gbCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCksIEJ0KHMpLCB1ID0gdSB8fCBlKGwsIHApLCB1ICYmICFyLmN0cmxLZXkgJiYgKHIuc3RvcFByb3BhZ2F0aW9uKCksIHIucHJldmVudERlZmF1bHQoKSk7XG4gICAgfVxuICB9XG4gIHR5cGVvZiB3aW5kb3cub253aGVlbCA8IFwidVwiID8gcy5ldmVudC5iaW5kKHQsIFwid2hlZWxcIiwgbykgOiB0eXBlb2Ygd2luZG93Lm9ubW91c2V3aGVlbCA8IFwidVwiICYmIHMuZXZlbnQuYmluZCh0LCBcIm1vdXNld2hlZWxcIiwgbyk7XG59XG5mdW5jdGlvbiBsYihzKSB7XG4gIGlmICghJGUuc3VwcG9ydHNUb3VjaCAmJiAhJGUuc3VwcG9ydHNJZVBvaW50ZXIpXG4gICAgcmV0dXJuO1xuICB2YXIgdCA9IHMuZWxlbWVudDtcbiAgZnVuY3Rpb24gZShnLCB2KSB7XG4gICAgdmFyIGIgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKSwgQyA9IHQuc2Nyb2xsTGVmdCwgeSA9IE1hdGguYWJzKGcpLCBFID0gTWF0aC5hYnModik7XG4gICAgaWYgKEUgPiB5KSB7XG4gICAgICBpZiAodiA8IDAgJiYgYiA9PT0gcy5jb250ZW50SGVpZ2h0IC0gcy5jb250YWluZXJIZWlnaHQgfHwgdiA+IDAgJiYgYiA9PT0gMClcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZID09PSAwICYmIHYgPiAwICYmICRlLmlzQ2hyb21lO1xuICAgIH0gZWxzZSBpZiAoeSA+IEUgJiYgKGcgPCAwICYmIEMgPT09IHMuY29udGVudFdpZHRoIC0gcy5jb250YWluZXJXaWR0aCB8fCBnID4gMCAmJiBDID09PSAwKSlcbiAgICAgIHJldHVybiAhMDtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgZnVuY3Rpb24gaShnLCB2KSB7XG4gICAgdC5zY3JvbGxUb3AgLT0gdiwgdC5zY3JvbGxMZWZ0IC09IGcsIEJ0KHMpO1xuICB9XG4gIHZhciBuID0ge30sIG8gPSAwLCByID0ge30sIGEgPSBudWxsO1xuICBmdW5jdGlvbiBsKGcpIHtcbiAgICByZXR1cm4gZy50YXJnZXRUb3VjaGVzID8gZy50YXJnZXRUb3VjaGVzWzBdIDogZztcbiAgfVxuICBmdW5jdGlvbiBwKGcpIHtcbiAgICByZXR1cm4gZy5wb2ludGVyVHlwZSAmJiBnLnBvaW50ZXJUeXBlID09PSBcInBlblwiICYmIGcuYnV0dG9ucyA9PT0gMCA/ICExIDogISEoZy50YXJnZXRUb3VjaGVzICYmIGcudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEgfHwgZy5wb2ludGVyVHlwZSAmJiBnLnBvaW50ZXJUeXBlICE9PSBcIm1vdXNlXCIgJiYgZy5wb2ludGVyVHlwZSAhPT0gZy5NU1BPSU5URVJfVFlQRV9NT1VTRSk7XG4gIH1cbiAgZnVuY3Rpb24gdShnKSB7XG4gICAgaWYgKHAoZykpIHtcbiAgICAgIHZhciB2ID0gbChnKTtcbiAgICAgIG4ucGFnZVggPSB2LnBhZ2VYLCBuLnBhZ2VZID0gdi5wYWdlWSwgbyA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpLCBhICE9PSBudWxsICYmIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGYoZywgdiwgYikge1xuICAgIGlmICghdC5jb250YWlucyhnKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKHZhciBDID0gZzsgQyAmJiBDICE9PSB0OyApIHtcbiAgICAgIGlmIChDLmNsYXNzTGlzdC5jb250YWlucyhqLmVsZW1lbnQuY29uc3VtaW5nKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgdmFyIHkgPSAkdChDKTtcbiAgICAgIGlmIChiICYmIHkub3ZlcmZsb3dZLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIEUgPSBDLnNjcm9sbEhlaWdodCAtIEMuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoRSA+IDAgJiYgKEMuc2Nyb2xsVG9wID4gMCAmJiBiIDwgMCB8fCBDLnNjcm9sbFRvcCA8IEUgJiYgYiA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIGlmICh2ICYmIHkub3ZlcmZsb3dYLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIFQgPSBDLnNjcm9sbFdpZHRoIC0gQy5jbGllbnRXaWR0aDtcbiAgICAgICAgaWYgKFQgPiAwICYmIChDLnNjcm9sbExlZnQgPiAwICYmIHYgPCAwIHx8IEMuc2Nyb2xsTGVmdCA8IFQgJiYgdiA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIEMgPSBDLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBfKGcpIHtcbiAgICBpZiAocChnKSkge1xuICAgICAgdmFyIHYgPSBsKGcpLCBiID0geyBwYWdlWDogdi5wYWdlWCwgcGFnZVk6IHYucGFnZVkgfSwgQyA9IGIucGFnZVggLSBuLnBhZ2VYLCB5ID0gYi5wYWdlWSAtIG4ucGFnZVk7XG4gICAgICBpZiAoZihnLnRhcmdldCwgQywgeSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGkoQywgeSksIG4gPSBiO1xuICAgICAgdmFyIEUgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSwgVCA9IEUgLSBvO1xuICAgICAgVCA+IDAgJiYgKHIueCA9IEMgLyBULCByLnkgPSB5IC8gVCwgbyA9IEUpLCBlKEMsIHkpICYmIGcucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbSgpIHtcbiAgICBzLnNldHRpbmdzLnN3aXBlRWFzaW5nICYmIChjbGVhckludGVydmFsKGEpLCBhID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghci54ICYmICFyLnkpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHIueCkgPCAwLjAxICYmIE1hdGguYWJzKHIueSkgPCAwLjAxKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghcy5lbGVtZW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGkoci54ICogMzAsIHIueSAqIDMwKSwgci54ICo9IDAuOCwgci55ICo9IDAuODtcbiAgICB9LCAxMCkpO1xuICB9XG4gICRlLnN1cHBvcnRzVG91Y2ggPyAocy5ldmVudC5iaW5kKHQsIFwidG91Y2hzdGFydFwiLCB1KSwgcy5ldmVudC5iaW5kKHQsIFwidG91Y2htb3ZlXCIsIF8pLCBzLmV2ZW50LmJpbmQodCwgXCJ0b3VjaGVuZFwiLCBtKSkgOiAkZS5zdXBwb3J0c0llUG9pbnRlciAmJiAod2luZG93LlBvaW50ZXJFdmVudCA/IChzLmV2ZW50LmJpbmQodCwgXCJwb2ludGVyZG93blwiLCB1KSwgcy5ldmVudC5iaW5kKHQsIFwicG9pbnRlcm1vdmVcIiwgXyksIHMuZXZlbnQuYmluZCh0LCBcInBvaW50ZXJ1cFwiLCBtKSkgOiB3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgKHMuZXZlbnQuYmluZCh0LCBcIk1TUG9pbnRlckRvd25cIiwgdSksIHMuZXZlbnQuYmluZCh0LCBcIk1TUG9pbnRlck1vdmVcIiwgXyksIHMuZXZlbnQuYmluZCh0LCBcIk1TUG9pbnRlclVwXCIsIG0pKSk7XG59XG52YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVyczogW1wiY2xpY2stcmFpbFwiLCBcImRyYWctdGh1bWJcIiwgXCJrZXlib2FyZFwiLCBcIndoZWVsXCIsIFwidG91Y2hcIl0sXG4gICAgbWF4U2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICAgIG1pblNjcm9sbGJhckxlbmd0aDogbnVsbCxcbiAgICBzY3JvbGxpbmdUaHJlc2hvbGQ6IDFlMyxcbiAgICBzY3JvbGxYTWFyZ2luT2Zmc2V0OiAwLFxuICAgIHNjcm9sbFlNYXJnaW5PZmZzZXQ6IDAsXG4gICAgc3VwcHJlc3NTY3JvbGxYOiAhMSxcbiAgICBzdXBwcmVzc1Njcm9sbFk6ICExLFxuICAgIHN3aXBlRWFzaW5nOiAhMCxcbiAgICB1c2VCb3RoV2hlZWxBeGVzOiAhMSxcbiAgICB3aGVlbFByb3BhZ2F0aW9uOiAhMCxcbiAgICB3aGVlbFNwZWVkOiAxXG4gIH07XG59LCBoYiA9IHtcbiAgXCJjbGljay1yYWlsXCI6IG5iLFxuICBcImRyYWctdGh1bWJcIjogb2IsXG4gIGtleWJvYXJkOiByYixcbiAgd2hlZWw6IGFiLFxuICB0b3VjaDogbGJcbn0sIEJpID0gZnVuY3Rpb24odCwgZSkge1xuICB2YXIgaSA9IHRoaXM7XG4gIGlmIChlID09PSB2b2lkIDAgJiYgKGUgPSB7fSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpKSwgIXQgfHwgIXQubm9kZU5hbWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm8gZWxlbWVudCBpcyBzcGVjaWZpZWQgdG8gaW5pdGlhbGl6ZSBQZXJmZWN0U2Nyb2xsYmFyXCIpO1xuICB0aGlzLmVsZW1lbnQgPSB0LCB0LmNsYXNzTGlzdC5hZGQoai5tYWluKSwgdGhpcy5zZXR0aW5ncyA9IGNiKCk7XG4gIGZvciAodmFyIG4gaW4gZSlcbiAgICB0aGlzLnNldHRpbmdzW25dID0gZVtuXTtcbiAgdGhpcy5jb250YWluZXJXaWR0aCA9IG51bGwsIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gbnVsbCwgdGhpcy5jb250ZW50V2lkdGggPSBudWxsLCB0aGlzLmNvbnRlbnRIZWlnaHQgPSBudWxsO1xuICB2YXIgbyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5mb2N1cyk7XG4gIH0sIHIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuZm9jdXMpO1xuICB9O1xuICB0aGlzLmlzUnRsID0gJHQodCkuZGlyZWN0aW9uID09PSBcInJ0bFwiLCB0aGlzLmlzUnRsID09PSAhMCAmJiB0LmNsYXNzTGlzdC5hZGQoai5ydGwpLCB0aGlzLmlzTmVnYXRpdmVTY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcCA9IHQuc2Nyb2xsTGVmdCwgdSA9IG51bGw7XG4gICAgcmV0dXJuIHQuc2Nyb2xsTGVmdCA9IC0xLCB1ID0gdC5zY3JvbGxMZWZ0IDwgMCwgdC5zY3JvbGxMZWZ0ID0gcCwgdTtcbiAgfSgpLCB0aGlzLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCA9IHRoaXMuaXNOZWdhdGl2ZVNjcm9sbCA/IHQuc2Nyb2xsV2lkdGggLSB0LmNsaWVudFdpZHRoIDogMCwgdGhpcy5ldmVudCA9IG5ldyBKZSgpLCB0aGlzLm93bmVyRG9jdW1lbnQgPSB0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQsIHRoaXMuc2Nyb2xsYmFyWFJhaWwgPSBmcyhqLmVsZW1lbnQucmFpbChcInhcIikpLCB0LmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWFJhaWwpLCB0aGlzLnNjcm9sbGJhclggPSBmcyhqLmVsZW1lbnQudGh1bWIoXCJ4XCIpKSwgdGhpcy5zY3JvbGxiYXJYUmFpbC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclgpLCB0aGlzLnNjcm9sbGJhclguc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclgsIFwiZm9jdXNcIiwgbyksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclgsIFwiYmx1clwiLCByKSwgdGhpcy5zY3JvbGxiYXJYQWN0aXZlID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJYV2lkdGggPSBudWxsLCB0aGlzLnNjcm9sbGJhclhMZWZ0ID0gbnVsbDtcbiAgdmFyIGEgPSAkdCh0aGlzLnNjcm9sbGJhclhSYWlsKTtcbiAgdGhpcy5zY3JvbGxiYXJYQm90dG9tID0gcGFyc2VJbnQoYS5ib3R0b20sIDEwKSwgaXNOYU4odGhpcy5zY3JvbGxiYXJYQm90dG9tKSA/ICh0aGlzLmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tID0gITEsIHRoaXMuc2Nyb2xsYmFyWFRvcCA9IFYoYS50b3ApKSA6IHRoaXMuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPSAhMCwgdGhpcy5yYWlsQm9yZGVyWFdpZHRoID0gVihhLmJvcmRlckxlZnRXaWR0aCkgKyBWKGEuYm9yZGVyUmlnaHRXaWR0aCksIG90KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCB0aGlzLnJhaWxYTWFyZ2luV2lkdGggPSBWKGEubWFyZ2luTGVmdCkgKyBWKGEubWFyZ2luUmlnaHQpLCBvdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSksIHRoaXMucmFpbFhXaWR0aCA9IG51bGwsIHRoaXMucmFpbFhSYXRpbyA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWVJhaWwgPSBmcyhqLmVsZW1lbnQucmFpbChcInlcIikpLCB0LmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWVJhaWwpLCB0aGlzLnNjcm9sbGJhclkgPSBmcyhqLmVsZW1lbnQudGh1bWIoXCJ5XCIpKSwgdGhpcy5zY3JvbGxiYXJZUmFpbC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclkpLCB0aGlzLnNjcm9sbGJhclkuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclksIFwiZm9jdXNcIiwgbyksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclksIFwiYmx1clwiLCByKSwgdGhpcy5zY3JvbGxiYXJZQWN0aXZlID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZSGVpZ2h0ID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZVG9wID0gbnVsbDtcbiAgdmFyIGwgPSAkdCh0aGlzLnNjcm9sbGJhcllSYWlsKTtcbiAgdGhpcy5zY3JvbGxiYXJZUmlnaHQgPSBwYXJzZUludChsLnJpZ2h0LCAxMCksIGlzTmFOKHRoaXMuc2Nyb2xsYmFyWVJpZ2h0KSA/ICh0aGlzLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPSAhMSwgdGhpcy5zY3JvbGxiYXJZTGVmdCA9IFYobC5sZWZ0KSkgOiB0aGlzLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPSAhMCwgdGhpcy5zY3JvbGxiYXJZT3V0ZXJXaWR0aCA9IHRoaXMuaXNSdGwgPyBpYih0aGlzLnNjcm9sbGJhclkpIDogbnVsbCwgdGhpcy5yYWlsQm9yZGVyWVdpZHRoID0gVihsLmJvcmRlclRvcFdpZHRoKSArIFYobC5ib3JkZXJCb3R0b21XaWR0aCksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCB0aGlzLnJhaWxZTWFyZ2luSGVpZ2h0ID0gVihsLm1hcmdpblRvcCkgKyBWKGwubWFyZ2luQm90dG9tKSwgb3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcIlwiIH0pLCB0aGlzLnJhaWxZSGVpZ2h0ID0gbnVsbCwgdGhpcy5yYWlsWVJhdGlvID0gbnVsbCwgdGhpcy5yZWFjaCA9IHtcbiAgICB4OiB0LnNjcm9sbExlZnQgPD0gMCA/IFwic3RhcnRcIiA6IHQuc2Nyb2xsTGVmdCA+PSB0aGlzLmNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGFpbmVyV2lkdGggPyBcImVuZFwiIDogbnVsbCxcbiAgICB5OiB0LnNjcm9sbFRvcCA8PSAwID8gXCJzdGFydFwiIDogdC5zY3JvbGxUb3AgPj0gdGhpcy5jb250ZW50SGVpZ2h0IC0gdGhpcy5jb250YWluZXJIZWlnaHQgPyBcImVuZFwiIDogbnVsbFxuICB9LCB0aGlzLmlzQWxpdmUgPSAhMCwgdGhpcy5zZXR0aW5ncy5oYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gaGJbcF0oaSk7XG4gIH0pLCB0aGlzLmxhc3RTY3JvbGxUb3AgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKSwgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IHQuc2Nyb2xsTGVmdCwgdGhpcy5ldmVudC5iaW5kKHRoaXMuZWxlbWVudCwgXCJzY3JvbGxcIiwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBpLm9uU2Nyb2xsKHApO1xuICB9KSwgQnQodGhpcyk7XG59O1xuQmkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlzQWxpdmUgJiYgKHRoaXMubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ID0gdGhpcy5pc05lZ2F0aXZlU2Nyb2xsID8gdGhpcy5lbGVtZW50LnNjcm9sbFdpZHRoIC0gdGhpcy5lbGVtZW50LmNsaWVudFdpZHRoIDogMCwgb3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCB0aGlzLnJhaWxYTWFyZ2luV2lkdGggPSBWKCR0KHRoaXMuc2Nyb2xsYmFyWFJhaWwpLm1hcmdpbkxlZnQpICsgVigkdCh0aGlzLnNjcm9sbGJhclhSYWlsKS5tYXJnaW5SaWdodCksIHRoaXMucmFpbFlNYXJnaW5IZWlnaHQgPSBWKCR0KHRoaXMuc2Nyb2xsYmFyWVJhaWwpLm1hcmdpblRvcCkgKyBWKCR0KHRoaXMuc2Nyb2xsYmFyWVJhaWwpLm1hcmdpbkJvdHRvbSksIG90KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJub25lXCIgfSksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJub25lXCIgfSksIEJ0KHRoaXMpLCBCcyh0aGlzLCBcInRvcFwiLCAwLCAhMSwgITApLCBCcyh0aGlzLCBcImxlZnRcIiwgMCwgITEsICEwKSwgb3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcIlwiIH0pLCBvdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSkpO1xufTtcbkJpLnByb3RvdHlwZS5vblNjcm9sbCA9IGZ1bmN0aW9uKHQpIHtcbiAgdGhpcy5pc0FsaXZlICYmIChCdCh0aGlzKSwgQnModGhpcywgXCJ0b3BcIiwgdGhpcy5lbGVtZW50LnNjcm9sbFRvcCAtIHRoaXMubGFzdFNjcm9sbFRvcCksIEJzKFxuICAgIHRoaXMsXG4gICAgXCJsZWZ0XCIsXG4gICAgdGhpcy5lbGVtZW50LnNjcm9sbExlZnQgLSB0aGlzLmxhc3RTY3JvbGxMZWZ0XG4gICksIHRoaXMubGFzdFNjcm9sbFRvcCA9IE1hdGguZmxvb3IodGhpcy5lbGVtZW50LnNjcm9sbFRvcCksIHRoaXMubGFzdFNjcm9sbExlZnQgPSB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCk7XG59O1xuQmkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pc0FsaXZlICYmICh0aGlzLmV2ZW50LnVuYmluZEFsbCgpLCBOZSh0aGlzLnNjcm9sbGJhclgpLCBOZSh0aGlzLnNjcm9sbGJhclkpLCBOZSh0aGlzLnNjcm9sbGJhclhSYWlsKSwgTmUodGhpcy5zY3JvbGxiYXJZUmFpbCksIHRoaXMucmVtb3ZlUHNDbGFzc2VzKCksIHRoaXMuZWxlbWVudCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWSA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWFJhaWwgPSBudWxsLCB0aGlzLnNjcm9sbGJhcllSYWlsID0gbnVsbCwgdGhpcy5pc0FsaXZlID0gITEpO1xufTtcbkJpLnByb3RvdHlwZS5yZW1vdmVQc0NsYXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMuZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICF0Lm1hdGNoKC9ecHMoWy1fXS4rfCkkLyk7XG4gIH0pLmpvaW4oXCIgXCIpO1xufTtcbmNvbnN0IGpuID0gXCJwZXJmZWN0U2Nyb2xsYmFyXCIsIGRiID0gXCJwZXJmZWN0LXNjcm9sbGJhclwiLCBncyA9IFwidGUucGVyZmVjdFNjcm9sbGJhclwiLCBrdCA9IFwidGVcIiwgT3QgPSBcInBzXCIsIEtuID0gW1xuICB7IHRlOiBgc2Nyb2xsWC4ke2t0fS4ke090fWAsIHBzOiBcInBzLXNjcm9sbC14XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFkuJHtrdH0uJHtPdH1gLCBwczogXCJwcy1zY3JvbGwteVwiIH0sXG4gIHsgdGU6IGBzY3JvbGxVcC4ke2t0fS4ke090fWAsIHBzOiBcInBzLXNjcm9sbC11cFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxEb3duLiR7a3R9LiR7T3R9YCwgcHM6IFwicHMtc2Nyb2xsLWRvd25cIiB9LFxuICB7IHRlOiBgc2Nyb2xsTGVmdC4ke2t0fS4ke090fWAsIHBzOiBcInBzLXNjcm9sbC1sZWZ0XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFJpZ2h0LiR7a3R9LiR7T3R9YCwgcHM6IFwicHMtc2Nyb2xsLXJpZ2h0XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFhFbmQuJHtrdH0uJHtPdH1gLCBwczogXCJwcy14LXJlYWNoLWVuZFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxZRW5kLiR7a3R9LiR7T3R9YCwgcHM6IFwicHMteS1yZWFjaC1lbmRcIiB9LFxuICB7IHRlOiBgc2Nyb2xsWFN0YXJ0LiR7a3R9LiR7T3R9YCwgcHM6IFwicHMteC1yZWFjaC1zdGFydFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxZU3RhcnQuJHtrdH0uJHtPdH1gLCBwczogXCJwcy15LXJlYWNoLXN0YXJ0XCIgfVxuXSwgdWIgPSB7XG4gIGhhbmRsZXJzOiBbXCJjbGljay1yYWlsXCIsIFwiZHJhZy10aHVtYlwiLCBcImtleWJvYXJkXCIsIFwid2hlZWxcIiwgXCJ0b3VjaFwiXSxcbiAgd2hlZWxTcGVlZDogMSxcbiAgd2hlZWxQcm9wYWdhdGlvbjogITAsXG4gIHN3aXBlRWFzaW5nOiAhMCxcbiAgbWluU2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICBtYXhTY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gIHNjcm9sbGluZ1RocmVzaG9sZDogMWUzLFxuICB1c2VCb3RoV2hlZWxBeGVzOiAhMSxcbiAgc3VwcHJlc3NTY3JvbGxYOiAhMSxcbiAgc3VwcHJlc3NTY3JvbGxZOiAhMSxcbiAgc2Nyb2xsWE1hcmdpbk9mZnNldDogMCxcbiAgc2Nyb2xsWU1hcmdpbk9mZnNldDogMCxcbiAgcG9zaXRpb25SaWdodDogITBcbn0sIHBiID0ge1xuICBoYW5kbGVyczogXCIoc3RyaW5nfGFycmF5KVwiLFxuICB3aGVlbFNwZWVkOiBcIm51bWJlclwiLFxuICB3aGVlbFByb3BhZ2F0aW9uOiBcImJvb2xlYW5cIixcbiAgc3dpcGVFYXNpbmc6IFwiYm9vbGVhblwiLFxuICBtaW5TY3JvbGxiYXJMZW5ndGg6IFwiKG51bWJlcnxudWxsKVwiLFxuICBtYXhTY3JvbGxiYXJMZW5ndGg6IFwiKG51bWJlcnxudWxsKVwiLFxuICBzY3JvbGxpbmdUaHJlc2hvbGQ6IFwibnVtYmVyXCIsXG4gIHVzZUJvdGhXaGVlbEF4ZXM6IFwiYm9vbGVhblwiLFxuICBzdXBwcmVzc1Njcm9sbFg6IFwiYm9vbGVhblwiLFxuICBzdXBwcmVzc1Njcm9sbFk6IFwiYm9vbGVhblwiLFxuICBzY3JvbGxYTWFyZ2luT2Zmc2V0OiBcIm51bWJlclwiLFxuICBzY3JvbGxZTWFyZ2luT2Zmc2V0OiBcIm51bWJlclwiLFxuICBwb3NpdGlvblJpZ2h0OiBcImJvb2xlYW5cIlxufSwgX2IgPSB7XG4gIHBzOiBcImdyb3VwL3BzIG92ZXJmbG93LWhpZGRlbiBbb3ZlcmZsb3ctYW5jaG9yOm5vbmVdIHRvdWNoLW5vbmVcIixcbiAgcmFpbFg6IFwiZ3JvdXAveCBhYnNvbHV0ZSBib3R0b20tMCBoLVswLjkzNzVyZW1dIGhpZGRlbiBvcGFjaXR5LTAgdHJhbnNpdGlvbi1bYmFja2dyb3VuZC1jb2xvcixfb3BhY2l0eV0gZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIHotWzEwMzVdIGdyb3VwLVsmLnBzLS1hY3RpdmUteF0vcHM6YmxvY2sgZ3JvdXAtaG92ZXIvcHM6b3BhY2l0eS02MCBncm91cC1mb2N1cy9wczpvcGFjaXR5LTYwIGdyb3VwLVsmLnBzLS1zY3JvbGxpbmcteF0vcHM6b3BhY2l0eS02MCBob3Zlcjohb3BhY2l0eS05MCBmb2N1czohb3BhY2l0eS05MCBbJi5wcy0tY2xpY2tpbmddOiFvcGFjaXR5LTkwIG91dGxpbmUtbm9uZVwiLFxuICByYWlsWENvbG9yczogXCJncm91cC1bJi5wcy0tYWN0aXZlLXhdL3BzOmJnLXRyYW5zcGFyZW50IGhvdmVyOiFiZy1bI2VlZV0gZm9jdXM6IWJnLVsjZWVlXSBbJi5wcy0tY2xpY2tpbmddOiFiZy1bI2VlZV0gZGFyazpob3ZlcjohYmctWyM1NTVdIGRhcms6Zm9jdXM6IWJnLVsjNTU1XSBkYXJrOlsmLnBzLS1jbGlja2luZ106IWJnLVsjNTU1XVwiLFxuICByYWlsWFRodW1iOiBcImFic29sdXRlIGJvdHRvbS0wLjUgcm91bmRlZC1tZCBoLTEuNSBncm91cC1mb2N1cy9wczpvcGFjaXR5LTEwMCBncm91cC1hY3RpdmUvcHM6b3BhY2l0eS0xMDAgW3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvcl8uMnNfbGluZWFyLF9oZWlnaHRfLjJzX2Vhc2UtaW4tb3V0XSBncm91cC1ob3Zlci94OmgtWzExcHhdIGdyb3VwLWZvY3VzL3g6aC1bMC42ODc1cmVtXSBncm91cC1bJi5wcy0tY2xpY2tpbmddL3g6YmctWyM5OTldIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veDpoLVsxMXB4XSBvdXRsaW5lLW5vbmVcIixcbiAgcmFpbFhUaHVtYkNvbG9yczogXCJiZy1bI2FhYV0gZ3JvdXAtaG92ZXIveDpiZy1bIzk5OV0gZ3JvdXAtZm9jdXMveDpiZy1bIzk5OV1cIixcbiAgcmFpbFk6IFwiZ3JvdXAveSBhYnNvbHV0ZSByaWdodC0wIHctWzAuOTM3NXJlbV0gaGlkZGVuIG9wYWNpdHktMCB0cmFuc2l0aW9uLVtiYWNrZ3JvdW5kLWNvbG9yLF9vcGFjaXR5XSBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgei1bMTAzNV0gZ3JvdXAtWyYucHMtLWFjdGl2ZS15XS9wczpibG9jayBncm91cC1ob3Zlci9wczpvcGFjaXR5LTYwIGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktNjAgZ3JvdXAtWyYucHMtLXNjcm9sbGluZy15XS9wczpvcGFjaXR5LTYwIGhvdmVyOiFvcGFjaXR5LTkwIGZvY3VzOiFvcGFjaXR5LTkwIFsmLnBzLS1jbGlja2luZ106IW9wYWNpdHktOTAgb3V0bGluZS1ub25lXCIsXG4gIHJhaWxZQ29sb3JzOiBcImdyb3VwLVsmLnBzLS1hY3RpdmUteV0vcHM6YmctdHJhbnNwYXJlbnQgaG92ZXI6IWJnLVsjZWVlXSBmb2N1czohYmctWyNlZWVdIFsmLnBzLS1jbGlja2luZ106IWJnLVsjZWVlXSBkYXJrOmhvdmVyOiFiZy1bIzU1NV0gZGFyazpmb2N1czohYmctWyM1NTVdIGRhcms6WyYucHMtLWNsaWNraW5nXTohYmctWyM1NTVdXCIsXG4gIHJhaWxZVGh1bWI6IFwiYWJzb2x1dGUgcmlnaHQtMC41IHJvdW5kZWQtbWQgdy0xLjUgZ3JvdXAtZm9jdXMvcHM6b3BhY2l0eS0xMDAgZ3JvdXAtYWN0aXZlL3BzOm9wYWNpdHktMTAwIFt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3JfLjJzX2xpbmVhcixfd2lkdGhfLjJzX2Vhc2UtaW4tb3V0LF9vcGFjaXR5XSBncm91cC1ob3Zlci95OnctWzExcHhdIGdyb3VwLWZvY3VzL3k6dy1bMC42ODc1cmVtXSBncm91cC1bJi5wcy0tY2xpY2tpbmddL3k6dy1bMTFweF0gb3V0bGluZS1ub25lXCIsXG4gIHJhaWxZVGh1bWJDb2xvcnM6IFwiYmctWyNhYWFdIGdyb3VwLWhvdmVyL3k6YmctWyM5OTldIGdyb3VwLWZvY3VzL3k6YmctWyM5OTldIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veTpiZy1bIzk5OV1cIlxufSwgZmIgPSB7XG4gIHBzOiBcInN0cmluZ1wiLFxuICByYWlsWDogXCJzdHJpbmdcIixcbiAgcmFpbFhDb2xvcnM6IFwic3RyaW5nXCIsXG4gIHJhaWxYVGh1bWI6IFwic3RyaW5nXCIsXG4gIHJhaWxYVGh1bWJDb2xvcnM6IFwic3RyaW5nXCIsXG4gIHJhaWxZOiBcInN0cmluZ1wiLFxuICByYWlsWUNvbG9yczogXCJzdHJpbmdcIixcbiAgcmFpbFlUaHVtYjogXCJzdHJpbmdcIixcbiAgcmFpbFlUaHVtYkNvbG9yczogXCJzdHJpbmdcIlxufTtcbmNsYXNzIExvIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpID0ge30pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMucGVyZmVjdFNjcm9sbGJhciA9IG51bGwsIHRoaXMuX29ic2VydmVyID0gbnVsbCwgdGhpcy5fcHNDbGFzc2VzID0gW1xuICAgICAge1xuICAgICAgICBwczogXCJwc19fcmFpbC14XCIsXG4gICAgICAgIHRlOiB0aGlzLl9jbGFzc2VzLnJhaWxYLFxuICAgICAgICB0ZUNvbG9yOiB0aGlzLl9jbGFzc2VzLnJhaWxYQ29sb3JzXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwczogXCJwc19fcmFpbC15XCIsXG4gICAgICAgIHRlOiB0aGlzLl9jbGFzc2VzLnJhaWxZLFxuICAgICAgICB0ZUNvbG9yOiB0aGlzLl9jbGFzc2VzLnJhaWxZQ29sb3JzXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwczogXCJwc19fdGh1bWIteFwiLFxuICAgICAgICB0ZTogdGhpcy5fY2xhc3Nlcy5yYWlsWFRodW1iLFxuICAgICAgICB0ZUNvbG9yOiB0aGlzLl9jbGFzc2VzLnJhaWxYVGh1bWJDb2xvcnNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBzOiBcInBzX190aHVtYi15XCIsXG4gICAgICAgIHRlOiB0aGlzLl9jbGFzc2VzLnJhaWxZVGh1bWIsXG4gICAgICAgIHRlQ29sb3I6IHRoaXMuX2NsYXNzZXMucmFpbFlUaHVtYkNvbG9yc1xuICAgICAgfVxuICAgIF0sIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCBncywgdGhpcyksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgZGIpKSwgdGhpcy5pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGpuO1xuICB9XG4gIGdldCByYWlsWCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFwiLnBzX19yYWlsLXhcIiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IHJhaWxZKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXCIucHNfX3JhaWwteVwiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gZS5oYW5kbGVycyAhPT0gdm9pZCAwICYmIChlLmhhbmRsZXJzID0gZS5oYW5kbGVycy5zcGxpdChcIiBcIikpLCB0ID0ge1xuICAgICAgLi4udWIsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwoam4sIHQsIHBiKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLl9iLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKGpuLCB0LCBmYiksIHQ7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5wb3NpdGlvblJpZ2h0ICYmIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGdzKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX2RhdGFBdHRyT3B0aW9ucyA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsLCB0aGlzLnBlcmZlY3RTY3JvbGxiYXIuZGVzdHJveSgpLCB0aGlzLnJlbW92ZUV2ZW50KEtuKSwgdGhpcy5wZXJmZWN0U2Nyb2xsYmFyID0gbnVsbDtcbiAgfVxuICBpbml0KCkge1xuICAgIGlmICh0aGlzLnBlcmZlY3RTY3JvbGxiYXIgPSBuZXcgQmkodGhpcy5fZWxlbWVudCwgdGhpcy5fb3B0aW9ucyksIHRoaXMuX2FkZFBlcmZlY3RTY3JvbGxiYXJTdHlsZXMoKSwgdGhpcy5fdXBkYXRlU2Nyb2xsUG9zaXRpb24oKSwgdGhpcy5wZXJmZWN0U2Nyb2xsYmFyLnVwZGF0ZSgpLCB0aGlzLl9pbml0RXZlbnRzKEtuKSwgdGhpcy5fb3B0aW9ucy5wb3NpdGlvblJpZ2h0KSB7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHQgPSB7XG4gICAgICAgIGF0dHJpYnV0ZXM6ICEwLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcImNsYXNzXCIsIFwiY2xhc3NOYW1lXCJdXG4gICAgICB9O1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9lbGVtZW50LCB0KTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZVNjcm9sbFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoXCJoZWlnaHRcIiksIGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoXCJ3aWR0aFwiKTtcbiAgICB0aGlzLnJhaWxYICYmICh0aGlzLnJhaWxYLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKGNhbGMoLTEwMCUgKyAke3RoaXMuX2NhblRyYW5zZm9ybSh0KSA/IHQgOiBcIjBweFwifSkpYCksIHRoaXMucmFpbFkgJiYgKHRoaXMucmFpbFkuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoY2FsYygtMTAwJSArICR7dGhpcy5fY2FuVHJhbnNmb3JtKGUpID8gZSA6IFwiMHB4XCJ9KSlgKTtcbiAgfVxuICBfY2FuVHJhbnNmb3JtKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0LmluY2x1ZGVzKFwicHhcIik7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnBlcmZlY3RTY3JvbGxiYXIudXBkYXRlKCk7XG4gIH1cbiAgX2luaXRFdmVudHModCA9IFtdKSB7XG4gICAgdC5mb3JFYWNoKFxuICAgICAgKHsgcHM6IGUsIHRlOiBpIH0pID0+IGgub24oXG4gICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgIGUsXG4gICAgICAgIChuKSA9PiBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgaSwgeyBlOiBuIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBfYWRkUGVyZmVjdFNjcm9sbGJhclN0eWxlcygpIHtcbiAgICB0aGlzLl9wc0NsYXNzZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShgLiR7dC5wc31gLCB0aGlzLl9lbGVtZW50KTtcbiAgICAgIGMuYWRkQ2xhc3MoZSwgdC50ZSksIGMuYWRkQ2xhc3MoZSwgdC50ZUNvbG9yKTtcbiAgICB9KSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnBzKSwgYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcInBzXCIpO1xuICB9XG4gIHJlbW92ZUV2ZW50KHQpIHtcbiAgICBsZXQgZSA9IFtdO1xuICAgIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKGUgPSBLbi5maWx0ZXIoKHsgdGU6IGkgfSkgPT4gaSA9PT0gdCkpLCBlLmZvckVhY2goKHsgcHM6IGksIHRlOiBuIH0pID0+IHtcbiAgICAgIGgub2ZmKHRoaXMuX2VsZW1lbnQsIGkpLCBoLm9mZih0aGlzLl9lbGVtZW50LCBuKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBlID0gSS5nZXREYXRhKHRoaXMsIGdzKTtcbiAgICAgIGNvbnN0IGkgPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghZSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KHQpKSAmJiAoZSB8fCAoZSA9IG5ldyBMbyh0aGlzLCBpKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIGdzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCB5YyA9IExvLCBtYiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtc2VsZWN0LXJlZlwiLCBnYiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcGFnaW5hdGlvbi1uYXYtcmVmXCIsIGJiID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLXJpZ2h0LXJlZlwiLCB2YiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcGFnaW5hdGlvbi1sZWZ0LXJlZlwiLCBUYiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcGFnaW5hdGlvbi1zdGFydC1yZWZcIiwgRWIgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXBhZ2luYXRpb24tZW5kLXJlZlwiLCBDYiA9ICh7XG4gIHRleHQ6IHMsXG4gIGVudHJpZXM6IHQsXG4gIGVudHJpZXNPcHRpb25zOiBlLFxuICBmdWxsUGFnaW5hdGlvbjogaSxcbiAgcm93c1RleHQ6IG4sXG4gIGFsbFRleHQ6IG8sXG4gIHBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZTogcixcbiAgcGFnaW5hdGlvbkxlZnRJY29uVGVtcGxhdGU6IGEsXG4gIHBhZ2luYXRpb25SaWdodEljb25UZW1wbGF0ZTogbCxcbiAgcGFnaW5hdGlvbkVuZEljb25UZW1wbGF0ZTogcCxcbiAgY2xhc3NlczogdVxufSwgZiwgXykgPT4ge1xuICBjb25zdCBtID0gZS5tYXAoKGcpID0+IGcgPT09IFwiQWxsXCIgPyBgPG9wdGlvbiB2YWx1ZT1cIiR7Z31cIiAke2cgPT09IHQgPyBcInNlbGVjdGVkXCIgOiBcIlwifT4ke299PC9vcHRpb24+YCA6IGA8b3B0aW9uIHZhbHVlPVwiJHtnfVwiICR7ZyA9PT0gdCA/IFwic2VsZWN0ZWRcIiA6IFwiXCJ9PiR7Z308L29wdGlvbj5gKS5qb2luKGBcbmApO1xuICByZXR1cm4gYFxuPGRpdiBjbGFzcz1cIiR7dS5wYWdpbmF0aW9ufSAke18gPyBgJHt1LnBhZ2luYXRpb25Cb3JkZXJlZH1gIDogXCJcIn0gJHt1LmJvcmRlckNvbG9yfSAke3UuY29sb3J9XCI+XG4gIDxkaXYgY2xhc3M9XCIke3Uuc2VsZWN0SXRlbXNXcmFwcGVyfVwiPiAgXG4gICAgPHAgY2xhc3M9XCIke3UucGFnaW5hdGlvblJvd3NUZXh0fSAke2YgPyBgJHt1LmxvYWRpbmdQYWdpbmF0aW9uUm93c1RleHR9YCA6IFwiXCJ9XCI+JHtufTwvcD5cbiAgICA8ZGl2IGNsYXNzPVwiJHt1LnNlbGVjdFdyYXBwZXJ9ICR7ZiA/IGAke3UubG9hZGluZ1BhZ2luYXRpb25TZWxlY3RXcmFwcGVyfWAgOiBcIlwifVwiPlxuICAgICAgPHNlbGVjdCBuYW1lPVwiZW50cmllc1wiXG4gICAgICAgICR7ZiA/IFwiZGlzYWJsZWRcIiA6IFwiXCJ9IGNsYXNzPVwic2VsZWN0XCIgJHttYn0+XG4gICAgICAgICR7bX1cbiAgICAgIDwvc2VsZWN0PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uTmF2fSAke2YgPyBgJHt1LmxvYWRpbmdQYWdpbmF0aW9uTmF2fWAgOiBcIlwifVwiICR7Z2J9PlxuICAke3N9XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiJHt1LnBhZ2luYXRpb25CdXR0b25zV3JhcHBlcn1cIj5cbiAgICAke2kgPyBgPGJ1dHRvbiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwiZGFya1wiIGNsYXNzPVwiJHt1LnBhZ2luYXRpb25TdGFydEJ1dHRvbn1cIiAke1RifT5cbiAgICAgICAgICAgJHtyfVxuICAgICAgICAgIDwvYnV0dG9uPmAgOiBcIlwifVxuICAgIDxidXR0b24gZGF0YS10ZS1yaXBwbGUtaW5pdCBkYXRhLXRlLXJpcHBsZS1jb2xvcj1cImRhcmtcIiBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uTGVmdEJ1dHRvbn1cIiAke3ZifT5cbiAgICAgICR7YX1cbiAgPC9idXR0b24+XG4gICAgPGJ1dHRvbiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwiZGFya1wiIGNsYXNzPVwiJHt1LnBhZ2luYXRpb25SaWdodEJ1dHRvbn1cIiAke2JifT5cbiAgICAgICR7bH1cbiAgPC9idXR0b24+XG4gICAgJHtpID8gYDxidXR0b24gZGF0YS10ZS1yaXBwbGUtaW5pdCBkYXRhLXRlLXJpcHBsZS1jb2xvcj1cImRhcmtcIiBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uRW5kQnV0dG9ufVwiICR7RWJ9PlxuICAgICAgICAgICAke3B9XG4gICAgICAgICAgPC9idXR0b24+YCA6IFwiXCJ9XG4gIDwvZGl2PlxuPC9kaXY+XG5gO1xufSwgQWIgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXNvcnQtaWNvbi1yZWZcIiwgeWIgPSBcImRhdGEtdGUtZGF0YXRhYmxlLWhlYWRlci1jaGVja2JveC1yZWZcIiwgd2IgPSAocywgdCwgZSwgaSwgbiwgbywgciwgYSkgPT4ge1xuICBjb25zdCBsID0gZSA/IGBcbiAgPHRoIHNjb3BlPVwiY29sXCI+XG4gICAgPGRpdiBjbGFzcz1cIiR7YS5jaGVja2JveEhlYWRlcldyYXBwZXJ9XCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3M9XCIke2EuY2hlY2tib3hIZWFkZXJ9XCJcbiAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgdmFsdWU9XCJcIlxuICAgICAgICAke3lifVxuICAgICAgICAvPlxuICAgIDwvZGl2PlxuICA8L3RoPlxuICBgIDogJzx0aCBzY29wZT1cImNvbFwiPjwvdGg+JywgcCA9IHMubWFwKCh1LCBmKSA9PiB7XG4gICAgY29uc3QgXyA9IHUuZml4ZWQgPyBzLmZpbHRlcigobSwgZykgPT4gbS5maXhlZCA9PT0gdS5maXhlZCAmJiBnIDwgZikucmVkdWNlKChtLCBnKSA9PiBtICsgZy53aWR0aCwgMCkgOiBudWxsO1xuICAgIHJldHVybiBgPHRoIGNsYXNzPVwiJHthLmNvbHVtbn0gJHtpID8gYCR7YS50YWJsZUJvcmRlcmVkfWAgOiBcIlwifSAke2EuYm9yZGVyQ29sb3J9ICR7biA/IGAke2Euc219YCA6IFwiXCJ9ICR7dS5maXhlZCA/IGAke2EuZml4ZWRIZWFkZXJ9ICR7YS5jb2xvcn1gIDogXCJcIn0gJHtvID8gYCR7YS5sb2FkaW5nQ29sdW1ufWAgOiBcIlwifVwiIHN0eWxlPVwiJHt1LmZpeGVkID8gYCR7dS5maXhlZCA9PT0gXCJyaWdodFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCJ9OiAke199cHg7YCA6IFwiXCJ9XCIgc2NvcGU9XCJjb2xcIj4ke3Uuc29ydCA/IGA8ZGl2IGNsYXNzPVwiJHthLnNvcnRJY29uV3JhcHBlcn1cIj48c3BhbiBjbGFzcz1cIiR7YS5zb3J0SWNvbn0gJHtvID8gXCJpbnZpc2libGVcIiA6IFwiXCJ9XCIgZGF0YS10ZS1zb3J0PVwiJHt1LmZpZWxkfVwiICR7QWJ9PiR7cn08L3NwYW4+YCA6IFwiXCJ9IDxzcGFuIGNsYXNzPVwiJHt1LnNvcnQgPyBcIlwiIDogXCJwbC1bMThweF1cIn1cIj4ke3UubGFiZWx9PC9zcGFuPjwvZGl2PjwvdGg+YDtcbiAgfSk7XG4gIHJldHVybiBbdCA/IGwgOiBcIlwiLCAuLi5wXS5qb2luKGBcbmApO1xufSwgeGIgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXJvdy1yZWZcIiwga2IgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXJvdy1jaGVja2JveC1yZWZcIiwgT2IgPSBcImRhdGEtdGUtZGF0YXRhYmxlLWNlbGwtcmVmXCIsIFNiID0gKHtcbiAgcm93czogcyxcbiAgY29sdW1uczogdCxcbiAgbm9Gb3VuZE1lc3NhZ2U6IGUsXG4gIGVkaXQ6IGksXG4gIHNlbGVjdGFibGU6IG4sXG4gIGxvYWRpbmc6IG8sXG4gIGJvcmRlcmVkOiByLFxuICBib3JkZXJsZXNzOiBhLFxuICBzdHJpcGVkOiBsLFxuICBob3ZlcjogcCxcbiAgc206IHUsXG4gIGNsYXNzZXM6IGZcbn0pID0+IHtcbiAgY29uc3QgXyA9IHMubWFwKChtKSA9PiB7XG4gICAgY29uc3QgZyA9IGBcbiAgICAgIDx0ZCBkYXRhLXRlLWZpZWxkPVwiY2hlY2tib3hcIiBjbGFzcz1cIiR7ciA/IGAke2YudGFibGVCb3JkZXJlZH0gJHtmLmJvcmRlckNvbG9yfWAgOiBcIlwifVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLmNoZWNrYm94Um93V3JhcHBlcn1cIj5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIGNsYXNzPVwiJHtmLmNoZWNrYm94Um93fVwiXG4gICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgdmFsdWU9XCJcIlxuICAgICAgICAgICAgZGF0YS10ZS1yb3ctaW5kZXg9XCIke20ucm93SW5kZXh9XCIgICR7a2J9Lz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3RkPmAsIHYgPSB0Lm1hcCgoYiwgQykgPT4ge1xuICAgICAgY29uc3QgeSA9IHt9O1xuICAgICAgaWYgKGIud2lkdGggJiYgKHlbXCJtaW4td2lkdGhcIl0gPSBgJHtiLndpZHRoIC0gMX1weGAsIHlbXCJtYXgtd2lkdGhcIl0gPSBgJHtiLndpZHRofXB4YCwgeS53aWR0aCA9IGAke2Iud2lkdGh9cHhgKSwgYi5maXhlZCkge1xuICAgICAgICBjb25zdCBUID0gdC5maWx0ZXIoKEEsIHcpID0+IEEuZml4ZWQgPT09IGIuZml4ZWQgJiYgdyA8IEMpLnJlZHVjZSgoQSwgdykgPT4gQSArIHcud2lkdGgsIDApO1xuICAgICAgICB5W2IuZml4ZWQgPT09IFwicmlnaHRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiXSA9IGAke1R9cHhgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGA8dGQgc3R5bGU9XCIke09iamVjdC5rZXlzKHkpLm1hcCgoVCkgPT4gYCR7VH06ICR7eVtUXX1gKS5qb2luKFwiOyBcIil9XCIgY2xhc3M9XCIke2Yucm93SXRlbX0gJHtmLmJvcmRlckNvbG9yfSAke2kgPyBgJHtmLmVkaXR9YCA6IFwiXCJ9ICR7ciA/IGAke2YudGFibGVCb3JkZXJlZH1gIDogXCJcIn0gJHt1ID8gYCR7Zi5zbX1gIDogXCJcIn0gJHtiLmZpeGVkID8gYCR7Zi5maXhlZEhlYWRlcn0gJHtmLmNvbG9yfWAgOiBcIlwifVwiICR7T2J9IGRhdGEtdGUtZmllbGQ9XCIke2IuZmllbGR9XCIgJHtpICYmICdjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCInfT4ke21bYi5maWVsZF19PC90ZD5gO1xuICAgIH0pLmpvaW4oXCJcIik7XG4gICAgcmV0dXJuIGA8dHIgc2NvcGU9XCJyb3dcIiBjbGFzcz1cIiR7Zi5yb3d9ICR7Zi5ib3JkZXJDb2xvcn0gJHtmLnJvd0FuaW1hdGlvbn0gJHtsID8gYCR7Zi5zdHJpcGVkfWAgOiBcIlwifSAke2EgPyBgJHtmLmJvcmRlcmxlc3N9YCA6IFwiXCJ9ICR7cCA/IGAke2YuaG92ZXJSb3d9YCA6IFwiXCJ9XCIgZGF0YS10ZS1pbmRleD1cIiR7bS5yb3dJbmRleH1cIiAke3hifT4ke24gPyBnIDogXCJcIn0ke3Z9PC90cj5gO1xuICB9KTtcbiAgcmV0dXJuIHMubGVuZ3RoID4gMCB8fCBvID8gXy5qb2luKGBcbmApIDogYDx0ciBjbGFzcz1cIiR7Zi5ub0ZvdW5kTWVzc2FnZVdyYXBwZXJ9ICR7Zi5ib3JkZXJDb2xvcn1cIj48dGQgY2xhc3M9XCIke2Yubm9Gb3VuZE1lc3NhZ2V9XCI+JHtlfTwvdGQ+PC90cj5gO1xufSwgSWIgPSBcImRhdGEtdGUtZGF0YXRhYmxlLWlubmVyLXJlZlwiLCBEYiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtaGVhZGVyLXJlZlwiLCBWYSA9ICh7XG4gIGNvbHVtbnM6IHMsXG4gIHJvd3M6IHQsXG4gIG5vRm91bmRNZXNzYWdlOiBlLFxuICBlZGl0OiBpLFxuICBtdWx0aTogbixcbiAgc2VsZWN0YWJsZTogbyxcbiAgbG9hZGluZzogcixcbiAgbG9hZGluZ01lc3NhZ2U6IGEsXG4gIHBhZ2luYXRpb246IGwsXG4gIGJvcmRlcmVkOiBwLFxuICBib3JkZXJsZXNzOiB1LFxuICBzdHJpcGVkOiBmLFxuICBob3ZlcjogXyxcbiAgZml4ZWRIZWFkZXI6IG0sXG4gIHNtOiBnLFxuICBzb3J0SWNvblRlbXBsYXRlOiB2LFxuICBjbGFzc2VzOiBiXG59KSA9PiB7XG4gIGNvbnN0IEMgPSBTYih7XG4gICAgcm93czogdCxcbiAgICBjb2x1bW5zOiBzLFxuICAgIG5vRm91bmRNZXNzYWdlOiBlLFxuICAgIGVkaXQ6IGksXG4gICAgbG9hZGluZzogcixcbiAgICBzZWxlY3RhYmxlOiBvLFxuICAgIGJvcmRlcmVkOiBwLFxuICAgIGJvcmRlcmxlc3M6IHUsXG4gICAgc3RyaXBlZDogZixcbiAgICBob3ZlcjogXyxcbiAgICBzbTogZyxcbiAgICBjbGFzc2VzOiBiXG4gIH0pLCB5ID0gd2IoXG4gICAgcyxcbiAgICBvLFxuICAgIG4sXG4gICAgcCxcbiAgICBnLFxuICAgIHIsXG4gICAgdixcbiAgICBiXG4gICk7XG4gIHJldHVybiB7IHRhYmxlOiBgXG48ZGl2IGNsYXNzPVwiJHtiLmNvbG9yfVwiICR7SWJ9PlxuICA8dGFibGUgY2xhc3M9XCIke2IudGFibGV9XCI+XG4gICAgPHRoZWFkIGNsYXNzPVwiJHtiLnRhYmxlSGVhZGVyfSAke3AgPyBgJHtiLnRhYmxlQm9yZGVyZWR9YCA6IFwiXCJ9ICR7dSA/IGAke2IuYm9yZGVybGVzc31gIDogXCJcIn0gJHtiLmJvcmRlckNvbG9yfVwiICR7RGJ9PlxuICAgICAgPHRyPlxuICAgICAgICAke3l9XG4gICAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG4gICAgPHRib2R5IGNsYXNzPVwiJHttID8gYCR7Yi5maXhlZEhlYWRlckJvZHl9YCA6IFwiXCJ9XCI+XG4gICAgICAke3IgPyBcIlwiIDogQ31cbiAgICA8L3Rib2R5PlxuICA8L3RhYmxlPlxuPC9kaXY+XG4ke3IgPyBgXG4gIDxkaXYgY2xhc3M9XCIke2IubG9hZGluZ0l0ZW1zV3JhcHBlcn1cIj5cbiAgICA8ZGl2IGNsYXNzPVwiJHtiLmxvYWRpbmdQcm9ncmVzc0JhcldyYXBwZXJ9XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHtiLmxvYWRpbmdQcm9ncmVzc0Jhcn1cIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48cCBjbGFzcz1cIiR7Yi5sb2FkaW5nTWVzc2FnZX1cIj4ke2F9PC9wPlxuYCA6IFwiXCJ9XG4ke2wuZW5hYmxlID8gQ2IobCwgciwgcCkgOiBcIlwifVxuICBgLCByb3dzOiBDLCBjb2x1bW46IHkgfTtcbn0sICRiID0gKHsgcm93czogcywgZmllbGQ6IHQsIG9yZGVyOiBlIH0pID0+IHMuc29ydCgobiwgbykgPT4ge1xuICBsZXQgciA9IG5bdF0sIGEgPSBvW3RdO1xuICByZXR1cm4gdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiAociA9IHIudG9Mb3dlckNhc2UoKSksIHR5cGVvZiBhID09IFwic3RyaW5nXCIgJiYgKGEgPSBhLnRvTG93ZXJDYXNlKCkpLCByIDwgYSA/IGUgPT09IFwiZGVzY1wiID8gMSA6IC0xIDogciA+IGEgPyBlID09PSBcImRlc2NcIiA/IC0xIDogMSA6IDA7XG59KSwgTGIgPSAocywgdCwgZSkgPT4ge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHM7XG4gIGNvbnN0IGkgPSAobikgPT4ge1xuICAgIGNvbnN0IG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHJldHVybiBvLmlubmVySFRNTCA9IG4sIG4gPSBvLnRleHRDb250ZW50IHx8IG8uaW5uZXJUZXh0IHx8IFwiXCIsIG4udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLm1hdGNoKHQudG9Mb3dlckNhc2UoKSk7XG4gIH07XG4gIHJldHVybiBzLmZpbHRlcigobikgPT4ge1xuICAgIGlmIChlICYmIHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gaShuW2VdKTtcbiAgICBsZXQgbyA9IE9iamVjdC52YWx1ZXMobik7XG4gICAgcmV0dXJuIGUgJiYgQXJyYXkuaXNBcnJheShlKSAmJiAobyA9IE9iamVjdC5rZXlzKG4pLmZpbHRlcigocikgPT4gZS5pbmNsdWRlcyhyKSkubWFwKChyKSA9PiBuW3JdKSksIG8uZmlsdGVyKChyKSA9PiBpKHIpKS5sZW5ndGggPiAwO1xuICB9KTtcbn0sIEZhID0gKHsgcm93czogcywgZW50cmllczogdCwgYWN0aXZlUGFnZTogZSB9KSA9PiB7XG4gIGNvbnN0IGkgPSBlICogdDtcbiAgcmV0dXJuIHMuc2xpY2UoaSwgaSArIE51bWJlcih0KSk7XG59LCB4aSA9IFwiZGF0YXRhYmxlXCIsIF90ID0gYGRhdGEtdGUtJHt4aX1gLCBnaSA9IGB0ZS4ke3hpfWAsIHpzID0gYC4ke2dpfWAsIE1iID0gYFske190fS1pbm5lci1yZWZdYCwgem4gPSBgWyR7X3R9LWNlbGwtcmVmXWAsIE5iID0gYFske190fS1oZWFkZXItcmVmXWAsIFJiID0gYFske190fS1oZWFkZXItY2hlY2tib3gtcmVmXWAsIFBiID0gYFske190fS1wYWdpbmF0aW9uLXJpZ2h0LXJlZl1gLCBCYiA9IGBbJHtfdH0tcGFnaW5hdGlvbi1sZWZ0LXJlZl1gLCBIYiA9IGBbJHtfdH0tcGFnaW5hdGlvbi1zdGFydC1yZWZdYCwgV2IgPSBgWyR7X3R9LXBhZ2luYXRpb24tZW5kLXJlZl1gLCBWYiA9IGBbJHtfdH0tcGFnaW5hdGlvbi1uYXYtcmVmXWAsIEZiID0gYFske190fS1zZWxlY3QtcmVmXWAsIFVuID0gYFske190fS1zb3J0LWljb24tcmVmXWAsIGRpID0gYFske190fS1yb3ctcmVmXWAsIFhuID0gYFske190fS1yb3ctY2hlY2tib3gtcmVmXWAsIFliID0gYHNlbGVjdFJvd3Mke3pzfWAsIFlhID0gYHJlbmRlciR7enN9YCwgamIgPSBgcm93Q2xpY2ske3pzfWAsIEtiID0gYHVwZGF0ZSR7enN9YCwgemIgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDEwLjVMMTIgM20wIDBsNy41IDcuNU0xMiAzdjE4XCIgLz5cbjwvc3ZnPmAsIFViID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE4Ljc1IDE5LjVsLTcuNS03LjUgNy41LTcuNW0tNiAxNUw1LjI1IDEybDcuNS03LjVcIiAvPlxuPC9zdmc+YCwgWGIgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTUuNzUgMTkuNUw4LjI1IDEybDcuNS03LjVcIiAvPlxuPC9zdmc+YCwgR2IgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNOC4yNSA0LjVsNy41IDcuNS03LjUgNy41XCIgLz5cbjwvc3ZnPmAsIHFiID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTExLjI1IDQuNWw3LjUgNy41LTcuNSA3LjVtLTYtMTVsNy41IDcuNS03LjUgNy41XCIvPlxuPC9zdmc+YCwgWmIgPSBcImJvcmRlci1uZXV0cmFsLTIwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTUwMFwiLCBRYiA9IFwiYm9yZGVyLW5vbmVcIiwgSmIgPSBcInJlbGF0aXZlIGZsb2F0LWxlZnQgLW1sLVsxLjVyZW1dIG1yLVs2cHhdIG10LVswLjE1cmVtXSBoLVsxLjEyNXJlbV0gdy1bMS4xMjVyZW1dIGFwcGVhcmFuY2Utbm9uZSByb3VuZGVkLVswLjI1cmVtXSBib3JkZXItWzAuMTI1cmVtXSBib3JkZXItc29saWQgYm9yZGVyLW5ldXRyYWwtMzAwIG91dGxpbmUtbm9uZSBiZWZvcmU6cG9pbnRlci1ldmVudHMtbm9uZSBiZWZvcmU6YWJzb2x1dGUgYmVmb3JlOmgtWzAuODc1cmVtXSBiZWZvcmU6dy1bMC44NzVyZW1dIGJlZm9yZTpzY2FsZS0wIGJlZm9yZTpyb3VuZGVkLWZ1bGwgYmVmb3JlOmJnLXRyYW5zcGFyZW50IGJlZm9yZTpvcGFjaXR5LTAgYmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF90cmFuc3BhcmVudF0gYmVmb3JlOmNvbnRlbnQtWycnXSBjaGVja2VkOmJvcmRlci1wcmltYXJ5IGNoZWNrZWQ6YmctcHJpbWFyeSBjaGVja2VkOmJlZm9yZTpvcGFjaXR5LVswLjE2XSBjaGVja2VkOmFmdGVyOmFic29sdXRlIGNoZWNrZWQ6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6YmxvY2sgY2hlY2tlZDphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmFmdGVyOmJnLXRyYW5zcGFyZW50IGNoZWNrZWQ6YWZ0ZXI6Y29udGVudC1bJyddIGhvdmVyOmN1cnNvci1wb2ludGVyIGhvdmVyOmJlZm9yZTpvcGFjaXR5LVswLjA0XSBob3ZlcjpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZm9jdXM6c2hhZG93LW5vbmUgZm9jdXM6dHJhbnNpdGlvbi1bYm9yZGVyLWNvbG9yXzAuMnNdIGZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgZm9jdXM6YmVmb3JlOm9wYWNpdHktWzAuMTJdIGZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBmb2N1czphZnRlcjphYnNvbHV0ZSBmb2N1czphZnRlcjp6LVsxXSBmb2N1czphZnRlcjpibG9jayBmb2N1czphZnRlcjpoLVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6dy1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnJvdW5kZWQtWzAuMTI1cmVtXSBmb2N1czphZnRlcjpjb250ZW50LVsnJ10gY2hlY2tlZDpmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBjaGVja2VkOmZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdW5kZWQtbm9uZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci10LTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDpmb2N1czphZnRlcjpiZy10cmFuc3BhcmVudCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBkYXJrOmNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgZGFyazpjaGVja2VkOmJnLXByaW1hcnkgZGFyazpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMjU1LDI1NSwyNTUsMC40KV0gZGFyazpjaGVja2VkOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfIzNiNzFjYV0gZGFyazpib3JkZXItbmV1dHJhbC00MDBcIiwgdHYgPSBcIm1iLVswLjEyNXJlbV0gbWluLWgtWzEuNXJlbV0gcGwtWzEuNXJlbV0gbWwtMyBmbGV4IGl0ZW1zLWNlbnRlclwiLCBldiA9IFwicmVsYXRpdmUgZmxvYXQtbGVmdCAtbWwtWzEuNXJlbV0gbXItWzZweF0gbXQtWzAuMTVyZW1dIGgtWzEuMTI1cmVtXSB3LVsxLjEyNXJlbV0gYXBwZWFyYW5jZS1ub25lIHJvdW5kZWQtWzAuMjVyZW1dIGJvcmRlci1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItbmV1dHJhbC0zMDAgb3V0bGluZS1ub25lIGJlZm9yZTpwb2ludGVyLWV2ZW50cy1ub25lIGJlZm9yZTphYnNvbHV0ZSBiZWZvcmU6aC1bMC44NzVyZW1dIGJlZm9yZTp3LVswLjg3NXJlbV0gYmVmb3JlOnNjYWxlLTAgYmVmb3JlOnJvdW5kZWQtZnVsbCBiZWZvcmU6YmctdHJhbnNwYXJlbnQgYmVmb3JlOm9wYWNpdHktMCBiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3RyYW5zcGFyZW50XSBiZWZvcmU6Y29udGVudC1bJyddIGNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgY2hlY2tlZDpiZy1wcmltYXJ5IGNoZWNrZWQ6YmVmb3JlOm9wYWNpdHktWzAuMTZdIGNoZWNrZWQ6YWZ0ZXI6YWJzb2x1dGUgY2hlY2tlZDphZnRlcjotbXQtcHggY2hlY2tlZDphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDphZnRlcjpibG9jayBjaGVja2VkOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgY2hlY2tlZDphZnRlcjpjb250ZW50LVsnJ10gaG92ZXI6Y3Vyc29yLXBvaW50ZXIgaG92ZXI6YmVmb3JlOm9wYWNpdHktWzAuMDRdIGhvdmVyOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBmb2N1czpzaGFkb3ctbm9uZSBmb2N1czp0cmFuc2l0aW9uLVtib3JkZXItY29sb3JfMC4yc10gZm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBmb2N1czpiZWZvcmU6b3BhY2l0eS1bMC4xMl0gZm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGZvY3VzOmFmdGVyOmFic29sdXRlIGZvY3VzOmFmdGVyOnotWzFdIGZvY3VzOmFmdGVyOmJsb2NrIGZvY3VzOmFmdGVyOmgtWzAuODc1cmVtXSBmb2N1czphZnRlcjp3LVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6cm91bmRlZC1bMC4xMjVyZW1dIGZvY3VzOmFmdGVyOmNvbnRlbnQtWycnXSBjaGVja2VkOmZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgY2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gY2hlY2tlZDpmb2N1czphZnRlcjotbXQtcHggY2hlY2tlZDpmb2N1czphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm91bmRlZC1ub25lIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJnLXRyYW5zcGFyZW50IGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGRhcms6Y2hlY2tlZDpib3JkZXItcHJpbWFyeSBkYXJrOmNoZWNrZWQ6YmctcHJpbWFyeSBkYXJrOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgyNTUsMjU1LDI1NSwwLjQpXSBkYXJrOmNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBkYXJrOmJvcmRlci1uZXV0cmFsLTQwMFwiLCBpdiA9IFwibWItWzAuMTI1cmVtXSBtaW4taC1bMS41cmVtXSBwbC1bMS41cmVtXSBtbC0zIGZsZXggaXRlbXMtY2VudGVyXCIsIHN2ID0gXCJiZy13aGl0ZSBkYXJrOmJnLW5ldXRyYWwtODAwXCIsIG52ID0gXCJweS00IHBsLTEgdGV4dC1jbGlwIG92ZXJmbG93LWhpZGRlbiB0ZXh0LVsjMjEyNTI5XSBkYXJrOnRleHQtd2hpdGVcIiwgb3YgPSBcImZvY3VzOm91dGxpbmUtbm9uZVwiLCBydiA9IFwic3RpY2t5IHRvcC0wIHotMzBcIiwgYXYgPSBcInN0aWNreSB6LTEwIGJnLWluaGVyaXRcIiwgbHYgPSBcImhvdmVyOmJnLW5ldXRyYWwtMTAwIGRhcms6aG92ZXI6YmctbmV1dHJhbC03MDBcIiwgY3YgPSBcInBvaW50ZXItZXZlbnRzLW5vbmUgY3Vyc29yLW5vbmUgdGV4dC1uZXV0cmFsLTQwMCBkYXJrOnRleHQtbmV1dHJhbC0zMDBcIiwgaHYgPSBcImgtWzJweF0gcmVsYXRpdmUgdy1mdWxsIG92ZXJmbG93LWhpZGRlblwiLCBkdiA9IFwidGV4dC1jZW50ZXIgdGV4dC1uZXV0cmFsLTUwMCBmb250LWxpZ2ggdGV4dC1zbSBteS00IGRhcms6dGV4dC1uZXV0cmFsLTQwMFwiLCB1diA9IFwidGV4dC1uZXV0cmFsLTUwMCBkYXJrOnRleHQtbmV1dHJhbC0zMDBcIiwgcHYgPSBcInRleHQtbmV1dHJhbC01MDAgZGFyazp0ZXh0LW5ldXRyYWwtMzAwXCIsIF92ID0gXCJwb2ludGVyLWV2ZW50cy1ub25lIGN1cnNvci1ub25lXCIsIGZ2ID0gXCJoLWZ1bGwgdy1bNDUlXSBiZy1wcmltYXJ5LTQwMCBkYXJrOmJnLXByaW1hcnktNjAwXCIsIG12ID0gXCJoLWZ1bGwgYW5pbWF0ZS1bcHJvZ3Jlc3NfM3NfZWFzZS1pbi1vdXRfaW5maW5pdGVdXCIsIGd2ID0gXCJwbC0yIHB5LTMgZm9udC1saWdodCB0ZXh0LXNtIGRhcms6dGV4dC1uZXV0cmFsLTMwMFwiLCBidiA9IFwiYm9yZGVyLWJcIiwgdnYgPSBcImZsZXggbWQ6ZmxleC1yb3cganVzdGlmeS1lbmQgaXRlbXMtY2VudGVyIHB5LTIgc3BhY2UteC00IHRleHQtc20gZmxleC1jb2wgbGVhZGluZy1bMS42XVwiLCBUdiA9IFwiYm9yZGVyIGJvcmRlci10LTBcIiwgRXYgPSBcIm9yZGVyLTEgbXktMyBtZDpvcmRlci1ub25lIG1kOm15LTAgbWQ6cHItMVwiLCBDdiA9IFwiaW5saW5lLWJsb2NrIHJvdW5kZWQgcC0yLjUgdGV4dC14cyBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctbmV1dHJhbC0xMDAgaG92ZXI6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTAgYWN0aXZlOnRleHQtcHJpbWFyeS03MDAgZGlzYWJsZWQ6dGV4dC1zbGF0ZS0zMDAgZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTUwMCBkYXJrOmRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6ZGlzYWJsZWQ6dGV4dC1uZXV0cmFsLTYwMFwiLCBBdiA9IFwiaW5saW5lLWJsb2NrIHJvdW5kZWQgcC0yLjUgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLW5ldXRyYWwtMTAwIGhvdmVyOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTp0ZXh0LXByaW1hcnktNzAwIGRpc2FibGVkOnRleHQtc2xhdGUtMzAwIGRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6aG92ZXI6YmctbmV1dHJhbC01MDAgZGFyazpkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmRpc2FibGVkOnRleHQtbmV1dHJhbC02MDBcIiwgeXYgPSBcImZvbnQtbm9ybWFsIG9yZGVyLTIgbWItMyBtZDpvcmRlci1ub25lIG1kOm1iLTBcIiwgd3YgPSBcImlubGluZS1ibG9jayByb3VuZGVkIHAtMi41IGZvbnQtbWVkaXVtIHVwcGVyY2FzZSBsZWFkaW5nLW5vcm1hbCB0cmFuc2l0aW9uIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBob3ZlcjpiZy1uZXV0cmFsLTEwMCBob3Zlcjp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6dGV4dC1wcmltYXJ5LTcwMCBkaXNhYmxlZDp0ZXh0LXNsYXRlLTMwMCBkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNTAwIGRhcms6ZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpkaXNhYmxlZDp0ZXh0LW5ldXRyYWwtNjAwXCIsIHh2ID0gXCJmb250LWxpZ2h0XCIsIGt2ID0gXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBwLTIuNSBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctbmV1dHJhbC0xMDAgaG92ZXI6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTAgYWN0aXZlOnRleHQtcHJpbWFyeS03MDAgZGlzYWJsZWQ6dGV4dC1zbGF0ZS0zMDAgZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTUwMCBkYXJrOmRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6ZGlzYWJsZWQ6dGV4dC1uZXV0cmFsLTYwMFwiLCBPdiA9IFwiYm9yZGVyLWJcIiwgU3YgPSBcInRyYW5zaXRpb24gZWFzZS1pbi1vdXQgZHVyYXRpb24tMzAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsIEl2ID0gXCJ3aGl0ZXNwYWNlLW5vd3JhcCB0ZXh0LWNsaXAgb3ZlcmZsb3ctaGlkZGVuIHB4LVsxLjRyZW1dIHB5LTRcIiwgRHYgPSBcInJlbGF0aXZlXCIsICR2ID0gXCIhYmctbmV1dHJhbC0xMDAgZGFyazohYmctbmV1dHJhbC02MDBcIiwgTHYgPSBcImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtNCBvcmRlci0zIG1kOm9yZGVyLW5vbmVcIiwgTXYgPSBcInctWzcwcHhdXCIsIE52ID0gXCIhcHktMlwiLCBSdiA9IFwidy1bMTVweF0gaC1bMTBweF0gb3JpZ2luLWJvdHRvbSBmb250LWJsYWNrIG1yLTEgb3BhY2l0eS0wIHRleHQtbmV1dHJhbC01MDAgZ3JvdXAtaG92ZXI6b3BhY2l0eS0xMDAgdHJhbnNpdGlvbiBob3ZlcjplYXNlLWluLW91dCB0cmFuc2Zvcm0gZWFzZS1saW5lYXIgZHVyYXRpb24tMzAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1uZXV0cmFsLTQwMFwiLCBQdiA9IFwiZmxleCBmbGV4LXJvdyBncm91cFwiLCBCdiA9IFwiWyY6bnRoLWNoaWxkKG9kZCldOmJnLW5ldXRyYWwtNTAgWyY6bnRoLWNoaWxkKG9kZCldOmRhcms6YmctbmV1dHJhbC03MDBcIiwgSHYgPSBcImJvcmRlclwiLCBXdiA9IFwiYm9yZGVyLWIgZm9udC1ub3JtYWwgcHgtWzEuNHJlbV1cIiwgVnYgPSBcInRleHQtbGVmdCB0ZXh0LXNtIGZvbnQtbGlnaHQgdy1mdWxsIGxlYWRpbmctWzEuNl1cIiwgRnYgPSB7XG4gIGJvcmRlcmVkOiBcImJvb2xlYW5cIixcbiAgYm9yZGVybGVzczogXCJib29sZWFuXCIsXG4gIGNsaWNrYWJsZVJvd3M6IFwiYm9vbGVhblwiLFxuICBkZWZhdWx0VmFsdWU6IFwic3RyaW5nXCIsXG4gIGVkaXQ6IFwiYm9vbGVhblwiLFxuICBlbnRyaWVzOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBlbnRyaWVzT3B0aW9uczogXCJhcnJheVwiLFxuICBmdWxsUGFnaW5hdGlvbjogXCJib29sZWFuXCIsXG4gIGhvdmVyOiBcImJvb2xlYW5cIixcbiAgbG9hZGluZzogXCJib29sZWFuXCIsXG4gIGxvYWRpbmdNZXNzYWdlOiBcInN0cmluZ1wiLFxuICBtYXhXaWR0aDogXCIobnVsbHxudW1iZXJ8c3RyaW5nKVwiLFxuICBtYXhIZWlnaHQ6IFwiKG51bGx8bnVtYmVyfHN0cmluZylcIixcbiAgbXVsdGk6IFwiYm9vbGVhblwiLFxuICBub0ZvdW5kTWVzc2FnZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbjogXCJib29sZWFuXCIsXG4gIHNlbGVjdGFibGU6IFwiYm9vbGVhblwiLFxuICBzbTogXCJib29sZWFuXCIsXG4gIHNvcnRGaWVsZDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHNvcnRPcmRlcjogXCJzdHJpbmdcIixcbiAgZml4ZWRIZWFkZXI6IFwiYm9vbGVhblwiLFxuICBzdHJpcGVkOiBcImJvb2xlYW5cIixcbiAgcm93c1RleHQ6IFwic3RyaW5nXCIsXG4gIG9mVGV4dDogXCJzdHJpbmdcIixcbiAgYWxsVGV4dDogXCJzdHJpbmdcIixcbiAgZm9yY2VTb3J0OiBcImJvb2xlYW5cIixcbiAgc29ydEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvblN0YXJ0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiXG59LCBZdiA9IHtcbiAgYm9yZGVyZWQ6ICExLFxuICBib3JkZXJsZXNzOiAhMSxcbiAgY2xpY2thYmxlUm93czogITEsXG4gIGRlZmF1bHRWYWx1ZTogXCItXCIsXG4gIGVkaXQ6ICExLFxuICBlbnRyaWVzOiAxMCxcbiAgZW50cmllc09wdGlvbnM6IFsxMCwgMjUsIDUwLCAyMDBdLFxuICBmaXhlZEhlYWRlcjogITEsXG4gIGZ1bGxQYWdpbmF0aW9uOiAhMSxcbiAgaG92ZXI6ICExLFxuICBsb2FkaW5nOiAhMSxcbiAgbG9hZGluZ01lc3NhZ2U6IFwiTG9hZGluZyByZXN1bHRzLi4uXCIsXG4gIG1heFdpZHRoOiBudWxsLFxuICBtYXhIZWlnaHQ6IG51bGwsXG4gIG11bHRpOiAhMSxcbiAgbm9Gb3VuZE1lc3NhZ2U6IFwiTm8gbWF0Y2hpbmcgcmVzdWx0cyBmb3VuZFwiLFxuICBwYWdpbmF0aW9uOiAhMCxcbiAgc2VsZWN0YWJsZTogITEsXG4gIHNtOiAhMSxcbiAgc29ydEZpZWxkOiBudWxsLFxuICBzb3J0T3JkZXI6IFwiYXNjXCIsXG4gIHN0cmlwZWQ6ICExLFxuICByb3dzVGV4dDogXCJSb3dzIHBlciBwYWdlOlwiLFxuICBvZlRleHQ6IFwib2ZcIixcbiAgYWxsVGV4dDogXCJBbGxcIixcbiAgZm9yY2VTb3J0OiAhMSxcbiAgc29ydEljb25UZW1wbGF0ZTogemIsXG4gIHBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZTogVWIsXG4gIHBhZ2luYXRpb25FbmRJY29uVGVtcGxhdGU6IHFiLFxuICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZTogWGIsXG4gIHBhZ2luYXRpb25SaWdodEljb25UZW1wbGF0ZTogR2Jcbn0sIGp2ID0ge1xuICBsYWJlbDogXCJzdHJpbmdcIixcbiAgZmllbGQ6IFwic3RyaW5nXCIsXG4gIGZpeGVkOiBcIihib29sZWFufHN0cmluZylcIixcbiAgZm9ybWF0OiBcIihmdW5jdGlvbnxudWxsKVwiLFxuICB3aWR0aDogXCIobnVtYmVyfG51bGwpXCIsXG4gIHNvcnQ6IFwiYm9vbGVhblwiLFxuICBjb2x1bW5JbmRleDogXCJudW1iZXJcIlxufSwgS3YgPSB7XG4gIGxhYmVsOiBcIlwiLFxuICBmaWVsZDogXCJcIixcbiAgZml4ZWQ6ICExLFxuICBmb3JtYXQ6IG51bGwsXG4gIHdpZHRoOiBudWxsLFxuICBzb3J0OiAhMCxcbiAgY29sdW1uSW5kZXg6IDBcbn0sIHp2ID0ge1xuICB0YWJsZTogVnYsXG4gIHRhYmxlSGVhZGVyOiBXdixcbiAgY29sdW1uOiBudixcbiAgcGFnaW5hdGlvbjogdnYsXG4gIHNlbGVjdFdyYXBwZXI6IE12LFxuICBzY3JvbGw6IER2LFxuICB0YWJsZUJvcmRlcmVkOiBIdixcbiAgcGFnaW5hdGlvbkJvcmRlcmVkOiBUdixcbiAgYm9yZGVybGVzczogUWIsXG4gIGNoZWNrYm94Um93V3JhcHBlcjogaXYsXG4gIGNoZWNrYm94Um93OiBldixcbiAgY2hlY2tib3hIZWFkZXJXcmFwcGVyOiB0dixcbiAgY2hlY2tib3hIZWFkZXI6IEpiLFxuICByb3c6IE92LFxuICByb3dJdGVtOiBJdixcbiAgc3RyaXBlZDogQnYsXG4gIHNvcnRJY29uV3JhcHBlcjogUHYsXG4gIHNvcnRJY29uOiBSdixcbiAgcGFnaW5hdGlvblJvd3NUZXh0OiB4dixcbiAgcGFnaW5hdGlvbk5hdjogeXYsXG4gIHBhZ2luYXRpb25CdXR0b25zV3JhcHBlcjogRXYsXG4gIGhvdmVyUm93OiBsdixcbiAgYm9yZGVyQ29sb3I6IFpiLFxuICBjb2xvcjogc3YsXG4gIGZpeGVkSGVhZGVyOiBydixcbiAgZml4ZWRIZWFkZXJCb2R5OiBhdixcbiAgc2VsZWN0YWJsZVJvdzogJHYsXG4gIHJvd0FuaW1hdGlvbjogU3YsXG4gIHNtOiBOdixcbiAgZWRpdDogb3YsXG4gIHNlbGVjdEl0ZW1zV3JhcHBlcjogTHYsXG4gIHBhZ2luYXRpb25TdGFydEJ1dHRvbjoga3YsXG4gIHBhZ2luYXRpb25MZWZ0QnV0dG9uOiBBdixcbiAgcGFnaW5hdGlvblJpZ2h0QnV0dG9uOiB3dixcbiAgcGFnaW5hdGlvbkVuZEJ1dHRvbjogQ3YsXG4gIGxvYWRpbmdJdGVtc1dyYXBwZXI6IGh2LFxuICBsb2FkaW5nUHJvZ3Jlc3NCYXJXcmFwcGVyOiBtdixcbiAgbG9hZGluZ1Byb2dyZXNzQmFyOiBmdixcbiAgbG9hZGluZ01lc3NhZ2U6IGR2LFxuICBsb2FkaW5nUGFnaW5hdGlvblJvd3NUZXh0OiBwdixcbiAgbG9hZGluZ1BhZ2luYXRpb25TZWxlY3RXcmFwcGVyOiBfdixcbiAgbG9hZGluZ1BhZ2luYXRpb25OYXY6IHV2LFxuICBsb2FkaW5nQ29sdW1uOiBjdixcbiAgbm9Gb3VuZE1lc3NhZ2VXcmFwcGVyOiBidixcbiAgbm9Gb3VuZE1lc3NhZ2U6IGd2XG59LCBVdiA9IHtcbiAgdGFibGU6IFwic3RyaW5nXCIsXG4gIHRhYmxlSGVhZGVyOiBcInN0cmluZ1wiLFxuICBjb2x1bW46IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb246IFwic3RyaW5nXCIsXG4gIHNlbGVjdFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHNjcm9sbDogXCJzdHJpbmdcIixcbiAgdGFibGVCb3JkZXJlZDogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkJvcmRlcmVkOiBcInN0cmluZ1wiLFxuICBib3JkZXJsZXNzOiBcInN0cmluZ1wiLFxuICBjaGVja2JveFJvd1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94Um93OiBcInN0cmluZ1wiLFxuICBjaGVja2JveEhlYWRlcldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94SGVhZGVyOiBcInN0cmluZ1wiLFxuICByb3c6IFwic3RyaW5nXCIsXG4gIHJvd0l0ZW06IFwic3RyaW5nXCIsXG4gIHN0cmlwZWQ6IFwic3RyaW5nXCIsXG4gIHNvcnRJY29uV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgc29ydEljb246IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25Sb3dzVGV4dDogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbk5hdjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkJ1dHRvbnNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBob3ZlclJvdzogXCJzdHJpbmdcIixcbiAgYm9yZGVyQ29sb3I6IFwic3RyaW5nXCIsXG4gIGNvbG9yOiBcInN0cmluZ1wiLFxuICBmaXhlZEhlYWRlcjogXCJzdHJpbmdcIixcbiAgZml4ZWRIZWFkZXJCb2R5OiBcInN0cmluZ1wiLFxuICBzZWxlY3RhYmxlUm93OiBcInN0cmluZ1wiLFxuICByb3dBbmltYXRpb246IFwic3RyaW5nXCIsXG4gIHNtOiBcInN0cmluZ1wiLFxuICBlZGl0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJdGVtc1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25TdGFydEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkxlZnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25SaWdodEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkVuZEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ0l0ZW1zV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1Byb2dyZXNzQmFyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1Byb2dyZXNzQmFyOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nTWVzc2FnZTogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1BhZ2luYXRpb25Sb3dzVGV4dDogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1BhZ2luYXRpb25TZWxlY3RXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nUGFnaW5hdGlvbk5hdjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ0NvbHVtbjogXCJzdHJpbmdcIixcbiAgbm9Gb3VuZE1lc3NhZ2VXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBub0ZvdW5kTWVzc2FnZTogXCJzdHJpbmdcIlxufTtcbmNsYXNzIHdjIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpID0ge30sIG4gPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9ucyhpKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMobiksIHRoaXMuX3NvcnRSZXZlcnNlID0gITEsIHRoaXMuX2FjdGl2ZVBhZ2UgPSAwLCB0aGlzLl9zZWFyY2ggPSBcIlwiLCB0aGlzLl9zZWFyY2hDb2x1bW4gPSBudWxsLCB0aGlzLl9wYWdpbmF0aW9uTGVmdCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25SaWdodCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25TdGFydCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25FbmQgPSBudWxsLCB0aGlzLl9zZWxlY3QgPSBudWxsLCB0aGlzLl9zZWxlY3RJbnN0YW5jZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkID0gW10sIHRoaXMuX2NoZWNrYm94ZXMgPSBudWxsLCB0aGlzLl9oZWFkZXJDaGVja2JveCA9IG51bGwsIHRoaXMuX3Jvd3MgPSB0aGlzLl9nZXRSb3dzKGUucm93cyksIHRoaXMuX2NvbHVtbnMgPSB0aGlzLl9nZXRDb2x1bW5zKGUuY29sdW1ucyksIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCBnaSwgdGhpcyksIHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIgPSBudWxsLCB0aGlzLl9zZXR1cCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4geGk7XG4gIH1cbiAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbnMubWFwKCh0LCBlKSA9PiB7XG4gICAgICBsZXQgaSA9IHtcbiAgICAgICAgLi4uS3YsXG4gICAgICAgIGZpZWxkOiBgZmllbGRfJHtlfWAsXG4gICAgICAgIGNvbHVtbkluZGV4OiBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBpLmxhYmVsID0gdCA6IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgKGkgPSB7XG4gICAgICAgIC4uLmksXG4gICAgICAgIC4uLnRcbiAgICAgIH0pLCBMKFwiY29sdW1uXCIsIGksIGp2KSwgaTtcbiAgICB9KTtcbiAgfVxuICBnZXQgcm93cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm93cy5tYXAoKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSB7XG4gICAgICAgIHJvd0luZGV4OiBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0aGlzLmNvbHVtbnMuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgICB0W29dID09PSAwID8gaVtuLmZpZWxkXSA9IHRbb10gOiBpW24uZmllbGRdID0gdFtvXSB8fCB0aGlzLl9vcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH0pIDogdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0aGlzLmNvbHVtbnMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICB0W24uZmllbGRdID09PSAwID8gaVtuLmZpZWxkXSA9IHRbbi5maWVsZF0gOiBpW24uZmllbGRdID0gdFtuLmZpZWxkXSB8fCB0aGlzLl9vcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH0pLCBpO1xuICAgIH0pO1xuICB9XG4gIGdldCBzZWFyY2hSZXN1bHQoKSB7XG4gICAgcmV0dXJuIExiKHRoaXMucm93cywgdGhpcy5fc2VhcmNoLCB0aGlzLl9zZWFyY2hDb2x1bW4pO1xuICB9XG4gIGdldCBjb21wdXRlZFJvd3MoKSB7XG4gICAgbGV0IHQgPSBbLi4udGhpcy5zZWFyY2hSZXN1bHRdO1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciAmJiAodCA9ICRiKHtcbiAgICAgIHJvd3M6IHQsXG4gICAgICBmaWVsZDogdGhpcy5fb3B0aW9ucy5zb3J0RmllbGQsXG4gICAgICBvcmRlcjogdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXJcbiAgICB9KSksIHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbiAmJiAodGhpcy5fb3B0aW9ucy5lbnRyaWVzID09PSBcIkFsbFwiID8gdCA9IEZhKHtcbiAgICAgIHJvd3M6IHQsXG4gICAgICBlbnRyaWVzOiB0Lmxlbmd0aCxcbiAgICAgIGFjdGl2ZVBhZ2U6IHRoaXMuX2FjdGl2ZVBhZ2VcbiAgICB9KSA6IHQgPSBGYSh7XG4gICAgICByb3dzOiB0LFxuICAgICAgZW50cmllczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzLFxuICAgICAgYWN0aXZlUGFnZTogdGhpcy5fYWN0aXZlUGFnZVxuICAgIH0pKSwgdDtcbiAgfVxuICBnZXQgcGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZW50cmllcyA9PT0gXCJBbGxcIiA/IDEgOiBNYXRoLmNlaWwodGhpcy5zZWFyY2hSZXN1bHQubGVuZ3RoIC8gdGhpcy5fb3B0aW9ucy5lbnRyaWVzKTtcbiAgfVxuICBnZXQgbmF2aWdhdGlvblRleHQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2FjdGl2ZVBhZ2UgKiB0aGlzLl9vcHRpb25zLmVudHJpZXM7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoUmVzdWx0Lmxlbmd0aCA9PT0gMCA/IGAwICR7dGhpcy5fb3B0aW9ucy5vZlRleHR9IDBgIDogdGhpcy5fb3B0aW9ucy5lbnRyaWVzID09PSBcIkFsbFwiID8gYDEgLSAke3RoaXMuc2VhcmNoUmVzdWx0Lmxlbmd0aH0gJHt0aGlzLl9vcHRpb25zLm9mVGV4dH0gJHt0aGlzLnNlYXJjaFJlc3VsdC5sZW5ndGh9YCA6IGAke3QgKyAxfSAtICR7dGhpcy5jb21wdXRlZFJvd3MubGVuZ3RoICsgdH0gJHt0aGlzLl9vcHRpb25zLm9mVGV4dH0gJHt0aGlzLnNlYXJjaFJlc3VsdC5sZW5ndGh9YDtcbiAgfVxuICBnZXQgdGFibGVPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB0aGlzLl9jbGFzc2VzLFxuICAgICAgY29sdW1uczogdGhpcy5jb2x1bW5zLFxuICAgICAgcm93czogdGhpcy5jb21wdXRlZFJvd3MsXG4gICAgICBub0ZvdW5kTWVzc2FnZTogdGhpcy5fb3B0aW9ucy5ub0ZvdW5kTWVzc2FnZSxcbiAgICAgIGVkaXQ6IHRoaXMuX29wdGlvbnMuZWRpdCxcbiAgICAgIGxvYWRpbmc6IHRoaXMuX29wdGlvbnMubG9hZGluZyxcbiAgICAgIGxvYWRlckNsYXNzOiB0aGlzLl9vcHRpb25zLmxvYWRlckNsYXNzLFxuICAgICAgbG9hZGluZ01lc3NhZ2U6IHRoaXMuX29wdGlvbnMubG9hZGluZ01lc3NhZ2UsXG4gICAgICBzZWxlY3RhYmxlOiB0aGlzLl9vcHRpb25zLnNlbGVjdGFibGUsXG4gICAgICBtdWx0aTogdGhpcy5fb3B0aW9ucy5tdWx0aSxcbiAgICAgIGJvcmRlcmVkOiB0aGlzLl9vcHRpb25zLmJvcmRlcmVkLFxuICAgICAgYm9yZGVybGVzczogdGhpcy5fb3B0aW9ucy5ib3JkZXJsZXNzLFxuICAgICAgc3RyaXBlZDogdGhpcy5fb3B0aW9ucy5zdHJpcGVkLFxuICAgICAgaG92ZXI6IHRoaXMuX29wdGlvbnMuaG92ZXIsXG4gICAgICBmaXhlZEhlYWRlcjogdGhpcy5fb3B0aW9ucy5maXhlZEhlYWRlcixcbiAgICAgIHNtOiB0aGlzLl9vcHRpb25zLnNtLFxuICAgICAgc29ydEljb25UZW1wbGF0ZTogdGhpcy5fb3B0aW9ucy5zb3J0SWNvblRlbXBsYXRlLFxuICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICBlbmFibGU6IHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbixcbiAgICAgICAgdGV4dDogdGhpcy5uYXZpZ2F0aW9uVGV4dCxcbiAgICAgICAgZW50cmllczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzLFxuICAgICAgICBlbnRyaWVzT3B0aW9uczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzT3B0aW9ucyxcbiAgICAgICAgZnVsbFBhZ2luYXRpb246IHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24sXG4gICAgICAgIHJvd3NUZXh0OiB0aGlzLl9vcHRpb25zLnJvd3NUZXh0LFxuICAgICAgICBvZlRleHQ6IHRoaXMuX29wdGlvbnMub2ZUZXh0LFxuICAgICAgICBhbGxUZXh0OiB0aGlzLl9vcHRpb25zLmFsbFRleHQsXG4gICAgICAgIHBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZTogdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uU3RhcnRJY29uVGVtcGxhdGUsXG4gICAgICAgIHBhZ2luYXRpb25MZWZ0SWNvblRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb25MZWZ0SWNvblRlbXBsYXRlLFxuICAgICAgICBwYWdpbmF0aW9uUmlnaHRJY29uVGVtcGxhdGU6IHRoaXMuX29wdGlvbnMucGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlLFxuICAgICAgICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb25FbmRJY29uVGVtcGxhdGUsXG4gICAgICAgIGNsYXNzZXM6IHRoaXMuX2NsYXNzZXNcbiAgICAgIH0sXG4gICAgICBmb3JjZVNvcnQ6IHRoaXMuX29wdGlvbnMuZm9yY2VTb3J0XG4gICAgfTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdXBkYXRlKHQsIGUgPSB7fSkge1xuICAgIHQgJiYgdC5yb3dzICYmICh0aGlzLl9yb3dzID0gdC5yb3dzKSwgdCAmJiB0LmNvbHVtbnMgJiYgKHRoaXMuX2NvbHVtbnMgPSB0LmNvbHVtbnMpLCB0aGlzLl9jbGVhckNsYXNzTGlzdChlKSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnMoeyAuLi50aGlzLl9vcHRpb25zLCAuLi5lIH0pLCB0aGlzLl9zZXR1cCgpLCB0aGlzLl9wZXJmb3JtU29ydCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fc2VsZWN0SW5zdGFuY2UgJiYgdGhpcy5fc2VsZWN0SW5zdGFuY2UuZGlzcG9zZSgpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgZ2kpLCB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpLCB0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyLmRlc3Ryb3koKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgc2VhcmNoKHQsIGUpIHtcbiAgICB0aGlzLl9zZWFyY2ggPSB0LCB0aGlzLl9zZWFyY2hDb2x1bW4gPSBlLCB0aGlzLl9hY3RpdmVQYWdlID0gMCwgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCksIHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0ICYmICh0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyLmVsZW1lbnQuc2Nyb2xsVG9wID0gMCwgdGhpcy5fcGVyZmVjdFNjcm9sbGJhci51cGRhdGUoKSk7XG4gIH1cbiAgc29ydCh0LCBlID0gXCJhc2NcIikge1xuICAgIHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID0gZSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHRoaXMuX29wdGlvbnMuc29ydEZpZWxkID0gdGhpcy5jb2x1bW5zLmZpbmQoXG4gICAgICAobikgPT4gbi5sYWJlbCA9PT0gdFxuICAgICkuZmllbGQgOiB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9IHQuZmllbGQ7XG4gICAgY29uc3QgaSA9IGQuZmluZE9uZShcbiAgICAgIGBbZGF0YS10ZS1zb3J0PVwiJHt0aGlzLl9vcHRpb25zLnNvcnRGaWVsZH1cIl1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgdGhpcy5fYWN0aXZlUGFnZSA9IDAsIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCksIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKGkpO1xuICB9XG4gIHNldEFjdGl2ZVBhZ2UodCkge1xuICAgIHQgPCB0aGlzLnBhZ2VzICYmIHRoaXMuX2NoYW5nZUFjdGl2ZVBhZ2UodCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnp2LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKHhpLCB0LCBVdiksIHQ7XG4gIH1cbiAgX2NoYW5nZUFjdGl2ZVBhZ2UodCkge1xuICAgIHRoaXMuX2FjdGl2ZVBhZ2UgPSB0LCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fcmVuZGVyUm93cygpO1xuICB9XG4gIF9jbGVhckNsYXNzTGlzdCh0KSB7XG4gICAgW1wiaG92ZXJcIiwgXCJib3JkZXJlZFwiLCBcImJvcmRlcmxlc3NcIiwgXCJzbVwiLCBcInN0cmlwZWRcIl0uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5fb3B0aW9uc1tlXSAmJiAhdFtlXSAmJiBjLnJlbW92ZURhdGFBdHRyaWJ1dGUoYGRhdGEtdGUtJHtlfWApO1xuICAgIH0pO1xuICB9XG4gIF9lbWl0U2VsZWN0RXZlbnQoKSB7XG4gICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFliLCB7XG4gICAgICBzZWxlY3RlZFJvd3M6IHRoaXMucm93cy5maWx0ZXIoXG4gICAgICAgICh0KSA9PiB0aGlzLl9zZWxlY3RlZC5pbmRleE9mKHQucm93SW5kZXgpICE9PSAtMVxuICAgICAgKSxcbiAgICAgIHNlbGVjdGVkSW5kZXhlczogdGhpcy5fc2VsZWN0ZWQsXG4gICAgICBhbGxTZWxlY3RlZDogdGhpcy5fc2VsZWN0ZWQubGVuZ3RoID09PSB0aGlzLnJvd3MubGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgX2dldFJvd3ModCA9IFtdKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcInRib2R5XCIsIHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBlID8gWy4uLmQuZmluZChcInRyXCIsIGUpLm1hcCgobikgPT4gZC5maW5kKFwidGRcIiwgbikubWFwKChvKSA9PiBvLmlubmVySFRNTCkpLCAuLi50XSA6IHQ7XG4gIH1cbiAgX2dldENvbHVtbnModCA9IFtdKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcInRoZWFkXCIsIHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IGkgPSBkLmZpbmRPbmUoXCJ0clwiLCBlKTtcbiAgICByZXR1cm4gWy4uLmQuZmluZChcInRoXCIsIGkpLm1hcCgobykgPT4gKHtcbiAgICAgIGxhYmVsOiBvLmlubmVySFRNTCxcbiAgICAgIC4uLmMuZ2V0RGF0YUF0dHJpYnV0ZXMobylcbiAgICB9KSksIC4uLnRdO1xuICB9XG4gIF9nZXRDU1NWYWx1ZSh0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogYCR7dH1weGA7XG4gIH1cbiAgX2dldE9wdGlvbnModCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5ZdixcbiAgICAgIC4uLmMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gTCh4aSwgZSwgRnYpLCBlO1xuICB9XG4gIF9zZXRBY3RpdmVSb3dzKCkge1xuICAgIGQuZmluZChkaSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpcy5fc2VsZWN0ZWQuaW5jbHVkZXMoYy5nZXREYXRhQXR0cmlidXRlKHQsIFwiaW5kZXhcIikpID8gYy5hZGRDbGFzcyh0LCBgYWN0aXZlICR7dGhpcy5fY2xhc3Nlcy5zZWxlY3RhYmxlUm93fWApIDogYy5yZW1vdmVDbGFzcyh0LCBgYWN0aXZlICR7dGhpcy5fY2xhc3Nlcy5zZWxlY3RhYmxlUm93fWApO1xuICAgIH0pO1xuICB9XG4gIF9zZXRFbnRyaWVzKHQpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9ucyh7XG4gICAgICAuLi50aGlzLl9vcHRpb25zLFxuICAgICAgZW50cmllczogdC50YXJnZXQudmFsdWVcbiAgICB9KSwgdGhpcy5fYWN0aXZlUGFnZSA+IHRoaXMucGFnZXMgLSAxICYmICh0aGlzLl9hY3RpdmVQYWdlID0gdGhpcy5wYWdlcyAtIDEpLCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fcmVuZGVyUm93cygpO1xuICB9XG4gIF9zZXRTZWxlY3RlZCgpIHtcbiAgICBkLmZpbmQoWG4sIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goXG4gICAgICAodCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlKHQsIFwicm93SW5kZXhcIik7XG4gICAgICAgIHQuY2hlY2tlZCA9IHRoaXMuX3NlbGVjdGVkLmluY2x1ZGVzKGUpO1xuICAgICAgfVxuICAgICksIHRoaXMuX3NldEFjdGl2ZVJvd3MoKTtcbiAgfVxuICBfc2V0QWN0aXZlU29ydEljb24odCkge1xuICAgIGQuZmluZChVbiwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID09PSBcImRlc2NcIiAmJiBlID09PSB0ID8gMTgwIDogMDtcbiAgICAgIGMuc3R5bGUoZSwge1xuICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoJHtpfWRlZylgXG4gICAgICB9KSwgZSA9PT0gdCAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA/IGMuYWRkQ2xhc3MoZSwgXCJvcGFjaXR5LTEwMFwiKSA6IGMucmVtb3ZlQ2xhc3MoZSwgXCJvcGFjaXR5LTEwMFwiKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXAoKSB7XG4gICAgdGhpcy5fcmVuZGVyVGFibGUoKSwgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX3NldHVwUGFnaW5hdGlvbigpLCB0aGlzLl9vcHRpb25zLmVkaXQgJiYgdGhpcy5fc2V0dXBFZGl0YWJsZSgpLCB0aGlzLl9vcHRpb25zLmNsaWNrYWJsZVJvd3MgJiYgdGhpcy5fc2V0dXBDbGlja2FibGVSb3dzKCksIHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZSAmJiB0aGlzLl9zZXR1cFNlbGVjdGFibGUoKSwgdGhpcy5fc2V0dXBTY3JvbGwoKSwgdGhpcy5fc2V0dXBTb3J0KCk7XG4gIH1cbiAgX3NldHVwQ2xpY2thYmxlUm93cygpIHtcbiAgICBkLmZpbmQoZGksIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBjLmdldERhdGFBdHRyaWJ1dGUodCwgXCJpbmRleFwiKTtcbiAgICAgIGMuYWRkQ2xhc3ModCwgXCJjdXJzb3ItcG9pbnRlclwiKSwgaC5vbih0LCBcImNsaWNrXCIsIChpKSA9PiB7XG4gICAgICAgIGQubWF0Y2hlcyhpLnRhcmdldCwgWG4pIHx8IGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBqYiwge1xuICAgICAgICAgIGluZGV4OiBlLFxuICAgICAgICAgIHJvdzogdGhpcy5yb3dzW2VdXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwRWRpdGFibGUoKSB7XG4gICAgZC5maW5kKGRpLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlKHQsIFwiaW5kZXhcIik7XG4gICAgICBkLmZpbmQoem4sIHQpLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgaC5vbihpLCBcImlucHV0XCIsIChuKSA9PiB0aGlzLl91cGRhdGVSb3cobiwgZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwU2Nyb2xsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoTWIsIHRoaXMuX2VsZW1lbnQpLCBlID0ge307XG4gICAgaWYgKHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0ICYmIChlLm1heEhlaWdodCA9IHRoaXMuX2dldENTU1ZhbHVlKHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0KSksIHRoaXMuX29wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDU1NWYWx1ZSh0aGlzLl9vcHRpb25zLm1heFdpZHRoKTtcbiAgICAgIGUubWF4V2lkdGggPSBpLCBjLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHsgbWF4V2lkdGg6IGkgfSk7XG4gICAgfVxuICAgIGlmIChjLnN0eWxlKHQsIGUpLCBjLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuc2Nyb2xsfWApLCB0aGlzLl9vcHRpb25zLmZpeGVkSGVhZGVyKSB7XG4gICAgICBsZXQgaSA9IGQuZmluZChOYiwgdGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9vcHRpb25zLnNlbGVjdGFibGUgJiYgKGkgPSBpLmZpbHRlcigobiwgbykgPT4gKGMuYWRkQ2xhc3MoXG4gICAgICAgIG4sXG4gICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZml4ZWRIZWFkZXJ9ICR7dGhpcy5fY2xhc3Nlcy5jb2xvcn1gXG4gICAgICApLCBvICE9PSAwKSkpLCBpLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgICAgYy5hZGRDbGFzcyhcbiAgICAgICAgICBuLFxuICAgICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZml4ZWRIZWFkZXJ9ICR7dGhpcy5fY2xhc3Nlcy5jb2xvcn1gXG4gICAgICAgICksIHRoaXMuY29sdW1uc1tvXS5maXhlZCAmJiBjLmFkZENsYXNzKG4sIFwiIXotNDBcIik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG5ldyB5Yyh0KTtcbiAgfVxuICBfc2V0dXBTb3J0KCkge1xuICAgIGQuZmluZChVbiwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInNvcnRcIiksIFtpXSA9IGQucGFyZW50cyh0LCBcInRoXCIpO1xuICAgICAgaWYgKHRoaXMuY29sdW1ucy5zb3J0KVxuICAgICAgICBjLmFkZENsYXNzKGksIFwiY3Vyc29yLXBvaW50ZXJcIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgICAgIGUgPT09IHRoaXMuX29wdGlvbnMuc29ydEZpZWxkICYmIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKHQpLCBoLm9uKGksIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9PT0gZSAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9PT0gXCJhc2NcIiA/IHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID0gXCJkZXNjXCIgOiB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9PT0gZSAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9PT0gXCJkZXNjXCIgPyB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9IHRoaXMuX29wdGlvbnMuZm9yY2VTb3J0ID8gXCJhc2NcIiA6IG51bGwgOiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9IFwiYXNjXCIsIHRoaXMuX29wdGlvbnMuc29ydEZpZWxkID0gZSwgdGhpcy5fYWN0aXZlUGFnZSA9IDAsIHRoaXMuX3BlcmZvcm1Tb3J0KCksIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3BlcmZvcm1Tb3J0KCkge1xuICAgIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCk7XG4gIH1cbiAgX3NldHVwU2VsZWN0YWJsZSgpIHtcbiAgICB0aGlzLl9jaGVja2JveGVzID0gZC5maW5kKFhuLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5faGVhZGVyQ2hlY2tib3ggPSBkLmZpbmRPbmUoXG4gICAgICBSYixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBoLm9uKFxuICAgICAgdGhpcy5faGVhZGVyQ2hlY2tib3gsXG4gICAgICBcImlucHV0XCIsXG4gICAgICAodCkgPT4gdGhpcy5fdG9nZ2xlU2VsZWN0QWxsKHQpXG4gICAgKSwgdGhpcy5fY2hlY2tib3hlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlKHQsIFwicm93SW5kZXhcIik7XG4gICAgICBoLm9uKFxuICAgICAgICB0LFxuICAgICAgICBcImlucHV0XCIsXG4gICAgICAgIChpKSA9PiB0aGlzLl90b2dnbGVTZWxlY3RSb3coaSwgZSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwUGFnaW5hdGlvbigpIHtcbiAgICB0aGlzLl9wYWdpbmF0aW9uUmlnaHQgPSBkLmZpbmRPbmUoXG4gICAgICBQYixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9wYWdpbmF0aW9uTGVmdCA9IGQuZmluZE9uZShcbiAgICAgIEJiLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGgub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uUmlnaHQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKHRoaXMuX2FjdGl2ZVBhZ2UgKyAxKVxuICAgICksIGgub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uTGVmdCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgICgpID0+IHRoaXMuX2NoYW5nZUFjdGl2ZVBhZ2UodGhpcy5fYWN0aXZlUGFnZSAtIDEpXG4gICAgKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiAodGhpcy5fcGFnaW5hdGlvblN0YXJ0ID0gZC5maW5kT25lKFxuICAgICAgSGIsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fcGFnaW5hdGlvbkVuZCA9IGQuZmluZE9uZShcbiAgICAgIFdiLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGgub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uU3RhcnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKDApXG4gICAgKSwgaC5vbihcbiAgICAgIHRoaXMuX3BhZ2luYXRpb25FbmQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKHRoaXMucGFnZXMgLSAxKVxuICAgICkpLCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fc2V0dXBQYWdpbmF0aW9uU2VsZWN0KCk7XG4gIH1cbiAgX3NldHVwUGFnaW5hdGlvblNlbGVjdCgpIHtcbiAgICB0aGlzLl9zZWxlY3QgPSBkLmZpbmRPbmUoRmIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9zZWxlY3RJbnN0YW5jZSA9IG5ldyAkbyh0aGlzLl9zZWxlY3QpLCBoLm9uKFxuICAgICAgdGhpcy5fc2VsZWN0LFxuICAgICAgXCJ2YWx1ZUNoYW5nZS50ZS5zZWxlY3RcIixcbiAgICAgICh0KSA9PiB0aGlzLl9zZXRFbnRyaWVzKHQpXG4gICAgKTtcbiAgfVxuICBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIChoLm9mZih0aGlzLl9wYWdpbmF0aW9uUmlnaHQsIFwiY2xpY2tcIiksIGgub2ZmKHRoaXMuX3BhZ2luYXRpb25MZWZ0LCBcImNsaWNrXCIpLCBoLm9mZih0aGlzLl9zZWxlY3QsIFwidmFsdWVDaGFuZ2UudGUuc2VsZWN0XCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIChoLm9mZih0aGlzLl9wYWdpbmF0aW9uU3RhcnQsIFwiY2xpY2tcIiksIGgub2ZmKHRoaXMuX3BhZ2luYXRpb25FbmQsIFwiY2xpY2tcIikpKSwgdGhpcy5fb3B0aW9ucy5lZGl0ICYmIGQuZmluZCh6biwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgaC5vZmYodCwgXCJpbnB1dFwiKTtcbiAgICB9KSwgdGhpcy5fb3B0aW9ucy5jbGlja2FibGVSb3dzICYmIGQuZmluZChkaSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgaC5vZmYodCwgXCJjbGlja1wiKTtcbiAgICB9KSwgZC5maW5kKFVuLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBbZV0gPSBkLnBhcmVudHModCwgXCJ0aFwiKTtcbiAgICAgIGgub2ZmKGUsIFwiY2xpY2tcIik7XG4gICAgfSksIHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZSAmJiAoaC5vZmYodGhpcy5faGVhZGVyQ2hlY2tib3gsIFwiaW5wdXRcIiksIHRoaXMuX2NoZWNrYm94ZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgaC5vZmYodCwgXCJpbnB1dFwiKTtcbiAgICB9KSk7XG4gIH1cbiAgX3JlbmRlclRhYmxlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gVmEodGhpcy50YWJsZU9wdGlvbnMpLnRhYmxlLCB0aGlzLl9mb3JtYXRDZWxscygpLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWWEpO1xuICB9XG4gIF9yZW5kZXJSb3dzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXCJ0Ym9keVwiLCB0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uKSB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgICBWYixcbiAgICAgICAgdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIGUuaW5uZXJUZXh0ID0gdGhpcy5uYXZpZ2F0aW9uVGV4dDtcbiAgICB9XG4gICAgdC5pbm5lckhUTUwgPSBWYSh0aGlzLnRhYmxlT3B0aW9ucykucm93cywgdGhpcy5fZm9ybWF0Q2VsbHMoKSwgdGhpcy5fb3B0aW9ucy5lZGl0ICYmIHRoaXMuX3NldHVwRWRpdGFibGUoKSwgdGhpcy5fb3B0aW9ucy5zZWxlY3RhYmxlICYmICh0aGlzLl9zZXR1cFNlbGVjdGFibGUoKSwgdGhpcy5fc2V0U2VsZWN0ZWQoKSksIHRoaXMuX29wdGlvbnMuY2xpY2thYmxlUm93cyAmJiB0aGlzLl9zZXR1cENsaWNrYWJsZVJvd3MoKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFlhKTtcbiAgfVxuICBfZm9ybWF0Q2VsbHMoKSB7XG4gICAgZC5maW5kKGRpLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCBpID0gYy5nZXREYXRhQXR0cmlidXRlKGUsIFwiaW5kZXhcIik7XG4gICAgICBkLmZpbmQoem4sIGUpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgY29uc3QgciA9IGMuZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImZpZWxkXCIpLCBhID0gdGhpcy5jb2x1bW5zLmZpbmQoKGwpID0+IGwuZmllbGQgPT09IHIpO1xuICAgICAgICBhICYmIGEuZm9ybWF0ICE9PSBudWxsICYmIGEuZm9ybWF0KG8sIHRoaXMucm93c1tpXVtyXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlRGlzYWJsZVN0YXRlKCkge1xuICAgIHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbiAhPT0gITEgJiYgKHRoaXMuX2FjdGl2ZVBhZ2UgPT09IDAgfHwgdGhpcy5fb3B0aW9ucy5sb2FkaW5nID8gKHRoaXMuX3BhZ2luYXRpb25MZWZ0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIHRoaXMuX3BhZ2luYXRpb25TdGFydC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSkgOiAodGhpcy5fcGFnaW5hdGlvbkxlZnQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24gJiYgdGhpcy5fcGFnaW5hdGlvblN0YXJ0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSwgdGhpcy5fYWN0aXZlUGFnZSA9PT0gdGhpcy5wYWdlcyAtIDEgfHwgdGhpcy5fb3B0aW9ucy5sb2FkaW5nIHx8IHRoaXMucGFnZXMgPT09IDAgPyAodGhpcy5fcGFnaW5hdGlvblJpZ2h0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIHRoaXMuX3BhZ2luYXRpb25FbmQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIikpIDogKHRoaXMuX3BhZ2luYXRpb25SaWdodC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiB0aGlzLl9wYWdpbmF0aW9uRW5kLnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSk7XG4gIH1cbiAgX3RvZ2dsZVNlbGVjdEFsbCh0KSB7XG4gICAgdC50YXJnZXQuY2hlY2tlZCA/IHRoaXMuX3NlbGVjdGVkID0gdGhpcy5yb3dzLm1hcCgoZSkgPT4gZS5yb3dJbmRleCkgOiB0aGlzLl9zZWxlY3RlZCA9IFtdLCB0aGlzLl9zZXRTZWxlY3RlZCgpLCB0aGlzLl9lbWl0U2VsZWN0RXZlbnQoKTtcbiAgfVxuICBfdG9nZ2xlU2VsZWN0Um93KHQsIGUpIHtcbiAgICB0LnRhcmdldC5jaGVja2VkID8gdGhpcy5fb3B0aW9ucy5tdWx0aSAmJiAhdGhpcy5fc2VsZWN0ZWQuaW5jbHVkZXMoZSkgPyB0aGlzLl9zZWxlY3RlZCA9IFsuLi50aGlzLl9zZWxlY3RlZCwgZV0gOiAodGhpcy5fc2VsZWN0ZWQgPSBbZV0sIHRoaXMuX2NoZWNrYm94ZXMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgaSAhPT0gdC50YXJnZXQgJiYgKGkuY2hlY2tlZCA9ICExKTtcbiAgICB9KSkgOiB0aGlzLl9zZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGVkLmZpbHRlcigoaSkgPT4gaSAhPT0gZSksIHRoaXMuX29wdGlvbnMubXVsdGkgJiYgIXQudGFyZ2V0LmNoZWNrZWQgJiYgKHRoaXMuX2hlYWRlckNoZWNrYm94LmNoZWNrZWQgPSAhMSksIHRoaXMuX3NldEFjdGl2ZVJvd3MoKSwgdGhpcy5fZW1pdFNlbGVjdEV2ZW50KCk7XG4gIH1cbiAgX3VwZGF0ZVJvdyh0LCBlKSB7XG4gICAgY29uc3QgaSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZSh0LnRhcmdldCwgXCJmaWVsZFwiKSwgbiA9IHQudGFyZ2V0LnRleHRDb250ZW50LCBvID0gdGhpcy5fcm93c1tlXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgY29uc3QgYSA9IHRoaXMuY29sdW1ucy5maW5kKChsKSA9PiBsLmZpZWxkID09PSBpKS5jb2x1bW5JbmRleDtcbiAgICAgIG9bYV0gPSBuO1xuICAgIH0gZWxzZVxuICAgICAgb1tpXSA9IG47XG4gICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEtiLCB7XG4gICAgICByb3dzOiB0aGlzLl9yb3dzLFxuICAgICAgY29sdW1uczogdGhpcy5fY29sdW1uc1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSwgaSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgbiA9IEkuZ2V0RGF0YSh0aGlzLCBnaSk7XG4gICAgICBjb25zdCBvID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIW4gJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChuIHx8IChuID0gbmV3IHdjKHRoaXMsIG8sIGUpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIG5bdF0oZSwgaSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIGdpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBqYSA9IFwicmF0aW5nXCIsICRzID0gXCJ0ZS5yYXRpbmdcIiwgWHYgPSBcImRhdGEtdGUtcmF0aW5nLWluaXRcIiwgR3YgPSBcIltkYXRhLXRlLXJhdGluZy1pY29uLXJlZl1cIiwgdGkgPSBgLiR7JHN9YCwgcXYgPSBcIkFycm93TGVmdFwiLCBadiA9IFwiQXJyb3dSaWdodFwiLCBRdiA9IHtcbiAgdG9vbHRpcDogXCJzdHJpbmdcIixcbiAgdmFsdWU6IFwiKHN0cmluZ3xudW1iZXIpXCIsXG4gIHJlYWRvbmx5OiBcImJvb2xlYW5cIixcbiAgYWZ0ZXI6IFwic3RyaW5nXCIsXG4gIGJlZm9yZTogXCJzdHJpbmdcIixcbiAgZHluYW1pYzogXCJib29sZWFuXCIsXG4gIGFjdGl2ZTogXCJzdHJpbmdcIlxufSwgSnYgPSB7XG4gIHRvb2x0aXA6IFwidG9wXCIsXG4gIHZhbHVlOiBcIlwiLFxuICByZWFkb25seTogITEsXG4gIGFmdGVyOiBcIlwiLFxuICBiZWZvcmU6IFwiXCIsXG4gIGR5bmFtaWM6ICExLFxuICBhY3RpdmU6IFwiZmlsbC1jdXJyZW50XCJcbn0sIEthID0gYG9uU2VsZWN0JHt0aX1gLCB0MCA9IGBvbkhvdmVyJHt0aX1gLCB6YSA9IGBrZXl1cCR7dGl9YCwgVWEgPSBgZm9jdXNvdXQke3RpfWAsIFhhID0gYGtleWRvd24ke3RpfWAsIEdhID0gYG1vdXNlZG93biR7dGl9YDtcbmNsYXNzIHowIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9pY29ucyA9IGQuZmluZChHdiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2luZGV4ID0gLTEsIHRoaXMuX3NhdmVkSW5kZXggPSBudWxsLCB0aGlzLl9vcmlnaW5hbENsYXNzTGlzdCA9IFtdLCB0aGlzLl9vcmlnaW5hbEljb25zID0gW10sIHRoaXMuX2ZuID0ge30sIHRoaXMuX3Rvb2x0aXBzID0gW10sIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCAkcywgdGhpcyksIHRoaXMuX2luaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGphO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsICRzKSwgdGhpcy5fb3B0aW9ucy5yZWFkb25seSB8fCAoaC5vZmYodGhpcy5fZWxlbWVudCwgemEpLCBoLm9mZih0aGlzLl9lbGVtZW50LCBVYSksIGgub2ZmKHRoaXMuX2VsZW1lbnQsIFhhKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLl9mbi5tb3VzZWxlYXZlKSwgdGhpcy5faWNvbnMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgaC5vZmYodCwgR2EpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuX2ZuLm1vdXNlZW50ZXJbZV0pLCBjLnJlbW92ZUNsYXNzKHQsIFwiY3Vyc29yLXBvaW50ZXJcIik7XG4gICAgfSksIHRoaXMuX3Rvb2x0aXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFh2KSwgdC5kaXNwb3NlKCk7XG4gICAgfSksIHRoaXMuX2ljb25zLnJlbW92ZUF0dHJpYnV0ZShcInRhYkluZGV4XCIpKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9vcHRpb25zLnJlYWRvbmx5IHx8ICh0aGlzLl9iaW5kTW91c2VFbnRlcigpLCB0aGlzLl9iaW5kTW91c2VMZWF2ZSgpLCB0aGlzLl9iaW5kTW91c2VEb3duKCksIHRoaXMuX2JpbmRLZXlEb3duKCksIHRoaXMuX2JpbmRLZXlVcCgpLCB0aGlzLl9iaW5kRm9jdXNMb3N0KCksIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGMuYWRkQ2xhc3ModCwgXCJjdXJzb3ItcG9pbnRlclwiKTtcbiAgICB9KSksIHRoaXMuX29wdGlvbnMuZHluYW1pYyAmJiAodGhpcy5fc2F2ZU9yaWdpbmFsQ2xhc3NMaXN0KCksIHRoaXMuX3NhdmVPcmlnaW5hbEljb25zKCkpLCB0aGlzLl9zZXRDdXN0b21UZXh0KCksIHRoaXMuX3NldFRvb2xUaXBzKCksIHRoaXMuX29wdGlvbnMudmFsdWUgJiYgKHRoaXMuX2luZGV4ID0gdGhpcy5fb3B0aW9ucy52YWx1ZSAtIDEsIHRoaXMuX3VwZGF0ZVJhdGluZyh0aGlzLl9pbmRleCkpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uSnYsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwoamEsIHQsIFF2KSwgdDtcbiAgfVxuICBfYmluZE1vdXNlRW50ZXIoKSB7XG4gICAgdGhpcy5fZm4ubW91c2VlbnRlciA9IFtdLCB0aGlzLl9pY29ucy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2VlbnRlclwiLFxuICAgICAgICAvLyB0aGlzLl9mbi5tb3VzZWVudGVyW2ldIGlzIG5lZWRlZCB0byBjcmVhdGUgcmVmZXJlbmNlIGFuZCB1bnBpbiBldmVudHMgYWZ0ZXIgY2FsbCBkaXNwb3NlXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICB0aGlzLl9mbi5tb3VzZWVudGVyW2VdID0gKGkpID0+IHtcbiAgICAgICAgICB0aGlzLl9pbmRleCA9IHRoaXMuX2ljb25zLmluZGV4T2YoaS50YXJnZXQpLCB0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5faW5kZXgpLCB0aGlzLl90cmlnZ2VyRXZlbnRzKHQsIHQwKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZE1vdXNlTGVhdmUoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJtb3VzZWxlYXZlXCIsXG4gICAgICAvLyB0aGlzLl9mbi5tb3VzZWxlYXZlIGlzIG5lZWRlZCB0byBjcmVhdGUgcmVmZXJlbmNlIGFuZCB1bnBpbiBldmVudHMgYWZ0ZXIgY2FsbCBkaXNwb3NlXG4gICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIHRoaXMuX2ZuLm1vdXNlbGVhdmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3NhdmVkSW5kZXggIT09IG51bGwgPyAodGhpcy5fdXBkYXRlUmF0aW5nKHRoaXMuX3NhdmVkSW5kZXgpLCB0aGlzLl9pbmRleCA9IHRoaXMuX3NhdmVkSW5kZXgpIDogdGhpcy5fb3B0aW9ucy52YWx1ZSA/ICh0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5fb3B0aW9ucy52YWx1ZSAtIDEpLCB0aGlzLl9pbmRleCA9IHRoaXMuX29wdGlvbnMudmFsdWUgLSAxKSA6ICh0aGlzLl9pbmRleCA9IC0xLCB0aGlzLl9jbGVhclJhdGluZygpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9iaW5kTW91c2VEb3duKCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGgub24odCwgR2EsICgpID0+IHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJub25lXCIpLCB0aGlzLl9zYXZlZEluZGV4ID0gdGhpcy5faW5kZXgsIHRoaXMuX3RyaWdnZXJFdmVudHModCwgS2EpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRLZXlEb3duKCkge1xuICAgIHRoaXMuX2VsZW1lbnQudGFiSW5kZXggPSAwLCBoLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFhhLFxuICAgICAgKHQpID0+IHRoaXMuX3VwZGF0ZUFmdGVyS2V5RG93bih0KVxuICAgICk7XG4gIH1cbiAgX2JpbmRLZXlVcCgpIHtcbiAgICBoLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHphLFxuICAgICAgKCkgPT4gdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJhdXRvXCIpXG4gICAgKTtcbiAgfVxuICBfYmluZEZvY3VzTG9zdCgpIHtcbiAgICBoLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFVhLFxuICAgICAgKCkgPT4gdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJub25lXCIpXG4gICAgKTtcbiAgfVxuICBfc2V0RWxlbWVudE91dGxpbmUodCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3V0bGluZSA9IHQ7XG4gIH1cbiAgX3RyaWdnZXJFdmVudHModCwgZSkge1xuICAgIGgudHJpZ2dlcih0LCBlLCB7XG4gICAgICB2YWx1ZTogdGhpcy5faW5kZXggKyAxXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZUFmdGVyS2V5RG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2ljb25zLmxlbmd0aCAtIDEsIGkgPSB0aGlzLl9pbmRleDtcbiAgICB0LmtleSA9PT0gWnYgJiYgdGhpcy5faW5kZXggPCBlICYmICh0aGlzLl9pbmRleCArPSAxKSwgdC5rZXkgPT09IHF2ICYmIHRoaXMuX2luZGV4ID4gLTEgJiYgKHRoaXMuX2luZGV4IC09IDEpLCBpICE9PSB0aGlzLl9pbmRleCAmJiAodGhpcy5fc2F2ZWRJbmRleCA9IHRoaXMuX2luZGV4LCB0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5fc2F2ZWRJbmRleCksIHRoaXMuX3RyaWdnZXJFdmVudHModGhpcy5faWNvbnNbdGhpcy5fc2F2ZWRJbmRleF0sIEthKSk7XG4gIH1cbiAgX3VwZGF0ZVJhdGluZyh0KSB7XG4gICAgdGhpcy5fY2xlYXJSYXRpbmcoKSwgdGhpcy5fb3B0aW9ucy5keW5hbWljICYmIHRoaXMuX3Jlc3RvcmVPcmlnaW5hbEljb24odCksIHRoaXMuX2ljb25zLmZvckVhY2goKGUsIGkpID0+IHtcbiAgICAgIGkgPD0gdCAmJiBjLmFkZENsYXNzKGUucXVlcnlTZWxlY3RvcihcInN2Z1wiKSwgdGhpcy5fb3B0aW9ucy5hY3RpdmUpO1xuICAgIH0pO1xuICB9XG4gIF9jbGVhclJhdGluZygpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBjb25zdCBpID0gdC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpO1xuICAgICAgdGhpcy5fb3B0aW9ucy5keW5hbWljICYmICh0LmNsYXNzTGlzdCA9IHRoaXMuX29yaWdpbmFsQ2xhc3NMaXN0W2VdLCBpLmlubmVySFRNTCA9IHRoaXMuX29yaWdpbmFsSWNvbnNbZV0pLCBjLnJlbW92ZUNsYXNzKGksIHRoaXMuX29wdGlvbnMuYWN0aXZlKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0VG9vbFRpcHMoKSB7XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInRvZ2dsZVwiKTtcbiAgICAgIHQudGl0bGUgJiYgIWkgJiYgKGMuc2V0RGF0YUF0dHJpYnV0ZSh0LCBcInRvZ2dsZVwiLCBcInRvb2x0aXBcIiksIHRoaXMuX3Rvb2x0aXBzW2VdID0gbmV3IFFlKHQsIHtcbiAgICAgICAgcGxhY2VtZW50OiB0aGlzLl9vcHRpb25zLnRvb2x0aXBcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0Q3VzdG9tVGV4dCgpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlKHQsIFwiYWZ0ZXJcIiksIGkgPSBjLmdldERhdGFBdHRyaWJ1dGUodCwgXCJiZWZvcmVcIik7XG4gICAgICBlICYmIHQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYWZ0ZXJFbmRcIiwgZSksIGkgJiYgdC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVCZWdpblwiLCBpKTtcbiAgICB9KTtcbiAgfVxuICBfc2F2ZU9yaWdpbmFsQ2xhc3NMaXN0KCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LmNsYXNzTGlzdC52YWx1ZTtcbiAgICAgIHRoaXMuX29yaWdpbmFsQ2xhc3NMaXN0LnB1c2goZSk7XG4gICAgfSk7XG4gIH1cbiAgX3NhdmVPcmlnaW5hbEljb25zKCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIikuaW5uZXJIVE1MO1xuICAgICAgdGhpcy5fb3JpZ2luYWxJY29ucy5wdXNoKGUpO1xuICAgIH0pO1xuICB9XG4gIF9yZXN0b3JlT3JpZ2luYWxJY29uKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fb3JpZ2luYWxDbGFzc0xpc3RbdF0sIGkgPSB0aGlzLl9vcmlnaW5hbEljb25zW3RdO1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIGlmIChvIDw9IHQpIHtcbiAgICAgICAgY29uc3QgciA9IG4ucXVlcnlTZWxlY3RvcihcInN2Z1wiKTtcbiAgICAgICAgci5pbm5lckhUTUwgPSBpLCBuLmNsYXNzTGlzdCA9IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCAkcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgR24gPSBcInBvcGNvbmZpcm1cIiwgYmkgPSBcInRlLnBvcGNvbmZpcm1cIiwgeGMgPSBgLiR7Yml9YCwgZTAgPSBgY2FuY2VsJHt4Y31gLCBpMCA9IGBjb25maXJtJHt4Y31gLCBzMCA9IFwiW2RhdGEtdGUtcG9wY29uZmlybS1ib2R5XVwiLCBxbiA9IFwiZGF0YS10ZS1wb3Bjb25maXJtLXBvcG92ZXJcIiwgbjAgPSBcImRhdGEtdGUtcG9wY29uZmlybS1tb2RhbFwiLCBxYSA9IFwiZGF0YS10ZS1wb3Bjb25maXJtLWJhY2tkcm9wXCIsIG8wID0ge1xuICBwb3Bjb25maXJtTW9kZTogXCJzdHJpbmdcIixcbiAgbWVzc2FnZTogXCJzdHJpbmdcIixcbiAgY2FuY2VsVGV4dDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIG9rVGV4dDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHBvcGNvbmZpcm1JY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIGNhbmNlbExhYmVsOiBcIihudWxsfHN0cmluZylcIixcbiAgY29uZmlybUxhYmVsOiBcIihudWxsfHN0cmluZylcIixcbiAgcG9zaXRpb246IFwiKG51bGx8c3RyaW5nKVwiXG59LCByMCA9IHtcbiAgcG9wY29uZmlybU1vZGU6IFwiaW5saW5lXCIsXG4gIG1lc3NhZ2U6IFwiQXJlIHlvdSBzdXJlP1wiLFxuICBjYW5jZWxUZXh0OiBcIkNhbmNlbFwiLFxuICBva1RleHQ6IFwiT0tcIixcbiAgcG9wY29uZmlybUljb25UZW1wbGF0ZTogXCJcIixcbiAgY2FuY2VsTGFiZWw6IFwiQ2FuY2VsXCIsXG4gIGNvbmZpcm1MYWJlbDogXCJDb25maXJtXCIsXG4gIHBvc2l0aW9uOiBcImJvdHRvbVwiXG59LCBhMCA9IHtcbiAgYmFja2Ryb3A6IFwic3RyaW5nXCIsXG4gIGJvZHk6IFwic3RyaW5nXCIsXG4gIGJ0bkNhbmNlbDogXCJzdHJpbmdcIixcbiAgYnRuQ29uZmlybTogXCJzdHJpbmdcIixcbiAgYnRuc0NvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZmFkZTogXCJzdHJpbmdcIixcbiAgaWNvbjogXCJzdHJpbmdcIixcbiAgbWVzc2FnZTogXCJzdHJpbmdcIixcbiAgbWVzc2FnZVRleHQ6IFwic3RyaW5nXCIsXG4gIG1vZGFsOiBcInN0cmluZ1wiLFxuICBwb3BvdmVyOiBcInN0cmluZ1wiXG59LCBsMCA9IHtcbiAgYmFja2Ryb3A6IFwiaC1mdWxsIHctZnVsbCB6LVsxMDcwXSBmaXhlZCB0b3AtMCBsZWZ0LTAgYmctWyMwMDAwMDA2Nl0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgYm9keTogXCJwLVsxcmVtXSBiZy13aGl0ZSByb3VuZGVkLVswLjVyZW1dIG9wYWNpdHktMCBkYXJrOmJnLW5ldXRyYWwtNzAwXCIsXG4gIGJ0bkNhbmNlbDogXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBiZy1wcmltYXJ5LTEwMCBweC00IHBiLVs1cHhdIHB0LVs2cHhdIHRleHQteHMgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRleHQtcHJpbWFyeS03MDAgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctcHJpbWFyeS1hY2NlbnQtMTAwIGZvY3VzOmJnLXByaW1hcnktYWNjZW50LTEwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTpiZy1wcmltYXJ5LWFjY2VudC0yMDBcIixcbiAgYnRuQ29uZmlybTogXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBiZy1wcmltYXJ5IHB4LTQgcGItWzVweF0gcHQtWzZweF0gdGV4dC14cyBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdGV4dC13aGl0ZSBzaGFkb3ctWzBfNHB4XzlweF8tNHB4XyMzYjcxY2FdIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLXByaW1hcnktNjAwIGhvdmVyOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMyksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjIpXSBmb2N1czpiZy1wcmltYXJ5LTYwMCBmb2N1czpzaGFkb3ctWzBfOHB4XzlweF8tNHB4X3JnYmEoNTksMTEzLDIwMiwwLjMpLDBfNHB4XzE4cHhfMF9yZ2JhKDU5LDExMywyMDIsMC4yKV0gZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6YmctcHJpbWFyeS03MDAgYWN0aXZlOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMyksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjIpXSBkYXJrOnNoYWRvdy1bMF80cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuNSldIGRhcms6aG92ZXI6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4yKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMSldIGRhcms6Zm9jdXM6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4yKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMSldIGRhcms6YWN0aXZlOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMiksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjEpXVwiLFxuICBidG5zQ29udGFpbmVyOiBcImZsZXgganVzdGlmeS1lbmQgc3BhY2UteC0yXCIsXG4gIGZhZGU6IFwidHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVsxNTBtc10gZWFzZS1saW5lYXJcIixcbiAgaWNvbjogXCJwci0yXCIsXG4gIG1lc3NhZ2U6IFwiZmxleCBtYi0zXCIsXG4gIG1lc3NhZ2VUZXh0OiBcInRleHQtbmV1dHJhbC02MDAgZGFyazp0ZXh0LXdoaXRlXCIsXG4gIG1vZGFsOiBcImFic29sdXRlIHctWzMwMHB4XSB6LVsxMDgwXSBzaGFkb3ctc20gcm91bmRlZC1bMC41cmVtXVwiLFxuICBwb3BvdmVyOiBcInctWzMwMHB4XSBib3JkZXItMCByb3VuZGVkLVswLjVyZW1dIHotWzEwODBdIHNoYWRvdy1zbVwiXG59O1xuY2xhc3Mga2Mge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jYW5jZWxCdXR0b24gPSBcIlwiLCB0aGlzLl9jb25maXJtQnV0dG9uID0gXCJcIiwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX3VpZCA9IHRoaXMuX2VsZW1lbnQuaWQgPyBgcG9wY29uZmlybS0ke3RoaXMuX2VsZW1lbnQuaWR9YCA6IGJ0KFwicG9wY29uZmlybS1cIiksIHQgJiYgSS5zZXREYXRhKHQsIGJpLCB0aGlzKSwgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5vcGVuLmJpbmQodGhpcyksIGgub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBHbjtcbiAgfVxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoYCMke3RoaXMuX3VpZH1gKTtcbiAgfVxuICBnZXQgcG9wY29uZmlybUJvZHkoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIHMwLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgICh0aGlzLl9pc09wZW4gfHwgdGhpcy5jb250YWluZXIgIT09IG51bGwpICYmIHRoaXMuY2xvc2UoKSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGJpKSwgaC5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBvcGVuKCkge1xuICAgIHRoaXMuX2lzT3BlbiB8fCAodGhpcy5fb3B0aW9ucy5wb3Bjb25maXJtTW9kZSA9PT0gXCJpbmxpbmVcIiA/IHRoaXMuX29wZW5Qb3BvdmVyKHRoaXMuX2dldFBvcG92ZXJUZW1wbGF0ZSgpKSA6IHRoaXMuX29wZW5Nb2RhbCh0aGlzLl9nZXRNb2RhbFRlbXBsYXRlKCkpLCB0aGlzLl9oYW5kbGVDYW5jZWxCdXR0b25DbGljaygpLCB0aGlzLl9oYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9Fc2NhcGVLZXkoKSwgdGhpcy5fbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2lzT3Blbikge1xuICAgICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCB8fCBkLmZpbmRPbmUoYFske3FufV1gKSAhPT0gbnVsbClcbiAgICAgICAgaC5vbihcbiAgICAgICAgICB0aGlzLnBvcGNvbmZpcm1Cb2R5LFxuICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgIHRoaXMuX2hhbmRsZVBvcGNvbmZpcm1UcmFuc2l0aW9uRW5kLmJpbmQodGhpcylcbiAgICAgICAgKSwgYy5yZW1vdmVDbGFzcyh0aGlzLnBvcGNvbmZpcm1Cb2R5LCBcIm9wYWNpdHktMTAwXCIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske3FhfV1gXG4gICAgICAgICk7XG4gICAgICAgIGMucmVtb3ZlQ2xhc3ModGhpcy5wb3Bjb25maXJtQm9keSwgXCJvcGFjaXR5LTEwMFwiKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KSwgdGhpcy5faXNPcGVuID0gITE7XG4gICAgICB9XG4gICAgICBoLm9mZihkb2N1bWVudCwgXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVPdXRzaWRlQ2xpY2suYmluZCh0aGlzKSksIGgub2ZmKGRvY3VtZW50LCBcImtleWRvd25cIiwgdGhpcy5faGFuZGxlRXNjYXBlS2V5LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlUG9wY29uZmlybVRyYW5zaXRpb25FbmQodCkge1xuICAgIGlmICh0LnRhcmdldCAhPT0gdGhpcy5wb3Bjb25maXJtQm9keSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgYFske3FufV1gXG4gICAgKTtcbiAgICBoLm9mZih0aGlzLnBvcGNvbmZpcm1Cb2R5LCBcInRyYW5zaXRpb25lbmRcIiksIHRoaXMuX2lzT3BlbiAmJiB0ICYmIHQucHJvcGVydHlOYW1lID09PSBcIm9wYWNpdHlcIiAmJiAodGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgZSAmJiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGUpLCB0aGlzLl9pc09wZW4gPSAhMSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0UG9wb3ZlclRlbXBsYXRlKCkge1xuICAgIGNvbnN0IHQgPSBEKFwiZGl2XCIpLCBlID0gdGhpcy5fZ2V0UG9wY29uZmlybVRlbXBsYXRlKCk7XG4gICAgcmV0dXJuIHQuc2V0QXR0cmlidXRlKHFuLCBcIlwiKSwgYy5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnBvcG92ZXIpLCB0LmlkID0gdGhpcy5fdWlkLCB0LmlubmVySFRNTCA9IGUsIHQ7XG4gIH1cbiAgX2dldE1vZGFsVGVtcGxhdGUoKSB7XG4gICAgY29uc3QgdCA9IEQoXCJkaXZcIiksIGUgPSB0aGlzLl9nZXRQb3Bjb25maXJtVGVtcGxhdGUoKTtcbiAgICByZXR1cm4gdC5zZXRBdHRyaWJ1dGUobjAsIFwiXCIpLCBjLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMubW9kYWx9YCksIHQuaWQgPSB0aGlzLl91aWQsIHQuaW5uZXJIVE1MID0gZSwgdDtcbiAgfVxuICBfZ2V0UG9wY29uZmlybVRlbXBsYXRlKCkge1xuICAgIHJldHVybiBgPGRpdiBkYXRhLXRlLXBvcGNvbmZpcm0tYm9keSBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5ib2R5fVwiPlxuICAgICAgPHAgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMubWVzc2FnZX1cIj5cbiAgICAgICR7dGhpcy5fb3B0aW9ucy5wb3Bjb25maXJtSWNvblRlbXBsYXRlID8gYDxzcGFuIGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLmljb259XCI+JHt0aGlzLl9vcHRpb25zLnBvcGNvbmZpcm1JY29uVGVtcGxhdGV9PC9zcGFuPmAgOiBcIlwifVxuICAgICAgPHNwYW4gY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMubWVzc2FnZVRleHR9XCI+JHt0aGlzLl9vcHRpb25zLm1lc3NhZ2V9PC9zcGFuPlxuICAgICAgPC9wPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5idG5zQ29udGFpbmVyfVwiPlxuICAgICAgJHt0aGlzLl9vcHRpb25zLmNhbmNlbFRleHQgPyBgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS10ZS1yaXBwbGUtaW5pdCBkYXRhLXRlLXJpcHBsZS1jb2xvcj1cImxpZ2h0XCIgaWQ9XCJwb3Bjb25maXJtLWJ1dHRvbi1jYW5jZWxcIiBhcmlhLWxhYmVsPVwiJHt0aGlzLl9vcHRpb25zLmNhbmNlbExhYmVsfVwiXG4gICAgICAgIGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLmJ0bkNhbmNlbH1cIj4ke3RoaXMuX29wdGlvbnMuY2FuY2VsVGV4dH08L2J1dHRvbj5gIDogXCJcIn1cbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJsaWdodFwiIGlkPVwicG9wY29uZmlybS1idXR0b24tY29uZmlybVwiXG4gICAgICBhcmlhLWxhYmVsPVwiJHt0aGlzLl9vcHRpb25zLmNvbmZpcm1MYWJlbH1cIlxuICAgICAgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMuYnRuQ29uZmlybX1cIj4ke3RoaXMuX29wdGlvbnMub2tUZXh0ID8gdGhpcy5fb3B0aW9ucy5va1RleHQgOiBcIk9rXCJ9PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5gO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucjAsXG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIEwoR24sIHQsIG8wKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmwwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKEduLCB0LCBhMCksIHQ7XG4gIH1cbiAgX29wZW5Qb3BvdmVyKHQpIHtcbiAgICB0aGlzLl9wb3BwZXIgPSBFZSh0aGlzLl9lbGVtZW50LCB0LCB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX3RyYW5zbGF0ZVBvc2l0aW9uVmFsdWUoKSxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCA1XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGMuYWRkQ2xhc3MoXG4gICAgICAgIHRoaXMucG9wY29uZmlybUJvZHksXG4gICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZmFkZX0gb3BhY2l0eS0xMDBgXG4gICAgICApLCB0aGlzLl9pc09wZW4gPSAhMDtcbiAgICB9LCAwKTtcbiAgfVxuICBfb3Blbk1vZGFsKHQpIHtcbiAgICBjb25zdCBlID0gRChcImRpdlwiKTtcbiAgICBlLnNldEF0dHJpYnV0ZShxYSwgXCJcIiksIGMuYWRkQ2xhc3MoZSwgdGhpcy5fY2xhc3Nlcy5iYWNrZHJvcCksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSksIGUuYXBwZW5kQ2hpbGQodCksIGMuYWRkQ2xhc3ModGhpcy5wb3Bjb25maXJtQm9keSwgXCJvcGFjaXR5LTEwMFwiKSwgdGhpcy5faXNPcGVuID0gITA7XG4gIH1cbiAgX2hhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICB0aGlzLl9jYW5jZWxCdXR0b24gPSBkLmZpbmRPbmUoXG4gICAgICBcIiNwb3Bjb25maXJtLWJ1dHRvbi1jYW5jZWxcIixcbiAgICAgIHRcbiAgICApLCBVZS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMuX2NhbmNlbEJ1dHRvbiwgeyByaXBwbGVDb2xvcjogXCJsaWdodFwiIH0pLCB0aGlzLl9jYW5jZWxCdXR0b24gIT09IG51bGwgJiYgaC5vbih0aGlzLl9jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZTApO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY29udGFpbmVyO1xuICAgIHRoaXMuX2NvbmZpcm1CdXR0b24gPSBkLmZpbmRPbmUoXG4gICAgICBcIiNwb3Bjb25maXJtLWJ1dHRvbi1jb25maXJtXCIsXG4gICAgICB0XG4gICAgKSwgVWUuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLl9jb25maXJtQnV0dG9uLCB7IHJpcHBsZUNvbG9yOiBcImxpZ2h0XCIgfSksIGgub24odGhpcy5fY29uZmlybUJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlKCksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBpMCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvRXNjYXBlS2V5KCkge1xuICAgIGgub24oZG9jdW1lbnQsIFwia2V5ZG93blwiLCB0aGlzLl9oYW5kbGVFc2NhcGVLZXkuYmluZCh0aGlzKSk7XG4gIH1cbiAgX2hhbmRsZUVzY2FwZUtleSh0KSB7XG4gICAgdC5rZXlDb2RlID09PSBMaSAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX2xpc3RlblRvT3V0c2lkZUNsaWNrKCkge1xuICAgIGgub24oZG9jdW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5faGFuZGxlT3V0c2lkZUNsaWNrLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVPdXRzaWRlQ2xpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbnRhaW5lciwgaSA9IHQudGFyZ2V0ID09PSBlLCBuID0gZSAmJiBlLmNvbnRhaW5zKHQudGFyZ2V0KSwgbyA9IHQudGFyZ2V0ID09PSB0aGlzLl9lbGVtZW50LCByID0gdGhpcy5fZWxlbWVudCAmJiB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKHQudGFyZ2V0KTtcbiAgICAhaSAmJiAhbiAmJiAhbyAmJiAhciAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX3RyYW5zbGF0ZVBvc2l0aW9uVmFsdWUoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwidG9wIGxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwidG9wLWVuZFwiO1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICByZXR1cm4gXCJ0b3BcIjtcbiAgICAgIGNhc2UgXCJ0b3AgcmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwidG9wLXN0YXJ0XCI7XG4gICAgICBjYXNlIFwiYm90dG9tIGxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tLWVuZFwiO1xuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgICAgIGNhc2UgXCJib3R0b20gcmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tLXN0YXJ0XCI7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0XCI7XG4gICAgICBjYXNlIFwibGVmdCB0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdC1lbmRcIjtcbiAgICAgIGNhc2UgXCJsZWZ0IGJvdHRvbVwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0LXN0YXJ0XCI7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwicmlnaHRcIjtcbiAgICAgIGNhc2UgXCJyaWdodCB0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwicmlnaHQtZW5kXCI7XG4gICAgICBjYXNlIFwicmlnaHQgYm90dG9tXCI6XG4gICAgICAgIHJldHVybiBcInJpZ2h0LXN0YXJ0XCI7XG4gICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgICB9XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpID0gSS5nZXREYXRhKHRoaXMsIGJpKSwgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSkge1xuICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgcmV0dXJuIG5ldyBrYyh0aGlzLCBuKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICAgIGlbdF0oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgYmkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IFpuID0gXCJsaWdodGJveFwiLCB2aSA9IFwidGUubGlnaHRib3hcIiwgYzAgPSBgLiR7dml9YCwgaDAgPSBcIi5kYXRhLWFwaVwiLCBTZSA9IGBjbGljayR7YzB9JHtoMH1gLCBPYyA9IFwiW2RhdGEtdGUtbGlnaHRib3gtaW5pdF1cIiwgZDAgPSBgJHtPY30gaW1nOm5vdChbZGF0YS10ZS1saWdodGJveC1kaXNhYmxlZF0pYCwgWmEgPSBcImRhdGEtdGUtbGlnaHRib3gtY2FwdGlvblwiLCB1MCA9IFwiZGF0YS10ZS1saWdodGJveC1kaXNhYmxlZFwiLCBTdCA9IFwiZGF0YS10ZS1saWdodGJveC1hY3RpdmVcIiwgcDAgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSAxMmgtMTVtMCAwbDYuNzUgNi43NU00LjUgMTJsNi43NS02Ljc1XCIgLz5cbjwvc3ZnPlxuYCwgXzAgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDEyaDE1bTAgMGwtNi43NS02Ljc1TTE5LjUgMTJsLTYuNzUgNi43NVwiIC8+XG48L3N2Zz5cbmAsIGYwID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0zLjc1IDMuNzV2NC41bTAtNC41aDQuNW0tNC41IDBMOSA5TTMuNzUgMjAuMjV2LTQuNW0wIDQuNWg0LjVtLTQuNSAwTDkgMTVNMjAuMjUgMy43NWgtNC41bTQuNSAwdjQuNW0wLTQuNUwxNSA5bTUuMjUgMTEuMjVoLTQuNW00LjUgMHYtNC41bTAgNC41TDE1IDE1XCIgLz5cbjwvc3ZnPlxuYCwgbTAgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTkgOVY0LjVNOSA5SDQuNU05IDlMMy43NSAzLjc1TTkgMTV2NC41TTkgMTVINC41TTkgMTVsLTUuMjUgNS4yNU0xNSA5aDQuNU0xNSA5VjQuNU0xNSA5bDUuMjUtNS4yNU0xNSAxNWg0LjVNMTUgMTV2NC41bTAtNC41bDUuMjUgNS4yNVwiIC8+XG48L3N2Zz5cbmAsIGcwID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0yMSAyMWwtNS4xOTctNS4xOTdtMCAwQTcuNSA3LjUgMCAxMDUuMTk2IDUuMTk2YTcuNSA3LjUgMCAwMDEwLjYwNyAxMC42MDd6TTEwLjUgNy41djZtMy0zaC02XCIgLz5cbjwvc3ZnPlxuYCwgYjAgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0yMSAyMWwtNS4xOTctNS4xOTdtMCAwQTcuNSA3LjUgMCAxMDUuMTk2IDUuMTk2YTcuNSA3LjUgMCAwMDEwLjYwNyAxMC42MDd6TTEzLjUgMTAuNWgtNlwiIC8+XG48L3N2Zz5cbmAsIHYwID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk02IDE4TDE4IDZNNiA2bDEyIDEyXCIgLz5cbjwvc3ZnPlxuYCwgVDAgPSB7XG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgem9vbUxldmVsOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBwcmV2SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBuZXh0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBzaG93RnVsbHNjcmVlbkljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgaGlkZUZ1bGxzY3JlZW5JY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHpvb21Jbkljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgY2xvc2VJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHpvb21PdXRJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcInN0cmluZ1wiXG59LCBFMCA9IHtcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgem9vbUxldmVsOiAxLFxuICBwcmV2SWNvblRlbXBsYXRlOiBwMCxcbiAgbmV4dEljb25UZW1wbGF0ZTogXzAsXG4gIHNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlOiBmMCxcbiAgaGlkZUZ1bGxzY3JlZW5JY29uVGVtcGxhdGU6IG0wLFxuICB6b29tSW5JY29uVGVtcGxhdGU6IGcwLFxuICB6b29tT3V0SWNvblRlbXBsYXRlOiBiMCxcbiAgY2xvc2VJY29uVGVtcGxhdGU6IHYwLFxuICBzcGlubmVyQ29udGVudDogXCJMb2FkaW5nLi4uXCJcbn0sIEMwID0ge1xuICBjYXB0aW9uOiBcInRleHQtd2hpdGUgdGV4dC1lbGxpcHNpcyBvdmVyZmxvdy1oaWRkZW4gd2hpdGVzcGFjZS1ub3dyYXAgbXgtWzEwcHhdIHRleHQtY2VudGVyXCIsXG4gIGNhcHRpb25XcmFwcGVyOiBcImZpeGVkIGxlZnQtMCBib3R0b20tMCB3LWZ1bGwgaC1bNTBweF0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgY2xvc2VCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1bNTBweF0gaC1bNTBweF0gcHgtNCB0ZXh0LVsjYjNiM2IzXSB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXQgaG92ZXI6dGV4dC13aGl0ZSBmb2N1czp0ZXh0LXdoaXRlIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG91dGxpbmUtbm9uZVwiLFxuICBmdWxsc2NyZWVuQnRuOiBcImJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHctWzUwcHhdIGgtWzUwcHhdIHB4LTQgdGV4dC1bI2IzYjNiM10gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0IGhvdmVyOnRleHQtd2hpdGUgZm9jdXM6dGV4dC13aGl0ZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBvdXRsaW5lLW5vbmVcIixcbiAgZ2FsbGVyeTogXCJpbnZpc2libGUgZml4ZWQgbGVmdC0wIHRvcC0wIHctZnVsbCBoLWZ1bGwgei1bMTEwMF0gcG9pbnRlci1ldmVudHMtbm9uZSBvcGFjaXR5LTAgYmctWyMwMDAwMDBlNl0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tWzQwMG1zXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBnYWxsZXJ5Q29udGVudDogXCJmaXhlZCB0b3AtWzUwcHhdIGxlZnQtWzUwcHhdIHctW2NhbGMoMTAwJS0xMDBweCldIGgtW2NhbGMoMTAwJS0xMDBweCldXCIsXG4gIGdhbGxlcnlDb3VudGVyOiBcImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHB4LVsxMHB4XSBtYi0wIGgtZnVsbCB0ZXh0LVsjYjNiM2IzXVwiLFxuICBpbWc6IFwiYWJzb2x1dGUgbGVmdC0wIHRvcC0wIHctZnVsbCBtYXgtaC1mdWxsIGgtYXV0byBjdXJzb3ItcG9pbnRlciBwb2ludGVyLWV2ZW50cy1hdXRvXCIsXG4gIGltZ1dyYXBwZXI6IFwiYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHctZnVsbCBoLWZ1bGwgb3BhY2l0eS0wIHRyYW5zZm9ybSBzY2FsZS1bMC4yNV0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tWzQwMG1zXSBlYXNlLW91dCBwb2ludGVyLWV2ZW50cy1ub25lIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6dHJhbnNmb3JtLW5vbmVcIixcbiAgbGVmdFRvb2xzOiBcImZsb2F0LWxlZnQgaC1mdWxsXCIsXG4gIGxvYWRlcjogXCJmaXhlZCBsZWZ0LTAgdG9wLTAgei1bMl0gdy1mdWxsIGgtZnVsbCB0ZXh0LW5ldXRyYWwtNTAgb3BhY2l0eS0xIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHBvaW50ZXItZXZlbnRzLW5vbmUgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVsxMDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIG5leHRCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1mdWxsIGgtWzUwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRleHQtWyNiM2IzYjNdIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dCBob3Zlcjp0ZXh0LXdoaXRlIGZvY3VzOnRleHQtd2hpdGUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgb3V0bGluZS1ub25lXCIsXG4gIG5leHRCdG5XcmFwcGVyOiBcImZpeGVkIHJpZ2h0LTAgdG9wLTAgdy1bNTBweF0gaC1mdWxsIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi1bNDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIHByZXZCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1mdWxsIGgtWzUwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRleHQtWyNiM2IzYjNdIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dCBob3Zlcjp0ZXh0LXdoaXRlIGZvY3VzOnRleHQtd2hpdGUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgb3V0bGluZS1ub25lXCIsXG4gIHByZXZCdG5XcmFwcGVyOiBcImZpeGVkIGxlZnQtMCB0b3AtMCB3LVs1MHB4XSBoLWZ1bGwgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVs0MDBtc10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgcmlnaHRUb29sczogXCJmbG9hdC1yaWdodFwiLFxuICBzcGlubmVyOiBcImlubGluZS1ibG9jayBoLTggdy04IGFuaW1hdGUtW3NwaW5uZXItZ3Jvd18wLjc1c19saW5lYXJfaW5maW5pdGVdIHJvdW5kZWQtZnVsbCBiZy1jdXJyZW50IGFsaWduLVstMC4xMjVlbV0gbW90aW9uLXJlZHVjZTphbmltYXRlLVtzcGlubmVyLWdyb3dfMS41c19saW5lYXJfaW5maW5pdGVdXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcIiFhYnNvbHV0ZSAhLW0tcHggIWgtcHggIXctcHggIW92ZXJmbG93LWhpZGRlbiAhd2hpdGVzcGFjZS1ub3dyYXAgIWJvcmRlci0wICFwLTAgIVtjbGlwOnJlY3QoMCwwLDAsMCldXCIsXG4gIHRvb2xiYXI6IFwiYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHctZnVsbCBoLVs1MHB4XSB6LTIwIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi1bNDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIHZlcnRpY2FsOiBcImgtZnVsbCBtYXgtaC1mdWxsIHctYXV0b1wiLFxuICB6b29tQnRuOiBcImJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHctWzUwcHhdIGgtWzUwcHhdIHB4LTQgdGV4dC1bI2IzYjNiM10gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0IGhvdmVyOnRleHQtd2hpdGUgZm9jdXM6dGV4dC13aGl0ZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBvdXRsaW5lLW5vbmVcIlxufSwgQTAgPSB7XG4gIGNhcHRpb246IFwic3RyaW5nXCIsXG4gIGNhcHRpb25XcmFwcGVyOiBcInN0cmluZ1wiLFxuICBjbG9zZUJ0bjogXCJzdHJpbmdcIixcbiAgZnVsbHNjcmVlbkJ0bjogXCJzdHJpbmdcIixcbiAgZ2FsbGVyeTogXCJzdHJpbmdcIixcbiAgZ2FsbGVyeUNvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIGdhbGxlcnlDb3VudGVyOiBcInN0cmluZ1wiLFxuICBpbWc6IFwic3RyaW5nXCIsXG4gIGltZ1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGxlZnRUb29sczogXCJzdHJpbmdcIixcbiAgbG9hZGVyOiBcInN0cmluZ1wiLFxuICBuZXh0QnRuOiBcInN0cmluZ1wiLFxuICBuZXh0QnRuV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgcHJldkJ0bjogXCJzdHJpbmdcIixcbiAgcHJldkJ0bldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHJpZ2h0VG9vbHM6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXI6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcInN0cmluZ1wiLFxuICB0b29sYmFyOiBcInN0cmluZ1wiLFxuICB2ZXJ0aWNhbDogXCJzdHJpbmdcIixcbiAgem9vbUJ0bjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIExzIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSBlLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZ2V0Q29udGFpbmVyKCksIHRoaXMuX2lkID0gYGxpZ2h0Ym94LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsIHRoaXMuX2FjdGl2ZUltZyA9IDAsIHRoaXMuX2ltYWdlcyA9IFtdLCB0aGlzLl96b29tID0gMSwgdGhpcy5fZ2FsbGVyeSA9IG51bGwsIHRoaXMuX2dhbGxlcnlUb29sYmFyID0gbnVsbCwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQgPSBudWxsLCB0aGlzLl9sb2FkZXIgPSBudWxsLCB0aGlzLl9pbWdDb3VudGVyID0gbnVsbCwgdGhpcy5fYW5pbWF0aW5nID0gITEsIHRoaXMuX2Z1bGxzY3JlZW4gPSAhMSwgdGhpcy5fem9vbUJ0biA9IG51bGwsIHRoaXMuX2Z1bGxzY3JlZW5CdG4gPSBudWxsLCB0aGlzLl90b29sc1RvZ2dsZVRpbWVyID0gMCwgdGhpcy5fbW91c2Vkb3duID0gITEsIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWCA9IDAsIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWSA9IDAsIHRoaXMuX29yaWdpbmFsUG9zaXRpb25YID0gMCwgdGhpcy5fb3JpZ2luYWxQb3NpdGlvblkgPSAwLCB0aGlzLl9wb3NpdGlvblggPSAwLCB0aGlzLl9wb3NpdGlvblkgPSAwLCB0aGlzLl96b29tVGltZXIgPSAwLCB0aGlzLl90YXBDb3VudGVyID0gMCwgdGhpcy5fdGFwVGltZSA9IDAsIHRoaXMuX3JpZ2h0QXJyb3cgPSBudWxsLCB0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyID0gbnVsbCwgdGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIgPSBudWxsLCB0aGlzLl9pbml0aWF0ZWQgPSAhMSwgdGhpcy5fbXVsdGl0b3VjaCA9ICExLCB0aGlzLl90b3VjaFpvb21Qb3NpdGlvbiA9IFtdLCB0aGlzLl9lbGVtZW50ICYmIChJLnNldERhdGEodCwgdmksIHRoaXMpLCB0aGlzLmluaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFpuO1xuICB9XG4gIGdldCBhY3RpdmVJbWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUltZztcbiAgfVxuICBnZXQgY3VycmVudEltZygpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgYFske1N0fV1gLFxuICAgICAgdGhpcy5fZ2FsbGVyeUNvbnRlbnRcbiAgICApO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICAuLi5FMCxcbiAgICAgIC4uLmMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50aGlzLl9vcHRpb25zXG4gICAgfTtcbiAgICByZXR1cm4gTChabiwgdCwgVDApLCB0O1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXRpYXRlZCB8fCAodGhpcy5fYXBwZW5kVGVtcGxhdGUoKSwgdGhpcy5faW5pdGlhdGVkID0gITApO1xuICB9XG4gIG9wZW4odCA9IDApIHtcbiAgICB0aGlzLl9nZXRJbWFnZXMoKSwgdGhpcy5fc2V0QWN0aXZlSW1nKHQpLCB0aGlzLl9zb3J0SW1hZ2VzKCksIHRoaXMuX3RyaWdnZXJFdmVudHMoXCJvcGVuXCIsIFwib3BlbmVkXCIpLCB0aGlzLl9sb2FkSW1hZ2VzKCkudGhlbigoZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzaXplSW1hZ2VzKGUpLCB0aGlzLl90b2dnbGVUZW1wbGF0ZSgpLCB0aGlzLl9hZGRFdmVudHMoKSwgdGhpcy5fZm9jdXNGdWxsc2NyZWVuQnRuKCk7XG4gICAgfSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5yZXNldCgpLCB0aGlzLl9yZW1vdmVFdmVudHMoKSwgdGhpcy5fdG9nZ2xlVGVtcGxhdGUoKSwgdGhpcy5fdHJpZ2dlckV2ZW50cyhcImNsb3NlXCIsIFwiY2xvc2VkXCIpO1xuICB9XG4gIHNsaWRlKHQgPSBcInJpZ2h0XCIpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPT09ICEwIHx8IHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSB8fCAodGhpcy5fdHJpZ2dlckV2ZW50cyhcInNsaWRlXCIsIFwic2xpZGVkXCIpLCB0aGlzLl9iZWZvcmVTbGlkZUV2ZW50cygpLCB0ID09PSBcInJpZ2h0XCIgJiYgdGhpcy5fc2xpZGVIb3Jpem9udGFsbHkodCksIHQgPT09IFwibGVmdFwiICYmIHRoaXMuX3NsaWRlSG9yaXpvbnRhbGx5KHQpLCB0ID09PSBcImZpcnN0XCIgJiYgdGhpcy5fc2xpZGVUb1RhcmdldCh0KSwgdCA9PT0gXCJsYXN0XCIgJiYgdGhpcy5fc2xpZGVUb1RhcmdldCh0KSwgdGhpcy5fYWZ0ZXJTbGlkZUV2ZW50cygpKTtcbiAgfVxuICB6b29tSW4oKSB7XG4gICAgdGhpcy5fem9vbSA+PSAzIHx8ICh0aGlzLl90cmlnZ2VyRXZlbnRzKFwiem9vbUluXCIsIFwiem9vbWVkSW5cIiksIHRoaXMuX3pvb20gKz0gcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnMuem9vbUxldmVsKSwgYy5zdHlsZSh0aGlzLmN1cnJlbnRJbWcucGFyZW50Tm9kZSwge1xuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHt0aGlzLl96b29tfSlgXG4gICAgfSksIHRoaXMuX3VwZGF0ZVpvb21CdG4oKSk7XG4gIH1cbiAgem9vbU91dCgpIHtcbiAgICB0aGlzLl96b29tIDw9IDEgfHwgKHRoaXMuX3RyaWdnZXJFdmVudHMoXCJ6b29tT3V0XCIsIFwiem9vbWVkT3V0XCIpLCB0aGlzLl96b29tIC09IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21MZXZlbCksIGMuc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7dGhpcy5fem9vbX0pYFxuICAgIH0pLCB0aGlzLl91cGRhdGVab29tQnRuKCksIHRoaXMuX3VwZGF0ZUltZ1Bvc2l0aW9uKCkpO1xuICB9XG4gIHRvZ2dsZUZ1bGxzY3JlZW4oKSB7XG4gICAgdGhpcy5fZnVsbHNjcmVlbiA9PT0gITEgPyAodGhpcy5fZnVsbHNjcmVlbkJ0bi5zZXRBdHRyaWJ1dGUoU3QsIFwiXCIpLCB0aGlzLl9mdWxsc2NyZWVuQnRuLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5oaWRlRnVsbHNjcmVlbkljb25UZW1wbGF0ZSwgdGhpcy5fZ2FsbGVyeS5yZXF1ZXN0RnVsbHNjcmVlbiAmJiB0aGlzLl9nYWxsZXJ5LnJlcXVlc3RGdWxsc2NyZWVuKCksIHRoaXMuX2Z1bGxzY3JlZW4gPSAhMCkgOiAodGhpcy5fZnVsbHNjcmVlbkJ0bi5yZW1vdmVBdHRyaWJ1dGUoU3QpLCBkb2N1bWVudC5leGl0RnVsbHNjcmVlbiAmJiBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpLCB0aGlzLl9mdWxsc2NyZWVuID0gITEpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc3RvcmVEZWZhdWx0RnVsbHNjcmVlbigpLCB0aGlzLl9yZXN0b3JlRGVmYXVsdFBvc2l0aW9uKCksIHRoaXMuX3Jlc3RvcmVEZWZhdWx0Wm9vbSgpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lciksIGNsZWFyVGltZW91dCh0aGlzLl9kb3VibGVUYXBUaW1lcik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBoLm9mZihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgU2UsXG4gICAgICBkMCxcbiAgICAgIHRoaXMudG9nZ2xlXG4gICAgKSwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQgJiYgdGhpcy5fcmVtb3ZlRXZlbnRzKCksIHRoaXMuX2dhbGxlcnkgJiYgdGhpcy5fZ2FsbGVyeS5yZW1vdmUoKSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHZpKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLkMwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKFpuLCB0LCBBMCksIHQ7XG4gIH1cbiAgX2dldEltYWdlcygpIHtcbiAgICBjb25zdCBlID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2VsZW1lbnQpLmZpbHRlcihcbiAgICAgIChpKSA9PiAhaS5oYXNBdHRyaWJ1dGUodTApXG4gICAgKTtcbiAgICB0aGlzLl9pbWFnZXMgPSBlO1xuICB9XG4gIF9nZXRDb250YWluZXIoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gZC5maW5kT25lKHRoaXMub3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9zZXRBY3RpdmVJbWcodCkge1xuICAgIHRoaXMuX2FjdGl2ZUltZyA9IHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyB0IDogdGhpcy5faW1hZ2VzLmluZGV4T2YodC50YXJnZXQpO1xuICB9XG4gIF9hcHBlbmRUZW1wbGF0ZSgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5ID0gRChcImRpdlwiKSwgYy5hZGRDbGFzcyh0aGlzLl9nYWxsZXJ5LCBgJHt0aGlzLl9jbGFzc2VzLmdhbGxlcnl9YCksIHRoaXMuX2VsZW1lbnQuZGF0YXNldC5pZCA9IHRoaXMuX2lkLCB0aGlzLl9nYWxsZXJ5LmlkID0gdGhpcy5faWQsIHRoaXMuX2FwcGVuZExvYWRlcigpLCB0aGlzLl9hcHBlbmRUb29sYmFyKCksIHRoaXMuX2FwcGVuZENvbnRlbnQoKSwgdGhpcy5fYXBwZW5kQXJyb3dzKCksIHRoaXMuX2FwcGVuZENhcHRpb24oKSwgdGhpcy5fY29udGFpbmVyLmFwcGVuZCh0aGlzLl9nYWxsZXJ5KTtcbiAgfVxuICBfYXBwZW5kVG9vbGJhcigpIHtcbiAgICB0aGlzLl9nYWxsZXJ5VG9vbGJhciA9IEQoXCJkaXZcIiksIHRoaXMuX2ltZ0NvdW50ZXIgPSBEKFwicFwiKSwgdGhpcy5fZnVsbHNjcmVlbkJ0biA9IEQoXCJidXR0b25cIiksIHRoaXMuX3pvb21CdG4gPSBEKFwiYnV0dG9uXCIpO1xuICAgIGNvbnN0IHQgPSBEKFwiYnV0dG9uXCIpLCBlID0gRChcImRpdlwiKSwgaSA9IEQoXCJkaXZcIik7XG4gICAgYy5hZGRDbGFzcyh0aGlzLl9nYWxsZXJ5VG9vbGJhciwgYCR7dGhpcy5fY2xhc3Nlcy50b29sYmFyfWApLCBjLmFkZENsYXNzKHRoaXMuX2ltZ0NvdW50ZXIsIGAke3RoaXMuX2NsYXNzZXMuZ2FsbGVyeUNvdW50ZXJ9YCksIGMuYWRkQ2xhc3ModGhpcy5fZnVsbHNjcmVlbkJ0biwgYCR7dGhpcy5fY2xhc3Nlcy5mdWxsc2NyZWVuQnRufWApLCBjLmFkZENsYXNzKHRoaXMuX3pvb21CdG4sIGAke3RoaXMuX2NsYXNzZXMuem9vbUluQnRufWApLCBjLmFkZENsYXNzKHRoaXMuX3pvb21CdG4sIHRoaXMuX2NsYXNzZXMuem9vbUJ0biksIGMuYWRkQ2xhc3MoZSwgYCR7dGhpcy5fY2xhc3Nlcy5sZWZ0VG9vbHN9YCksIGMuYWRkQ2xhc3MoaSwgYCR7dGhpcy5fY2xhc3Nlcy5yaWdodFRvb2xzfWApLCBjLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuY2xvc2VCdG59YCksIHRoaXMuX2Z1bGxzY3JlZW5CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlLCB0LmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5jbG9zZUljb25UZW1wbGF0ZSwgdGhpcy5fem9vbUJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuem9vbUluSWNvblRlbXBsYXRlLCB0aGlzLl9mdWxsc2NyZWVuQnRuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJUb2dnbGUgZnVsbHNjcmVlblwiKSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBpblwiKSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiQ2xvc2VcIiksIGgub24oXG4gICAgICB0aGlzLl9mdWxsc2NyZWVuQnRuLFxuICAgICAgU2UsXG4gICAgICAoKSA9PiB0aGlzLnRvZ2dsZUZ1bGxzY3JlZW4oKVxuICAgICksIGgub24oXG4gICAgICB0aGlzLl96b29tQnRuLFxuICAgICAgU2UsXG4gICAgICAoKSA9PiB0aGlzLl90b2dnbGVab29tKClcbiAgICApLCBoLm9uKHQsIFNlLCAoKSA9PiB0aGlzLmNsb3NlKCkpLCBlLmFwcGVuZCh0aGlzLl9pbWdDb3VudGVyKSwgaS5hcHBlbmQodGhpcy5fZnVsbHNjcmVlbkJ0biksIGkuYXBwZW5kKHRoaXMuX3pvb21CdG4pLCBpLmFwcGVuZCh0KSwgdGhpcy5fZ2FsbGVyeVRvb2xiYXIuYXBwZW5kKGUpLCB0aGlzLl9nYWxsZXJ5VG9vbGJhci5hcHBlbmQoaSksIHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2dhbGxlcnlUb29sYmFyKTtcbiAgfVxuICBfYXBwZW5kQ29udGVudCgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5Q29udGVudCA9IEQoXCJkaXZcIiksIGMuYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9nYWxsZXJ5Q29udGVudCxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMuZ2FsbGVyeUNvbnRlbnR9YFxuICAgICksIHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2dhbGxlcnlDb250ZW50KTtcbiAgfVxuICBfYXBwZW5kTG9hZGVyKCkge1xuICAgIHRoaXMuX2xvYWRlciA9IEQoXCJkaXZcIik7XG4gICAgY29uc3QgdCA9IEQoXCJkaXZcIiksIGUgPSBEKFwic3BhblwiKTtcbiAgICBjLmFkZENsYXNzKHRoaXMuX2xvYWRlciwgYCR7dGhpcy5fY2xhc3Nlcy5sb2FkZXJ9YCksIGMuYWRkQ2xhc3ModCwgYCR7dGhpcy5fY2xhc3Nlcy5zcGlubmVyfWApLCBjLmFkZENsYXNzKGUsIGAke3RoaXMuX2NsYXNzZXMuc3Bpbm5lckNvbnRlbnR9YCksIHQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInN0YXR1c1wiKSwgZS5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuc3Bpbm5lckNvbnRlbnQsIHQuYXBwZW5kKGUpLCB0aGlzLl9sb2FkZXIuYXBwZW5kKHQpLCB0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0aGlzLl9sb2FkZXIpO1xuICB9XG4gIF9hcHBlbmRBcnJvd3MoKSB7XG4gICAgdGhpcy5fbGVmdEFycm93V3JhcHBlciA9IEQoXCJkaXZcIiksIGMuYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5wcmV2QnRuV3JhcHBlcn1gXG4gICAgKTtcbiAgICBjb25zdCB0ID0gRChcImJ1dHRvblwiKTtcbiAgICB0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJQcmV2aW91c1wiKSwgYy5hZGRDbGFzcyh0LCBgJHt0aGlzLl9jbGFzc2VzLnByZXZCdG59YCksIGgub24odCwgU2UsICgpID0+IHRoaXMuc2xpZGUoXCJsZWZ0XCIpKSwgdGhpcy5fbGVmdEFycm93V3JhcHBlci5hcHBlbmQodCksIHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyID0gRChcImRpdlwiKSwgYy5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5uZXh0QnRuV3JhcHBlcn1gXG4gICAgKSwgdGhpcy5fcmlnaHRBcnJvdyA9IEQoXCJidXR0b25cIiksIHRoaXMuX3JpZ2h0QXJyb3cuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIk5leHRcIiksIGMuYWRkQ2xhc3ModGhpcy5fcmlnaHRBcnJvdywgYCR7dGhpcy5fY2xhc3Nlcy5uZXh0QnRufWApLCBoLm9uKHRoaXMuX3JpZ2h0QXJyb3csIFNlLCAoKSA9PiB0aGlzLnNsaWRlKCkpLCB0aGlzLl9yaWdodEFycm93V3JhcHBlci5hcHBlbmQodGhpcy5fcmlnaHRBcnJvdyksIHRoaXMuX3JpZ2h0QXJyb3cuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLm5leHRJY29uVGVtcGxhdGUsIHQuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnByZXZJY29uVGVtcGxhdGUsIHRoaXMuX2dldEltYWdlcygpLCAhKHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSkgJiYgKHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2xlZnRBcnJvd1dyYXBwZXIpLCB0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0aGlzLl9yaWdodEFycm93V3JhcHBlcikpO1xuICB9XG4gIF9hcHBlbmRDYXB0aW9uKCkge1xuICAgIGNvbnN0IHQgPSBEKFwiZGl2XCIpLCBlID0gRChcInBcIik7XG4gICAgZS5zZXRBdHRyaWJ1dGUoWmEsIFwiXCIpLCBjLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuY2FwdGlvbldyYXBwZXJ9YCksIGMuYWRkQ2xhc3MoZSwgYCR7dGhpcy5fY2xhc3Nlcy5jYXB0aW9ufWApLCB0LmFwcGVuZChlKSwgdGhpcy5fZ2FsbGVyeS5hcHBlbmQodCk7XG4gIH1cbiAgX3NvcnRJbWFnZXMoKSB7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLl9hY3RpdmVJbWc7IHQrKylcbiAgICAgIHRoaXMuX2ltYWdlcy5wdXNoKHRoaXMuX2ltYWdlcy5zaGlmdCgpKTtcbiAgfVxuICBhc3luYyBfbG9hZEltYWdlcygpIHtcbiAgICBjb25zdCB0ID0gW10sIGUgPSBbXTtcbiAgICB0aGlzLl9nYWxsZXJ5Q29udGVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VzLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIHQucHVzaChcbiAgICAgICAgbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICAgICAgICBjb25zdCBhID0gbmV3IEltYWdlKCksIGwgPSBEKFwiZGl2XCIpO1xuICAgICAgICAgIGMuYWRkQ2xhc3MobCwgYCR7dGhpcy5fY2xhc3Nlcy5pbWdXcmFwcGVyfWApLCBjLmFkZENsYXNzKGEsIGAke3RoaXMuX2NsYXNzZXMuaW1nfWApLCB0aGlzLl9hZGRJbWdTdHlsZXMoYSwgbCwgaSwgbywgbiksIGwuYXBwZW5kKGEpLCB0aGlzLl9nYWxsZXJ5Q29udGVudC5hcHBlbmQobCksIGEub25sb2FkID0gciwgYS5zcmMgPSBuLmRhdGFzZXQudGVJbWcgfHwgbi5zcmMsIGUucHVzaChhKSwgaSArPSAxMDA7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pLCBhd2FpdCBQcm9taXNlLmFsbCh0KSwgZTtcbiAgfVxuICBfYWRkSW1nU3R5bGVzKHQsIGUsIGksIG4sIG8pIHtcbiAgICB0LmFsdCA9IG8uYWx0LCB0LmRyYWdnYWJsZSA9ICExLCBjLnN0eWxlKGUsIHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICBsZWZ0OiBgJHtpfSVgLFxuICAgICAgdG9wOiAwXG4gICAgfSksIChvLmRhdGFzZXQudGVDYXB0aW9uIHx8IG8uZGF0YXNldC50ZUNhcHRpb24gPT09IFwiXCIpICYmICh0LmRhdGFzZXQuY2FwdGlvbiA9IG8uZGF0YXNldC50ZUNhcHRpb24pLCBpID09PSAwID8gKG8ud2lkdGggPCBvLmhlaWdodCAmJiBjLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMudmVydGljYWx9YCksIGMuc3R5bGUoZSwgeyBvcGFjaXR5OiAxIH0pLCB0LnNldEF0dHJpYnV0ZShTdCwgXCJcIikpIDogdC5yZW1vdmVBdHRyaWJ1dGUoU3QpLCBuID09PSB0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSAmJiB0aGlzLl9pbWFnZXMubGVuZ3RoID4gMSAmJiBjLnN0eWxlKGUsIHsgbGVmdDogXCItMTAwJVwiIH0pO1xuICB9XG4gIF9yZXNpemVJbWFnZXModCkge1xuICAgIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5fY2FsY3VsYXRlSW1nU2l6ZShlKTtcbiAgICB9KTtcbiAgfVxuICBfY2FsY3VsYXRlSW1nU2l6ZSh0KSB7XG4gICAgdC53aWR0aCA+PSB0LmhlaWdodCA/ICh0LnN0eWxlLndpZHRoID0gXCIxMDAlXCIsIHQuc3R5bGUubWF4V2lkdGggPSBcIjEwMCVcIiwgdC5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIiwgdC5zdHlsZS50b3AgPSBgJHsodC5wYXJlbnROb2RlLm9mZnNldEhlaWdodCAtIHQuaGVpZ2h0KSAvIDJ9cHhgLCB0LnN0eWxlLmxlZnQgPSAwKSA6ICh0LnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiLCB0LnN0eWxlLm1heEhlaWdodCA9IFwiMTAwJVwiLCB0LnN0eWxlLndpZHRoID0gXCJhdXRvXCIsIHQuc3R5bGUubGVmdCA9IGAkeyh0LnBhcmVudE5vZGUub2Zmc2V0V2lkdGggLSB0LndpZHRoKSAvIDJ9cHhgLCB0LnN0eWxlLnRvcCA9IDApLCB0LndpZHRoID49IHQucGFyZW50Tm9kZS5vZmZzZXRXaWR0aCAmJiAodC5zdHlsZS53aWR0aCA9IGAke3QucGFyZW50Tm9kZS5vZmZzZXRXaWR0aH1weGAsIHQuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCIsIHQuc3R5bGUubGVmdCA9IDAsIHQuc3R5bGUudG9wID0gYCR7KHQucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQgLSB0LmhlaWdodCkgLyAyfXB4YCksIHQuaGVpZ2h0ID49IHQucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQgJiYgKHQuc3R5bGUuaGVpZ2h0ID0gYCR7dC5wYXJlbnROb2RlLm9mZnNldEhlaWdodH1weGAsIHQuc3R5bGUud2lkdGggPSBcImF1dG9cIiwgdC5zdHlsZS50b3AgPSAwLCB0LnN0eWxlLmxlZnQgPSBgJHsodC5wYXJlbnROb2RlLm9mZnNldFdpZHRoIC0gdC53aWR0aCkgLyAyfXB4YCksIHRoaXMuX3Bvc2l0aW9uWCA9IHBhcnNlRmxvYXQodC5zdHlsZS5sZWZ0KSB8fCAwLCB0aGlzLl9wb3NpdGlvblkgPSBwYXJzZUZsb2F0KHQuc3R5bGUudG9wKSB8fCAwO1xuICB9XG4gIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLl9pbWFnZXMgPSBkLmZpbmQoXCJpbWdcIiwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQpLCB0aGlzLl9pbWFnZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpcy5fY2FsY3VsYXRlSW1nU2l6ZSh0KTtcbiAgICB9KTtcbiAgfVxuICBfb25GdWxsc2NyZWVuQ2hhbmdlKCkge1xuICAgIChkb2N1bWVudC53ZWJraXRJc0Z1bGxTY3JlZW4gfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbiB8fCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50KSA9PT0gdm9pZCAwICYmICh0aGlzLl9mdWxsc2NyZWVuID0gITEsIHRoaXMuX2Z1bGxzY3JlZW5CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlLCB0aGlzLl9mdWxsc2NyZWVuQnRuLnJlbW92ZUF0dHJpYnV0ZShTdCkpO1xuICB9XG4gIF9iZWZvcmVTbGlkZUV2ZW50cygpIHtcbiAgICB0aGlzLl9hbmltYXRpb25TdGFydCgpLCB0aGlzLl9yZXN0b3JlRGVmYXVsdFpvb20oKSwgdGhpcy5fcmVzdG9yZURlZmF1bHRQb3NpdGlvbigpLCB0aGlzLl9yZXNldERvdWJsZVRhcCgpO1xuICB9XG4gIF9zbGlkZUhvcml6b250YWxseSh0KSB7XG4gICAgdGhpcy5faW1hZ2VzID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2dhbGxlcnlDb250ZW50KSwgdGhpcy5faW1hZ2VzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGxldCBpO1xuICAgICAgdCA9PT0gXCJyaWdodFwiID8gKGkgPSBwYXJzZUludChlLnBhcmVudE5vZGUuc3R5bGUubGVmdCwgMTApIC0gMTAwLCBpIDwgLTEwMCAmJiAoaSA9ICh0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMikgKiAxMDApKSA6IChpID0gcGFyc2VJbnQoZS5wYXJlbnROb2RlLnN0eWxlLmxlZnQsIDEwKSArIDEwMCwgaSA9PT0gKHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxKSAqIDEwMCAmJiAoaSA9IC0xMDApKSwgdGhpcy5fc2xpZGVJbWcoZSwgaSk7XG4gICAgfSksIHRoaXMuX3VwZGF0ZUFjdGl2ZUltZyh0KTtcbiAgfVxuICBfc2xpZGVJbWcodCwgZSkge1xuICAgIGUgPT09IDAgPyAodC5zZXRBdHRyaWJ1dGUoU3QsIFwiXCIpLCBjLnN0eWxlKHQucGFyZW50Tm9kZSwgeyBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIiB9KSkgOiAodC5yZW1vdmVBdHRyaWJ1dGUoU3QpLCBjLnN0eWxlKHQucGFyZW50Tm9kZSwge1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiXG4gICAgfSkpLCB0LnBhcmVudE5vZGUuc3R5bGUubGVmdCA9IGAke2V9JWA7XG4gIH1cbiAgX3NsaWRlVG9UYXJnZXQodCkge1xuICAgIHQgPT09IFwiZmlyc3RcIiAmJiB0aGlzLl9hY3RpdmVJbWcgPT09IDAgfHwgdCA9PT0gXCJsYXN0XCIgJiYgdGhpcy5fYWN0aXZlSW1nID09PSB0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSB8fCAodGhpcy5yZXNldCgpLCB0aGlzLl9yZW1vdmVFdmVudHMoKSwgdGhpcy5fc2hvd0xvYWRlcigpLCB0aGlzLl9nZXRJbWFnZXMoKSwgdGhpcy5fYWN0aXZlSW1nID0gdCA9PT0gXCJmaXJzdFwiID8gMCA6IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxLCB0aGlzLl9zb3J0SW1hZ2VzKCksIGMuc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiLFxuICAgICAgb3BhY2l0eTogMFxuICAgIH0pLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2xvYWRJbWFnZXMoKS50aGVuKChlKSA9PiB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUltYWdlcyhlKSwgdGhpcy5fYWRkRXZlbnRzKCksIHRoaXMuX3VwZGF0ZUNhcHRpb24oKSwgdGhpcy5faGlkZUxvYWRlcigpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIixcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgfSk7XG4gICAgfSwgNDAwKSk7XG4gIH1cbiAgX3VwZGF0ZUFjdGl2ZUltZyh0KSB7XG4gICAgdCA9PT0gXCJyaWdodFwiICYmICh0aGlzLl9hY3RpdmVJbWcgPT09IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxID8gdGhpcy5fYWN0aXZlSW1nID0gMCA6IHRoaXMuX2FjdGl2ZUltZysrKSwgdCA9PT0gXCJsZWZ0XCIgJiYgKHRoaXMuX2FjdGl2ZUltZyA9PT0gMCA/IHRoaXMuX2FjdGl2ZUltZyA9IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxIDogdGhpcy5fYWN0aXZlSW1nLS0pO1xuICB9XG4gIF9hZnRlclNsaWRlRXZlbnRzKCkge1xuICAgIHRoaXMuX3VwZGF0ZUNvdW50ZXIoKSwgdGhpcy5fdXBkYXRlQ2FwdGlvbigpO1xuICB9XG4gIF91cGRhdGVDb3VudGVyKCkge1xuICAgIHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSB8fCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2ltZ0NvdW50ZXIuaW5uZXJIVE1MID0gYCR7dGhpcy5fYWN0aXZlSW1nICsgMX0gLyAke3RoaXMuX2ltYWdlcy5sZW5ndGh9YDtcbiAgICB9LCAyMDApO1xuICB9XG4gIF91cGRhdGVDYXB0aW9uKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbGV0IHQgPSB0aGlzLmN1cnJlbnRJbWcuYWx0O1xuICAgICAgKHRoaXMuY3VycmVudEltZy5kYXRhc2V0LmNhcHRpb24gfHwgdGhpcy5jdXJyZW50SW1nLmRhdGFzZXQuY2FwdGlvbiA9PT0gXCJcIikgJiYgKHQgPSB0aGlzLmN1cnJlbnRJbWcuZGF0YXNldC5jYXB0aW9uKSwgZC5maW5kT25lKFxuICAgICAgICBgWyR7WmF9XWAsXG4gICAgICAgIHRoaXMuX2dhbGxlcnlcbiAgICAgICkuaW5uZXJIVE1MID0gdDtcbiAgICB9LCAyMDApO1xuICB9XG4gIF90b2dnbGVUZW1wbGF0ZSgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5LnN0eWxlLnZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiID8gKGMuc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiXG4gICAgfSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faGlkZUdhbGxlcnkoKSwgdGhpcy5fZW5hYmxlU2Nyb2xsKCksIHRoaXMuX3Nob3dMb2FkZXIoKTtcbiAgICB9LCAxMDApKSA6ICh0aGlzLl9zaG93R2FsbGVyeSgpLCB0aGlzLl9kaXNhYmxlU2Nyb2xsKCksIHRoaXMuX3VwZGF0ZUNvdW50ZXIoKSwgdGhpcy5fdXBkYXRlQ2FwdGlvbigpLCB0aGlzLl9zZXRUb29sc1RvZ2dsZVRpbW91dCgpLCB0aGlzLl9oaWRlTG9hZGVyKCkpO1xuICB9XG4gIF9zaG93TG9hZGVyKCkge1xuICAgIGMuc3R5bGUodGhpcy5fbG9hZGVyLCB7IG9wYWNpdHk6IDEgfSk7XG4gIH1cbiAgX2hpZGVMb2FkZXIoKSB7XG4gICAgYy5zdHlsZSh0aGlzLl9sb2FkZXIsIHsgb3BhY2l0eTogMCB9KTtcbiAgfVxuICBfaGlkZUdhbGxlcnkoKSB7XG4gICAgYy5zdHlsZSh0aGlzLl9nYWxsZXJ5LCB7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiXG4gICAgfSk7XG4gIH1cbiAgX3Nob3dHYWxsZXJ5KCkge1xuICAgIGMuc3R5bGUodGhpcy5fZ2FsbGVyeSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwiaW5pdGlhbFwiLFxuICAgICAgdmlzaWJpbGl0eTogXCJ2aXNpYmxlXCJcbiAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7IHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiIH0pO1xuICAgIH0sIDUwKTtcbiAgfVxuICBfdG9nZ2xlWm9vbSgpIHtcbiAgICB0aGlzLl96b29tICE9PSAxID8gdGhpcy56b29tT3V0KCkgOiB0aGlzLnpvb21JbigpO1xuICB9XG4gIF91cGRhdGVab29tQnRuKCkge1xuICAgIHRoaXMuX3pvb20gPiAxID8gKHRoaXMuX3pvb21CdG4uc2V0QXR0cmlidXRlKFN0LCBcIlwiKSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBvdXRcIiksIHRoaXMuX3pvb21CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnpvb21PdXRJY29uVGVtcGxhdGUpIDogKHRoaXMuX3pvb21CdG4ucmVtb3ZlQXR0cmlidXRlKFN0KSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBpblwiKSwgdGhpcy5fem9vbUJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuem9vbUluSWNvblRlbXBsYXRlKTtcbiAgfVxuICBfdXBkYXRlSW1nUG9zaXRpb24oKSB7XG4gICAgdGhpcy5fem9vbSA9PT0gMSAmJiB0aGlzLl9yZXN0b3JlRGVmYXVsdFBvc2l0aW9uKCk7XG4gIH1cbiAgX2FkZEV2ZW50cygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2dhbGxlcnlDb250ZW50KTtcbiAgICB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSA9IHRoaXMuX29uV2luZG93VG91Y2htb3ZlLmJpbmQodGhpcyksIHRoaXMuX29uV2luZG93VG91Y2hzdGFydCA9IHRoaXMuX29uV2luZG93VG91Y2hzdGFydC5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ01vdXNlZG93biA9IHRoaXMuX29uTW91c2Vkb3duLmJpbmQodGhpcyksIHRoaXMuX29uSW1nTW91c2Vtb3ZlID0gdGhpcy5fb25Nb3VzZW1vdmUuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdXaGVlbCA9IHRoaXMuX29uWm9vbS5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ01vdXNldXAgPSB0aGlzLl9vbk1vdXNldXAuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdUb3VjaGVuZCA9IHRoaXMuX29uVG91Y2hlbmQuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdEb3VibGVDbGljayA9IHRoaXMuX29uRG91YmxlQ2xpY2suYmluZCh0aGlzKSwgdGhpcy5fb25XaW5kb3dSZXNpemUgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpLCB0aGlzLl9vbldpbmRvd0Z1bGxzY3JlZW5DaGFuZ2UgPSB0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UuYmluZCh0aGlzKSwgdGhpcy5fb25BbnlJbWdBY3Rpb24gPSB0aGlzLl9yZXNldFRvb2xzVG9nZ2xlci5iaW5kKHRoaXMpLCB0aGlzLl9vbkdhbGxlcnlDbGljayA9IHRoaXMuX29uQmFja2Ryb3BDbGljay5iaW5kKHRoaXMpLCB0aGlzLl9vbktleXVwRXZlbnQgPSB0aGlzLl9vbktleXVwLmJpbmQodGhpcyksIHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd25FdmVudCA9IHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd24uYmluZCh0aGlzKSwgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50ID0gdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bi5iaW5kKHRoaXMpLCB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgIGgub24oZSwgXCJtb3VzZWRvd25cIiwgdGhpcy5fb25JbWdNb3VzZWRvd24sIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH0pLCBoLm9uKGUsIFwidG91Y2hzdGFydFwiLCB0aGlzLl9vbkltZ01vdXNlZG93biwge1xuICAgICAgICBwYXNzaXZlOiAhMFxuICAgICAgfSksIGgub24oZSwgXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25JbWdNb3VzZW1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH0pLCBoLm9uKGUsIFwidG91Y2htb3ZlXCIsIHRoaXMuX29uSW1nTW91c2Vtb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9KSwgaC5vbihlLCBcIndoZWVsXCIsIHRoaXMuX29uSW1nV2hlZWwsIHsgcGFzc2l2ZTogITAgfSksIGgub24oZSwgXCJkYmxjbGlja1wiLCB0aGlzLl9vbkltZ0RvdWJsZUNsaWNrLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9KTtcbiAgICB9KSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSwge1xuICAgICAgcGFzc2l2ZTogITFcbiAgICB9KSwgaC5vbih3aW5kb3csIFwidG91Y2hzdGFydFwiLCB0aGlzLl9vbldpbmRvd1RvdWNoc3RhcnQpLCBoLm9uKHdpbmRvdywgXCJtb3VzZXVwXCIsIHRoaXMuX29uSW1nTW91c2V1cCksIGgub24od2luZG93LCBcInRvdWNoZW5kXCIsIHRoaXMuX29uSW1nVG91Y2hlbmQpLCBoLm9uKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUpLCBoLm9uKHdpbmRvdywgXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSksIGgub24od2luZG93LCBcImtleXVwXCIsIHRoaXMuX29uS2V5dXBFdmVudCksIGgub24od2luZG93LCBcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgdGhpcy5fb25XaW5kb3dGdWxsc2NyZWVuQ2hhbmdlKSwgaC5vbih0aGlzLl9nYWxsZXJ5LCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkFueUltZ0FjdGlvbiksIGgub24odGhpcy5fZ2FsbGVyeSwgXCJjbGlja1wiLCB0aGlzLl9vbkdhbGxlcnlDbGljayksIGgub24oXG4gICAgICB0aGlzLl9yaWdodEFycm93LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICB0aGlzLl9vblJpZ2h0QXJyb3dLZXlkb3duRXZlbnRcbiAgICApLCBoLm9uKFxuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bixcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50XG4gICAgKTtcbiAgfVxuICBfcmVtb3ZlRXZlbnRzKCkge1xuICAgIGQuZmluZChcImltZ1wiLCB0aGlzLl9nYWxsZXJ5Q29udGVudCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaC5vZmYoZSwgXCJtb3VzZWRvd25cIiwgdGhpcy5fb25JbWdNb3VzZWRvd24pLCBoLm9mZihlLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25JbWdNb3VzZWRvd24pLCBoLm9mZihlLCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkltZ01vdXNlbW92ZSksIGgub2ZmKGUsIFwidG91Y2htb3ZlXCIsIHRoaXMuX29uSW1nTW91c2Vtb3ZlKSwgaC5vZmYoZSwgXCJ3aGVlbFwiLCB0aGlzLl9vbkltZ1doZWVsKSwgaC5vZmYoZSwgXCJkYmxjbGlja1wiLCB0aGlzLl9vbkltZ0RvdWJsZUNsaWNrKTtcbiAgICB9KSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSwge1xuICAgICAgcGFzc2l2ZTogITFcbiAgICB9KSwgaC5vZmYod2luZG93LCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25XaW5kb3dUb3VjaHN0YXJ0KSwgaC5vZmYod2luZG93LCBcIm1vdXNldXBcIiwgdGhpcy5fb25JbWdNb3VzZXVwKSwgaC5vZmYod2luZG93LCBcInRvdWNoZW5kXCIsIHRoaXMuX29uSW1nVG91Y2hlbmQpLCBoLm9mZih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX29uV2luZG93UmVzaXplKSwgaC5vZmYod2luZG93LCBcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29uV2luZG93UmVzaXplKSwgaC5vZmYod2luZG93LCBcImtleXVwXCIsIHRoaXMuX29uS2V5dXBFdmVudCksIGgub2ZmKFxuICAgICAgd2luZG93LFxuICAgICAgXCJmdWxsc2NyZWVuY2hhbmdlXCIsXG4gICAgICB0aGlzLl9vbldpbmRvd0Z1bGxzY3JlZW5DaGFuZ2VcbiAgICApLCBoLm9mZih0aGlzLl9nYWxsZXJ5LCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkFueUltZ0FjdGlvbiksIGgub2ZmKHRoaXMuX2dhbGxlcnksIFwiY2xpY2tcIiwgdGhpcy5fb25HYWxsZXJ5Q2xpY2spLCBoLm9mZihcbiAgICAgIHRoaXMuX3JpZ2h0QXJyb3csXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd25FdmVudFxuICAgICksIGgub2ZmKFxuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bixcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50XG4gICAgKTtcbiAgfVxuICBfb25Nb3VzZWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0LnRvdWNoZXMsIGkgPSBlID8gZVswXS5jbGllbnRYIDogdC5jbGllbnRYLCBuID0gZSA/IGVbMF0uY2xpZW50WSA6IHQuY2xpZW50WTtcbiAgICB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWCA9IHBhcnNlRmxvYXQodGhpcy5jdXJyZW50SW1nLnN0eWxlLmxlZnQpIHx8IDAsIHRoaXMuX29yaWdpbmFsUG9zaXRpb25ZID0gcGFyc2VGbG9hdCh0aGlzLmN1cnJlbnRJbWcuc3R5bGUudG9wKSB8fCAwLCB0aGlzLl9wb3NpdGlvblggPSB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWCwgdGhpcy5fcG9zaXRpb25ZID0gdGhpcy5fb3JpZ2luYWxQb3NpdGlvblksIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWCA9IGkgKiAoMSAvIHRoaXMuX3pvb20pIC0gdGhpcy5fcG9zaXRpb25YLCB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblkgPSBuICogKDEgLyB0aGlzLl96b29tKSAtIHRoaXMuX3Bvc2l0aW9uWSwgdGhpcy5fbW91c2Vkb3duID0gITAsIHQudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgJiYgdC50b3VjaGVzLmxlbmd0aCA+IDEgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMCwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSB0LnRvdWNoZXMpO1xuICB9XG4gIF9vbk1vdXNlbW92ZSh0KSB7XG4gICAgaWYgKCF0aGlzLl9tb3VzZWRvd24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHQudG91Y2hlcywgaSA9IGUgPyBlWzBdLmNsaWVudFggOiB0LmNsaWVudFgsIG4gPSBlID8gZVswXS5jbGllbnRZIDogdC5jbGllbnRZO1xuICAgIGlmIChlICYmIHRoaXMuX3Jlc2V0VG9vbHNUb2dnbGVyKCksICF0aGlzLl9tdWx0aXRvdWNoKVxuICAgICAgaWYgKHRoaXMuX3pvb20gIT09IDEpXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uWCA9IGkgKiAoMSAvIHRoaXMuX3pvb20pIC0gdGhpcy5fbW91c2Vkb3duUG9zaXRpb25YLCB0aGlzLl9wb3NpdGlvblkgPSBuICogKDEgLyB0aGlzLl96b29tKSAtIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWSwgYy5zdHlsZSh0aGlzLmN1cnJlbnRJbWcsIHtcbiAgICAgICAgICBsZWZ0OiBgJHt0aGlzLl9wb3NpdGlvblh9cHhgLFxuICAgICAgICAgIHRvcDogYCR7dGhpcy5fcG9zaXRpb25ZfXB4YFxuICAgICAgICB9KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5faW1hZ2VzLmxlbmd0aCA8PSAxKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25YID0gaSAqICgxIC8gdGhpcy5fem9vbSkgLSB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblgsIGMuc3R5bGUodGhpcy5jdXJyZW50SW1nLCB7IGxlZnQ6IGAke3RoaXMuX3Bvc2l0aW9uWH1weGAgfSk7XG4gICAgICB9XG4gIH1cbiAgX29uTW91c2V1cCh0KSB7XG4gICAgdGhpcy5fbW91c2Vkb3duID0gITEsIHRoaXMuX21vdmVJbWcodC50YXJnZXQpO1xuICB9XG4gIF9vblRvdWNoZW5kKHQpIHtcbiAgICB0aGlzLl9tb3VzZWRvd24gPSAhMSwgdGhpcy5fbXVsdGl0b3VjaCA/IHQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDAgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMSwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSBbXSkgOiB0aGlzLl9tdWx0aXRvdWNoIHx8ICh0aGlzLl9jaGVja0RvdWJsZVRhcCh0KSwgdGhpcy5fbW92ZUltZyh0LnRhcmdldCkpO1xuICB9XG4gIF9jYWxjdWxhdGVUb3VjaFpvb20odCkge1xuICAgIGNvbnN0IGUgPSBNYXRoLmh5cG90KFxuICAgICAgdGhpcy5fdG91Y2hab29tUG9zaXRpb25bMV0ucGFnZVggLSB0aGlzLl90b3VjaFpvb21Qb3NpdGlvblswXS5wYWdlWCxcbiAgICAgIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uWzFdLnBhZ2VZIC0gdGhpcy5fdG91Y2hab29tUG9zaXRpb25bMF0ucGFnZVlcbiAgICApLCBpID0gTWF0aC5oeXBvdChcbiAgICAgIHQudG91Y2hlc1sxXS5wYWdlWCAtIHQudG91Y2hlc1swXS5wYWdlWCxcbiAgICAgIHQudG91Y2hlc1sxXS5wYWdlWSAtIHQudG91Y2hlc1swXS5wYWdlWVxuICAgICksIG4gPSBNYXRoLmFicyhlIC0gaSksIG8gPSB0LnZpZXcuc2NyZWVuLndpZHRoO1xuICAgIG4gPiBvICogMC4wMyAmJiAoZSA8PSBpID8gdGhpcy56b29tSW4oKSA6IHRoaXMuem9vbU91dCgpLCB0aGlzLl90b3VjaFpvb21Qb3NpdGlvbiA9IHQudG91Y2hlcyk7XG4gIH1cbiAgX29uV2luZG93VG91Y2hzdGFydCh0KSB7XG4gICAgdC50b3VjaGVzLmxlbmd0aCA+IDEgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMCwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSB0LnRvdWNoZXMpO1xuICB9XG4gIF9vbldpbmRvd1RvdWNobW92ZSh0KSB7XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgdC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEgJiYgdGhpcy5fY2FsY3VsYXRlVG91Y2hab29tKHQpO1xuICB9XG4gIF9vblJpZ2h0QXJyb3dLZXlkb3duKHQpIHtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSA5OlxuICAgICAgICBpZiAodC5zaGlmdEtleSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9mb2N1c0Z1bGxzY3JlZW5CdG4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIF9vbkZ1bGxzY3JlZW5CdG5LZXlkb3duKHQpIHtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSA5OlxuICAgICAgICBpZiAoIXQuc2hpZnRLZXkpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fZm9jdXNSaWdodEFycm93KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfb25LZXl1cCh0KSB7XG4gICAgc3dpdGNoICh0aGlzLl9yZXNldFRvb2xzVG9nZ2xlcigpLCB0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIHRoaXMuc2xpZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM3OlxuICAgICAgICB0aGlzLnNsaWRlKFwibGVmdFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3OlxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzNjpcbiAgICAgICAgdGhpcy5zbGlkZShcImZpcnN0XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzU6XG4gICAgICAgIHRoaXMuc2xpZGUoXCJsYXN0XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHRoaXMuem9vbUluKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0MDpcbiAgICAgICAgdGhpcy56b29tT3V0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfZm9jdXNGdWxsc2NyZWVuQnRuKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bi5mb2N1cygpO1xuICAgIH0sIDEwMCk7XG4gIH1cbiAgX2ZvY3VzUmlnaHRBcnJvdygpIHtcbiAgICB0aGlzLl9yaWdodEFycm93LmZvY3VzKCk7XG4gIH1cbiAgX21vdmVJbWcodCkge1xuICAgIGlmICh0aGlzLl9tdWx0aXRvdWNoIHx8IHRoaXMuX3pvb20gIT09IDEgfHwgdCAhPT0gdGhpcy5jdXJyZW50SW1nIHx8IHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fcG9zaXRpb25YIC0gdGhpcy5fb3JpZ2luYWxQb3NpdGlvblg7XG4gICAgZSA+IDAgPyB0aGlzLnNsaWRlKFwibGVmdFwiKSA6IGUgPCAwICYmIHRoaXMuc2xpZGUoKTtcbiAgfVxuICBfY2hlY2tEb3VibGVUYXAodCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kb3VibGVUYXBUaW1lcik7XG4gICAgY29uc3QgaSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdGhpcy5fdGFwVGltZTtcbiAgICB0aGlzLl90YXBDb3VudGVyID4gMCAmJiBpIDwgNTAwID8gKHRoaXMuX29uRG91YmxlQ2xpY2sodCksIHRoaXMuX2RvdWJsZVRhcFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl90YXBUaW1lID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCksIHRoaXMuX3RhcENvdW50ZXIgPSAwO1xuICAgIH0sIDMwMCkpIDogKHRoaXMuX3RhcENvdW50ZXIrKywgdGhpcy5fdGFwVGltZSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgfVxuICBfcmVzZXREb3VibGVUYXAoKSB7XG4gICAgdGhpcy5fdGFwVGltZSA9IDAsIHRoaXMuX3RhcENvdW50ZXIgPSAwLCBjbGVhclRpbWVvdXQodGhpcy5fZG91YmxlVGFwVGltZXIpO1xuICB9XG4gIF9vbkRvdWJsZUNsaWNrKHQpIHtcbiAgICB0aGlzLl9tdWx0aXRvdWNoIHx8ICh0LnRvdWNoZXMgfHwgdGhpcy5fc2V0TmV3UG9zaXRpb25Pblpvb21Jbih0KSwgdGhpcy5fem9vbSAhPT0gMSA/IHRoaXMuX3Jlc3RvcmVEZWZhdWx0Wm9vbSgpIDogdGhpcy56b29tSW4oKSk7XG4gIH1cbiAgX29uWm9vbSh0KSB7XG4gICAgaWYgKHQuZGVsdGFZID4gMClcbiAgICAgIHRoaXMuem9vbU91dCgpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3pvb20gPj0gMylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fc2V0TmV3UG9zaXRpb25Pblpvb21Jbih0KSwgdGhpcy56b29tSW4oKTtcbiAgICB9XG4gIH1cbiAgX29uQmFja2Ryb3BDbGljayh0KSB7XG4gICAgdGhpcy5fcmVzZXRUb29sc1RvZ2dsZXIoKSwgdC50YXJnZXQudGFnTmFtZSA9PT0gXCJESVZcIiAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX3NldE5ld1Bvc2l0aW9uT25ab29tSW4odCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl96b29tVGltZXIpLCB0aGlzLl9wb3NpdGlvblggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgLSB0Lm9mZnNldFggLSA1MCwgdGhpcy5fcG9zaXRpb25ZID0gd2luZG93LmlubmVySGVpZ2h0IC8gMiAtIHQub2Zmc2V0WSAtIDUwLCB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudHJhbnNpdGlvbiA9IFwiYWxsIDAuNXMgZWFzZS1vdXRcIiwgdGhpcy5jdXJyZW50SW1nLnN0eWxlLmxlZnQgPSBgJHt0aGlzLl9wb3NpdGlvblh9cHhgLCB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudG9wID0gYCR7dGhpcy5fcG9zaXRpb25ZfXB4YCwgdGhpcy5fem9vbVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudHJhbnNpdGlvbiA9IFwibm9uZVwiO1xuICAgIH0sIDUwMCk7XG4gIH1cbiAgX3Jlc2V0VG9vbHNUb2dnbGVyKCkge1xuICAgIHRoaXMuX3Nob3dUb29scygpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lciksIHRoaXMuX3NldFRvb2xzVG9nZ2xlVGltb3V0KCk7XG4gIH1cbiAgX3NldFRvb2xzVG9nZ2xlVGltb3V0KCkge1xuICAgIHRoaXMuX3Rvb2xzVG9nZ2xlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2hpZGVUb29scygpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lcik7XG4gICAgfSwgNGUzKTtcbiAgfVxuICBfaGlkZVRvb2xzKCkge1xuICAgIGMuc3R5bGUodGhpcy5fZ2FsbGVyeVRvb2xiYXIsIHsgb3BhY2l0eTogMCB9KSwgYy5zdHlsZSh0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLCB7IG9wYWNpdHk6IDAgfSksIGMuc3R5bGUodGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIsIHsgb3BhY2l0eTogMCB9KTtcbiAgfVxuICBfc2hvd1Rvb2xzKCkge1xuICAgIGMuc3R5bGUodGhpcy5fZ2FsbGVyeVRvb2xiYXIsIHsgb3BhY2l0eTogMSB9KSwgYy5zdHlsZSh0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLCB7IG9wYWNpdHk6IDEgfSksIGMuc3R5bGUodGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIsIHsgb3BhY2l0eTogMSB9KTtcbiAgfVxuICBfZGlzYWJsZVNjcm9sbCgpIHtcbiAgICBjLmFkZENsYXNzKGRvY3VtZW50LmJvZHksIFwib3ZlcmZsb3cteS1oaWRkZW4gcmVsYXRpdmVcIiksIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ICYmIGMuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJtZDpwci1bMTdweF1cIik7XG4gIH1cbiAgX2VuYWJsZVNjcm9sbCgpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGMucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJvdmVyZmxvdy15LWhpZGRlbiByZWxhdGl2ZVwiKSwgYy5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCBcIm1kOnByLVsxN3B4XVwiKTtcbiAgICB9LCAzMDApO1xuICB9XG4gIF9hbmltYXRpb25TdGFydCgpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPSAhMCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRpbmcgPSAhMTtcbiAgICB9LCA0MDApO1xuICB9XG4gIF9yZXN0b3JlRGVmYXVsdFpvb20oKSB7XG4gICAgdGhpcy5fem9vbSAhPT0gMSAmJiAodGhpcy5fem9vbSA9IDEsIGMuc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7dGhpcy5fem9vbX0pYFxuICAgIH0pLCB0aGlzLl91cGRhdGVab29tQnRuKCksIHRoaXMuX3VwZGF0ZUltZ1Bvc2l0aW9uKCkpO1xuICB9XG4gIF9yZXN0b3JlRGVmYXVsdEZ1bGxzY3JlZW4oKSB7XG4gICAgdGhpcy5fZnVsbHNjcmVlbiAmJiB0aGlzLnRvZ2dsZUZ1bGxzY3JlZW4oKTtcbiAgfVxuICBfcmVzdG9yZURlZmF1bHRQb3NpdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fem9vbVRpbWVyKTtcbiAgICBjb25zdCB0ID0gdGhpcy5jdXJyZW50SW1nO1xuICAgIGMuc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHsgbGVmdDogMCwgdG9wOiAwIH0pLCBjLnN0eWxlKHRoaXMuY3VycmVudEltZywge1xuICAgICAgdHJhbnNpdGlvbjogXCJhbGwgMC41cyBlYXNlLW91dFwiLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH0pLCB0aGlzLl9jYWxjdWxhdGVJbWdTaXplKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGMuc3R5bGUodGhpcy5jdXJyZW50SW1nLCB7IHRyYW5zaXRpb246IFwibm9uZVwiIH0pO1xuICAgIH0sIDUwMCk7XG4gIH1cbiAgYXN5bmMgX3RyaWdnZXJFdmVudHModCwgZSkge1xuICAgIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHt0fS50ZS5saWdodGJveGApLCBlICYmIGF3YWl0IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke2V9LnRlLmxpZ2h0Ym94YCk7XG4gICAgfSwgNTA1KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgdmkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29uc3QgZSA9IGQuY2xvc2VzdChcbiAgICAgICAgdC50YXJnZXQsXG4gICAgICAgIGAke09jfWBcbiAgICAgICk7XG4gICAgICAoTHMuZ2V0SW5zdGFuY2UoZSkgfHwgbmV3IExzKGUpKS5vcGVuKHQpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gSS5nZXREYXRhKHRoaXMsIHZpKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgTHModGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgeTAgPSAocywgdCA9IFwiaGlkZVwiKSA9PiB7XG4gIGNvbnN0IGUgPSBgY2xpY2suZGlzbWlzcyR7cy5FVkVOVF9LRVl9YCwgaSA9IHMuTkFNRTtcbiAgaC5vbihcbiAgICBkb2N1bWVudCxcbiAgICBlLFxuICAgIGBbZGF0YS10ZS0ke2l9LWRpc21pc3NdYCxcbiAgICBmdW5jdGlvbihuKSB7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBuLnByZXZlbnREZWZhdWx0KCksIG1lKHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0gUXQodGhpcykgfHwgdGhpcy5jbG9zZXN0KGAuJHtpfWApIHx8IHRoaXMuY2xvc2VzdChgW2RhdGEtdGUtJHtpfS1pbml0XWApO1xuICAgICAgaWYgKCFvKVxuICAgICAgICByZXR1cm47XG4gICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UobylbdF0oKTtcbiAgICB9XG4gICk7XG59LCB3MCA9IChzKSA9PiB7XG4gIGlsKCgpID0+IHtcbiAgICBjb25zdCB0ID0gZWwoKTtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgZSA9IHMuTkFNRSwgaSA9IHQuZm5bZV07XG4gICAgICB0LmZuW2VdID0gcy5qUXVlcnlJbnRlcmZhY2UsIHQuZm5bZV0uQ29uc3RydWN0b3IgPSBzLCB0LmZuW2VdLm5vQ29uZmxpY3QgPSAoKSA9PiAodC5mbltlXSA9IGksIHMualF1ZXJ5SW50ZXJmYWNlKTtcbiAgICB9XG4gIH0pO1xufSwgeDAgPSAocywgdCkgPT4ge1xuICBoLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX1gLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCBzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykudG9nZ2xlKCk7XG4gICAgfVxuICApO1xufSwgazAgPSAocywgdCkgPT4ge1xuICBoLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX0uZGF0YS1hcGlgLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKFtcIkFcIiwgXCJBUkVBXCJdLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLCBtZSh0aGlzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcy5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnNob3coKTtcbiAgICB9XG4gICk7XG59LCBPMCA9IChzLCB0KSA9PiB7XG4gIGgub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBjb25zdCBpID0gUXQodGhpcyk7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBlLnByZXZlbnREZWZhdWx0KCksIG1lKHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBoLm9uZShpLCBzLkVWRU5UX0hJRERFTiwgKCkgPT4ge1xuICAgICAgICBMdCh0aGlzKSAmJiB0aGlzLmZvY3VzKCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG4gPSBkLmZpbmRPbmUocy5PUEVOX1NFTEVDVE9SKTtcbiAgICAgIG4gJiYgbiAhPT0gaSAmJiBzLmdldEluc3RhbmNlKG4pLmhpZGUoKSwgcy5nZXRPckNyZWF0ZUluc3RhbmNlKGkpLnRvZ2dsZSh0aGlzKTtcbiAgICB9XG4gICk7XG59LCBTMCA9IChzLCB0KSA9PiB7XG4gIGgub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfWAsXG4gICAgdCxcbiAgICAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgaSA9IGUudGFyZ2V0LmNsb3Nlc3QodCk7XG4gICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UoaSkudG9nZ2xlKCk7XG4gICAgfVxuICApO1xufSwgSTAgPSAocywgdCkgPT4ge1xuICBoLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX1gLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgY29uc3QgaSA9IFF0KHRoaXMpO1xuICAgICAgW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBlLnByZXZlbnREZWZhdWx0KCksIGgub25lKGksIHMuRVZFTlRfU0hPVywgKHIpID0+IHtcbiAgICAgICAgci5kZWZhdWx0UHJldmVudGVkIHx8IGgub25lKGksIHMuRVZFTlRfSElEREVOLCAoKSA9PiB7XG4gICAgICAgICAgTHQodGhpcykgJiYgdGhpcy5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbiA9IGQuZmluZE9uZShcbiAgICAgICAgYFske3MuT1BFTl9TRUxFQ1RPUn09XCJ0cnVlXCJdYFxuICAgICAgKTtcbiAgICAgIG4gJiYgcy5nZXRJbnN0YW5jZShuKS5oaWRlKCksIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKS50b2dnbGUodGhpcyk7XG4gICAgfVxuICApO1xufSwgRDAgPSAocywgdCkgPT4ge1xuICBoLm9uZShcbiAgICBkb2N1bWVudCxcbiAgICBcIm1vdXNlZG93blwiLFxuICAgIHQsXG4gICAgcy5hdXRvSW5pdGlhbChuZXcgcygpKVxuICApO1xufSwgJDAgPSAocywgdCkgPT4ge1xuICBoLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX0uZGF0YS1hcGlgLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgKGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiQVwiIHx8IGUuZGVsZWdhdGVUYXJnZXQgJiYgZS5kZWxlZ2F0ZVRhcmdldC50YWdOYW1lID09PSBcIkFcIikgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgaSA9IGZvKHRoaXMpO1xuICAgICAgZC5maW5kKGkpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgcy5nZXRPckNyZWF0ZUluc3RhbmNlKG8sIHsgdG9nZ2xlOiAhMSB9KS50b2dnbGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbn0sIEwwID0gKHMsIHQpID0+IHtcbiAgW10uc2xpY2UuY2FsbChcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQpXG4gICkubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gbmV3IHMoaSk7XG4gIH0pO1xufSwgTTAgPSAocywgdCkgPT4ge1xuICBbXS5zbGljZS5jYWxsKFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodClcbiAgKS5tYXAoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBuZXcgcyhpKTtcbiAgfSk7XG59LCBOMCA9IChzLCB0KSA9PiB7XG4gIGQuZmluZCh0KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgbmV3IHMoZSk7XG4gIH0pLCBoLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX0uZGF0YS1hcGlgLFxuICAgIGAke3R9IGltZzpub3QoW2RhdGEtdGUtbGlnaHRib3gtZGlzYWJsZWRdKWAsXG4gICAgcy50b2dnbGUoKVxuICApO1xufSwgUjAgPSAocywgdCkgPT4ge1xuICBjb25zdCBlID0gKG8pID0+IG9bMF0gPT09IFwie1wiICYmIG9bby5sZW5ndGggLSAxXSA9PT0gXCJ9XCIgfHwgb1swXSA9PT0gXCJbXCIgJiYgb1tvLmxlbmd0aCAtIDFdID09PSBcIl1cIiwgaSA9IChvKSA9PiB0eXBlb2YgbyAhPSBcInN0cmluZ1wiID8gbyA6IGUobykgPyBKU09OLnBhcnNlKG8ucmVwbGFjZSgvJy9nLCAnXCInKSkgOiBvLCBuID0gKG8pID0+IHtcbiAgICBjb25zdCByID0ge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGlmIChhLm1hdGNoKC9kYXRhc2V0LiovKSkge1xuICAgICAgICBjb25zdCBsID0gYS5zbGljZSg3LCA4KS50b0xvd2VyQ2FzZSgpLmNvbmNhdChhLnNsaWNlKDgpKTtcbiAgICAgICAgcltsXSA9IGkob1thXSk7XG4gICAgICB9XG4gICAgfSksIHI7XG4gIH07XG4gIGQuZmluZCh0KS5mb3JFYWNoKChvKSA9PiB7XG4gICAgaWYgKGMuZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImNoYXJ0XCIpICE9PSBcImJ1YmJsZVwiICYmIGMuZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImNoYXJ0XCIpICE9PSBcInNjYXR0ZXJcIikge1xuICAgICAgY29uc3QgciA9IGMuZ2V0RGF0YUF0dHJpYnV0ZXMobyksIGEgPSB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkYXRhc2V0czogW24ocildXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gci5jaGFydCAmJiAoYS50eXBlID0gci5jaGFydCksIHIubGFiZWxzICYmIChhLmRhdGEubGFiZWxzID0gSlNPTi5wYXJzZShyLmxhYmVscy5yZXBsYWNlKC8nL2csICdcIicpKSksIG5ldyBzKG8sIHtcbiAgICAgICAgLi4uYSxcbiAgICAgICAgLi4ubWlbYS50eXBlXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbn07XG5jbGFzcyBQMCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdHMgPSBbXTtcbiAgfVxuICBnZXQgaW5pdGlhbGl6ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdHM7XG4gIH1cbiAgaXNJbml0ZWQodCkge1xuICAgIHJldHVybiB0aGlzLmluaXRzLmluY2x1ZGVzKHQpO1xuICB9XG4gIGFkZCh0KSB7XG4gICAgdGhpcy5pbml0cy5wdXNoKHQpO1xuICB9XG59XG5jb25zdCBfbyA9IG5ldyBQMCgpLCBUaSA9IHtcbiAgYWxlcnQ6IHtcbiAgICBuYW1lOiBcIkFsZXJ0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtYWxlcnQtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExLFxuICAgIGRpc21pc3NNZXRob2Q6IFwiY2xvc2VcIlxuICB9LFxuICBhbmltYXRpb246IHtcbiAgICBuYW1lOiBcIkFuaW1hdGVcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1hbmltYXRpb24taW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGNhcm91c2VsOiB7XG4gICAgbmFtZTogXCJDYXJvdXNlbFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNhcm91c2VsLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBjaGlwczoge1xuICAgIG5hbWU6IFwiQ2hpcHNJbnB1dFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNoaXBzLWlucHV0LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBjaGlwOiB7XG4gICAgbmFtZTogXCJDaGlwXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtY2hpcC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgb25Jbml0OiBcImluaXRcIlxuICB9LFxuICBkYXRlcGlja2VyOiB7XG4gICAgbmFtZTogXCJEYXRlcGlja2VyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgaW5wdXQ6IHtcbiAgICBuYW1lOiBcIklucHV0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtaW5wdXQtd3JhcHBlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgcGVyZmVjdFNjcm9sbGJhcjoge1xuICAgIG5hbWU6IFwiUGVyZmVjdFNjcm9sbGJhclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXBlcmZlY3Qtc2Nyb2xsYmFyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICByYXRpbmc6IHtcbiAgICBuYW1lOiBcIlJhdGluZ1wiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXJhdGluZy1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc2Nyb2xsc3B5OiB7XG4gICAgbmFtZTogXCJTY3JvbGxTcHlcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1zcHk9J3Njcm9sbCddXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBzZWxlY3Q6IHtcbiAgICBuYW1lOiBcIlNlbGVjdFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXNlbGVjdC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc2lkZW5hdjoge1xuICAgIG5hbWU6IFwiU2lkZW5hdlwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXNpZGVuYXYtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHN0ZXBwZXI6IHtcbiAgICBuYW1lOiBcIlN0ZXBwZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1zdGVwcGVyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICB0aW1lcGlja2VyOiB7XG4gICAgbmFtZTogXCJUaW1lcGlja2VyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdGltZXBpY2tlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgdG9hc3Q6IHtcbiAgICBuYW1lOiBcIlRvYXN0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9hc3QtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExLFxuICAgIGRpc21pc3NNZXRob2Q6IFwiaGlkZVwiXG4gIH0sXG4gIGRhdGF0YWJsZToge1xuICAgIG5hbWU6IFwiRGF0YXRhYmxlXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtZGF0YXRhYmxlLWluaXRdXCJcbiAgfSxcbiAgcG9wY29uZmlybToge1xuICAgIG5hbWU6IFwiUG9wY29uZmlybVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvZ2dsZT0ncG9wY29uZmlybSddXCJcbiAgfSxcbiAgLy8gYWR2YW5jZWRJbml0c1xuICBjaGFydDoge1xuICAgIG5hbWU6IFwiQ2hhcnRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jaGFydF1cIixcbiAgICBpc1RvZ2dsZXI6ICExLFxuICAgIGFkdmFuY2VkOiBSMFxuICB9LFxuICAvLyB0b2dnbGVyc1xuICBidXR0b246IHtcbiAgICBuYW1lOiBcIkJ1dHRvblwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvZ2dsZT0nYnV0dG9uJ11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBTMFxuICB9LFxuICBjb2xsYXBzZToge1xuICAgIG5hbWU6IFwiQ29sbGFwc2VcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jb2xsYXBzZS1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6ICQwXG4gIH0sXG4gIGRyb3Bkb3duOiB7XG4gICAgbmFtZTogXCJEcm9wZG93blwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWRyb3Bkb3duLXRvZ2dsZS1yZWZdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogeDBcbiAgfSxcbiAgbW9kYWw6IHtcbiAgICBuYW1lOiBcIk1vZGFsXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdtb2RhbCddXCIsXG4gICAgZGlzbWlzc01ldGhvZDogXCJoaWRlXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogSTBcbiAgfSxcbiAgcmlwcGxlOiB7XG4gICAgbmFtZTogXCJSaXBwbGVcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1yaXBwbGUtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBEMFxuICB9LFxuICBvZmZjYW52YXM6IHtcbiAgICBuYW1lOiBcIk9mZmNhbnZhc1wiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLW9mZmNhbnZhcy10b2dnbGVdXCIsXG4gICAgZGlzbWlzc01ldGhvZDogXCJoaWRlXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogTzBcbiAgfSxcbiAgdGFiOiB7XG4gICAgbmFtZTogXCJUYWJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3RhYiddLCBbZGF0YS10ZS10b2dnbGU9J3BpbGwnXSwgW2RhdGEtdGUtdG9nZ2xlPSdsaXN0J11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBrMFxuICB9LFxuICB0b29sdGlwOiB7XG4gICAgbmFtZTogXCJUb29sdGlwXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSd0b29sdGlwJ11cIixcbiAgICBpc1RvZ2dsZXI6ICExLFxuICAgIGNhbGxiYWNrOiBMMFxuICB9LFxuICBwb3BvdmVyOiB7XG4gICAgbmFtZTogXCJQb3BvdmVyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdwb3BvdmVyJ11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBNMFxuICB9LFxuICBsaWdodGJveDoge1xuICAgIG5hbWU6IFwiTGlnaHRib3hcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1saWdodGJveC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IE4wXG4gIH1cbn0sIEIwID0gKHMpID0+IFRpW3MuTkFNRV0gfHwgbnVsbCwgSDAgPSAocykgPT4ge1xuICBpZiAoIXMgfHwgX28uaXNJbml0ZWQocy5OQU1FKSlcbiAgICByZXR1cm47XG4gIF9vLmFkZChzLk5BTUUpO1xuICBjb25zdCB0ID0gQjAocyksIGUgPSAodCA9PSBudWxsID8gdm9pZCAwIDogdC5pc1RvZ2dsZXIpIHx8ICExO1xuICBpZiAodzAocyksIHQgIT0gbnVsbCAmJiB0LmRpc21pc3NNZXRob2QgJiYgeTAocywgdC5kaXNtaXNzTWV0aG9kKSwgdCAhPSBudWxsICYmIHQuYWR2YW5jZWQpIHtcbiAgICB0ID09IG51bGwgfHwgdC5hZHZhbmNlZChzLCB0ID09IG51bGwgPyB2b2lkIDAgOiB0LnNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGUpIHtcbiAgICB0ID09IG51bGwgfHwgdC5jYWxsYmFjayhzLCB0ID09IG51bGwgPyB2b2lkIDAgOiB0LnNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZC5maW5kKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuc2VsZWN0b3IpLmZvckVhY2goKGkpID0+IHtcbiAgICBsZXQgbiA9IHMuZ2V0SW5zdGFuY2UoaSk7XG4gICAgbiB8fCAobiA9IG5ldyBzKGkpLCB0ICE9IG51bGwgJiYgdC5vbkluaXQgJiYgblt0Lm9uSW5pdF0oKSk7XG4gIH0pO1xufSwgVzAgPSAocykgPT4ge1xuICBzLmZvckVhY2goKHQpID0+IEgwKHQpKTtcbn0sIFUwID0gKHMsIHQgPSAhMSkgPT4ge1xuICBjb25zdCBlID0gT2JqZWN0LmtleXMoVGkpLm1hcCgoaSkgPT4ge1xuICAgIGlmICghIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoVGlbaV0uc2VsZWN0b3IpKSB7XG4gICAgICBjb25zdCBvID0gc1tUaVtpXS5uYW1lXTtcbiAgICAgIHJldHVybiAhbyAmJiAhX28uaXNJbml0ZWQoaSkgJiYgdCAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgIGBQbGVhc2UgaW1wb3J0ICR7VGlbaV0ubmFtZX0gZnJvbSBcInR3LWVsZW1lbnRzXCIgcGFja2FnZSBhbmQgYWRkIGl0IHRvIGEgb2JqZWN0IHBhcmFtZXRlciBpbnNpZGUgXCJpbml0VEVcIiBmdW5jdGlvbmBcbiAgICAgICksIG87XG4gICAgfVxuICB9KTtcbiAgVzAoZSk7XG59O1xuZXhwb3J0IHtcbiAgSGwgYXMgQWxlcnQsXG4gIEpsIGFzIEFuaW1hdGUsXG4gIGRsIGFzIEJ1dHRvbixcbiAgVXQgYXMgQ2Fyb3VzZWwsXG4gIHZjIGFzIENoYXJ0LFxuICBoaSBhcyBDaGlwLFxuICBLMCBhcyBDaGlwc0lucHV0LFxuICBxdCBhcyBDb2xsYXBzZSxcbiAgd2MgYXMgRGF0YXRhYmxlLFxuICBGMCBhcyBEYXRlcGlja2VyLFxuICBJdCBhcyBEcm9wZG93bixcbiAgVyBhcyBJbnB1dCxcbiAgTHMgYXMgTGlnaHRib3gsXG4gIEZsIGFzIE1vZGFsLFxuICBubyBhcyBPZmZjYW52YXMsXG4gIHljIGFzIFBlcmZlY3RTY3JvbGxiYXIsXG4gIGtjIGFzIFBvcGNvbmZpcm0sXG4gIFlsIGFzIFBvcG92ZXIsXG4gIHowIGFzIFJhdGluZyxcbiAgVWUgYXMgUmlwcGxlLFxuICB6bCBhcyBTY3JvbGxTcHksXG4gICRvIGFzIFNlbGVjdCxcbiAgcGkgYXMgU2lkZW5hdixcbiAgajAgYXMgU3RlcHBlcixcbiAgVWwgYXMgVGFiLFxuICBZMCBhcyBUaW1lcGlja2VyLFxuICBYbCBhcyBUb2FzdCxcbiAgUWUgYXMgVG9vbHRpcCxcbiAgVTAgYXMgaW5pdFRFXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHctZWxlbWVudHMuZXMubWluLmpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmYgPSB7fTtcbi8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbi8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5lID0gKGNodW5rSWQpID0+IHtcblx0cmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uZikucmVkdWNlKChwcm9taXNlcywga2V5KSA9PiB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mW2tleV0oY2h1bmtJZCwgcHJvbWlzZXMpO1xuXHRcdHJldHVybiBwcm9taXNlcztcblx0fSwgW10pKTtcbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYXN5bmMgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnUgPSAoY2h1bmtJZCkgPT4ge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwianMvXCIgKyBjaHVua0lkICsgXCIuYm90LmpzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsInZhciBpblByb2dyZXNzID0ge307XG52YXIgZGF0YVdlYnBhY2tQcmVmaXggPSBcInBhcmlzLnNpbXBsZTJiOlwiO1xuLy8gbG9hZFNjcmlwdCBmdW5jdGlvbiB0byBsb2FkIGEgc2NyaXB0IHZpYSBzY3JpcHQgdGFnXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmwgPSAodXJsLCBkb25lLCBrZXksIGNodW5rSWQpID0+IHtcblx0aWYoaW5Qcm9ncmVzc1t1cmxdKSB7IGluUHJvZ3Jlc3NbdXJsXS5wdXNoKGRvbmUpOyByZXR1cm47IH1cblx0dmFyIHNjcmlwdCwgbmVlZEF0dGFjaDtcblx0aWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcyA9IHNjcmlwdHNbaV07XG5cdFx0XHRpZihzLmdldEF0dHJpYnV0ZShcInNyY1wiKSA9PSB1cmwgfHwgcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIikgPT0gZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpIHsgc2NyaXB0ID0gczsgYnJlYWs7IH1cblx0XHR9XG5cdH1cblx0aWYoIXNjcmlwdCkge1xuXHRcdG5lZWRBdHRhY2ggPSB0cnVlO1xuXHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuXHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwO1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIiwgZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpO1xuXHRcdHNjcmlwdC5zcmMgPSB1cmw7XG5cdH1cblx0aW5Qcm9ncmVzc1t1cmxdID0gW2RvbmVdO1xuXHR2YXIgb25TY3JpcHRDb21wbGV0ZSA9IChwcmV2LCBldmVudCkgPT4ge1xuXHRcdC8vIGF2b2lkIG1lbSBsZWFrcyBpbiBJRS5cblx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR2YXIgZG9uZUZucyA9IGluUHJvZ3Jlc3NbdXJsXTtcblx0XHRkZWxldGUgaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdHNjcmlwdC5wYXJlbnROb2RlICYmIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0ZG9uZUZucyAmJiBkb25lRm5zLmZvckVhY2goKGZuKSA9PiAoZm4oZXZlbnQpKSk7XG5cdFx0aWYocHJldikgcmV0dXJuIHByZXYoZXZlbnQpO1xuXHR9XG5cdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgdW5kZWZpbmVkLCB7IHR5cGU6ICd0aW1lb3V0JywgdGFyZ2V0OiBzY3JpcHQgfSksIDEyMDAwMCk7XG5cdHNjcmlwdC5vbmVycm9yID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmVycm9yKTtcblx0c2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25sb2FkKTtcblx0bmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG59OyIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSBzY3JpcHRVcmwgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3JjXG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsICsgXCIuLi9cIjsiLCIvLyBubyBiYXNlVVJJXG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4vLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxudmFyIGluc3RhbGxlZENodW5rcyA9IHtcblx0XCJtYWluXCI6IDBcbn07XG5cbl9fd2VicGFja19yZXF1aXJlX18uZi5qID0gKGNodW5rSWQsIHByb21pc2VzKSA9PiB7XG5cdFx0Ly8gSlNPTlAgY2h1bmsgbG9hZGluZyBmb3IgamF2YXNjcmlwdFxuXHRcdHZhciBpbnN0YWxsZWRDaHVua0RhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSA/IGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA6IHVuZGVmaW5lZDtcblx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEgIT09IDApIHsgLy8gMCBtZWFucyBcImFscmVhZHkgaW5zdGFsbGVkXCIuXG5cblx0XHRcdC8vIGEgUHJvbWlzZSBtZWFucyBcImN1cnJlbnRseSBsb2FkaW5nXCIuXG5cdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEpIHtcblx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodHJ1ZSkgeyAvLyBhbGwgY2h1bmtzIGhhdmUgSlNcblx0XHRcdFx0XHQvLyBzZXR1cCBQcm9taXNlIGluIGNodW5rIGNhY2hlXG5cdFx0XHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiAoaW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gW3Jlc29sdmUsIHJlamVjdF0pKTtcblx0XHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSA9IHByb21pc2UpO1xuXG5cdFx0XHRcdFx0Ly8gc3RhcnQgY2h1bmsgbG9hZGluZ1xuXHRcdFx0XHRcdHZhciB1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLnUoY2h1bmtJZCk7XG5cdFx0XHRcdFx0Ly8gY3JlYXRlIGVycm9yIGJlZm9yZSBzdGFjayB1bndvdW5kIHRvIGdldCB1c2VmdWwgc3RhY2t0cmFjZSBsYXRlclxuXHRcdFx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcigpO1xuXHRcdFx0XHRcdHZhciBsb2FkaW5nRW5kZWQgPSAoZXZlbnQpID0+IHtcblx0XHRcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpKSB7XG5cdFx0XHRcdFx0XHRcdGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcblx0XHRcdFx0XHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJlYWxTcmMgPSBldmVudCAmJiBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LnNyYztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5tZXNzYWdlID0gJ0xvYWRpbmcgY2h1bmsgJyArIGNodW5rSWQgKyAnIGZhaWxlZC5cXG4oJyArIGVycm9yVHlwZSArICc6ICcgKyByZWFsU3JjICsgJyknO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLm5hbWUgPSAnQ2h1bmtMb2FkRXJyb3InO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IucmVxdWVzdCA9IHJlYWxTcmM7XG5cdFx0XHRcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhWzFdKGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5sKHVybCwgbG9hZGluZ0VuZGVkLCBcImNodW5rLVwiICsgY2h1bmtJZCwgY2h1bmtJZCk7XG5cdFx0XHRcdH0gZWxzZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuXHRcdFx0fVxuXHRcdH1cbn07XG5cbi8vIG5vIHByZWZldGNoaW5nXG5cbi8vIG5vIHByZWxvYWRlZFxuXG4vLyBubyBITVJcblxuLy8gbm8gSE1SIG1hbmlmZXN0XG5cbi8vIG5vIG9uIGNodW5rcyBsb2FkZWRcblxuLy8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG52YXIgd2VicGFja0pzb25wQ2FsbGJhY2sgPSAocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24sIGRhdGEpID0+IHtcblx0dmFyIFtjaHVua0lkcywgbW9yZU1vZHVsZXMsIHJ1bnRpbWVdID0gZGF0YTtcblx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG5cdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuXHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwO1xuXHRpZihjaHVua0lkcy5zb21lKChpZCkgPT4gKGluc3RhbGxlZENodW5rc1tpZF0gIT09IDApKSkge1xuXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYocnVudGltZSkgdmFyIHJlc3VsdCA9IHJ1bnRpbWUoX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdH1cblx0aWYocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24pIHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKGRhdGEpO1xuXHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuXHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJiBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcblx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSgpO1xuXHRcdH1cblx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuXHR9XG5cbn1cblxudmFyIGNodW5rTG9hZGluZ0dsb2JhbCA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtwYXJpc19zaW1wbGUyYlwiXSA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtwYXJpc19zaW1wbGUyYlwiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiLy8gYm90LnRzXG5pbXBvcnQgXCJmbG93Yml0ZS9kaXN0L2RhdGVwaWNrZXIuanNcIjtcbmltcG9ydCB7XG4gIElucHV0LFxuICBUaW1lcGlja2VyLFxuICBpbml0VEUsXG59IGZyb20gXCJ0dy1lbGVtZW50c1wiO1xuXG5pbml0VEUoeyBJbnB1dCwgVGltZXBpY2tlciB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==