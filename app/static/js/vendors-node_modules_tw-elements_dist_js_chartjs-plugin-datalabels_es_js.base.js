"use strict";
(self["webpackChunkparis_simple2b"] = self["webpackChunkparis_simple2b"] || []).push([["vendors-node_modules_tw-elements_dist_js_chartjs-plugin-datalabels_es_js"],{

/***/ "./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Me)
/* harmony export */ });
/* harmony import */ var _chart_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart.es.js */ "./node_modules/tw-elements/dist/js/chart.es.js");

/*!
 * chartjs-plugin-datalabels v2.2.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2022 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */
var D = function() {
  if (typeof window < "u") {
    if (window.devicePixelRatio)
      return window.devicePixelRatio;
    var e = window.screen;
    if (e)
      return (e.deviceXDPI || 1) / (e.logicalXDPI || 1);
  }
  return 1;
}(), m = {
  // @todo move this in Chart.helpers.toTextLines
  toTextLines: function(e) {
    var t = [], r;
    for (e = [].concat(e); e.length; )
      r = e.pop(), typeof r == "string" ? t.unshift.apply(t, r.split(`
`)) : Array.isArray(r) ? e.push.apply(e, r) : (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e) || t.unshift("" + r);
    return t;
  },
  // @todo move this in Chart.helpers.canvas.textSize
  // @todo cache calls of measureText if font doesn't change?!
  textSize: function(e, t, r) {
    var a = [].concat(t), i = a.length, n = e.font, o = 0, s;
    for (e.font = r.string, s = 0; s < i; ++s)
      o = Math.max(e.measureText(a[s]).width, o);
    return e.font = n, {
      height: i * r.lineHeight,
      width: o
    };
  },
  /**
   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).
   * @todo move this method in Chart.helpers.bound
   * https://doc.qt.io/qt-5/qtglobal.html#qBound
   */
  bound: function(e, t, r) {
    return Math.max(e, Math.min(t, r));
  },
  /**
   * Returns an array of pair [value, state] where state is:
   * * -1: value is only in a0 (removed)
   * *  1: value is only in a1 (added)
   */
  arrayDiff: function(e, t) {
    var r = e.slice(), a = [], i, n, o, s;
    for (i = 0, o = t.length; i < o; ++i)
      s = t[i], n = r.indexOf(s), n === -1 ? a.push([s, 1]) : r.splice(n, 1);
    for (i = 0, o = r.length; i < o; ++i)
      a.push([r[i], -1]);
    return a;
  },
  /**
   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70
   */
  rasterize: function(e) {
    return Math.round(e * D) / D;
  }
};
function A(e, t) {
  var r = t.x, a = t.y;
  if (r === null)
    return { x: 0, y: -1 };
  if (a === null)
    return { x: 1, y: 0 };
  var i = e.x - r, n = e.y - a, o = Math.sqrt(i * i + n * n);
  return {
    x: o ? i / o : 0,
    y: o ? n / o : -1
  };
}
function ae(e, t, r, a, i) {
  switch (i) {
    case "center":
      r = a = 0;
      break;
    case "bottom":
      r = 0, a = 1;
      break;
    case "right":
      r = 1, a = 0;
      break;
    case "left":
      r = -1, a = 0;
      break;
    case "top":
      r = 0, a = -1;
      break;
    case "start":
      r = -r, a = -a;
      break;
    case "end":
      break;
    default:
      i *= Math.PI / 180, r = Math.cos(i), a = Math.sin(i);
      break;
  }
  return {
    x: e,
    y: t,
    vx: r,
    vy: a
  };
}
var te = 0, j = 1, N = 2, O = 4, F = 8;
function M(e, t, r) {
  var a = te;
  return e < r.left ? a |= j : e > r.right && (a |= N), t < r.top ? a |= F : t > r.bottom && (a |= O), a;
}
function ie(e, t) {
  for (var r = e.x0, a = e.y0, i = e.x1, n = e.y1, o = M(r, a, t), s = M(i, n, t), l, u, v; !(!(o | s) || o & s); )
    l = o || s, l & F ? (u = r + (i - r) * (t.top - a) / (n - a), v = t.top) : l & O ? (u = r + (i - r) * (t.bottom - a) / (n - a), v = t.bottom) : l & N ? (v = a + (n - a) * (t.right - r) / (i - r), u = t.right) : l & j && (v = a + (n - a) * (t.left - r) / (i - r), u = t.left), l === o ? (r = u, a = v, o = M(r, a, t)) : (i = u, n = v, s = M(i, n, t));
  return {
    x0: r,
    x1: i,
    y0: a,
    y1: n
  };
}
function P(e, t) {
  var r = t.anchor, a = e, i, n;
  return t.clamp && (a = ie(a, t.area)), r === "start" ? (i = a.x0, n = a.y0) : r === "end" ? (i = a.x1, n = a.y1) : (i = (a.x0 + a.x1) / 2, n = (a.y0 + a.y1) / 2), ae(i, n, e.vx, e.vy, t.align);
}
var E = {
  arc: function(e, t) {
    var r = (e.startAngle + e.endAngle) / 2, a = Math.cos(r), i = Math.sin(r), n = e.innerRadius, o = e.outerRadius;
    return P({
      x0: e.x + a * n,
      y0: e.y + i * n,
      x1: e.x + a * o,
      y1: e.y + i * o,
      vx: a,
      vy: i
    }, t);
  },
  point: function(e, t) {
    var r = A(e, t.origin), a = r.x * e.options.radius, i = r.y * e.options.radius;
    return P({
      x0: e.x - a,
      y0: e.y - i,
      x1: e.x + a,
      y1: e.y + i,
      vx: r.x,
      vy: r.y
    }, t);
  },
  bar: function(e, t) {
    var r = A(e, t.origin), a = e.x, i = e.y, n = 0, o = 0;
    return e.horizontal ? (a = Math.min(e.x, e.base), n = Math.abs(e.base - e.x)) : (i = Math.min(e.y, e.base), o = Math.abs(e.base - e.y)), P({
      x0: a,
      y0: i + o,
      x1: a + n,
      y1: i,
      vx: r.x,
      vy: r.y
    }, t);
  },
  fallback: function(e, t) {
    var r = A(e, t.origin);
    return P({
      x0: e.x,
      y0: e.y,
      x1: e.x + (e.width || 0),
      y1: e.y + (e.height || 0),
      vx: r.x,
      vy: r.y
    }, t);
  }
}, x = m.rasterize;
function ne(e) {
  var t = e.borderWidth || 0, r = e.padding, a = e.size.height, i = e.size.width, n = -i / 2, o = -a / 2;
  return {
    frame: {
      x: n - r.left - t,
      y: o - r.top - t,
      w: i + r.width + t * 2,
      h: a + r.height + t * 2
    },
    text: {
      x: n,
      y: o,
      w: i,
      h: a
    }
  };
}
function oe(e, t) {
  var r = t.chart.getDatasetMeta(t.datasetIndex).vScale;
  if (!r)
    return null;
  if (r.xCenter !== void 0 && r.yCenter !== void 0)
    return { x: r.xCenter, y: r.yCenter };
  var a = r.getBasePixel();
  return e.horizontal ? { x: a, y: null } : { x: null, y: a };
}
function se(e) {
  return e instanceof _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.A ? E.arc : e instanceof _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.P ? E.point : e instanceof _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.B ? E.bar : E.fallback;
}
function le(e, t, r, a, i, n) {
  var o = Math.PI / 2;
  if (n) {
    var s = Math.min(n, i / 2, a / 2), l = t + s, u = r + s, v = t + a - s, d = r + i - s;
    e.moveTo(t, u), l < v && u < d ? (e.arc(l, u, s, -Math.PI, -o), e.arc(v, u, s, -o, 0), e.arc(v, d, s, 0, o), e.arc(l, d, s, o, Math.PI)) : l < v ? (e.moveTo(l, r), e.arc(v, u, s, -o, o), e.arc(l, u, s, o, Math.PI + o)) : u < d ? (e.arc(l, u, s, -Math.PI, 0), e.arc(l, d, s, 0, Math.PI)) : e.arc(l, u, s, -Math.PI, Math.PI), e.closePath(), e.moveTo(t, r);
  } else
    e.rect(t, r, a, i);
}
function ue(e, t, r) {
  var a = r.backgroundColor, i = r.borderColor, n = r.borderWidth;
  !a && (!i || !n) || (e.beginPath(), le(
    e,
    x(t.x) + n / 2,
    x(t.y) + n / 2,
    x(t.w) - n,
    x(t.h) - n,
    r.borderRadius
  ), e.closePath(), a && (e.fillStyle = a, e.fill()), i && n && (e.strokeStyle = i, e.lineWidth = n, e.lineJoin = "miter", e.stroke()));
}
function ve(e, t, r) {
  var a = r.lineHeight, i = e.w, n = e.x, o = e.y + a / 2;
  return t === "center" ? n += i / 2 : (t === "end" || t === "right") && (n += i), {
    h: a,
    w: i,
    x: n,
    y: o
  };
}
function de(e, t, r) {
  var a = e.shadowBlur, i = r.stroked, n = x(r.x), o = x(r.y), s = x(r.w);
  i && e.strokeText(t, n, o, s), r.filled && (a && i && (e.shadowBlur = 0), e.fillText(t, n, o, s), a && i && (e.shadowBlur = a));
}
function fe(e, t, r, a) {
  var i = a.textAlign, n = a.color, o = !!n, s = a.font, l = t.length, u = a.textStrokeColor, v = a.textStrokeWidth, d = u && v, y;
  if (!(!l || !o && !d))
    for (r = ve(r, i, s), e.font = s.string, e.textAlign = i, e.textBaseline = "middle", e.shadowBlur = a.textShadowBlur, e.shadowColor = a.textShadowColor, o && (e.fillStyle = n), d && (e.lineJoin = "round", e.lineWidth = v, e.strokeStyle = u), y = 0, l = t.length; y < l; ++y)
      de(e, t[y], {
        stroked: d,
        filled: o,
        w: r.w,
        x: r.x,
        y: r.y + r.h * y
      });
}
var L = function(e, t, r, a) {
  var i = this;
  i._config = e, i._index = a, i._model = null, i._rects = null, i._ctx = t, i._el = r;
};
(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)(L.prototype, {
  /**
   * @private
   */
  _modelize: function(e, t, r, a) {
    var i = this, n = i._index, o = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.t)((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.font, {}], a, n)), s = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.color, _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.d.color], a, n);
    return {
      align: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.align, "center"], a, n),
      anchor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.anchor, "center"], a, n),
      area: a.chart.chartArea,
      backgroundColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.backgroundColor, null], a, n),
      borderColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.borderColor, null], a, n),
      borderRadius: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.borderRadius, 0], a, n),
      borderWidth: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.borderWidth, 0], a, n),
      clamp: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.clamp, !1], a, n),
      clip: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.clip, !1], a, n),
      color: s,
      display: e,
      font: o,
      lines: t,
      offset: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.offset, 4], a, n),
      opacity: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.opacity, 1], a, n),
      origin: oe(i._el, a),
      padding: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.a)((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.padding, 4], a, n)),
      positioner: se(i._el),
      rotation: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.rotation, 0], a, n) * (Math.PI / 180),
      size: m.textSize(i._ctx, t, o),
      textAlign: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textAlign, "start"], a, n),
      textShadowBlur: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textShadowBlur, 0], a, n),
      textShadowColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textShadowColor, s], a, n),
      textStrokeColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textStrokeColor, s], a, n),
      textStrokeWidth: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textStrokeWidth, 0], a, n)
    };
  },
  update: function(e) {
    var t = this, r = null, a = null, i = t._index, n = t._config, o, s, l, u = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([n.display, !0], e, i);
    u && (o = e.dataset.data[i], s = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.v)((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.c)(n.formatter, [o, e]), o), l = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(s) ? [] : m.toTextLines(s), l.length && (r = t._modelize(u, l, n, e), a = ne(r))), t._model = r, t._rects = a;
  },
  geometry: function() {
    return this._rects ? this._rects.frame : {};
  },
  rotation: function() {
    return this._model ? this._model.rotation : 0;
  },
  visible: function() {
    return this._model && this._model.opacity;
  },
  model: function() {
    return this._model;
  },
  draw: function(e, t) {
    var r = this, a = e.ctx, i = r._model, n = r._rects, o;
    this.visible() && (a.save(), i.clip && (o = i.area, a.beginPath(), a.rect(
      o.left,
      o.top,
      o.right - o.left,
      o.bottom - o.top
    ), a.clip()), a.globalAlpha = m.bound(0, i.opacity, 1), a.translate(x(t.x), x(t.y)), a.rotate(i.rotation), ue(a, n.frame, i), fe(a, i.lines, n.text, i), a.restore());
  }
});
var he = Number.MIN_SAFE_INTEGER || -9007199254740991, ye = Number.MAX_SAFE_INTEGER || 9007199254740991;
function b(e, t, r) {
  var a = Math.cos(r), i = Math.sin(r), n = t.x, o = t.y;
  return {
    x: n + a * (e.x - n) - i * (e.y - o),
    y: o + i * (e.x - n) + a * (e.y - o)
  };
}
function W(e, t) {
  var r = ye, a = he, i = t.origin, n, o, s, l, u;
  for (n = 0; n < e.length; ++n)
    o = e[n], s = o.x - i.x, l = o.y - i.y, u = t.vx * s + t.vy * l, r = Math.min(r, u), a = Math.max(a, u);
  return {
    min: r,
    max: a
  };
}
function I(e, t) {
  var r = t.x - e.x, a = t.y - e.y, i = Math.sqrt(r * r + a * a);
  return {
    vx: (t.x - e.x) / i,
    vy: (t.y - e.y) / i,
    origin: e,
    ln: i
  };
}
var G = function() {
  this._rotation = 0, this._rect = {
    x: 0,
    y: 0,
    w: 0,
    h: 0
  };
};
(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)(G.prototype, {
  center: function() {
    var e = this._rect;
    return {
      x: e.x + e.w / 2,
      y: e.y + e.h / 2
    };
  },
  update: function(e, t, r) {
    this._rotation = r, this._rect = {
      x: t.x + e.x,
      y: t.y + e.y,
      w: t.w,
      h: t.h
    };
  },
  contains: function(e) {
    var t = this, r = 1, a = t._rect;
    return e = b(e, t.center(), -t._rotation), !(e.x < a.x - r || e.y < a.y - r || e.x > a.x + a.w + r * 2 || e.y > a.y + a.h + r * 2);
  },
  // Separating Axis Theorem
  // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169
  intersects: function(e) {
    var t = this._points(), r = e._points(), a = [
      I(t[0], t[1]),
      I(t[0], t[3])
    ], i, n, o;
    for (this._rotation !== e._rotation && a.push(
      I(r[0], r[1]),
      I(r[0], r[3])
    ), i = 0; i < a.length; ++i)
      if (n = W(t, a[i]), o = W(r, a[i]), n.max < o.min || o.max < n.min)
        return !1;
    return !0;
  },
  /**
   * @private
   */
  _points: function() {
    var e = this, t = e._rect, r = e._rotation, a = e.center();
    return [
      b({ x: t.x, y: t.y }, a, r),
      b({ x: t.x + t.w, y: t.y }, a, r),
      b({ x: t.x + t.w, y: t.y + t.h }, a, r),
      b({ x: t.x, y: t.y + t.h }, a, r)
    ];
  }
});
function H(e, t, r) {
  var a = t.positioner(e, t), i = a.vx, n = a.vy;
  if (!i && !n)
    return { x: a.x, y: a.y };
  var o = r.w, s = r.h, l = t.rotation, u = Math.abs(o / 2 * Math.cos(l)) + Math.abs(s / 2 * Math.sin(l)), v = Math.abs(o / 2 * Math.sin(l)) + Math.abs(s / 2 * Math.cos(l)), d = 1 / Math.max(Math.abs(i), Math.abs(n));
  return u *= i * d, v *= n * d, u += t.offset * i, v += t.offset * n, {
    x: a.x + u,
    y: a.y + v
  };
}
function xe(e, t) {
  var r, a, i, n;
  for (r = e.length - 1; r >= 0; --r)
    for (i = e[r].$layout, a = r - 1; a >= 0 && i._visible; --a)
      n = e[a].$layout, n._visible && i._box.intersects(n._box) && t(i, n);
  return e;
}
function _e(e) {
  var t, r, a, i, n, o, s;
  for (t = 0, r = e.length; t < r; ++t)
    a = e[t], i = a.$layout, i._visible && (s = new Proxy(a._el, { get: (l, u) => l.getProps([u], !0)[u] }), n = a.geometry(), o = H(s, a.model(), n), i._box.update(o, n, a.rotation()));
  return xe(e, function(l, u) {
    var v = l._hidable, d = u._hidable;
    v && d || d ? u._visible = !1 : v && (l._visible = !1);
  });
}
var w = {
  prepare: function(e) {
    var t = [], r, a, i, n, o;
    for (r = 0, i = e.length; r < i; ++r)
      for (a = 0, n = e[r].length; a < n; ++a)
        o = e[r][a], t.push(o), o.$layout = {
          _box: new G(),
          _hidable: !1,
          _visible: !0,
          _set: r,
          _idx: o._index
        };
    return t.sort(function(s, l) {
      var u = s.$layout, v = l.$layout;
      return u._idx === v._idx ? v._set - u._set : v._idx - u._idx;
    }), this.update(t), t;
  },
  update: function(e) {
    var t = !1, r, a, i, n, o;
    for (r = 0, a = e.length; r < a; ++r)
      i = e[r], n = i.model(), o = i.$layout, o._hidable = n && n.display === "auto", o._visible = i.visible(), t |= o._hidable;
    t && _e(e);
  },
  lookup: function(e, t) {
    var r, a;
    for (r = e.length - 1; r >= 0; --r)
      if (a = e[r].$layout, a && a._visible && a._box.contains(t))
        return e[r];
    return null;
  },
  draw: function(e, t) {
    var r, a, i, n, o, s;
    for (r = 0, a = t.length; r < a; ++r)
      i = t[r], n = i.$layout, n._visible && (o = i.geometry(), s = H(i._el, i.model(), o), n._box.update(s, o, i.rotation()), i.draw(e, s));
  }
}, ce = function(e) {
  if ((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e))
    return null;
  var t = e, r, a, i;
  if ((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.b)(e))
    if (!(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e.label))
      t = e.label;
    else if (!(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e.r))
      t = e.r;
    else
      for (t = "", r = Object.keys(e), i = 0, a = r.length; i < a; ++i)
        t += (i !== 0 ? ", " : "") + r[i] + ": " + e[r[i]];
  return "" + t;
}, be = {
  align: "center",
  anchor: "center",
  backgroundColor: null,
  borderColor: null,
  borderRadius: 0,
  borderWidth: 0,
  clamp: !1,
  clip: !1,
  color: void 0,
  display: !0,
  font: {
    family: void 0,
    lineHeight: 1.2,
    size: void 0,
    style: void 0,
    weight: null
  },
  formatter: ce,
  labels: void 0,
  listeners: {},
  offset: 4,
  opacity: 1,
  padding: {
    top: 4,
    right: 4,
    bottom: 4,
    left: 4
  },
  rotation: 0,
  textAlign: "start",
  textStrokeColor: void 0,
  textStrokeWidth: 0,
  textShadowBlur: 0,
  textShadowColor: void 0
}, h = "$datalabels", U = "$default";
function pe(e, t) {
  var r = e.datalabels, a = {}, i = [], n, o;
  return r === !1 ? null : (r === !0 && (r = {}), t = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)({}, [t, r]), n = t.labels || {}, o = Object.keys(n), delete t.labels, o.length ? o.forEach(function(s) {
    n[s] && i.push((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)({}, [
      t,
      n[s],
      { _key: s }
    ]));
  }) : i.push(t), a = i.reduce(function(s, l) {
    return (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.e)(l.listeners || {}, function(u, v) {
      s[v] = s[v] || {}, s[v][l._key || U] = u;
    }), delete l.listeners, s;
  }, {}), {
    labels: i,
    listeners: a
  });
}
function R(e, t, r, a) {
  if (t) {
    var i = r.$context, n = r.$groups, o;
    t[n._set] && (o = t[n._set][n._key], o && (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.c)(o, [i, a]) === !0 && (e[h]._dirty = !0, r.update(i)));
  }
}
function me(e, t, r, a, i) {
  var n, o;
  !r && !a || (r ? a ? r !== a && (o = n = !0) : o = !0 : n = !0, o && R(e, t.leave, r, i), n && R(e, t.enter, a, i));
}
function we(e, t) {
  var r = e[h], a = r._listeners, i, n;
  if (!(!a.enter && !a.leave)) {
    if (t.type === "mousemove")
      n = w.lookup(r._labels, t);
    else if (t.type !== "mouseout")
      return;
    i = r._hovered, r._hovered = n, me(e, a, i, n, t);
  }
}
function ge(e, t) {
  var r = e[h], a = r._listeners.click, i = a && w.lookup(r._labels, t);
  i && R(e, a, i, t);
}
var Me = {
  id: "datalabels",
  defaults: be,
  beforeInit: function(e) {
    e[h] = {
      _actives: []
    };
  },
  beforeUpdate: function(e) {
    var t = e[h];
    t._listened = !1, t._listeners = {}, t._datasets = [], t._labels = [];
  },
  afterDatasetUpdate: function(e, t, r) {
    var a = t.index, i = e[h], n = i._datasets[a] = [], o = e.isDatasetVisible(a), s = e.data.datasets[a], l = pe(s, r), u = t.meta.data || [], v = e.ctx, d, y, $, T, S, B, c, _;
    for (v.save(), d = 0, $ = u.length; d < $; ++d)
      if (c = u[d], c[h] = [], o && c && e.getDataVisibility(d) && !c.skip)
        for (y = 0, T = l.labels.length; y < T; ++y)
          S = l.labels[y], B = S._key, _ = new L(S, v, c, d), _.$groups = {
            _set: a,
            _key: B || U
          }, _.$context = {
            active: !1,
            chart: e,
            dataIndex: d,
            dataset: s,
            datasetIndex: a
          }, _.update(_.$context), c[h].push(_), n.push(_);
    v.restore(), (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)(i._listeners, l.listeners, {
      merger: function(k, C, X) {
        C[k] = C[k] || {}, C[k][t.index] = X[k], i._listened = !0;
      }
    });
  },
  afterUpdate: function(e) {
    e[h]._labels = w.prepare(e[h]._datasets);
  },
  // Draw labels on top of all dataset elements
  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29
  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32
  afterDatasetsDraw: function(e) {
    w.draw(e, e[h]._labels);
  },
  beforeEvent: function(e, t) {
    if (e[h]._listened) {
      var r = t.event;
      switch (r.type) {
        case "mousemove":
        case "mouseout":
          we(e, r);
          break;
        case "click":
          ge(e, r);
          break;
      }
    }
  },
  afterEvent: function(e) {
    var t = e[h], r = t._actives, a = t._actives = e.getActiveElements(), i = m.arrayDiff(r, a), n, o, s, l, u, v, d;
    for (n = 0, o = i.length; n < o; ++n)
      if (u = i[n], u[1])
        for (d = u[0].element[h] || [], s = 0, l = d.length; s < l; ++s)
          v = d[s], v.$context.active = u[1] === 1, v.update(v.$context);
    (t._dirty || i.length) && (w.update(t._labels), e.render()), delete t._dirty;
  }
};

//# sourceMappingURL=chartjs-plugin-datalabels.es.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMvdmVuZG9ycy1ub2RlX21vZHVsZXNfdHctZWxlbWVudHNfZGlzdF9qc19jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzX2VzX2pzLmJhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBeUk7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0EsOENBQThDLCtDQUFDO0FBQy9DO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsc0JBQXNCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQkFBMEIsZ0JBQWdCLElBQUk7QUFDOUM7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBQyx3QkFBd0IsMkNBQUMsMEJBQTBCLDJDQUFFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMlFBQTJRLE9BQU87QUFDbFI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtDQUFDLENBQUMsK0NBQUMsWUFBWSxlQUFlLCtDQUFDLFdBQVcsaURBQU87QUFDckY7QUFDQSxhQUFhLCtDQUFDO0FBQ2QsY0FBYywrQ0FBQztBQUNmO0FBQ0EsdUJBQXVCLCtDQUFDO0FBQ3hCLG1CQUFtQiwrQ0FBQztBQUNwQixvQkFBb0IsK0NBQUM7QUFDckIsbUJBQW1CLCtDQUFDO0FBQ3BCLGFBQWEsK0NBQUM7QUFDZCxZQUFZLCtDQUFDO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtDQUFDO0FBQ2YsZUFBZSwrQ0FBQztBQUNoQjtBQUNBLGVBQWUsK0NBQUMsQ0FBQywrQ0FBQztBQUNsQjtBQUNBLGdCQUFnQiwrQ0FBQztBQUNqQjtBQUNBLGlCQUFpQiwrQ0FBQztBQUNsQixzQkFBc0IsK0NBQUM7QUFDdkIsdUJBQXVCLCtDQUFDO0FBQ3hCLHVCQUF1QiwrQ0FBQztBQUN4Qix1QkFBdUIsK0NBQUM7QUFDeEI7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnRkFBZ0YsK0NBQUM7QUFDakYscUNBQXFDLCtDQUFDLENBQUMsK0NBQUMsK0JBQStCLCtDQUFDO0FBQ3hFLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQixVQUFVLHNCQUFzQjtBQUNoQyxVQUFVLDRCQUE0QjtBQUN0QyxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakMsc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkMsbUVBQW1FLHVDQUF1QztBQUMxRztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQyxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBLENBQUM7QUFDRCxNQUFNLCtDQUFDO0FBQ1A7QUFDQTtBQUNBLE1BQU0sK0NBQUU7QUFDUixTQUFTLCtDQUFDO0FBQ1Y7QUFDQSxjQUFjLCtDQUFDO0FBQ2Y7QUFDQTtBQUNBLDREQUE0RCxPQUFPO0FBQ25FO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw4QkFBOEI7QUFDOUIsK0NBQStDLE9BQU8sK0NBQUMsR0FBRyw2QkFBNkI7QUFDdkYsbUJBQW1CLCtDQUFDLEdBQUc7QUFDdkI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEdBQUc7QUFDSCxXQUFXLCtDQUFDLGtCQUFrQjtBQUM5Qix1QkFBdUI7QUFDdkIsS0FBSztBQUNMLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsK0NBQUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsR0FBRztBQUNIO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGlCQUFpQiwrQ0FBQztBQUNsQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBLDZEQUE2RCxPQUFPO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BhcmlzLnNpbXBsZTJiLy4vbm9kZV9tb2R1bGVzL3R3LWVsZW1lbnRzL2Rpc3QvanMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtIGFzIGcsIGkgYXMgcCwgdCBhcyBxLCByIGFzIGYsIGQgYXMgSiwgYSBhcyBLLCB2IGFzIFYsIGMgYXMgeiwgZSBhcyBZLCBBIGFzIFEsIFAgYXMgWiwgQiBhcyBlZSwgYiBhcyByZSB9IGZyb20gXCIuL2NoYXJ0LmVzLmpzXCI7XG4vKiFcbiAqIGNoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMgdjIuMi4wXG4gKiBodHRwczovL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMubmV0bGlmeS5hcHBcbiAqIChjKSAyMDE3LTIwMjIgY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG52YXIgRCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA8IFwidVwiKSB7XG4gICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHZhciBlID0gd2luZG93LnNjcmVlbjtcbiAgICBpZiAoZSlcbiAgICAgIHJldHVybiAoZS5kZXZpY2VYRFBJIHx8IDEpIC8gKGUubG9naWNhbFhEUEkgfHwgMSk7XG4gIH1cbiAgcmV0dXJuIDE7XG59KCksIG0gPSB7XG4gIC8vIEB0b2RvIG1vdmUgdGhpcyBpbiBDaGFydC5oZWxwZXJzLnRvVGV4dExpbmVzXG4gIHRvVGV4dExpbmVzOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHQgPSBbXSwgcjtcbiAgICBmb3IgKGUgPSBbXS5jb25jYXQoZSk7IGUubGVuZ3RoOyApXG4gICAgICByID0gZS5wb3AoKSwgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiA/IHQudW5zaGlmdC5hcHBseSh0LCByLnNwbGl0KGBcbmApKSA6IEFycmF5LmlzQXJyYXkocikgPyBlLnB1c2guYXBwbHkoZSwgcikgOiBwKGUpIHx8IHQudW5zaGlmdChcIlwiICsgcik7XG4gICAgcmV0dXJuIHQ7XG4gIH0sXG4gIC8vIEB0b2RvIG1vdmUgdGhpcyBpbiBDaGFydC5oZWxwZXJzLmNhbnZhcy50ZXh0U2l6ZVxuICAvLyBAdG9kbyBjYWNoZSBjYWxscyBvZiBtZWFzdXJlVGV4dCBpZiBmb250IGRvZXNuJ3QgY2hhbmdlPyFcbiAgdGV4dFNpemU6IGZ1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICB2YXIgYSA9IFtdLmNvbmNhdCh0KSwgaSA9IGEubGVuZ3RoLCBuID0gZS5mb250LCBvID0gMCwgcztcbiAgICBmb3IgKGUuZm9udCA9IHIuc3RyaW5nLCBzID0gMDsgcyA8IGk7ICsrcylcbiAgICAgIG8gPSBNYXRoLm1heChlLm1lYXN1cmVUZXh0KGFbc10pLndpZHRoLCBvKTtcbiAgICByZXR1cm4gZS5mb250ID0gbiwge1xuICAgICAgaGVpZ2h0OiBpICogci5saW5lSGVpZ2h0LFxuICAgICAgd2lkdGg6IG9cbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB2YWx1ZSBib3VuZGVkIGJ5IG1pbiBhbmQgbWF4LiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gbWF4KG1pbiwgbWluKHZhbHVlLCBtYXgpKS5cbiAgICogQHRvZG8gbW92ZSB0aGlzIG1ldGhvZCBpbiBDaGFydC5oZWxwZXJzLmJvdW5kXG4gICAqIGh0dHBzOi8vZG9jLnF0LmlvL3F0LTUvcXRnbG9iYWwuaHRtbCNxQm91bmRcbiAgICovXG4gIGJvdW5kOiBmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KGUsIE1hdGgubWluKHQsIHIpKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcGFpciBbdmFsdWUsIHN0YXRlXSB3aGVyZSBzdGF0ZSBpczpcbiAgICogKiAtMTogdmFsdWUgaXMgb25seSBpbiBhMCAocmVtb3ZlZClcbiAgICogKiAgMTogdmFsdWUgaXMgb25seSBpbiBhMSAoYWRkZWQpXG4gICAqL1xuICBhcnJheURpZmY6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB2YXIgciA9IGUuc2xpY2UoKSwgYSA9IFtdLCBpLCBuLCBvLCBzO1xuICAgIGZvciAoaSA9IDAsIG8gPSB0Lmxlbmd0aDsgaSA8IG87ICsraSlcbiAgICAgIHMgPSB0W2ldLCBuID0gci5pbmRleE9mKHMpLCBuID09PSAtMSA/IGEucHVzaChbcywgMV0pIDogci5zcGxpY2UobiwgMSk7XG4gICAgZm9yIChpID0gMCwgbyA9IHIubGVuZ3RoOyBpIDwgbzsgKytpKVxuICAgICAgYS5wdXNoKFtyW2ldLCAtMV0pO1xuICAgIHJldHVybiBhO1xuICB9LFxuICAvKipcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvNzBcbiAgICovXG4gIHJhc3Rlcml6ZTogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGUgKiBEKSAvIEQ7XG4gIH1cbn07XG5mdW5jdGlvbiBBKGUsIHQpIHtcbiAgdmFyIHIgPSB0LngsIGEgPSB0Lnk7XG4gIGlmIChyID09PSBudWxsKVxuICAgIHJldHVybiB7IHg6IDAsIHk6IC0xIH07XG4gIGlmIChhID09PSBudWxsKVxuICAgIHJldHVybiB7IHg6IDEsIHk6IDAgfTtcbiAgdmFyIGkgPSBlLnggLSByLCBuID0gZS55IC0gYSwgbyA9IE1hdGguc3FydChpICogaSArIG4gKiBuKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBvID8gaSAvIG8gOiAwLFxuICAgIHk6IG8gPyBuIC8gbyA6IC0xXG4gIH07XG59XG5mdW5jdGlvbiBhZShlLCB0LCByLCBhLCBpKSB7XG4gIHN3aXRjaCAoaSkge1xuICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgIHIgPSBhID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIHIgPSAwLCBhID0gMTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgciA9IDEsIGEgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIHIgPSAtMSwgYSA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICByID0gMCwgYSA9IC0xO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICByID0gLXIsIGEgPSAtYTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpICo9IE1hdGguUEkgLyAxODAsIHIgPSBNYXRoLmNvcyhpKSwgYSA9IE1hdGguc2luKGkpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBlLFxuICAgIHk6IHQsXG4gICAgdng6IHIsXG4gICAgdnk6IGFcbiAgfTtcbn1cbnZhciB0ZSA9IDAsIGogPSAxLCBOID0gMiwgTyA9IDQsIEYgPSA4O1xuZnVuY3Rpb24gTShlLCB0LCByKSB7XG4gIHZhciBhID0gdGU7XG4gIHJldHVybiBlIDwgci5sZWZ0ID8gYSB8PSBqIDogZSA+IHIucmlnaHQgJiYgKGEgfD0gTiksIHQgPCByLnRvcCA/IGEgfD0gRiA6IHQgPiByLmJvdHRvbSAmJiAoYSB8PSBPKSwgYTtcbn1cbmZ1bmN0aW9uIGllKGUsIHQpIHtcbiAgZm9yICh2YXIgciA9IGUueDAsIGEgPSBlLnkwLCBpID0gZS54MSwgbiA9IGUueTEsIG8gPSBNKHIsIGEsIHQpLCBzID0gTShpLCBuLCB0KSwgbCwgdSwgdjsgISghKG8gfCBzKSB8fCBvICYgcyk7IClcbiAgICBsID0gbyB8fCBzLCBsICYgRiA/ICh1ID0gciArIChpIC0gcikgKiAodC50b3AgLSBhKSAvIChuIC0gYSksIHYgPSB0LnRvcCkgOiBsICYgTyA/ICh1ID0gciArIChpIC0gcikgKiAodC5ib3R0b20gLSBhKSAvIChuIC0gYSksIHYgPSB0LmJvdHRvbSkgOiBsICYgTiA/ICh2ID0gYSArIChuIC0gYSkgKiAodC5yaWdodCAtIHIpIC8gKGkgLSByKSwgdSA9IHQucmlnaHQpIDogbCAmIGogJiYgKHYgPSBhICsgKG4gLSBhKSAqICh0LmxlZnQgLSByKSAvIChpIC0gciksIHUgPSB0LmxlZnQpLCBsID09PSBvID8gKHIgPSB1LCBhID0gdiwgbyA9IE0ociwgYSwgdCkpIDogKGkgPSB1LCBuID0gdiwgcyA9IE0oaSwgbiwgdCkpO1xuICByZXR1cm4ge1xuICAgIHgwOiByLFxuICAgIHgxOiBpLFxuICAgIHkwOiBhLFxuICAgIHkxOiBuXG4gIH07XG59XG5mdW5jdGlvbiBQKGUsIHQpIHtcbiAgdmFyIHIgPSB0LmFuY2hvciwgYSA9IGUsIGksIG47XG4gIHJldHVybiB0LmNsYW1wICYmIChhID0gaWUoYSwgdC5hcmVhKSksIHIgPT09IFwic3RhcnRcIiA/IChpID0gYS54MCwgbiA9IGEueTApIDogciA9PT0gXCJlbmRcIiA/IChpID0gYS54MSwgbiA9IGEueTEpIDogKGkgPSAoYS54MCArIGEueDEpIC8gMiwgbiA9IChhLnkwICsgYS55MSkgLyAyKSwgYWUoaSwgbiwgZS52eCwgZS52eSwgdC5hbGlnbik7XG59XG52YXIgRSA9IHtcbiAgYXJjOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIHIgPSAoZS5zdGFydEFuZ2xlICsgZS5lbmRBbmdsZSkgLyAyLCBhID0gTWF0aC5jb3MociksIGkgPSBNYXRoLnNpbihyKSwgbiA9IGUuaW5uZXJSYWRpdXMsIG8gPSBlLm91dGVyUmFkaXVzO1xuICAgIHJldHVybiBQKHtcbiAgICAgIHgwOiBlLnggKyBhICogbixcbiAgICAgIHkwOiBlLnkgKyBpICogbixcbiAgICAgIHgxOiBlLnggKyBhICogbyxcbiAgICAgIHkxOiBlLnkgKyBpICogbyxcbiAgICAgIHZ4OiBhLFxuICAgICAgdnk6IGlcbiAgICB9LCB0KTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB2YXIgciA9IEEoZSwgdC5vcmlnaW4pLCBhID0gci54ICogZS5vcHRpb25zLnJhZGl1cywgaSA9IHIueSAqIGUub3B0aW9ucy5yYWRpdXM7XG4gICAgcmV0dXJuIFAoe1xuICAgICAgeDA6IGUueCAtIGEsXG4gICAgICB5MDogZS55IC0gaSxcbiAgICAgIHgxOiBlLnggKyBhLFxuICAgICAgeTE6IGUueSArIGksXG4gICAgICB2eDogci54LFxuICAgICAgdnk6IHIueVxuICAgIH0sIHQpO1xuICB9LFxuICBiYXI6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB2YXIgciA9IEEoZSwgdC5vcmlnaW4pLCBhID0gZS54LCBpID0gZS55LCBuID0gMCwgbyA9IDA7XG4gICAgcmV0dXJuIGUuaG9yaXpvbnRhbCA/IChhID0gTWF0aC5taW4oZS54LCBlLmJhc2UpLCBuID0gTWF0aC5hYnMoZS5iYXNlIC0gZS54KSkgOiAoaSA9IE1hdGgubWluKGUueSwgZS5iYXNlKSwgbyA9IE1hdGguYWJzKGUuYmFzZSAtIGUueSkpLCBQKHtcbiAgICAgIHgwOiBhLFxuICAgICAgeTA6IGkgKyBvLFxuICAgICAgeDE6IGEgKyBuLFxuICAgICAgeTE6IGksXG4gICAgICB2eDogci54LFxuICAgICAgdnk6IHIueVxuICAgIH0sIHQpO1xuICB9LFxuICBmYWxsYmFjazogZnVuY3Rpb24oZSwgdCkge1xuICAgIHZhciByID0gQShlLCB0Lm9yaWdpbik7XG4gICAgcmV0dXJuIFAoe1xuICAgICAgeDA6IGUueCxcbiAgICAgIHkwOiBlLnksXG4gICAgICB4MTogZS54ICsgKGUud2lkdGggfHwgMCksXG4gICAgICB5MTogZS55ICsgKGUuaGVpZ2h0IHx8IDApLFxuICAgICAgdng6IHIueCxcbiAgICAgIHZ5OiByLnlcbiAgICB9LCB0KTtcbiAgfVxufSwgeCA9IG0ucmFzdGVyaXplO1xuZnVuY3Rpb24gbmUoZSkge1xuICB2YXIgdCA9IGUuYm9yZGVyV2lkdGggfHwgMCwgciA9IGUucGFkZGluZywgYSA9IGUuc2l6ZS5oZWlnaHQsIGkgPSBlLnNpemUud2lkdGgsIG4gPSAtaSAvIDIsIG8gPSAtYSAvIDI7XG4gIHJldHVybiB7XG4gICAgZnJhbWU6IHtcbiAgICAgIHg6IG4gLSByLmxlZnQgLSB0LFxuICAgICAgeTogbyAtIHIudG9wIC0gdCxcbiAgICAgIHc6IGkgKyByLndpZHRoICsgdCAqIDIsXG4gICAgICBoOiBhICsgci5oZWlnaHQgKyB0ICogMlxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgeDogbixcbiAgICAgIHk6IG8sXG4gICAgICB3OiBpLFxuICAgICAgaDogYVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG9lKGUsIHQpIHtcbiAgdmFyIHIgPSB0LmNoYXJ0LmdldERhdGFzZXRNZXRhKHQuZGF0YXNldEluZGV4KS52U2NhbGU7XG4gIGlmICghcilcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHIueENlbnRlciAhPT0gdm9pZCAwICYmIHIueUNlbnRlciAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB7IHg6IHIueENlbnRlciwgeTogci55Q2VudGVyIH07XG4gIHZhciBhID0gci5nZXRCYXNlUGl4ZWwoKTtcbiAgcmV0dXJuIGUuaG9yaXpvbnRhbCA/IHsgeDogYSwgeTogbnVsbCB9IDogeyB4OiBudWxsLCB5OiBhIH07XG59XG5mdW5jdGlvbiBzZShlKSB7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgUSA/IEUuYXJjIDogZSBpbnN0YW5jZW9mIFogPyBFLnBvaW50IDogZSBpbnN0YW5jZW9mIGVlID8gRS5iYXIgOiBFLmZhbGxiYWNrO1xufVxuZnVuY3Rpb24gbGUoZSwgdCwgciwgYSwgaSwgbikge1xuICB2YXIgbyA9IE1hdGguUEkgLyAyO1xuICBpZiAobikge1xuICAgIHZhciBzID0gTWF0aC5taW4obiwgaSAvIDIsIGEgLyAyKSwgbCA9IHQgKyBzLCB1ID0gciArIHMsIHYgPSB0ICsgYSAtIHMsIGQgPSByICsgaSAtIHM7XG4gICAgZS5tb3ZlVG8odCwgdSksIGwgPCB2ICYmIHUgPCBkID8gKGUuYXJjKGwsIHUsIHMsIC1NYXRoLlBJLCAtbyksIGUuYXJjKHYsIHUsIHMsIC1vLCAwKSwgZS5hcmModiwgZCwgcywgMCwgbyksIGUuYXJjKGwsIGQsIHMsIG8sIE1hdGguUEkpKSA6IGwgPCB2ID8gKGUubW92ZVRvKGwsIHIpLCBlLmFyYyh2LCB1LCBzLCAtbywgbyksIGUuYXJjKGwsIHUsIHMsIG8sIE1hdGguUEkgKyBvKSkgOiB1IDwgZCA/IChlLmFyYyhsLCB1LCBzLCAtTWF0aC5QSSwgMCksIGUuYXJjKGwsIGQsIHMsIDAsIE1hdGguUEkpKSA6IGUuYXJjKGwsIHUsIHMsIC1NYXRoLlBJLCBNYXRoLlBJKSwgZS5jbG9zZVBhdGgoKSwgZS5tb3ZlVG8odCwgcik7XG4gIH0gZWxzZVxuICAgIGUucmVjdCh0LCByLCBhLCBpKTtcbn1cbmZ1bmN0aW9uIHVlKGUsIHQsIHIpIHtcbiAgdmFyIGEgPSByLmJhY2tncm91bmRDb2xvciwgaSA9IHIuYm9yZGVyQ29sb3IsIG4gPSByLmJvcmRlcldpZHRoO1xuICAhYSAmJiAoIWkgfHwgIW4pIHx8IChlLmJlZ2luUGF0aCgpLCBsZShcbiAgICBlLFxuICAgIHgodC54KSArIG4gLyAyLFxuICAgIHgodC55KSArIG4gLyAyLFxuICAgIHgodC53KSAtIG4sXG4gICAgeCh0LmgpIC0gbixcbiAgICByLmJvcmRlclJhZGl1c1xuICApLCBlLmNsb3NlUGF0aCgpLCBhICYmIChlLmZpbGxTdHlsZSA9IGEsIGUuZmlsbCgpKSwgaSAmJiBuICYmIChlLnN0cm9rZVN0eWxlID0gaSwgZS5saW5lV2lkdGggPSBuLCBlLmxpbmVKb2luID0gXCJtaXRlclwiLCBlLnN0cm9rZSgpKSk7XG59XG5mdW5jdGlvbiB2ZShlLCB0LCByKSB7XG4gIHZhciBhID0gci5saW5lSGVpZ2h0LCBpID0gZS53LCBuID0gZS54LCBvID0gZS55ICsgYSAvIDI7XG4gIHJldHVybiB0ID09PSBcImNlbnRlclwiID8gbiArPSBpIC8gMiA6ICh0ID09PSBcImVuZFwiIHx8IHQgPT09IFwicmlnaHRcIikgJiYgKG4gKz0gaSksIHtcbiAgICBoOiBhLFxuICAgIHc6IGksXG4gICAgeDogbixcbiAgICB5OiBvXG4gIH07XG59XG5mdW5jdGlvbiBkZShlLCB0LCByKSB7XG4gIHZhciBhID0gZS5zaGFkb3dCbHVyLCBpID0gci5zdHJva2VkLCBuID0geChyLngpLCBvID0geChyLnkpLCBzID0geChyLncpO1xuICBpICYmIGUuc3Ryb2tlVGV4dCh0LCBuLCBvLCBzKSwgci5maWxsZWQgJiYgKGEgJiYgaSAmJiAoZS5zaGFkb3dCbHVyID0gMCksIGUuZmlsbFRleHQodCwgbiwgbywgcyksIGEgJiYgaSAmJiAoZS5zaGFkb3dCbHVyID0gYSkpO1xufVxuZnVuY3Rpb24gZmUoZSwgdCwgciwgYSkge1xuICB2YXIgaSA9IGEudGV4dEFsaWduLCBuID0gYS5jb2xvciwgbyA9ICEhbiwgcyA9IGEuZm9udCwgbCA9IHQubGVuZ3RoLCB1ID0gYS50ZXh0U3Ryb2tlQ29sb3IsIHYgPSBhLnRleHRTdHJva2VXaWR0aCwgZCA9IHUgJiYgdiwgeTtcbiAgaWYgKCEoIWwgfHwgIW8gJiYgIWQpKVxuICAgIGZvciAociA9IHZlKHIsIGksIHMpLCBlLmZvbnQgPSBzLnN0cmluZywgZS50ZXh0QWxpZ24gPSBpLCBlLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCIsIGUuc2hhZG93Qmx1ciA9IGEudGV4dFNoYWRvd0JsdXIsIGUuc2hhZG93Q29sb3IgPSBhLnRleHRTaGFkb3dDb2xvciwgbyAmJiAoZS5maWxsU3R5bGUgPSBuKSwgZCAmJiAoZS5saW5lSm9pbiA9IFwicm91bmRcIiwgZS5saW5lV2lkdGggPSB2LCBlLnN0cm9rZVN0eWxlID0gdSksIHkgPSAwLCBsID0gdC5sZW5ndGg7IHkgPCBsOyArK3kpXG4gICAgICBkZShlLCB0W3ldLCB7XG4gICAgICAgIHN0cm9rZWQ6IGQsXG4gICAgICAgIGZpbGxlZDogbyxcbiAgICAgICAgdzogci53LFxuICAgICAgICB4OiByLngsXG4gICAgICAgIHk6IHIueSArIHIuaCAqIHlcbiAgICAgIH0pO1xufVxudmFyIEwgPSBmdW5jdGlvbihlLCB0LCByLCBhKSB7XG4gIHZhciBpID0gdGhpcztcbiAgaS5fY29uZmlnID0gZSwgaS5faW5kZXggPSBhLCBpLl9tb2RlbCA9IG51bGwsIGkuX3JlY3RzID0gbnVsbCwgaS5fY3R4ID0gdCwgaS5fZWwgPSByO1xufTtcbmcoTC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW9kZWxpemU6IGZ1bmN0aW9uKGUsIHQsIHIsIGEpIHtcbiAgICB2YXIgaSA9IHRoaXMsIG4gPSBpLl9pbmRleCwgbyA9IHEoZihbci5mb250LCB7fV0sIGEsIG4pKSwgcyA9IGYoW3IuY29sb3IsIEouY29sb3JdLCBhLCBuKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWxpZ246IGYoW3IuYWxpZ24sIFwiY2VudGVyXCJdLCBhLCBuKSxcbiAgICAgIGFuY2hvcjogZihbci5hbmNob3IsIFwiY2VudGVyXCJdLCBhLCBuKSxcbiAgICAgIGFyZWE6IGEuY2hhcnQuY2hhcnRBcmVhLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBmKFtyLmJhY2tncm91bmRDb2xvciwgbnVsbF0sIGEsIG4pLFxuICAgICAgYm9yZGVyQ29sb3I6IGYoW3IuYm9yZGVyQ29sb3IsIG51bGxdLCBhLCBuKSxcbiAgICAgIGJvcmRlclJhZGl1czogZihbci5ib3JkZXJSYWRpdXMsIDBdLCBhLCBuKSxcbiAgICAgIGJvcmRlcldpZHRoOiBmKFtyLmJvcmRlcldpZHRoLCAwXSwgYSwgbiksXG4gICAgICBjbGFtcDogZihbci5jbGFtcCwgITFdLCBhLCBuKSxcbiAgICAgIGNsaXA6IGYoW3IuY2xpcCwgITFdLCBhLCBuKSxcbiAgICAgIGNvbG9yOiBzLFxuICAgICAgZGlzcGxheTogZSxcbiAgICAgIGZvbnQ6IG8sXG4gICAgICBsaW5lczogdCxcbiAgICAgIG9mZnNldDogZihbci5vZmZzZXQsIDRdLCBhLCBuKSxcbiAgICAgIG9wYWNpdHk6IGYoW3Iub3BhY2l0eSwgMV0sIGEsIG4pLFxuICAgICAgb3JpZ2luOiBvZShpLl9lbCwgYSksXG4gICAgICBwYWRkaW5nOiBLKGYoW3IucGFkZGluZywgNF0sIGEsIG4pKSxcbiAgICAgIHBvc2l0aW9uZXI6IHNlKGkuX2VsKSxcbiAgICAgIHJvdGF0aW9uOiBmKFtyLnJvdGF0aW9uLCAwXSwgYSwgbikgKiAoTWF0aC5QSSAvIDE4MCksXG4gICAgICBzaXplOiBtLnRleHRTaXplKGkuX2N0eCwgdCwgbyksXG4gICAgICB0ZXh0QWxpZ246IGYoW3IudGV4dEFsaWduLCBcInN0YXJ0XCJdLCBhLCBuKSxcbiAgICAgIHRleHRTaGFkb3dCbHVyOiBmKFtyLnRleHRTaGFkb3dCbHVyLCAwXSwgYSwgbiksXG4gICAgICB0ZXh0U2hhZG93Q29sb3I6IGYoW3IudGV4dFNoYWRvd0NvbG9yLCBzXSwgYSwgbiksXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6IGYoW3IudGV4dFN0cm9rZUNvbG9yLCBzXSwgYSwgbiksXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IGYoW3IudGV4dFN0cm9rZVdpZHRoLCAwXSwgYSwgbilcbiAgICB9O1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9IHRoaXMsIHIgPSBudWxsLCBhID0gbnVsbCwgaSA9IHQuX2luZGV4LCBuID0gdC5fY29uZmlnLCBvLCBzLCBsLCB1ID0gZihbbi5kaXNwbGF5LCAhMF0sIGUsIGkpO1xuICAgIHUgJiYgKG8gPSBlLmRhdGFzZXQuZGF0YVtpXSwgcyA9IFYoeihuLmZvcm1hdHRlciwgW28sIGVdKSwgbyksIGwgPSBwKHMpID8gW10gOiBtLnRvVGV4dExpbmVzKHMpLCBsLmxlbmd0aCAmJiAociA9IHQuX21vZGVsaXplKHUsIGwsIG4sIGUpLCBhID0gbmUocikpKSwgdC5fbW9kZWwgPSByLCB0Ll9yZWN0cyA9IGE7XG4gIH0sXG4gIGdlb21ldHJ5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjdHMgPyB0aGlzLl9yZWN0cy5mcmFtZSA6IHt9O1xuICB9LFxuICByb3RhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsID8gdGhpcy5fbW9kZWwucm90YXRpb24gOiAwO1xuICB9LFxuICB2aXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwub3BhY2l0eTtcbiAgfSxcbiAgbW9kZWw6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbDtcbiAgfSxcbiAgZHJhdzogZnVuY3Rpb24oZSwgdCkge1xuICAgIHZhciByID0gdGhpcywgYSA9IGUuY3R4LCBpID0gci5fbW9kZWwsIG4gPSByLl9yZWN0cywgbztcbiAgICB0aGlzLnZpc2libGUoKSAmJiAoYS5zYXZlKCksIGkuY2xpcCAmJiAobyA9IGkuYXJlYSwgYS5iZWdpblBhdGgoKSwgYS5yZWN0KFxuICAgICAgby5sZWZ0LFxuICAgICAgby50b3AsXG4gICAgICBvLnJpZ2h0IC0gby5sZWZ0LFxuICAgICAgby5ib3R0b20gLSBvLnRvcFxuICAgICksIGEuY2xpcCgpKSwgYS5nbG9iYWxBbHBoYSA9IG0uYm91bmQoMCwgaS5vcGFjaXR5LCAxKSwgYS50cmFuc2xhdGUoeCh0LngpLCB4KHQueSkpLCBhLnJvdGF0ZShpLnJvdGF0aW9uKSwgdWUoYSwgbi5mcmFtZSwgaSksIGZlKGEsIGkubGluZXMsIG4udGV4dCwgaSksIGEucmVzdG9yZSgpKTtcbiAgfVxufSk7XG52YXIgaGUgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MSwgeWUgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuZnVuY3Rpb24gYihlLCB0LCByKSB7XG4gIHZhciBhID0gTWF0aC5jb3MociksIGkgPSBNYXRoLnNpbihyKSwgbiA9IHQueCwgbyA9IHQueTtcbiAgcmV0dXJuIHtcbiAgICB4OiBuICsgYSAqIChlLnggLSBuKSAtIGkgKiAoZS55IC0gbyksXG4gICAgeTogbyArIGkgKiAoZS54IC0gbikgKyBhICogKGUueSAtIG8pXG4gIH07XG59XG5mdW5jdGlvbiBXKGUsIHQpIHtcbiAgdmFyIHIgPSB5ZSwgYSA9IGhlLCBpID0gdC5vcmlnaW4sIG4sIG8sIHMsIGwsIHU7XG4gIGZvciAobiA9IDA7IG4gPCBlLmxlbmd0aDsgKytuKVxuICAgIG8gPSBlW25dLCBzID0gby54IC0gaS54LCBsID0gby55IC0gaS55LCB1ID0gdC52eCAqIHMgKyB0LnZ5ICogbCwgciA9IE1hdGgubWluKHIsIHUpLCBhID0gTWF0aC5tYXgoYSwgdSk7XG4gIHJldHVybiB7XG4gICAgbWluOiByLFxuICAgIG1heDogYVxuICB9O1xufVxuZnVuY3Rpb24gSShlLCB0KSB7XG4gIHZhciByID0gdC54IC0gZS54LCBhID0gdC55IC0gZS55LCBpID0gTWF0aC5zcXJ0KHIgKiByICsgYSAqIGEpO1xuICByZXR1cm4ge1xuICAgIHZ4OiAodC54IC0gZS54KSAvIGksXG4gICAgdnk6ICh0LnkgLSBlLnkpIC8gaSxcbiAgICBvcmlnaW46IGUsXG4gICAgbG46IGlcbiAgfTtcbn1cbnZhciBHID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3JvdGF0aW9uID0gMCwgdGhpcy5fcmVjdCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgdzogMCxcbiAgICBoOiAwXG4gIH07XG59O1xuZyhHLnByb3RvdHlwZSwge1xuICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gdGhpcy5fcmVjdDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZS54ICsgZS53IC8gMixcbiAgICAgIHk6IGUueSArIGUuaCAvIDJcbiAgICB9O1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICB0aGlzLl9yb3RhdGlvbiA9IHIsIHRoaXMuX3JlY3QgPSB7XG4gICAgICB4OiB0LnggKyBlLngsXG4gICAgICB5OiB0LnkgKyBlLnksXG4gICAgICB3OiB0LncsXG4gICAgICBoOiB0LmhcbiAgICB9O1xuICB9LFxuICBjb250YWluczogZnVuY3Rpb24oZSkge1xuICAgIHZhciB0ID0gdGhpcywgciA9IDEsIGEgPSB0Ll9yZWN0O1xuICAgIHJldHVybiBlID0gYihlLCB0LmNlbnRlcigpLCAtdC5fcm90YXRpb24pLCAhKGUueCA8IGEueCAtIHIgfHwgZS55IDwgYS55IC0gciB8fCBlLnggPiBhLnggKyBhLncgKyByICogMiB8fCBlLnkgPiBhLnkgKyBhLmggKyByICogMik7XG4gIH0sXG4gIC8vIFNlcGFyYXRpbmcgQXhpcyBUaGVvcmVtXG4gIC8vIGh0dHBzOi8vZ2FtZWRldmVsb3BtZW50LnR1dHNwbHVzLmNvbS90dXRvcmlhbHMvY29sbGlzaW9uLWRldGVjdGlvbi11c2luZy10aGUtc2VwYXJhdGluZy1heGlzLXRoZW9yZW0tLWdhbWVkZXYtMTY5XG4gIGludGVyc2VjdHM6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9IHRoaXMuX3BvaW50cygpLCByID0gZS5fcG9pbnRzKCksIGEgPSBbXG4gICAgICBJKHRbMF0sIHRbMV0pLFxuICAgICAgSSh0WzBdLCB0WzNdKVxuICAgIF0sIGksIG4sIG87XG4gICAgZm9yICh0aGlzLl9yb3RhdGlvbiAhPT0gZS5fcm90YXRpb24gJiYgYS5wdXNoKFxuICAgICAgSShyWzBdLCByWzFdKSxcbiAgICAgIEkoclswXSwgclszXSlcbiAgICApLCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpXG4gICAgICBpZiAobiA9IFcodCwgYVtpXSksIG8gPSBXKHIsIGFbaV0pLCBuLm1heCA8IG8ubWluIHx8IG8ubWF4IDwgbi5taW4pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICByZXR1cm4gITA7XG4gIH0sXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BvaW50czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB0aGlzLCB0ID0gZS5fcmVjdCwgciA9IGUuX3JvdGF0aW9uLCBhID0gZS5jZW50ZXIoKTtcbiAgICByZXR1cm4gW1xuICAgICAgYih7IHg6IHQueCwgeTogdC55IH0sIGEsIHIpLFxuICAgICAgYih7IHg6IHQueCArIHQudywgeTogdC55IH0sIGEsIHIpLFxuICAgICAgYih7IHg6IHQueCArIHQudywgeTogdC55ICsgdC5oIH0sIGEsIHIpLFxuICAgICAgYih7IHg6IHQueCwgeTogdC55ICsgdC5oIH0sIGEsIHIpXG4gICAgXTtcbiAgfVxufSk7XG5mdW5jdGlvbiBIKGUsIHQsIHIpIHtcbiAgdmFyIGEgPSB0LnBvc2l0aW9uZXIoZSwgdCksIGkgPSBhLnZ4LCBuID0gYS52eTtcbiAgaWYgKCFpICYmICFuKVxuICAgIHJldHVybiB7IHg6IGEueCwgeTogYS55IH07XG4gIHZhciBvID0gci53LCBzID0gci5oLCBsID0gdC5yb3RhdGlvbiwgdSA9IE1hdGguYWJzKG8gLyAyICogTWF0aC5jb3MobCkpICsgTWF0aC5hYnMocyAvIDIgKiBNYXRoLnNpbihsKSksIHYgPSBNYXRoLmFicyhvIC8gMiAqIE1hdGguc2luKGwpKSArIE1hdGguYWJzKHMgLyAyICogTWF0aC5jb3MobCkpLCBkID0gMSAvIE1hdGgubWF4KE1hdGguYWJzKGkpLCBNYXRoLmFicyhuKSk7XG4gIHJldHVybiB1ICo9IGkgKiBkLCB2ICo9IG4gKiBkLCB1ICs9IHQub2Zmc2V0ICogaSwgdiArPSB0Lm9mZnNldCAqIG4sIHtcbiAgICB4OiBhLnggKyB1LFxuICAgIHk6IGEueSArIHZcbiAgfTtcbn1cbmZ1bmN0aW9uIHhlKGUsIHQpIHtcbiAgdmFyIHIsIGEsIGksIG47XG4gIGZvciAociA9IGUubGVuZ3RoIC0gMTsgciA+PSAwOyAtLXIpXG4gICAgZm9yIChpID0gZVtyXS4kbGF5b3V0LCBhID0gciAtIDE7IGEgPj0gMCAmJiBpLl92aXNpYmxlOyAtLWEpXG4gICAgICBuID0gZVthXS4kbGF5b3V0LCBuLl92aXNpYmxlICYmIGkuX2JveC5pbnRlcnNlY3RzKG4uX2JveCkgJiYgdChpLCBuKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfZShlKSB7XG4gIHZhciB0LCByLCBhLCBpLCBuLCBvLCBzO1xuICBmb3IgKHQgPSAwLCByID0gZS5sZW5ndGg7IHQgPCByOyArK3QpXG4gICAgYSA9IGVbdF0sIGkgPSBhLiRsYXlvdXQsIGkuX3Zpc2libGUgJiYgKHMgPSBuZXcgUHJveHkoYS5fZWwsIHsgZ2V0OiAobCwgdSkgPT4gbC5nZXRQcm9wcyhbdV0sICEwKVt1XSB9KSwgbiA9IGEuZ2VvbWV0cnkoKSwgbyA9IEgocywgYS5tb2RlbCgpLCBuKSwgaS5fYm94LnVwZGF0ZShvLCBuLCBhLnJvdGF0aW9uKCkpKTtcbiAgcmV0dXJuIHhlKGUsIGZ1bmN0aW9uKGwsIHUpIHtcbiAgICB2YXIgdiA9IGwuX2hpZGFibGUsIGQgPSB1Ll9oaWRhYmxlO1xuICAgIHYgJiYgZCB8fCBkID8gdS5fdmlzaWJsZSA9ICExIDogdiAmJiAobC5fdmlzaWJsZSA9ICExKTtcbiAgfSk7XG59XG52YXIgdyA9IHtcbiAgcHJlcGFyZTogZnVuY3Rpb24oZSkge1xuICAgIHZhciB0ID0gW10sIHIsIGEsIGksIG4sIG87XG4gICAgZm9yIChyID0gMCwgaSA9IGUubGVuZ3RoOyByIDwgaTsgKytyKVxuICAgICAgZm9yIChhID0gMCwgbiA9IGVbcl0ubGVuZ3RoOyBhIDwgbjsgKythKVxuICAgICAgICBvID0gZVtyXVthXSwgdC5wdXNoKG8pLCBvLiRsYXlvdXQgPSB7XG4gICAgICAgICAgX2JveDogbmV3IEcoKSxcbiAgICAgICAgICBfaGlkYWJsZTogITEsXG4gICAgICAgICAgX3Zpc2libGU6ICEwLFxuICAgICAgICAgIF9zZXQ6IHIsXG4gICAgICAgICAgX2lkeDogby5faW5kZXhcbiAgICAgICAgfTtcbiAgICByZXR1cm4gdC5zb3J0KGZ1bmN0aW9uKHMsIGwpIHtcbiAgICAgIHZhciB1ID0gcy4kbGF5b3V0LCB2ID0gbC4kbGF5b3V0O1xuICAgICAgcmV0dXJuIHUuX2lkeCA9PT0gdi5faWR4ID8gdi5fc2V0IC0gdS5fc2V0IDogdi5faWR4IC0gdS5faWR4O1xuICAgIH0pLCB0aGlzLnVwZGF0ZSh0KSwgdDtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHQgPSAhMSwgciwgYSwgaSwgbiwgbztcbiAgICBmb3IgKHIgPSAwLCBhID0gZS5sZW5ndGg7IHIgPCBhOyArK3IpXG4gICAgICBpID0gZVtyXSwgbiA9IGkubW9kZWwoKSwgbyA9IGkuJGxheW91dCwgby5faGlkYWJsZSA9IG4gJiYgbi5kaXNwbGF5ID09PSBcImF1dG9cIiwgby5fdmlzaWJsZSA9IGkudmlzaWJsZSgpLCB0IHw9IG8uX2hpZGFibGU7XG4gICAgdCAmJiBfZShlKTtcbiAgfSxcbiAgbG9va3VwOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIHIsIGE7XG4gICAgZm9yIChyID0gZS5sZW5ndGggLSAxOyByID49IDA7IC0tcilcbiAgICAgIGlmIChhID0gZVtyXS4kbGF5b3V0LCBhICYmIGEuX3Zpc2libGUgJiYgYS5fYm94LmNvbnRhaW5zKHQpKVxuICAgICAgICByZXR1cm4gZVtyXTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgZHJhdzogZnVuY3Rpb24oZSwgdCkge1xuICAgIHZhciByLCBhLCBpLCBuLCBvLCBzO1xuICAgIGZvciAociA9IDAsIGEgPSB0Lmxlbmd0aDsgciA8IGE7ICsrcilcbiAgICAgIGkgPSB0W3JdLCBuID0gaS4kbGF5b3V0LCBuLl92aXNpYmxlICYmIChvID0gaS5nZW9tZXRyeSgpLCBzID0gSChpLl9lbCwgaS5tb2RlbCgpLCBvKSwgbi5fYm94LnVwZGF0ZShzLCBvLCBpLnJvdGF0aW9uKCkpLCBpLmRyYXcoZSwgcykpO1xuICB9XG59LCBjZSA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKHAoZSkpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciB0ID0gZSwgciwgYSwgaTtcbiAgaWYgKHJlKGUpKVxuICAgIGlmICghcChlLmxhYmVsKSlcbiAgICAgIHQgPSBlLmxhYmVsO1xuICAgIGVsc2UgaWYgKCFwKGUucikpXG4gICAgICB0ID0gZS5yO1xuICAgIGVsc2VcbiAgICAgIGZvciAodCA9IFwiXCIsIHIgPSBPYmplY3Qua2V5cyhlKSwgaSA9IDAsIGEgPSByLmxlbmd0aDsgaSA8IGE7ICsraSlcbiAgICAgICAgdCArPSAoaSAhPT0gMCA/IFwiLCBcIiA6IFwiXCIpICsgcltpXSArIFwiOiBcIiArIGVbcltpXV07XG4gIHJldHVybiBcIlwiICsgdDtcbn0sIGJlID0ge1xuICBhbGlnbjogXCJjZW50ZXJcIixcbiAgYW5jaG9yOiBcImNlbnRlclwiLFxuICBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG4gIGJvcmRlckNvbG9yOiBudWxsLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBjbGFtcDogITEsXG4gIGNsaXA6ICExLFxuICBjb2xvcjogdm9pZCAwLFxuICBkaXNwbGF5OiAhMCxcbiAgZm9udDoge1xuICAgIGZhbWlseTogdm9pZCAwLFxuICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICBzaXplOiB2b2lkIDAsXG4gICAgc3R5bGU6IHZvaWQgMCxcbiAgICB3ZWlnaHQ6IG51bGxcbiAgfSxcbiAgZm9ybWF0dGVyOiBjZSxcbiAgbGFiZWxzOiB2b2lkIDAsXG4gIGxpc3RlbmVyczoge30sXG4gIG9mZnNldDogNCxcbiAgb3BhY2l0eTogMSxcbiAgcGFkZGluZzoge1xuICAgIHRvcDogNCxcbiAgICByaWdodDogNCxcbiAgICBib3R0b206IDQsXG4gICAgbGVmdDogNFxuICB9LFxuICByb3RhdGlvbjogMCxcbiAgdGV4dEFsaWduOiBcInN0YXJ0XCIsXG4gIHRleHRTdHJva2VDb2xvcjogdm9pZCAwLFxuICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gIHRleHRTaGFkb3dCbHVyOiAwLFxuICB0ZXh0U2hhZG93Q29sb3I6IHZvaWQgMFxufSwgaCA9IFwiJGRhdGFsYWJlbHNcIiwgVSA9IFwiJGRlZmF1bHRcIjtcbmZ1bmN0aW9uIHBlKGUsIHQpIHtcbiAgdmFyIHIgPSBlLmRhdGFsYWJlbHMsIGEgPSB7fSwgaSA9IFtdLCBuLCBvO1xuICByZXR1cm4gciA9PT0gITEgPyBudWxsIDogKHIgPT09ICEwICYmIChyID0ge30pLCB0ID0gZyh7fSwgW3QsIHJdKSwgbiA9IHQubGFiZWxzIHx8IHt9LCBvID0gT2JqZWN0LmtleXMobiksIGRlbGV0ZSB0LmxhYmVscywgby5sZW5ndGggPyBvLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIG5bc10gJiYgaS5wdXNoKGcoe30sIFtcbiAgICAgIHQsXG4gICAgICBuW3NdLFxuICAgICAgeyBfa2V5OiBzIH1cbiAgICBdKSk7XG4gIH0pIDogaS5wdXNoKHQpLCBhID0gaS5yZWR1Y2UoZnVuY3Rpb24ocywgbCkge1xuICAgIHJldHVybiBZKGwubGlzdGVuZXJzIHx8IHt9LCBmdW5jdGlvbih1LCB2KSB7XG4gICAgICBzW3ZdID0gc1t2XSB8fCB7fSwgc1t2XVtsLl9rZXkgfHwgVV0gPSB1O1xuICAgIH0pLCBkZWxldGUgbC5saXN0ZW5lcnMsIHM7XG4gIH0sIHt9KSwge1xuICAgIGxhYmVsczogaSxcbiAgICBsaXN0ZW5lcnM6IGFcbiAgfSk7XG59XG5mdW5jdGlvbiBSKGUsIHQsIHIsIGEpIHtcbiAgaWYgKHQpIHtcbiAgICB2YXIgaSA9IHIuJGNvbnRleHQsIG4gPSByLiRncm91cHMsIG87XG4gICAgdFtuLl9zZXRdICYmIChvID0gdFtuLl9zZXRdW24uX2tleV0sIG8gJiYgeihvLCBbaSwgYV0pID09PSAhMCAmJiAoZVtoXS5fZGlydHkgPSAhMCwgci51cGRhdGUoaSkpKTtcbiAgfVxufVxuZnVuY3Rpb24gbWUoZSwgdCwgciwgYSwgaSkge1xuICB2YXIgbiwgbztcbiAgIXIgJiYgIWEgfHwgKHIgPyBhID8gciAhPT0gYSAmJiAobyA9IG4gPSAhMCkgOiBvID0gITAgOiBuID0gITAsIG8gJiYgUihlLCB0LmxlYXZlLCByLCBpKSwgbiAmJiBSKGUsIHQuZW50ZXIsIGEsIGkpKTtcbn1cbmZ1bmN0aW9uIHdlKGUsIHQpIHtcbiAgdmFyIHIgPSBlW2hdLCBhID0gci5fbGlzdGVuZXJzLCBpLCBuO1xuICBpZiAoISghYS5lbnRlciAmJiAhYS5sZWF2ZSkpIHtcbiAgICBpZiAodC50eXBlID09PSBcIm1vdXNlbW92ZVwiKVxuICAgICAgbiA9IHcubG9va3VwKHIuX2xhYmVscywgdCk7XG4gICAgZWxzZSBpZiAodC50eXBlICE9PSBcIm1vdXNlb3V0XCIpXG4gICAgICByZXR1cm47XG4gICAgaSA9IHIuX2hvdmVyZWQsIHIuX2hvdmVyZWQgPSBuLCBtZShlLCBhLCBpLCBuLCB0KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2UoZSwgdCkge1xuICB2YXIgciA9IGVbaF0sIGEgPSByLl9saXN0ZW5lcnMuY2xpY2ssIGkgPSBhICYmIHcubG9va3VwKHIuX2xhYmVscywgdCk7XG4gIGkgJiYgUihlLCBhLCBpLCB0KTtcbn1cbnZhciBNZSA9IHtcbiAgaWQ6IFwiZGF0YWxhYmVsc1wiLFxuICBkZWZhdWx0czogYmUsXG4gIGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBlW2hdID0ge1xuICAgICAgX2FjdGl2ZXM6IFtdXG4gICAgfTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHQgPSBlW2hdO1xuICAgIHQuX2xpc3RlbmVkID0gITEsIHQuX2xpc3RlbmVycyA9IHt9LCB0Ll9kYXRhc2V0cyA9IFtdLCB0Ll9sYWJlbHMgPSBbXTtcbiAgfSxcbiAgYWZ0ZXJEYXRhc2V0VXBkYXRlOiBmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgdmFyIGEgPSB0LmluZGV4LCBpID0gZVtoXSwgbiA9IGkuX2RhdGFzZXRzW2FdID0gW10sIG8gPSBlLmlzRGF0YXNldFZpc2libGUoYSksIHMgPSBlLmRhdGEuZGF0YXNldHNbYV0sIGwgPSBwZShzLCByKSwgdSA9IHQubWV0YS5kYXRhIHx8IFtdLCB2ID0gZS5jdHgsIGQsIHksICQsIFQsIFMsIEIsIGMsIF87XG4gICAgZm9yICh2LnNhdmUoKSwgZCA9IDAsICQgPSB1Lmxlbmd0aDsgZCA8ICQ7ICsrZClcbiAgICAgIGlmIChjID0gdVtkXSwgY1toXSA9IFtdLCBvICYmIGMgJiYgZS5nZXREYXRhVmlzaWJpbGl0eShkKSAmJiAhYy5za2lwKVxuICAgICAgICBmb3IgKHkgPSAwLCBUID0gbC5sYWJlbHMubGVuZ3RoOyB5IDwgVDsgKyt5KVxuICAgICAgICAgIFMgPSBsLmxhYmVsc1t5XSwgQiA9IFMuX2tleSwgXyA9IG5ldyBMKFMsIHYsIGMsIGQpLCBfLiRncm91cHMgPSB7XG4gICAgICAgICAgICBfc2V0OiBhLFxuICAgICAgICAgICAgX2tleTogQiB8fCBVXG4gICAgICAgICAgfSwgXy4kY29udGV4dCA9IHtcbiAgICAgICAgICAgIGFjdGl2ZTogITEsXG4gICAgICAgICAgICBjaGFydDogZSxcbiAgICAgICAgICAgIGRhdGFJbmRleDogZCxcbiAgICAgICAgICAgIGRhdGFzZXQ6IHMsXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IGFcbiAgICAgICAgICB9LCBfLnVwZGF0ZShfLiRjb250ZXh0KSwgY1toXS5wdXNoKF8pLCBuLnB1c2goXyk7XG4gICAgdi5yZXN0b3JlKCksIGcoaS5fbGlzdGVuZXJzLCBsLmxpc3RlbmVycywge1xuICAgICAgbWVyZ2VyOiBmdW5jdGlvbihrLCBDLCBYKSB7XG4gICAgICAgIENba10gPSBDW2tdIHx8IHt9LCBDW2tdW3QuaW5kZXhdID0gWFtrXSwgaS5fbGlzdGVuZWQgPSAhMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uKGUpIHtcbiAgICBlW2hdLl9sYWJlbHMgPSB3LnByZXBhcmUoZVtoXS5fZGF0YXNldHMpO1xuICB9LFxuICAvLyBEcmF3IGxhYmVscyBvbiB0b3Agb2YgYWxsIGRhdGFzZXQgZWxlbWVudHNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvMjlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvMzJcbiAgYWZ0ZXJEYXRhc2V0c0RyYXc6IGZ1bmN0aW9uKGUpIHtcbiAgICB3LmRyYXcoZSwgZVtoXS5fbGFiZWxzKTtcbiAgfSxcbiAgYmVmb3JlRXZlbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBpZiAoZVtoXS5fbGlzdGVuZWQpIHtcbiAgICAgIHZhciByID0gdC5ldmVudDtcbiAgICAgIHN3aXRjaCAoci50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJtb3VzZW1vdmVcIjpcbiAgICAgICAgY2FzZSBcIm1vdXNlb3V0XCI6XG4gICAgICAgICAgd2UoZSwgcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjbGlja1wiOlxuICAgICAgICAgIGdlKGUsIHIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYWZ0ZXJFdmVudDogZnVuY3Rpb24oZSkge1xuICAgIHZhciB0ID0gZVtoXSwgciA9IHQuX2FjdGl2ZXMsIGEgPSB0Ll9hY3RpdmVzID0gZS5nZXRBY3RpdmVFbGVtZW50cygpLCBpID0gbS5hcnJheURpZmYociwgYSksIG4sIG8sIHMsIGwsIHUsIHYsIGQ7XG4gICAgZm9yIChuID0gMCwgbyA9IGkubGVuZ3RoOyBuIDwgbzsgKytuKVxuICAgICAgaWYgKHUgPSBpW25dLCB1WzFdKVxuICAgICAgICBmb3IgKGQgPSB1WzBdLmVsZW1lbnRbaF0gfHwgW10sIHMgPSAwLCBsID0gZC5sZW5ndGg7IHMgPCBsOyArK3MpXG4gICAgICAgICAgdiA9IGRbc10sIHYuJGNvbnRleHQuYWN0aXZlID0gdVsxXSA9PT0gMSwgdi51cGRhdGUodi4kY29udGV4dCk7XG4gICAgKHQuX2RpcnR5IHx8IGkubGVuZ3RoKSAmJiAody51cGRhdGUodC5fbGFiZWxzKSwgZS5yZW5kZXIoKSksIGRlbGV0ZSB0Ll9kaXJ0eTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIE1lIGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzLmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9